// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/parcel-bundler/src/builtins/bundle-url.js":[function(require,module,exports) {
var bundleURL = null;

function getBundleURLCached() {
  if (!bundleURL) {
    bundleURL = getBundleURL();
  }

  return bundleURL;
}

function getBundleURL() {
  // Attempt to find the URL of the current script and use that as the base URL
  try {
    throw new Error();
  } catch (err) {
    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);

    if (matches) {
      return getBaseURL(matches[0]);
    }
  }

  return '/';
}

function getBaseURL(url) {
  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)\/[^/]+$/, '$1') + '/';
}

exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
},{}],"node_modules/parcel-bundler/src/builtins/css-loader.js":[function(require,module,exports) {
var bundle = require('./bundle-url');

function updateLink(link) {
  var newLink = link.cloneNode();

  newLink.onload = function () {
    link.remove();
  };

  newLink.href = link.href.split('?')[0] + '?' + Date.now();
  link.parentNode.insertBefore(newLink, link.nextSibling);
}

var cssTimeout = null;

function reloadCSS() {
  if (cssTimeout) {
    return;
  }

  cssTimeout = setTimeout(function () {
    var links = document.querySelectorAll('link[rel="stylesheet"]');

    for (var i = 0; i < links.length; i++) {
      if (bundle.getBaseURL(links[i].href) === bundle.getBundleURL()) {
        updateLink(links[i]);
      }
    }

    cssTimeout = null;
  }, 50);
}

module.exports = reloadCSS;
},{"./bundle-url":"node_modules/parcel-bundler/src/builtins/bundle-url.js"}],"node_modules/ol/ol.css":[function(require,module,exports) {

        var reloadCSS = require('_css_loader');
        module.hot.dispose(reloadCSS);
        module.hot.accept(reloadCSS);
      
},{"_css_loader":"node_modules/parcel-bundler/src/builtins/css-loader.js"}],"node_modules/ol/util.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.abstract = abstract;
exports.getUid = getUid;
exports.VERSION = void 0;

/**
 * @module ol/util
 */

/**
 * @return {?} Any return.
 */
function abstract() {
  return (
    /** @type {?} */
    function () {
      throw new Error('Unimplemented abstract method.');
    }()
  );
}
/**
 * Counter for getUid.
 * @type {number}
 * @private
 */


var uidCounter_ = 0;
/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @api
 */

function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
/**
 * OpenLayers version.
 * @type {string}
 */


var VERSION = '6.3.1';
exports.VERSION = VERSION;
},{}],"node_modules/ol/AssertionError.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("./util.js");

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/AssertionError
 */


/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
 */
var AssertionError =
/** @class */
function (_super) {
  __extends(AssertionError, _super);
  /**
   * @param {number} code Error code.
   */


  function AssertionError(code) {
    var _this = this;

    var path = _util.VERSION === 'latest' ? _util.VERSION : 'v' + _util.VERSION.split('-')[0];
    var message = 'Assertion failed. See https://openlayers.org/en/' + path + '/doc/errors/#' + code + ' for details.';
    _this = _super.call(this, message) || this;
    /**
     * Error code. The meaning of the code can be found on
     * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
     * the version found in the OpenLayers script's header comment if a version
     * other than the latest is used).
     * @type {number}
     * @api
     */

    _this.code = code;
    /**
     * @type {string}
     */

    _this.name = 'AssertionError'; // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40

    _this.message = message;
    return _this;
  }

  return AssertionError;
}(Error);

var _default = AssertionError;
exports.default = _default;
},{"./util.js":"node_modules/ol/util.js"}],"node_modules/ol/asserts.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;

var _AssertionError = _interopRequireDefault(require("./AssertionError.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/asserts
 */

/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */
function assert(assertion, errorCode) {
  if (!assertion) {
    throw new _AssertionError.default(errorCode);
  }
}
},{"./AssertionError.js":"node_modules/ol/AssertionError.js"}],"node_modules/ol/obj.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.isEmpty = isEmpty;
exports.getValues = exports.assign = void 0;

/**
 * @module ol/obj
 */

/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.
 *
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */
var assign = typeof Object.assign === 'function' ? Object.assign : function (target, var_sources) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);

  for (var i = 1, ii = arguments.length; i < ii; ++i) {
    var source = arguments[i];

    if (source !== undefined && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }

  return output;
};
/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */

exports.assign = assign;

function clear(object) {
  for (var property in object) {
    delete object[property];
  }
}
/**
 * Polyfill for Object.values().  Get an array of property values from an object.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values
 *
 * @param {!Object<K,V>} object The object from which to get the values.
 * @return {!Array<V>} The property values.
 * @template K,V
 */


var getValues = typeof Object.values === 'function' ? Object.values : function (object) {
  var values = [];

  for (var property in object) {
    values.push(object[property]);
  }

  return values;
};
/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */

exports.getValues = getValues;

function isEmpty(object) {
  var property;

  for (property in object) {
    return false;
  }

  return !property;
}
},{}],"node_modules/ol/events.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.listen = listen;
exports.listenOnce = listenOnce;
exports.unlistenByKey = unlistenByKey;

var _obj = require("./obj.js");

/**
 * @module ol/events
 */

/**
 * Key to use with {@link module:ol/Observable~Observable#unByKey}.
 * @typedef {Object} EventsKey
 * @property {ListenerFunction} listener
 * @property {import("./events/Target.js").EventTargetLike} target
 * @property {string} type
 * @api
 */

/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */

/**
 * @typedef {Object} ListenerObject
 * @property {ListenerFunction} handleEvent
 */

/**
 * @typedef {ListenerFunction|ListenerObject} Listener
 */

/**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events~unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean=} opt_once If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */
function listen(target, type, listener, opt_this, opt_once) {
  if (opt_this && opt_this !== target) {
    listener = listener.bind(opt_this);
  }

  if (opt_once) {
    var originalListener_1 = listener;

    listener = function () {
      target.removeEventListener(type, listener);
      originalListener_1.apply(this, arguments);
    };
  }

  var eventsKey = {
    target: target,
    type: type,
    listener: listener
  };
  target.addEventListener(type, listener);
  return eventsKey;
}
/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events~unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events~listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */


function listenOnce(target, type, listener, opt_this) {
  return listen(target, type, listener, opt_this, true);
}
/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.
 *
 * @param {EventsKey} key The key.
 */


function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    (0, _obj.clear)(key);
  }
}
},{"./obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/events/EventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/events/EventType
 */

/**
 * @enum {string}
 * @const
 */
var _default = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: 'change',

  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: 'error',
  BLUR: 'blur',
  CLEAR: 'clear',
  CONTEXTMENU: 'contextmenu',
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  FOCUS: 'focus',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  RESIZE: 'resize',
  TOUCHMOVE: 'touchmove',
  WHEEL: 'wheel'
};
exports.default = _default;
},{}],"node_modules/ol/ObjectEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/ObjectEventType
 */

/**
 * @enum {string}
 */
var _default = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange'
};
exports.default = _default;
},{}],"node_modules/ol/Disposable.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/Disposable
 */

/**
 * @classdesc
 * Objects that need to clean up after themselves.
 */
var Disposable =
/** @class */
function () {
  function Disposable() {
    /**
     * The object has already been disposed.
     * @type {boolean}
     * @private
     */
    this.disposed_ = false;
  }
  /**
   * Clean up.
   */


  Disposable.prototype.dispose = function () {
    if (!this.disposed_) {
      this.disposed_ = true;
      this.disposeInternal();
    }
  };
  /**
   * Extension point for disposable objects.
   * @protected
   */


  Disposable.prototype.disposeInternal = function () {};

  return Disposable;
}();

var _default = Disposable;
exports.default = _default;
},{}],"node_modules/ol/array.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.binarySearch = binarySearch;
exports.numberSafeCompareFunction = numberSafeCompareFunction;
exports.includes = includes;
exports.linearFindNearest = linearFindNearest;
exports.reverseSubArray = reverseSubArray;
exports.extend = extend;
exports.remove = remove;
exports.find = find;
exports.equals = equals;
exports.stableSort = stableSort;
exports.findIndex = findIndex;
exports.isSorted = isSorted;

/**
 * @module ol/array
 */

/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function=} opt_comparator Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
function binarySearch(haystack, needle, opt_comparator) {
  var mid, cmp;
  var comparator = opt_comparator || numberSafeCompareFunction;
  var low = 0;
  var high = haystack.length;
  var found = false;

  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);

    if (cmp < 0.0) {
      /* Too low. */
      low = mid + 1;
    } else {
      /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }
  /* Key not found. */


  return found ? low : ~low;
}
/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */


function numberSafeCompareFunction(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
/**
 * Whether the array contains the given object.
 * @param {Array<*>} arr The array to test for the presence of the element.
 * @param {*} obj The object for which to test.
 * @return {boolean} The object is in the array.
 */


function includes(arr, obj) {
  return arr.indexOf(obj) >= 0;
}
/**
 * @param {Array<number>} arr Array.
 * @param {number} target Target.
 * @param {number} direction 0 means return the nearest, > 0
 *    means return the largest nearest, < 0 means return the
 *    smallest nearest.
 * @return {number} Index.
 */


function linearFindNearest(arr, target, direction) {
  var n = arr.length;

  if (arr[0] <= target) {
    return 0;
  } else if (target <= arr[n - 1]) {
    return n - 1;
  } else {
    var i = void 0;

    if (direction > 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] < target) {
          return i - 1;
        }
      }
    } else if (direction < 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] <= target) {
          return i;
        }
      }
    } else {
      for (i = 1; i < n; ++i) {
        if (arr[i] == target) {
          return i;
        } else if (arr[i] < target) {
          if (arr[i - 1] - target < target - arr[i]) {
            return i - 1;
          } else {
            return i;
          }
        }
      }
    }

    return n - 1;
  }
}
/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */


function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    var tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */


function extend(arr, data) {
  var extension = Array.isArray(data) ? data : [data];
  var length = extension.length;

  for (var i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */


function remove(arr, obj) {
  var i = arr.indexOf(obj);
  var found = i > -1;

  if (found) {
    arr.splice(i, 1);
  }

  return found;
}
/**
 * @param {Array<VALUE>} arr The array to search in.
 * @param {function(VALUE, number, ?) : boolean} func The function to compare.
 * @template VALUE
 * @return {VALUE|null} The element found or null.
 */


function find(arr, func) {
  var length = arr.length >>> 0;
  var value;

  for (var i = 0; i < length; i++) {
    value = arr[i];

    if (func(value, i, arr)) {
      return value;
    }
  }

  return null;
}
/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */


function equals(arr1, arr2) {
  var len1 = arr1.length;

  if (len1 !== arr2.length) {
    return false;
  }

  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
}
/**
 * Sort the passed array such that the relative order of equal elements is preverved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */


function stableSort(arr, compareFnc) {
  var length = arr.length;
  var tmp = Array(arr.length);
  var i;

  for (i = 0; i < length; i++) {
    tmp[i] = {
      index: i,
      value: arr[i]
    };
  }

  tmp.sort(function (a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });

  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
}
/**
 * @param {Array<*>} arr The array to search in.
 * @param {Function} func Comparison function.
 * @return {number} Return index.
 */


function findIndex(arr, func) {
  var index;
  var found = !arr.every(function (el, idx) {
    index = idx;
    return !func(el, idx, arr);
  });
  return found ? index : -1;
}
/**
 * @param {Array<*>} arr The array to test.
 * @param {Function=} opt_func Comparison function.
 * @param {boolean=} opt_strict Strictly sorted (default false).
 * @return {boolean} Return index.
 */


function isSorted(arr, opt_func, opt_strict) {
  var compare = opt_func || numberSafeCompareFunction;
  return arr.every(function (currentVal, index) {
    if (index === 0) {
      return true;
    }

    var res = compare(arr[index - 1], currentVal);
    return !(res > 0 || opt_strict && res === 0);
  });
}
},{}],"node_modules/ol/functions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRUE = TRUE;
exports.FALSE = FALSE;
exports.VOID = VOID;
exports.memoizeOne = memoizeOne;

var _array = require("./array.js");

/**
 * @module ol/functions
 */

/**
 * Always returns true.
 * @returns {boolean} true.
 */
function TRUE() {
  return true;
}
/**
 * Always returns false.
 * @returns {boolean} false.
 */


function FALSE() {
  return false;
}
/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {void} Nothing.
 */


function VOID() {}
/**
 * Wrap a function in another function that remembers the last return.  If the
 * returned function is called twice in a row with the same arguments and the same
 * this object, it will return the value from the first call in the second call.
 *
 * @param {function(...any): ReturnType} fn The function to memoize.
 * @return {function(...any): ReturnType} The memoized function.
 * @template ReturnType
 */


function memoizeOne(fn) {
  var called = false;
  /** @type {ReturnType} */

  var lastResult;
  /** @type {Array<any>} */

  var lastArgs;
  var lastThis;
  return function () {
    var nextArgs = Array.prototype.slice.call(arguments);

    if (!called || this !== lastThis || !(0, _array.equals)(nextArgs, lastArgs)) {
      called = true;
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }

    return lastResult;
  };
}
},{"./array.js":"node_modules/ol/array.js"}],"node_modules/ol/events/Event.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stopPropagation = stopPropagation;
exports.preventDefault = preventDefault;
exports.default = void 0;

/**
 * @module ol/events/Event
 */

/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/Target~Target}.
 */
var BaseEvent =
/** @class */
function () {
  /**
   * @param {string} type Type.
   */
  function BaseEvent(type) {
    /**
     * @type {boolean}
     */
    this.propagationStopped;
    /**
     * The event type.
     * @type {string}
     * @api
     */

    this.type = type;
    /**
     * The event target.
     * @type {Object}
     * @api
     */

    this.target = null;
  }
  /**
   * Stop event propagation.
   * @api
   */


  BaseEvent.prototype.preventDefault = function () {
    this.propagationStopped = true;
  };
  /**
   * Stop event propagation.
   * @api
   */


  BaseEvent.prototype.stopPropagation = function () {
    this.propagationStopped = true;
  };

  return BaseEvent;
}();
/**
 * @param {Event|import("./Event.js").default} evt Event
 */


function stopPropagation(evt) {
  evt.stopPropagation();
}
/**
 * @param {Event|import("./Event.js").default} evt Event
 */


function preventDefault(evt) {
  evt.preventDefault();
}

var _default = BaseEvent;
exports.default = _default;
},{}],"node_modules/ol/events/Target.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Disposable = _interopRequireDefault(require("../Disposable.js"));

var _functions = require("../functions.js");

var _Event = _interopRequireDefault(require("./Event.js"));

var _obj = require("../obj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/events/Target
 */


/**
 * @typedef {EventTarget|Target} EventTargetLike
 */

/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */
var Target =
/** @class */
function (_super) {
  __extends(Target, _super);
  /**
   * @param {*=} opt_target Default event target for dispatched events.
   */


  function Target(opt_target) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {*}
     */


    _this.eventTarget_ = opt_target;
    /**
     * @private
     * @type {!Object<string, number>}
     */

    _this.pendingRemovals_ = {};
    /**
     * @private
     * @type {!Object<string, number>}
     */

    _this.dispatching_ = {};
    /**
     * @private
     * @type {!Object<string, Array<import("../events.js").Listener>>}
     */

    _this.listeners_ = {};
    return _this;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */


  Target.prototype.addEventListener = function (type, listener) {
    if (!type || !listener) {
      return;
    }

    var listeners = this.listeners_[type];

    if (!listeners) {
      listeners = [];
      this.listeners_[type] = listeners;
    }

    if (listeners.indexOf(listener) === -1) {
      listeners.push(listener);
    }
  };
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */


  Target.prototype.dispatchEvent = function (event) {
    /** @type {import("./Event.js").default|Event} */
    var evt = typeof event === 'string' ? new _Event.default(event) : event;
    var type = evt.type;

    if (!evt.target) {
      evt.target = this.eventTarget_ || this;
    }

    var listeners = this.listeners_[type];
    var propagate;

    if (listeners) {
      if (!(type in this.dispatching_)) {
        this.dispatching_[type] = 0;
        this.pendingRemovals_[type] = 0;
      }

      ++this.dispatching_[type];

      for (var i = 0, ii = listeners.length; i < ii; ++i) {
        if ('handleEvent' in listeners[i]) {
          propagate =
          /** @type {import("../events.js").ListenerObject} */
          listeners[i].handleEvent(evt);
        } else {
          propagate =
          /** @type {import("../events.js").ListenerFunction} */
          listeners[i].call(this, evt);
        }

        if (propagate === false || evt.propagationStopped) {
          propagate = false;
          break;
        }
      }

      --this.dispatching_[type];

      if (this.dispatching_[type] === 0) {
        var pendingRemovals = this.pendingRemovals_[type];
        delete this.pendingRemovals_[type];

        while (pendingRemovals--) {
          this.removeEventListener(type, _functions.VOID);
        }

        delete this.dispatching_[type];
      }

      return propagate;
    }
  };
  /**
   * @inheritDoc
   */


  Target.prototype.disposeInternal = function () {
    (0, _obj.clear)(this.listeners_);
  };
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>} Listeners.
   */


  Target.prototype.getListeners = function (type) {
    return this.listeners_[type];
  };
  /**
   * @param {string=} opt_type Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */


  Target.prototype.hasListener = function (opt_type) {
    return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;
  };
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */


  Target.prototype.removeEventListener = function (type, listener) {
    var listeners = this.listeners_[type];

    if (listeners) {
      var index = listeners.indexOf(listener);

      if (index !== -1) {
        if (type in this.pendingRemovals_) {
          // make listener a no-op, and remove later in #dispatchEvent()
          listeners[index] = _functions.VOID;
          ++this.pendingRemovals_[type];
        } else {
          listeners.splice(index, 1);

          if (listeners.length === 0) {
            delete this.listeners_[type];
          }
        }
      }
    }
  };

  return Target;
}(_Disposable.default);

var _default = Target;
exports.default = _default;
},{"../Disposable.js":"node_modules/ol/Disposable.js","../functions.js":"node_modules/ol/functions.js","./Event.js":"node_modules/ol/events/Event.js","../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/Observable.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unByKey = unByKey;
exports.default = void 0;

var _events = require("./events.js");

var _Target = _interopRequireDefault(require("./events/Target.js"));

var _EventType = _interopRequireDefault(require("./events/EventType.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/Observable
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").default
 * @api
 */
var Observable =
/** @class */
function (_super) {
  __extends(Observable, _super);

  function Observable() {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {number}
     */


    _this.revision_ = 0;
    return _this;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */


  Observable.prototype.changed = function () {
    ++this.revision_;
    this.dispatchEvent(_EventType.default.CHANGE);
  };
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */


  Observable.prototype.getRevision = function () {
    return this.revision_;
  };
  /**
   * Listen for a certain type of event.
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {import("./events.js").ListenerFunction} listener The listener function.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
   *     called with an array of event types as the first argument, the return
   *     will be an array of keys.
   * @api
   */


  Observable.prototype.on = function (type, listener) {
    if (Array.isArray(type)) {
      var len = type.length;
      var keys = new Array(len);

      for (var i = 0; i < len; ++i) {
        keys[i] = (0, _events.listen)(this, type[i], listener);
      }

      return keys;
    } else {
      return (0, _events.listen)(this,
      /** @type {string} */
      type, listener);
    }
  };
  /**
   * Listen once for a certain type of event.
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {function(?): ?} listener The listener function.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
   *     called with an array of event types as the first argument, the return
   *     will be an array of keys.
   * @api
   */


  Observable.prototype.once = function (type, listener) {
    if (Array.isArray(type)) {
      var len = type.length;
      var keys = new Array(len);

      for (var i = 0; i < len; ++i) {
        keys[i] = (0, _events.listenOnce)(this, type[i], listener);
      }

      return keys;
    } else {
      return (0, _events.listenOnce)(this,
      /** @type {string} */
      type, listener);
    }
  };
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {function(?): ?} listener The listener function.
   * @api
   */


  Observable.prototype.un = function (type, listener) {
    if (Array.isArray(type)) {
      for (var i = 0, ii = type.length; i < ii; ++i) {
        this.removeEventListener(type[i], listener);
      }
    } else {
      this.removeEventListener(type, listener);
    }
  };

  return Observable;
}(_Target.default);
/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */


function unByKey(key) {
  if (Array.isArray(key)) {
    for (var i = 0, ii = key.length; i < ii; ++i) {
      (0, _events.unlistenByKey)(key[i]);
    }
  } else {
    (0, _events.unlistenByKey)(
    /** @type {import("./events.js").EventsKey} */
    key);
  }
}

var _default = Observable;
exports.default = _default;
},{"./events.js":"node_modules/ol/events.js","./events/Target.js":"node_modules/ol/events/Target.js","./events/EventType.js":"node_modules/ol/events/EventType.js"}],"node_modules/ol/Object.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getChangeEventType = getChangeEventType;
exports.default = exports.ObjectEvent = void 0;

var _util = require("./util.js");

var _ObjectEventType = _interopRequireDefault(require("./ObjectEventType.js"));

var _Observable = _interopRequireDefault(require("./Observable.js"));

var _Event = _interopRequireDefault(require("./events/Event.js"));

var _obj = require("./obj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/Object
 */


/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
 */
var ObjectEvent =
/** @class */
function (_super) {
  __extends(ObjectEvent, _super);
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */


  function ObjectEvent(type, key, oldValue) {
    var _this = _super.call(this, type) || this;
    /**
     * The name of the property whose value is changing.
     * @type {string}
     * @api
     */


    _this.key = key;
    /**
     * The old value. To get the new value use `e.target.get(e.key)` where
     * `e` is the event object.
     * @type {*}
     * @api
     */

    _this.oldValue = oldValue;
    return _this;
  }

  return ObjectEvent;
}(_Event.default);

exports.ObjectEvent = ObjectEvent;

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */
var BaseObject =
/** @class */
function (_super) {
  __extends(BaseObject, _super);
  /**
   * @param {Object<string, *>=} opt_values An object with key-value pairs.
   */


  function BaseObject(opt_values) {
    var _this = _super.call(this) || this; // Call {@link module:ol/util~getUid} to ensure that the order of objects' ids is
    // the same as the order in which they were created.  This also helps to
    // ensure that object properties are always added in the same order, which
    // helps many JavaScript engines generate faster code.


    (0, _util.getUid)(_this);
    /**
     * @private
     * @type {!Object<string, *>}
     */

    _this.values_ = {};

    if (opt_values !== undefined) {
      _this.setProperties(opt_values);
    }

    return _this;
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */


  BaseObject.prototype.get = function (key) {
    var value;

    if (this.values_.hasOwnProperty(key)) {
      value = this.values_[key];
    }

    return value;
  };
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */


  BaseObject.prototype.getKeys = function () {
    return Object.keys(this.values_);
  };
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */


  BaseObject.prototype.getProperties = function () {
    return (0, _obj.assign)({}, this.values_);
  };
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */


  BaseObject.prototype.notify = function (key, oldValue) {
    var eventType;
    eventType = getChangeEventType(key);
    this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    eventType = _ObjectEventType.default.PROPERTYCHANGE;
    this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
  };
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean=} opt_silent Update without triggering an event.
   * @api
   */


  BaseObject.prototype.set = function (key, value, opt_silent) {
    if (opt_silent) {
      this.values_[key] = value;
    } else {
      var oldValue = this.values_[key];
      this.values_[key] = value;

      if (oldValue !== value) {
        this.notify(key, oldValue);
      }
    }
  };
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean=} opt_silent Update without triggering an event.
   * @api
   */


  BaseObject.prototype.setProperties = function (values, opt_silent) {
    for (var key in values) {
      this.set(key, values[key], opt_silent);
    }
  };
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean=} opt_silent Unset without triggering an event.
   * @api
   */


  BaseObject.prototype.unset = function (key, opt_silent) {
    if (key in this.values_) {
      var oldValue = this.values_[key];
      delete this.values_[key];

      if (!opt_silent) {
        this.notify(key, oldValue);
      }
    }
  };

  return BaseObject;
}(_Observable.default);
/**
 * @type {Object<string, string>}
 */


var changeEventTypeCache = {};
/**
 * @param {string} key Key name.
 * @return {string} Change name.
 */

function getChangeEventType(key) {
  return changeEventTypeCache.hasOwnProperty(key) ? changeEventTypeCache[key] : changeEventTypeCache[key] = 'change:' + key;
}

var _default = BaseObject;
exports.default = _default;
},{"./util.js":"node_modules/ol/util.js","./ObjectEventType.js":"node_modules/ol/ObjectEventType.js","./Observable.js":"node_modules/ol/Observable.js","./events/Event.js":"node_modules/ol/events/Event.js","./obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/Feature.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createStyleFunction = createStyleFunction;
exports.default = void 0;

var _asserts = require("./asserts.js");

var _events = require("./events.js");

var _EventType = _interopRequireDefault(require("./events/EventType.js"));

var _Object = _interopRequireWildcard(require("./Object.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/Feature
 */


/**
 * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
 */

/**
 * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
 */

/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:ol/Object} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'ol/Feature';
 * import Polygon from 'ol/geom/Polygon';
 * import Point from 'ol/geom/Point';
 *
 * var feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon'
 * });
 *
 * // get the polygon geometry
 * var poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * var point = feature.getGeometry();
 * ```
 *
 * @api
 * @template {import("./geom/Geometry.js").default} Geometry
 */
var Feature =
/** @class */
function (_super) {
  __extends(Feature, _super);
  /**
   * @param {Geometry|Object<string, *>=} opt_geometryOrProperties
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */


  function Feature(opt_geometryOrProperties) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {number|string|undefined}
     */


    _this.id_ = undefined;
    /**
     * @type {string}
     * @private
     */

    _this.geometryName_ = 'geometry';
    /**
     * User provided style.
     * @private
     * @type {import("./style/Style.js").StyleLike}
     */

    _this.style_ = null;
    /**
     * @private
     * @type {import("./style/Style.js").StyleFunction|undefined}
     */

    _this.styleFunction_ = undefined;
    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */

    _this.geometryChangeKey_ = null;

    _this.addEventListener((0, _Object.getChangeEventType)(_this.geometryName_), _this.handleGeometryChanged_);

    if (opt_geometryOrProperties) {
      if (typeof
      /** @type {?} */
      opt_geometryOrProperties.getSimplifiedGeometry === 'function') {
        var geometry =
        /** @type {Geometry} */
        opt_geometryOrProperties;

        _this.setGeometry(geometry);
      } else {
        /** @type {Object<string, *>} */
        var properties = opt_geometryOrProperties;

        _this.setProperties(properties);
      }
    }

    return _this;
  }
  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature} The clone.
   * @api
   */


  Feature.prototype.clone = function () {
    var clone = new Feature(this.getProperties());
    clone.setGeometryName(this.getGeometryName());
    var geometry = this.getGeometry();

    if (geometry) {
      clone.setGeometry(geometry.clone());
    }

    var style = this.getStyle();

    if (style) {
      clone.setStyle(style);
    }

    return clone;
  };
  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */


  Feature.prototype.getGeometry = function () {
    return (
      /** @type {Geometry|undefined} */
      this.get(this.geometryName_)
    );
  };
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */


  Feature.prototype.getId = function () {
    return this.id_;
  };
  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */


  Feature.prototype.getGeometryName = function () {
    return this.geometryName_;
  };
  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike} The feature style.
   * @api
   */


  Feature.prototype.getStyle = function () {
    return this.style_;
  };
  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */


  Feature.prototype.getStyleFunction = function () {
    return this.styleFunction_;
  };
  /**
   * @private
   */


  Feature.prototype.handleGeometryChange_ = function () {
    this.changed();
  };
  /**
   * @private
   */


  Feature.prototype.handleGeometryChanged_ = function () {
    if (this.geometryChangeKey_) {
      (0, _events.unlistenByKey)(this.geometryChangeKey_);
      this.geometryChangeKey_ = null;
    }

    var geometry = this.getGeometry();

    if (geometry) {
      this.geometryChangeKey_ = (0, _events.listen)(geometry, _EventType.default.CHANGE, this.handleGeometryChange_, this);
    }

    this.changed();
  };
  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */


  Feature.prototype.setGeometry = function (geometry) {
    this.set(this.geometryName_, geometry);
  };
  /**
   * Set the style for the feature.  This can be a single style object, an array
   * of styles, or a function that takes a resolution and returns an array of
   * styles. If it is `null` the feature has no style (a `null` style).
   * @param {import("./style/Style.js").StyleLike} style Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */


  Feature.prototype.setStyle = function (style) {
    this.style_ = style;
    this.styleFunction_ = !style ? undefined : createStyleFunction(style);
    this.changed();
  };
  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */


  Feature.prototype.setId = function (id) {
    this.id_ = id;
    this.changed();
  };
  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */


  Feature.prototype.setGeometryName = function (name) {
    this.removeEventListener((0, _Object.getChangeEventType)(this.geometryName_), this.handleGeometryChanged_);
    this.geometryName_ = name;
    this.addEventListener((0, _Object.getChangeEventType)(this.geometryName_), this.handleGeometryChanged_);
    this.handleGeometryChanged_();
  };

  return Feature;
}(_Object.default);
/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of Style or single style objects wrapped
 * in a new feature style function.
 * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {import("./style/Style.js").StyleFunction} A style function.
 */


function createStyleFunction(obj) {
  if (typeof obj === 'function') {
    return obj;
  } else {
    /**
     * @type {Array<import("./style/Style.js").default>}
     */
    var styles_1;

    if (Array.isArray(obj)) {
      styles_1 = obj;
    } else {
      (0, _asserts.assert)(typeof
      /** @type {?} */
      obj.getZIndex === 'function', 41); // Expected an `import("./style/Style.js").Style` or an array of `import("./style/Style.js").Style`

      var style =
      /** @type {import("./style/Style.js").default} */
      obj;
      styles_1 = [style];
    }

    return function () {
      return styles_1;
    };
  }
}

var _default = Feature;
exports.default = _default;
},{"./asserts.js":"node_modules/ol/asserts.js","./events.js":"node_modules/ol/events.js","./events/EventType.js":"node_modules/ol/events/EventType.js","./Object.js":"node_modules/ol/Object.js"}],"node_modules/ol/math.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clamp = clamp;
exports.squaredSegmentDistance = squaredSegmentDistance;
exports.squaredDistance = squaredDistance;
exports.solveLinearSystem = solveLinearSystem;
exports.toDegrees = toDegrees;
exports.toRadians = toRadians;
exports.modulo = modulo;
exports.lerp = lerp;
exports.cosh = void 0;

/**
 * @module ol/math
 */

/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
/**
 * Return the hyperbolic cosine of a given number. The method will use the
 * native `Math.cosh` function if it is available, otherwise the hyperbolic
 * cosine will be calculated via the reference implementation of the Mozilla
 * developer network.
 *
 * @param {number} x X.
 * @return {number} Hyperbolic cosine of x.
 */


var cosh = function () {
  // Wrapped in a iife, to save the overhead of checking for the native
  // implementation on every invocation.
  var cosh;

  if ('cosh' in Math) {
    // The environment supports the native Math.cosh function, use it…
    cosh = Math.cosh;
  } else {
    // … else, use the reference implementation of MDN:
    cosh = function (x) {
      var y =
      /** @type {Math} */
      Math.exp(x);
      return (y + 1 / y) / 2;
    };
  }

  return cosh;
}();
/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */


exports.cosh = cosh;

function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;

  if (dx !== 0 || dy !== 0) {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }

  return squaredDistance(x, y, x1, y1);
}
/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */


function squaredDistance(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
}
/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>} The resulting vector.
 */


function solveLinearSystem(mat) {
  var n = mat.length;

  for (var i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);

    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);

      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    } // Swap max row with i-th (current) row


    var tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp; // Subtract the i-th row to make all the remaining rows 0 in the i-th column

    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];

      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  } // Solve Ax=b for upper triangular matrix A (mat)


  var x = new Array(n);

  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];

    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }

  return x;
}
/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */


function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}
/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */


function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */


function modulo(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
}
/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */


function lerp(a, b, x) {
  return a + x * (b - a);
}
},{}],"node_modules/ol/geom/GeometryType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/geom/GeometryType
 */

/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */
var _default = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  LINEAR_RING: 'LinearRing',
  POLYGON: 'Polygon',
  MULTI_POINT: 'MultiPoint',
  MULTI_LINE_STRING: 'MultiLineString',
  MULTI_POLYGON: 'MultiPolygon',
  GEOMETRY_COLLECTION: 'GeometryCollection',
  CIRCLE: 'Circle'
};
exports.default = _default;
},{}],"node_modules/ol/sphere.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDistance = getDistance;
exports.getLength = getLength;
exports.getArea = getArea;
exports.offset = offset;
exports.DEFAULT_RADIUS = void 0;

var _math = require("./math.js");

var _GeometryType = _interopRequireDefault(require("./geom/GeometryType.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/sphere
 */

/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 * @typedef {Object} SphereMetricOptions
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
 * Projection of the  geometry.  By default, the geometry is assumed to be in
 * Web Mercator.
 * @property {number} [radius=6371008.8] Sphere radius.  By default, the
 * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)
 * for the WGS84 ellipsoid is used.
 */

/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */
var DEFAULT_RADIUS = 6371008.8;
/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */

exports.DEFAULT_RADIUS = DEFAULT_RADIUS;

function getDistance(c1, c2, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = (0, _math.toRadians)(c1[1]);
  var lat2 = (0, _math.toRadians)(c2[1]);
  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = (0, _math.toRadians)(c2[0] - c1[0]) / 2;
  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */


function getLengthInternal(coordinates, radius) {
  var length = 0;

  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += getDistance(coordinates[i], coordinates[i + 1], radius);
  }

  return length;
}
/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions=} opt_options Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */


function getLength(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();

  if (type !== _GeometryType.default.GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }

  var length = 0;
  var coordinates, coords, i, ii, j, jj;

  switch (type) {
    case _GeometryType.default.POINT:
    case _GeometryType.default.MULTI_POINT:
      {
        break;
      }

    case _GeometryType.default.LINE_STRING:
    case _GeometryType.default.LINEAR_RING:
      {
        coordinates =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometry.getCoordinates();
        length = getLengthInternal(coordinates, radius);
        break;
      }

    case _GeometryType.default.MULTI_LINE_STRING:
    case _GeometryType.default.POLYGON:
      {
        coordinates =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          length += getLengthInternal(coordinates[i], radius);
        }

        break;
      }

    case _GeometryType.default.MULTI_POLYGON:
      {
        coordinates =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];

          for (j = 0, jj = coords.length; j < jj; ++j) {
            length += getLengthInternal(coords[j], radius);
          }
        }

        break;
      }

    case _GeometryType.default.GEOMETRY_COLLECTION:
      {
        var geometries =
        /** @type {import("./geom/GeometryCollection.js").default} */
        geometry.getGeometries();

        for (i = 0, ii = geometries.length; i < ii; ++i) {
          length += getLength(geometries[i], opt_options);
        }

        break;
      }

    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }

  return length;
}
/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */


function getAreaInternal(coordinates, radius) {
  var area = 0;
  var len = coordinates.length;
  var x1 = coordinates[len - 1][0];
  var y1 = coordinates[len - 1][1];

  for (var i = 0; i < len; i++) {
    var x2 = coordinates[i][0];
    var y2 = coordinates[i][1];
    area += (0, _math.toRadians)(x2 - x1) * (2 + Math.sin((0, _math.toRadians)(y1)) + Math.sin((0, _math.toRadians)(y2)));
    x1 = x2;
    y1 = y2;
  }

  return area * radius * radius / 2.0;
}
/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions=} opt_options Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */


function getArea(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();

  if (type !== _GeometryType.default.GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }

  var area = 0;
  var coordinates, coords, i, ii, j, jj;

  switch (type) {
    case _GeometryType.default.POINT:
    case _GeometryType.default.MULTI_POINT:
    case _GeometryType.default.LINE_STRING:
    case _GeometryType.default.MULTI_LINE_STRING:
    case _GeometryType.default.LINEAR_RING:
      {
        break;
      }

    case _GeometryType.default.POLYGON:
      {
        coordinates =
        /** @type {import("./geom/Polygon.js").default} */
        geometry.getCoordinates();
        area = Math.abs(getAreaInternal(coordinates[0], radius));

        for (i = 1, ii = coordinates.length; i < ii; ++i) {
          area -= Math.abs(getAreaInternal(coordinates[i], radius));
        }

        break;
      }

    case _GeometryType.default.MULTI_POLYGON:
      {
        coordinates =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];
          area += Math.abs(getAreaInternal(coords[0], radius));

          for (j = 1, jj = coords.length; j < jj; ++j) {
            area -= Math.abs(getAreaInternal(coords[j], radius));
          }
        }

        break;
      }

    case _GeometryType.default.GEOMETRY_COLLECTION:
      {
        var geometries =
        /** @type {import("./geom/GeometryCollection.js").default} */
        geometry.getGeometries();

        for (i = 0, ii = geometries.length; i < ii; ++i) {
          area += getArea(geometries[i], opt_options);
        }

        break;
      }

    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }

  return area;
}
/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */


function offset(c1, distance, bearing, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = (0, _math.toRadians)(c1[1]);
  var lon1 = (0, _math.toRadians)(c1[0]);
  var dByR = distance / radius;
  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [(0, _math.toDegrees)(lon), (0, _math.toDegrees)(lat)];
}
},{"./math.js":"node_modules/ol/math.js","./geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js"}],"node_modules/ol/extent/Corner.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/extent/Corner
 */

/**
 * Extent corner.
 * @enum {string}
 */
var _default = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
};
exports.default = _default;
},{}],"node_modules/ol/extent/Relationship.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/extent/Relationship
 */

/**
 * Relationship to an extent.
 * @enum {number}
 */
var _default = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
exports.default = _default;
},{}],"node_modules/ol/extent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.boundingExtent = boundingExtent;
exports.buffer = buffer;
exports.clone = clone;
exports.closestSquaredDistanceXY = closestSquaredDistanceXY;
exports.containsCoordinate = containsCoordinate;
exports.containsExtent = containsExtent;
exports.containsXY = containsXY;
exports.coordinateRelationship = coordinateRelationship;
exports.createEmpty = createEmpty;
exports.createOrUpdate = createOrUpdate;
exports.createOrUpdateEmpty = createOrUpdateEmpty;
exports.createOrUpdateFromCoordinate = createOrUpdateFromCoordinate;
exports.createOrUpdateFromCoordinates = createOrUpdateFromCoordinates;
exports.createOrUpdateFromFlatCoordinates = createOrUpdateFromFlatCoordinates;
exports.createOrUpdateFromRings = createOrUpdateFromRings;
exports.equals = equals;
exports.approximatelyEquals = approximatelyEquals;
exports.extend = extend;
exports.extendCoordinate = extendCoordinate;
exports.extendCoordinates = extendCoordinates;
exports.extendFlatCoordinates = extendFlatCoordinates;
exports.extendRings = extendRings;
exports.extendXY = extendXY;
exports.forEachCorner = forEachCorner;
exports.getArea = getArea;
exports.getBottomLeft = getBottomLeft;
exports.getBottomRight = getBottomRight;
exports.getCenter = getCenter;
exports.getCorner = getCorner;
exports.getEnlargedArea = getEnlargedArea;
exports.getForViewAndSize = getForViewAndSize;
exports.getHeight = getHeight;
exports.getIntersectionArea = getIntersectionArea;
exports.getIntersection = getIntersection;
exports.getMargin = getMargin;
exports.getSize = getSize;
exports.getTopLeft = getTopLeft;
exports.getTopRight = getTopRight;
exports.getWidth = getWidth;
exports.intersects = intersects;
exports.isEmpty = isEmpty;
exports.returnOrUpdate = returnOrUpdate;
exports.scaleFromCenter = scaleFromCenter;
exports.intersectsSegment = intersectsSegment;
exports.applyTransform = applyTransform;
exports.wrapX = wrapX;

var _asserts = require("./asserts.js");

var _Corner = _interopRequireDefault(require("./extent/Corner.js"));

var _Relationship = _interopRequireDefault(require("./extent/Relationship.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/extent
 */

/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */

/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */
function boundingExtent(coordinates) {
  var extent = createEmpty();

  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }

  return extent;
}
/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent=} opt_extent Destination extent.
 * @private
 * @return {Extent} Extent.
 */


function _boundingExtentXYs(xs, ys, opt_extent) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
}
/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 * @api
 */


function buffer(extent, value, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0] - value;
    opt_extent[1] = extent[1] - value;
    opt_extent[2] = extent[2] + value;
    opt_extent[3] = extent[3] + value;
    return opt_extent;
  } else {
    return [extent[0] - value, extent[1] - value, extent[2] + value, extent[3] + value];
  }
}
/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} The clone.
 */


function clone(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent.slice();
  }
}
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */


function closestSquaredDistanceXY(extent, x, y) {
  var dx, dy;

  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }

  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }

  return dx * dx + dy * dy;
}
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */


function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}
/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */


function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */


function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {Relationship} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */


function coordinateRelationship(extent, coordinate) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var x = coordinate[0];
  var y = coordinate[1];
  var relationship = _Relationship.default.UNKNOWN;

  if (x < minX) {
    relationship = relationship | _Relationship.default.LEFT;
  } else if (x > maxX) {
    relationship = relationship | _Relationship.default.RIGHT;
  }

  if (y < minY) {
    relationship = relationship | _Relationship.default.BELOW;
  } else if (y > maxY) {
    relationship = relationship | _Relationship.default.ABOVE;
  }

  if (relationship === _Relationship.default.UNKNOWN) {
    relationship = _Relationship.default.INTERSECTING;
  }

  return relationship;
}
/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */


function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent=} opt_extent Destination extent.
 * @return {Extent} Extent.
 */


function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = minX;
    opt_extent[1] = minY;
    opt_extent[2] = maxX;
    opt_extent[3] = maxY;
    return opt_extent;
  } else {
    return [minX, minY, maxX, maxY];
  }
}
/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */


function createOrUpdateEmpty(opt_extent) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
}
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */


function createOrUpdateFromCoordinate(coordinate, opt_extent) {
  var x = coordinate[0];
  var y = coordinate[1];
  return createOrUpdate(x, y, x, y, opt_extent);
}
/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */


function createOrUpdateFromCoordinates(coordinates, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendCoordinates(extent, coordinates);
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */


function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */


function createOrUpdateFromRings(rings, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendRings(extent, rings);
}
/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */


function equals(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
/**
 * Determine if two extents are approximately equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {number} tolerance Tolerance in extent coordinate units.
 * @return {boolean} The two extents differ by less than the tolerance.
 */


function approximatelyEquals(extent1, extent2, tolerance) {
  return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
}
/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */


function extend(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }

  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }

  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }

  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }

  return extent1;
}
/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */


function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }

  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }

  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }

  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */


function extendCoordinates(extent, coordinates) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }

  return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */


function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }

  return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */


function extendRings(extent, rings) {
  for (var i = 0, ii = rings.length; i < ii; ++i) {
    extendCoordinates(extent, rings[i]);
  }

  return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */


function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}
/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
 * @return {S|boolean} Value.
 * @template S
 */


function forEachCorner(extent, callback) {
  var val;
  val = callback(getBottomLeft(extent));

  if (val) {
    return val;
  }

  val = callback(getBottomRight(extent));

  if (val) {
    return val;
  }

  val = callback(getTopRight(extent));

  if (val) {
    return val;
  }

  val = callback(getTopLeft(extent));

  if (val) {
    return val;
  }

  return false;
}
/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */


function getArea(extent) {
  var area = 0;

  if (!isEmpty(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }

  return area;
}
/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */


function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}
/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */


function getBottomRight(extent) {
  return [extent[2], extent[1]];
}
/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */


function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}
/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {Corner} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */


function getCorner(extent, corner) {
  var coordinate;

  if (corner === _Corner.default.BOTTOM_LEFT) {
    coordinate = getBottomLeft(extent);
  } else if (corner === _Corner.default.BOTTOM_RIGHT) {
    coordinate = getBottomRight(extent);
  } else if (corner === _Corner.default.TOP_LEFT) {
    coordinate = getTopLeft(extent);
  } else if (corner === _Corner.default.TOP_RIGHT) {
    coordinate = getTopRight(extent);
  } else {
    (0, _asserts.assert)(false, 13); // Invalid corner
  }

  return coordinate;
}
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */


function getEnlargedArea(extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}
/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent=} opt_extent Destination extent.
 * @return {Extent} Extent.
 */


function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x = center[0];
  var y = center[1];
  var x0 = x - xCos + ySin;
  var x1 = x - xCos - ySin;
  var x2 = x + xCos - ySin;
  var x3 = x + xCos + ySin;
  var y0 = y - xSin - yCos;
  var y1 = y - xSin + yCos;
  var y2 = y + xSin + yCos;
  var y3 = y + xSin - yCos;
  return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
}
/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */


function getHeight(extent) {
  return extent[3] - extent[1];
}
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */


function getIntersectionArea(extent1, extent2) {
  var intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}
/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent=} opt_extent Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */


function getIntersection(extent1, extent2, opt_extent) {
  var intersection = opt_extent ? opt_extent : createEmpty();

  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }

    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }

    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }

    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }

  return intersection;
}
/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */


function getMargin(extent) {
  return getWidth(extent) + getHeight(extent);
}
/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */


function getSize(extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
}
/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */


function getTopLeft(extent) {
  return [extent[0], extent[3]];
}
/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */


function getTopRight(extent) {
  return [extent[2], extent[3]];
}
/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */


function getWidth(extent) {
  return extent[2] - extent[0];
}
/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */


function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */


function isEmpty(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}
/**
 * @param {Extent} extent Extent.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */


function returnOrUpdate(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent;
  }
}
/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */


function scaleFromCenter(extent, value) {
  var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
  var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
}
/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */


function intersectsSegment(extent, start, end) {
  var intersects = false;
  var startRel = coordinateRelationship(extent, start);
  var endRel = coordinateRelationship(extent, end);

  if (startRel === _Relationship.default.INTERSECTING || endRel === _Relationship.default.INTERSECTING) {
    intersects = true;
  } else {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var startX = start[0];
    var startY = start[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x = void 0,
        y = void 0;

    if (!!(endRel & _Relationship.default.ABOVE) && !(startRel & _Relationship.default.ABOVE)) {
      // potentially intersects top
      x = endX - (endY - maxY) / slope;
      intersects = x >= minX && x <= maxX;
    }

    if (!intersects && !!(endRel & _Relationship.default.RIGHT) && !(startRel & _Relationship.default.RIGHT)) {
      // potentially intersects right
      y = endY - (endX - maxX) * slope;
      intersects = y >= minY && y <= maxY;
    }

    if (!intersects && !!(endRel & _Relationship.default.BELOW) && !(startRel & _Relationship.default.BELOW)) {
      // potentially intersects bottom
      x = endX - (endY - minY) / slope;
      intersects = x >= minX && x <= maxX;
    }

    if (!intersects && !!(endRel & _Relationship.default.LEFT) && !(startRel & _Relationship.default.LEFT)) {
      // potentially intersects left
      y = endY - (endX - minX) * slope;
      intersects = y >= minY && y <= maxY;
    }
  }

  return intersects;
}
/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent=} opt_extent Destination extent.
 * @param {number=} opt_stops Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {Extent} Extent.
 * @api
 */


function applyTransform(extent, transformFn, opt_extent, opt_stops) {
  var coordinates = [];

  if (opt_stops > 1) {
    var width = extent[2] - extent[0];
    var height = extent[3] - extent[1];

    for (var i = 0; i < opt_stops; ++i) {
      coordinates.push(extent[0] + width * i / opt_stops, extent[1], extent[2], extent[1] + height * i / opt_stops, extent[2] - width * i / opt_stops, extent[3], extent[0], extent[3] - height * i / opt_stops);
    }
  } else {
    coordinates = [extent[0], extent[1], extent[2], extent[1], extent[2], extent[3], extent[0], extent[3]];
  }

  transformFn(coordinates, coordinates, 2);
  var xs = [];
  var ys = [];

  for (var i = 0, l = coordinates.length; i < l; i += 2) {
    xs.push(coordinates[i]);
    ys.push(coordinates[i + 1]);
  }

  return _boundingExtentXYs(xs, ys, opt_extent);
}
/**
 * Modifies the provided extent in-place to be within the real world
 * extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Extent} The extent within the real world extent.
 */


function wrapX(extent, projection) {
  var projectionExtent = projection.getExtent();
  var center = getCenter(extent);

  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    var worldWidth = getWidth(projectionExtent);
    var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
    var offset = worldsAway * worldWidth;
    extent[0] -= offset;
    extent[2] -= offset;
  }

  return extent;
}
},{"./asserts.js":"node_modules/ol/asserts.js","./extent/Corner.js":"node_modules/ol/extent/Corner.js","./extent/Relationship.js":"node_modules/ol/extent/Relationship.js"}],"node_modules/ol/proj/Units.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.METERS_PER_UNIT = void 0;

/**
 * @module ol/proj/Units
 */

/**
 * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
 * `'us-ft'`.
 * @enum {string}
 */
var Units = {
  DEGREES: 'degrees',
  FEET: 'ft',
  METERS: 'm',
  PIXELS: 'pixels',
  TILE_PIXELS: 'tile-pixels',
  USFEET: 'us-ft'
};
/**
 * Meters per unit lookup table.
 * @const
 * @type {Object<Units, number>}
 * @api
 */

var METERS_PER_UNIT = {}; // use the radius of the Normal sphere

exports.METERS_PER_UNIT = METERS_PER_UNIT;
METERS_PER_UNIT[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;
METERS_PER_UNIT[Units.FEET] = 0.3048;
METERS_PER_UNIT[Units.METERS] = 1;
METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;
var _default = Units;
exports.default = _default;
},{}],"node_modules/ol/proj/Projection.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Units = require("./Units.js");

/**
 * @module ol/proj/Projection
 */

/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").default|string} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `{number}` view resolution and an `{import("../coordinate.js").Coordinate}` as arguments, and returns
 * the `{number}` resolution in projection units at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj#getPointResolution} function will be used.
 */

/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj~get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
 * be added using `proj4.defs()`. After all required projection definitions are
 * added, call the {@link module:ol/proj/proj4~register} function.
 *
 * @api
 */
var Projection =
/** @class */
function () {
  /**
   * @param {Options} options Projection options.
   */
  function Projection(options) {
    /**
     * @private
     * @type {string}
     */
    this.code_ = options.code;
    /**
     * Units of projected coordinates. When set to `TILE_PIXELS`, a
     * `this.extent_` and `this.worldExtent_` must be configured properly for each
     * tile.
     * @private
     * @type {import("./Units.js").default}
     */

    this.units_ =
    /** @type {import("./Units.js").default} */
    options.units;
    /**
     * Validity extent of the projection in projected coordinates. For projections
     * with `TILE_PIXELS` units, this is the extent of the tile in
     * tile pixel space.
     * @private
     * @type {import("../extent.js").Extent}
     */

    this.extent_ = options.extent !== undefined ? options.extent : null;
    /**
     * Extent of the world in EPSG:4326. For projections with
     * `TILE_PIXELS` units, this is the extent of the tile in
     * projected coordinate space.
     * @private
     * @type {import("../extent.js").Extent}
     */

    this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;
    /**
     * @private
     * @type {string}
     */

    this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
    /**
     * @private
     * @type {boolean}
     */

    this.global_ = options.global !== undefined ? options.global : false;
    /**
     * @private
     * @type {boolean}
     */

    this.canWrapX_ = !!(this.global_ && this.extent_);
    /**
     * @private
     * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
     */

    this.getPointResolutionFunc_ = options.getPointResolution;
    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */

    this.defaultTileGrid_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    this.metersPerUnit_ = options.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */


  Projection.prototype.canWrapX = function () {
    return this.canWrapX_;
  };
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */


  Projection.prototype.getCode = function () {
    return this.code_;
  };
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */


  Projection.prototype.getExtent = function () {
    return this.extent_;
  };
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").default} Units.
   * @api
   */


  Projection.prototype.getUnits = function () {
    return this.units_;
  };
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */


  Projection.prototype.getMetersPerUnit = function () {
    return this.metersPerUnit_ || _Units.METERS_PER_UNIT[this.units_];
  };
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */


  Projection.prototype.getWorldExtent = function () {
    return this.worldExtent_;
  };
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */


  Projection.prototype.getAxisOrientation = function () {
    return this.axisOrientation_;
  };
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */


  Projection.prototype.isGlobal = function () {
    return this.global_;
  };
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */


  Projection.prototype.setGlobal = function (global) {
    this.global_ = global;
    this.canWrapX_ = !!(global && this.extent_);
  };
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */


  Projection.prototype.getDefaultTileGrid = function () {
    return this.defaultTileGrid_;
  };
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */


  Projection.prototype.setDefaultTileGrid = function (tileGrid) {
    this.defaultTileGrid_ = tileGrid;
  };
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */


  Projection.prototype.setExtent = function (extent) {
    this.extent_ = extent;
    this.canWrapX_ = !!(this.global_ && extent);
  };
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */


  Projection.prototype.setWorldExtent = function (worldExtent) {
    this.worldExtent_ = worldExtent;
  };
  /**
   * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */


  Projection.prototype.setGetPointResolution = function (func) {
    this.getPointResolutionFunc_ = func;
  };
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */


  Projection.prototype.getPointResolutionFunc = function () {
    return this.getPointResolutionFunc_;
  };

  return Projection;
}();

var _default = Projection;
exports.default = _default;
},{"./Units.js":"node_modules/ol/proj/Units.js"}],"node_modules/ol/proj/epsg3857.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromEPSG4326 = fromEPSG4326;
exports.toEPSG4326 = toEPSG4326;
exports.PROJECTIONS = exports.WORLD_EXTENT = exports.EXTENT = exports.HALF_SIZE = exports.RADIUS = void 0;

var _math = require("../math.js");

var _Projection = _interopRequireDefault(require("./Projection.js"));

var _Units = _interopRequireDefault(require("./Units.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/proj/epsg3857
 */


/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */
var RADIUS = 6378137;
/**
 * @const
 * @type {number}
 */

exports.RADIUS = RADIUS;
var HALF_SIZE = Math.PI * RADIUS;
/**
 * @const
 * @type {import("../extent.js").Extent}
 */

exports.HALF_SIZE = HALF_SIZE;
var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
/**
 * @const
 * @type {import("../extent.js").Extent}
 */

exports.EXTENT = EXTENT;
var WORLD_EXTENT = [-180, -85, 180, 85];
/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */

exports.WORLD_EXTENT = WORLD_EXTENT;

var EPSG3857Projection =
/** @class */
function (_super) {
  __extends(EPSG3857Projection, _super);
  /**
   * @param {string} code Code.
   */


  function EPSG3857Projection(code) {
    return _super.call(this, {
      code: code,
      units: _Units.default.METERS,
      extent: EXTENT,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function (resolution, point) {
        return resolution / (0, _math.cosh)(point[1] / RADIUS);
      }
    }) || this;
  }

  return EPSG3857Projection;
}(_Projection.default);
/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */


var PROJECTIONS = [new EPSG3857Projection('EPSG:3857'), new EPSG3857Projection('EPSG:102100'), new EPSG3857Projection('EPSG:102113'), new EPSG3857Projection('EPSG:900913'), new EPSG3857Projection('urn:ogc:def:crs:EPSG:6.18:3:3857'), new EPSG3857Projection('urn:ogc:def:crs:EPSG::3857'), new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')];
/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */

exports.PROJECTIONS = PROJECTIONS;

function fromEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;

  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }

  var halfSize = HALF_SIZE;

  for (var i = 0; i < length; i += dimension) {
    output[i] = halfSize * input[i] / 180;
    var y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));

    if (y > halfSize) {
      y = halfSize;
    } else if (y < -halfSize) {
      y = -halfSize;
    }

    output[i + 1] = y;
  }

  return output;
}
/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */


function toEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;

  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }

  for (var i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }

  return output;
}
},{"../math.js":"node_modules/ol/math.js","./Projection.js":"node_modules/ol/proj/Projection.js","./Units.js":"node_modules/ol/proj/Units.js"}],"node_modules/ol/proj/epsg4326.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PROJECTIONS = exports.METERS_PER_UNIT = exports.EXTENT = exports.RADIUS = void 0;

var _Projection = _interopRequireDefault(require("./Projection.js"));

var _Units = _interopRequireDefault(require("./Units.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/proj/epsg4326
 */


/**
 * Semi-major radius of the WGS84 ellipsoid.
 *
 * @const
 * @type {number}
 */
var RADIUS = 6378137;
/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {import("../extent.js").Extent}
 */

exports.RADIUS = RADIUS;
var EXTENT = [-180, -90, 180, 90];
/**
 * @const
 * @type {number}
 */

exports.EXTENT = EXTENT;
var METERS_PER_UNIT = Math.PI * RADIUS / 180;
/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */

exports.METERS_PER_UNIT = METERS_PER_UNIT;

var EPSG4326Projection =
/** @class */
function (_super) {
  __extends(EPSG4326Projection, _super);
  /**
   * @param {string} code Code.
   * @param {string=} opt_axisOrientation Axis orientation.
   */


  function EPSG4326Projection(code, opt_axisOrientation) {
    return _super.call(this, {
      code: code,
      units: _Units.default.DEGREES,
      extent: EXTENT,
      axisOrientation: opt_axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT,
      worldExtent: EXTENT
    }) || this;
  }

  return EPSG4326Projection;
}(_Projection.default);
/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */


var PROJECTIONS = [new EPSG4326Projection('CRS:84'), new EPSG4326Projection('EPSG:4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:EPSG::4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'), new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'), new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'), new EPSG4326Projection('urn:x-ogc:def:crs:EPSG:4326', 'neu')];
exports.PROJECTIONS = PROJECTIONS;
},{"./Projection.js":"node_modules/ol/proj/Projection.js","./Units.js":"node_modules/ol/proj/Units.js"}],"node_modules/ol/proj/transforms.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.add = add;
exports.remove = remove;
exports.get = get;

var _obj = require("../obj.js");

/**
 * @module ol/proj/transforms
 */

/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */
var transforms = {};
/**
 * Clear the transform cache.
 */

function clear() {
  transforms = {};
}
/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */


function add(source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();

  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }

  transforms[sourceCode][destinationCode] = transformFn;
}
/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */


function remove(source, destination) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];

  if ((0, _obj.isEmpty)(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }

  return transform;
}
/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
 */


function get(sourceCode, destinationCode) {
  var transform;

  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }

  return transform;
}
},{"../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/proj/projections.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.get = get;
exports.add = add;

/**
 * @module ol/proj/projections
 */

/**
 * @type {Object<string, import("./Projection.js").default>}
 */
var cache = {};
/**
 * Clear the projections cache.
 */

function clear() {
  cache = {};
}
/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default} The projection (if cached).
 */


function get(code) {
  return cache[code] || null;
}
/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */


function add(code, projection) {
  cache[code] = projection;
}
},{}],"node_modules/ol/proj.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneTransform = cloneTransform;
exports.identityTransform = identityTransform;
exports.addProjection = addProjection;
exports.addProjections = addProjections;
exports.get = get;
exports.getPointResolution = getPointResolution;
exports.addEquivalentProjections = addEquivalentProjections;
exports.addEquivalentTransforms = addEquivalentTransforms;
exports.clearAllProjections = clearAllProjections;
exports.createProjection = createProjection;
exports.createTransformFromCoordinateTransform = createTransformFromCoordinateTransform;
exports.addCoordinateTransforms = addCoordinateTransforms;
exports.fromLonLat = fromLonLat;
exports.toLonLat = toLonLat;
exports.equivalent = equivalent;
exports.getTransformFromProjections = getTransformFromProjections;
exports.getTransform = getTransform;
exports.transform = transform;
exports.transformExtent = transformExtent;
exports.transformWithProjections = transformWithProjections;
exports.setUserProjection = setUserProjection;
exports.clearUserProjection = clearUserProjection;
exports.getUserProjection = getUserProjection;
exports.useGeographic = useGeographic;
exports.toUserCoordinate = toUserCoordinate;
exports.fromUserCoordinate = fromUserCoordinate;
exports.toUserExtent = toUserExtent;
exports.fromUserExtent = fromUserExtent;
exports.addCommon = addCommon;
Object.defineProperty(exports, "Projection", {
  enumerable: true,
  get: function () {
    return _Projection.default;
  }
});
Object.defineProperty(exports, "METERS_PER_UNIT", {
  enumerable: true,
  get: function () {
    return _Units.METERS_PER_UNIT;
  }
});

var _sphere = require("./sphere.js");

var _extent = require("./extent.js");

var _math = require("./math.js");

var _epsg = require("./proj/epsg3857.js");

var _epsg2 = require("./proj/epsg4326.js");

var _Projection = _interopRequireDefault(require("./proj/Projection.js"));

var _Units = _interopRequireWildcard(require("./proj/Units.js"));

var _transforms = require("./proj/transforms.js");

var _projections = require("./proj/projections.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/proj
 */

/**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj~addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection} object for the new projection and add it with
 * {@link module:ol/proj~addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj~addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection} with
 * {@link module:ol/proj~addProjection}. See examples/wms-no-proj for an example of
 * this.
 */

/**
 * A projection as {@link module:ol/proj/Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */

/**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction
 * @api
 */

/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */
function cloneTransform(input, opt_output, opt_dimension) {
  var output;

  if (opt_output !== undefined) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }

    output = opt_output;
  } else {
    output = input.slice();
  }

  return output;
}
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array<number>} Input coordinate array (same array as input).
 */


function identityTransform(input, opt_output, opt_dimension) {
  if (opt_output !== undefined && input !== opt_output) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }

    input = opt_output;
  }

  return input;
}
/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */


function addProjection(projection) {
  (0, _projections.add)(projection.getCode(), projection);
  (0, _transforms.add)(projection, projection, cloneTransform);
}
/**
 * @param {Array<Projection>} projections Projections.
 */


function addProjections(projections) {
  projections.forEach(addProjection);
}
/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection} Projection object, or null if not in list.
 * @api
 */


function get(projectionLike) {
  return typeof projectionLike === 'string' ? (0, _projections.get)(
  /** @type {string} */
  projectionLike) :
  /** @type {Projection} */
  projectionLike || null;
}
/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the 'point' pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {Units=} opt_units Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */


function getPointResolution(projection, resolution, point, opt_units) {
  projection = get(projection);
  var pointResolution;
  var getter = projection.getPointResolutionFunc();

  if (getter) {
    pointResolution = getter(resolution, point);

    if (opt_units && opt_units !== projection.getUnits()) {
      var metersPerUnit = projection.getMetersPerUnit();

      if (metersPerUnit) {
        pointResolution = pointResolution * metersPerUnit / _Units.METERS_PER_UNIT[opt_units];
      }
    }
  } else {
    var units = projection.getUnits();

    if (units == _Units.default.DEGREES && !opt_units || opt_units == _Units.default.DEGREES) {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      var toEPSG4326_1 = getTransformFromProjections(projection, get('EPSG:4326'));
      var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];
      vertices = toEPSG4326_1(vertices, vertices, 2);
      var width = (0, _sphere.getDistance)(vertices.slice(0, 2), vertices.slice(2, 4));
      var height = (0, _sphere.getDistance)(vertices.slice(4, 6), vertices.slice(6, 8));
      pointResolution = (width + height) / 2;
      var metersPerUnit = opt_units ? _Units.METERS_PER_UNIT[opt_units] : projection.getMetersPerUnit();

      if (metersPerUnit !== undefined) {
        pointResolution /= metersPerUnit;
      }
    }
  }

  return pointResolution;
}
/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */


function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function (source) {
    projections.forEach(function (destination) {
      if (source !== destination) {
        (0, _transforms.add)(source, destination, cloneTransform);
      }
    });
  });
}
/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */


function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function (projection1) {
    projections2.forEach(function (projection2) {
      (0, _transforms.add)(projection1, projection2, forwardTransform);
      (0, _transforms.add)(projection2, projection1, inverseTransform);
    });
  });
}
/**
 * Clear all cached projections and transforms.
 */


function clearAllProjections() {
  (0, _projections.clear)();
  (0, _transforms.clear)();
}
/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */


function createProjection(projection, defaultCode) {
  if (!projection) {
    return get(defaultCode);
  } else if (typeof projection === 'string') {
    return get(projection);
  } else {
    return (
      /** @type {Projection} */
      projection
    );
  }
}
/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */


function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>=} opt_output Output.
     * @param {number=} opt_dimension Dimension.
     * @return {Array<number>} Output.
     */
    function (input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension !== undefined ? opt_dimension : 2;
      var output = opt_output !== undefined ? opt_output : new Array(length);

      for (var i = 0; i < length; i += dimension) {
        var point = coordTransform([input[i], input[i + 1]]);
        output[i] = point[0];
        output[i + 1] = point[1];

        for (var j = dimension - 1; j >= 2; --j) {
          output[i + j] = input[i + j];
        }
      }

      return output;
    }
  );
}
/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @api
 */


function addCoordinateTransforms(source, destination, forward, inverse) {
  var sourceProj = get(source);
  var destProj = get(destination);
  (0, _transforms.add)(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
  (0, _transforms.add)(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}
/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike=} opt_projection Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */


function fromLonLat(coordinate, opt_projection) {
  return transform(coordinate, 'EPSG:4326', opt_projection !== undefined ? opt_projection : 'EPSG:3857');
}
/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike=} opt_projection Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */


function toLonLat(coordinate, opt_projection) {
  var lonLat = transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');
  var lon = lonLat[0];

  if (lon < -180 || lon > 180) {
    lonLat[0] = (0, _math.modulo)(lon + 180, 360) - 180;
  }

  return lonLat;
}
/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */


function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }

  var equalUnits = projection1.getUnits() === projection2.getUnits();

  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  } else {
    var transformFunc = getTransformFromProjections(projection1, projection2);
    return transformFunc === cloneTransform && equalUnits;
  }
}
/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} sourceProjection Source Projection object.
 * @param {Projection} destinationProjection Destination Projection
 *     object.
 * @return {TransformFunction} Transform function.
 */


function getTransformFromProjections(sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();
  var transformFunc = (0, _transforms.get)(sourceCode, destinationCode);

  if (!transformFunc) {
    transformFunc = identityTransform;
  }

  return transformFunc;
}
/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */


function getTransform(source, destination) {
  var sourceProjection = get(source);
  var destinationProjection = get(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj~transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */


function transform(coordinate, source, destination) {
  var transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, undefined, coordinate.length);
}
/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @param {number=} opt_stops Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */


function transformExtent(extent, source, destination, opt_stops) {
  var transformFunc = getTransform(source, destination);
  return (0, _extent.applyTransform)(extent, transformFunc, undefined, opt_stops);
}
/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */


function transformWithProjections(point, sourceProjection, destinationProjection) {
  var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
  return transformFunc(point);
}
/**
 * @type {?Projection}
 */


var userProjection = null;
/**
 * Set the projection for coordinates supplied from and returned by API methods.
 * Note that this method is not yet a part of the stable API.  Support for user
 * projections is not yet complete and should be considered experimental.
 * @param {ProjectionLike} projection The user projection.
 */

function setUserProjection(projection) {
  userProjection = get(projection);
}
/**
 * Clear the user projection if set.  Note that this method is not yet a part of
 * the stable API.  Support for user projections is not yet complete and should
 * be considered experimental.
 */


function clearUserProjection() {
  userProjection = null;
}
/**
 * Get the projection for coordinates supplied from and returned by API methods.
 * Note that this method is not yet a part of the stable API.  Support for user
 * projections is not yet complete and should be considered experimental.
 * @returns {?Projection} The user projection (or null if not set).
 */


function getUserProjection() {
  return userProjection;
}
/**
 * Use geographic coordinates (WGS-84 datum) in API methods.  Note that this
 * method is not yet a part of the stable API.  Support for user projections is
 * not yet complete and should be considered experimental.
 */


function useGeographic() {
  setUserProjection('EPSG:4326');
}
/**
 * Return a coordinate transformed into the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} sourceProjection The input coordinate projection.
 * @returns {Array<number>} The input coordinate in the user projection.
 */


function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }

  return transform(coordinate, sourceProjection, userProjection);
}
/**
 * Return a coordinate transformed from the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} destProjection The destination projection.
 * @returns {Array<number>} The input coordinate transformed.
 */


function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    return coordinate;
  }

  return transform(coordinate, userProjection, destProjection);
}
/**
 * Return an extent transformed into the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} sourceProjection The input extent projection.
 * @returns {import("./extent.js").Extent} The input extent in the user projection.
 */


function toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }

  return transformExtent(extent, sourceProjection, userProjection);
}
/**
 * Return an extent transformed from the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} destProjection The destination projection.
 * @returns {import("./extent.js").Extent} The input extent transformed.
 */


function fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }

  return transformExtent(extent, userProjection, destProjection);
}
/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */


function addCommon() {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  addEquivalentProjections(_epsg.PROJECTIONS);
  addEquivalentProjections(_epsg2.PROJECTIONS); // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.

  addEquivalentTransforms(_epsg2.PROJECTIONS, _epsg.PROJECTIONS, _epsg.fromEPSG4326, _epsg.toEPSG4326);
}

addCommon();
},{"./sphere.js":"node_modules/ol/sphere.js","./extent.js":"node_modules/ol/extent.js","./math.js":"node_modules/ol/math.js","./proj/epsg3857.js":"node_modules/ol/proj/epsg3857.js","./proj/epsg4326.js":"node_modules/ol/proj/epsg4326.js","./proj/Projection.js":"node_modules/ol/proj/Projection.js","./proj/Units.js":"node_modules/ol/proj/Units.js","./proj/transforms.js":"node_modules/ol/proj/transforms.js","./proj/projections.js":"node_modules/ol/proj/projections.js"}],"node_modules/ol/format/Feature.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformGeometryWithOptions = transformGeometryWithOptions;
exports.transformExtentWithOptions = transformExtentWithOptions;
exports.default = void 0;

var _obj = require("../obj.js");

var _util = require("../util.js");

var _proj = require("../proj.js");

var _Units = _interopRequireDefault(require("../proj/Units.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/format/Feature
 */

/**
 * @typedef {Object} ReadOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are reading.
 * If not provided, the projection will be derived from the data (where possible) or
 * the `dataProjection` of the format is assigned (where set). If the projection
 * can not be derived from the data and if no `dataProjection` is set for a format,
 * the features will not be reprojected.
 * @property {import("../extent.js").Extent} [extent] Tile extent in map units of the tile being read.
 * This is only required when reading data with tile pixels as geometry units. When configured,
 * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be
 * provided.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * created by the format reader. If not provided, features will be returned in the
 * `dataProjection`.
 */

/**
 * @typedef {Object} WriteOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are writing.
 * If not provided, the `dataProjection` of the format is assigned (where set).
 * If no `dataProjection` is set for a format, the features will be returned
 * in the `featureProjection`.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * that will be serialized by the format writer. If not provided, geometries are assumed
 * to be in the `dataProjection` if that is set; in other words, they are not transformed.
 * @property {boolean} [rightHanded] When writing geometries, follow the right-hand
 * rule for linear ring orientation.  This means that polygons will have counter-clockwise
 * exterior rings and clockwise interior rings.  By default, coordinates are serialized
 * as they are provided at construction.  If `true`, the right-hand rule will
 * be applied.  If `false`, the left-hand rule will be applied (clockwise for
 * exterior and counter-clockwise for interior rings).  Note that not all
 * formats support this.  The GeoJSON format does use this property when writing
 * geometries.
 * @property {number} [decimals] Maximum number of decimal places for coordinates.
 * Coordinates are stored internally as floats, but floating-point arithmetic can create
 * coordinates with a large number of decimal places, not generally wanted on output.
 * Set a number here to round coordinates. Can also be used to ensure that
 * coordinates read in can be written back out with the same number of decimals.
 * Default is no rounding.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for feature formats.
 * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode
 * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial
 * file formats.  See the documentation for each format for more details.
 *
 * @abstract
 * @api
 */
var FeatureFormat =
/** @class */
function () {
  function FeatureFormat() {
    /**
     * @protected
     * @type {import("../proj/Projection.js").default}
     */
    this.dataProjection = null;
    /**
     * @protected
     * @type {import("../proj/Projection.js").default}
     */

    this.defaultFeatureProjection = null;
  }
  /**
   * Adds the data projection to the read options.
   * @param {Document|Node|Object|string} source Source.
   * @param {ReadOptions=} opt_options Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */


  FeatureFormat.prototype.getReadOptions = function (source, opt_options) {
    var options;

    if (opt_options) {
      var dataProjection = opt_options.dataProjection ? (0, _proj.get)(opt_options.dataProjection) : this.readProjection(source);

      if (opt_options.extent && dataProjection && dataProjection.getUnits() === _Units.default.TILE_PIXELS) {
        dataProjection = (0, _proj.get)(dataProjection);
        dataProjection.setWorldExtent(opt_options.extent);
      }

      options = {
        dataProjection: dataProjection,
        featureProjection: opt_options.featureProjection
      };
    }

    return this.adaptOptions(options);
  };
  /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */


  FeatureFormat.prototype.adaptOptions = function (options) {
    return (0, _obj.assign)({
      dataProjection: this.dataProjection,
      featureProjection: this.defaultFeatureProjection
    }, options);
  };
  /**
   * @abstract
   * @return {import("./FormatType.js").default} Format.
   */


  FeatureFormat.prototype.getType = function () {
    return (0, _util.abstract)();
  };
  /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Node|Object|string} source Source.
   * @param {ReadOptions=} opt_options Read options.
   * @return {import("../Feature.js").FeatureLike} Feature.
   */


  FeatureFormat.prototype.readFeature = function (source, opt_options) {
    return (0, _util.abstract)();
  };
  /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Node|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions=} opt_options Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   */


  FeatureFormat.prototype.readFeatures = function (source, opt_options) {
    return (0, _util.abstract)();
  };
  /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Node|Object|string} source Source.
   * @param {ReadOptions=} opt_options Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */


  FeatureFormat.prototype.readGeometry = function (source, opt_options) {
    return (0, _util.abstract)();
  };
  /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Node|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   */


  FeatureFormat.prototype.readProjection = function (source) {
    return (0, _util.abstract)();
  };
  /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {WriteOptions=} opt_options Write options.
   * @return {string} Result.
   */


  FeatureFormat.prototype.writeFeature = function (feature, opt_options) {
    return (0, _util.abstract)();
  };
  /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {WriteOptions=} opt_options Write options.
   * @return {string} Result.
   */


  FeatureFormat.prototype.writeFeatures = function (features, opt_options) {
    return (0, _util.abstract)();
  };
  /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions=} opt_options Write options.
   * @return {string} Result.
   */


  FeatureFormat.prototype.writeGeometry = function (geometry, opt_options) {
    return (0, _util.abstract)();
  };

  return FeatureFormat;
}();

var _default = FeatureFormat;
/**
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {boolean} write Set to true for writing, false for reading.
 * @param {(WriteOptions|ReadOptions)=} opt_options Options.
 * @return {import("../geom/Geometry.js").default} Transformed geometry.
 */

exports.default = _default;

function transformGeometryWithOptions(geometry, write, opt_options) {
  var featureProjection = opt_options ? (0, _proj.get)(opt_options.featureProjection) : null;
  var dataProjection = opt_options ? (0, _proj.get)(opt_options.dataProjection) : null;
  var transformed;

  if (featureProjection && dataProjection && !(0, _proj.equivalent)(featureProjection, dataProjection)) {
    transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
  } else {
    transformed = geometry;
  }

  if (write && opt_options &&
  /** @type {WriteOptions} */
  opt_options.decimals !== undefined) {
    var power_1 = Math.pow(10,
    /** @type {WriteOptions} */
    opt_options.decimals); // if decimals option on write, round each coordinate appropriately

    /**
     * @param {Array<number>} coordinates Coordinates.
     * @return {Array<number>} Transformed coordinates.
     */

    var transform = function (coordinates) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = Math.round(coordinates[i] * power_1) / power_1;
      }

      return coordinates;
    };

    if (transformed === geometry) {
      transformed = geometry.clone();
    }

    transformed.applyTransform(transform);
  }

  return transformed;
}
/**
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {ReadOptions=} opt_options Read options.
 * @return {import("../extent.js").Extent} Transformed extent.
 */


function transformExtentWithOptions(extent, opt_options) {
  var featureProjection = opt_options ? (0, _proj.get)(opt_options.featureProjection) : null;
  var dataProjection = opt_options ? (0, _proj.get)(opt_options.dataProjection) : null;

  if (featureProjection && dataProjection && !(0, _proj.equivalent)(featureProjection, dataProjection)) {
    return (0, _proj.transformExtent)(extent, dataProjection, featureProjection);
  } else {
    return extent;
  }
}
},{"../obj.js":"node_modules/ol/obj.js","../util.js":"node_modules/ol/util.js","../proj.js":"node_modules/ol/proj.js","../proj/Units.js":"node_modules/ol/proj/Units.js"}],"node_modules/ol/format/FormatType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/format/FormatType
 */

/**
 * @enum {string}
 */
var _default = {
  ARRAY_BUFFER: 'arraybuffer',
  JSON: 'json',
  TEXT: 'text',
  XML: 'xml'
};
exports.default = _default;
},{}],"node_modules/ol/format/JSONFeature.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("../util.js");

var _Feature = _interopRequireDefault(require("./Feature.js"));

var _FormatType = _interopRequireDefault(require("./FormatType.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/format/JSONFeature
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for JSON feature formats.
 *
 * @abstract
 */
var JSONFeature =
/** @class */
function (_super) {
  __extends(JSONFeature, _super);

  function JSONFeature() {
    return _super.call(this) || this;
  }
  /**
   * @inheritDoc
   */


  JSONFeature.prototype.getType = function () {
    return _FormatType.default.JSON;
  };
  /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Node|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */


  JSONFeature.prototype.readFeature = function (source, opt_options) {
    return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Node|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */


  JSONFeature.prototype.readFeatures = function (source, opt_options) {
    return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */


  JSONFeature.prototype.readFeatureFromObject = function (object, opt_options) {
    return (0, _util.abstract)();
  };
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */


  JSONFeature.prototype.readFeaturesFromObject = function (object, opt_options) {
    return (0, _util.abstract)();
  };
  /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Node|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */


  JSONFeature.prototype.readGeometry = function (source, opt_options) {
    return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */


  JSONFeature.prototype.readGeometryFromObject = function (object, opt_options) {
    return (0, _util.abstract)();
  };
  /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Node|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */


  JSONFeature.prototype.readProjection = function (source) {
    return this.readProjectionFromObject(getObject(source));
  };
  /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */


  JSONFeature.prototype.readProjectionFromObject = function (object) {
    return (0, _util.abstract)();
  };
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {string} Encoded feature.
   * @api
   */


  JSONFeature.prototype.writeFeature = function (feature, opt_options) {
    return JSON.stringify(this.writeFeatureObject(feature, opt_options));
  };
  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {Object} Object.
   */


  JSONFeature.prototype.writeFeatureObject = function (feature, opt_options) {
    return (0, _util.abstract)();
  };
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {string} Encoded features.
   * @api
   */


  JSONFeature.prototype.writeFeatures = function (features, opt_options) {
    return JSON.stringify(this.writeFeaturesObject(features, opt_options));
  };
  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {Object} Object.
   */


  JSONFeature.prototype.writeFeaturesObject = function (features, opt_options) {
    return (0, _util.abstract)();
  };
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {string} Encoded geometry.
   * @api
   */


  JSONFeature.prototype.writeGeometry = function (geometry, opt_options) {
    return JSON.stringify(this.writeGeometryObject(geometry, opt_options));
  };
  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {Object} Object.
   */


  JSONFeature.prototype.writeGeometryObject = function (geometry, opt_options) {
    return (0, _util.abstract)();
  };

  return JSONFeature;
}(_Feature.default);
/**
 * @param {Document|Node|Object|string} source Source.
 * @return {Object} Object.
 */


function getObject(source) {
  if (typeof source === 'string') {
    var object = JSON.parse(source);
    return object ?
    /** @type {Object} */
    object : null;
  } else if (source !== null) {
    return source;
  } else {
    return null;
  }
}

var _default = JSONFeature;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","./Feature.js":"node_modules/ol/format/Feature.js","./FormatType.js":"node_modules/ol/format/FormatType.js"}],"node_modules/ol/geom/flat/transform.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transform2D = transform2D;
exports.rotate = rotate;
exports.scale = scale;
exports.translate = translate;

/**
 * @module ol/geom/flat/transform
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    var x = flatCoordinates[j];
    var y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */


function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;

    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
}
/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */


function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;

    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */


function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;

    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
}
},{}],"node_modules/ol/transform.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.reset = reset;
exports.multiply = multiply;
exports.set = set;
exports.setFromArray = setFromArray;
exports.apply = apply;
exports.rotate = rotate;
exports.scale = scale;
exports.makeScale = makeScale;
exports.translate = translate;
exports.compose = compose;
exports.composeCssTransform = composeCssTransform;
exports.invert = invert;
exports.makeInverse = makeInverse;
exports.determinant = determinant;
exports.toString = toString;

var _asserts = require("./asserts.js");

/**
 * @module ol/transform
 */

/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 * @api
 */

/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3×3 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */

/**
 * @private
 * @type {Transform}
 */
var tmp_ = new Array(6);
/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */

function create() {
  return [1, 0, 0, 1, 0, 0];
}
/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */


function reset(transform) {
  return set(transform, 1, 0, 0, 1, 0, 0);
}
/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */


function multiply(transform1, transform2) {
  var a1 = transform1[0];
  var b1 = transform1[1];
  var c1 = transform1[2];
  var d1 = transform1[3];
  var e1 = transform1[4];
  var f1 = transform1[5];
  var a2 = transform2[0];
  var b2 = transform2[1];
  var c2 = transform2[2];
  var d2 = transform2[3];
  var e2 = transform2[4];
  var f2 = transform2[5];
  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;
  return transform1;
}
/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */


function set(transform, a, b, c, d, e, f) {
  transform[0] = a;
  transform[1] = b;
  transform[2] = c;
  transform[3] = d;
  transform[4] = e;
  transform[5] = f;
  return transform;
}
/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */


function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}
/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */


function apply(transform, coordinate) {
  var x = coordinate[0];
  var y = coordinate[1];
  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
  return coordinate;
}
/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */


function rotate(transform, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}
/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */


function scale(transform, x, y) {
  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}
/**
 * Creates a scale transform.
 * @param {!Transform} target Transform to overwrite.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scale transform.
 */


function makeScale(target, x, y) {
  return set(target, x, 0, 0, y, 0, 0);
}
/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */


function translate(transform, dx, dy) {
  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */


function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  var sin = Math.sin(angle);
  var cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
}
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative). The resulting transform
 * string can be applied as `transform` porperty of an HTMLElement's style.
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {string} The composite css transform.
 * @api
 */


function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
  return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}
/**
 * Invert the given transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (source) transform.
 */


function invert(source) {
  return makeInverse(source, source);
}
/**
 * Invert the given transform.
 * @param {!Transform} target Transform to be set as the inverse of
 *     the source transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (target) transform.
 */


function makeInverse(target, source) {
  var det = determinant(source);
  (0, _asserts.assert)(det !== 0, 32); // Transformation matrix cannot be inverted

  var a = source[0];
  var b = source[1];
  var c = source[2];
  var d = source[3];
  var e = source[4];
  var f = source[5];
  target[0] = d / det;
  target[1] = -b / det;
  target[2] = -c / det;
  target[3] = a / det;
  target[4] = (c * f - d * e) / det;
  target[5] = -(a * f - b * e) / det;
  return target;
}
/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */


function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
/**
 * A string version of the transform.  This can be used
 * for CSS transforms.
 * @param {!Transform} mat Matrix.
 * @return {string} The transform as a string.
 */


function toString(mat) {
  return 'matrix(' + mat.join(', ') + ')';
}
},{"./asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/geom/Geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("../util.js");

var _Object = _interopRequireDefault(require("../Object.js"));

var _extent = require("../extent.js");

var _transform = require("./flat/transform.js");

var _proj = require("../proj.js");

var _Units = _interopRequireDefault(require("../proj/Units.js"));

var _transform2 = require("../transform.js");

var _functions = require("../functions.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/Geometry
 */


/**
 * @type {import("../transform.js").Transform}
 */
var tmpTransform = (0, _transform2.create)();
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */

var Geometry =
/** @class */
function (_super) {
  __extends(Geometry, _super);

  function Geometry() {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */


    _this.extent_ = (0, _extent.createEmpty)();
    /**
     * @private
     * @type {number}
     */

    _this.extentRevision_ = -1;
    /**
     * @protected
     * @type {number}
     */

    _this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    /**
     * @protected
     * @type {number}
     */

    _this.simplifiedGeometryRevision = 0;
    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} revision The geometry revision.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */

    _this.simplifyTransformedInternal = (0, _functions.memoizeOne)(function (revision, squaredTolerance, opt_transform) {
      if (!opt_transform) {
        return this.getSimplifiedGeometry(squaredTolerance);
      }

      var clone = this.clone();
      clone.applyTransform(opt_transform);
      return clone.getSimplifiedGeometry(squaredTolerance);
    });
    return _this;
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */


  Geometry.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {
    return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);
  };
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */


  Geometry.prototype.clone = function () {
    return (0, _util.abstract)();
  };
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  Geometry.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    return (0, _util.abstract)();
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */


  Geometry.prototype.containsXY = function (x, y) {
    var coord = this.getClosestPoint([x, y]);
    return coord[0] === x && coord[1] === y;
  };
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate=} opt_closestPoint Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */


  Geometry.prototype.getClosestPoint = function (point, opt_closestPoint) {
    var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
    this.closestPointXY(point[0], point[1], closestPoint, Infinity);
    return closestPoint;
  };
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */


  Geometry.prototype.intersectsCoordinate = function (coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  };
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */


  Geometry.prototype.computeExtent = function (extent) {
    return (0, _util.abstract)();
  };
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent=} opt_extent Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */


  Geometry.prototype.getExtent = function (opt_extent) {
    if (this.extentRevision_ != this.getRevision()) {
      this.extent_ = this.computeExtent(this.extent_);
      this.extentRevision_ = this.getRevision();
    }

    return (0, _extent.returnOrUpdate)(this.extent_, opt_extent);
  };
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */


  Geometry.prototype.rotate = function (angle, anchor) {
    (0, _util.abstract)();
  };
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to
   *     sx).
   * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */


  Geometry.prototype.scale = function (sx, opt_sy, opt_anchor) {
    (0, _util.abstract)();
  };
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */


  Geometry.prototype.simplify = function (tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  };
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */


  Geometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {
    return (0, _util.abstract)();
  };
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {import("./GeometryType.js").default} Geometry type.
   */


  Geometry.prototype.getType = function () {
    return (0, _util.abstract)();
  };
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */


  Geometry.prototype.applyTransform = function (transformFn) {
    (0, _util.abstract)();
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */


  Geometry.prototype.intersectsExtent = function (extent) {
    return (0, _util.abstract)();
  };
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */


  Geometry.prototype.translate = function (deltaX, deltaY) {
    (0, _util.abstract)();
  };
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {Geometry} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */


  Geometry.prototype.transform = function (source, destination) {
    /** @type {import("../proj/Projection.js").default} */
    var sourceProj = (0, _proj.get)(source);
    var transformFn = sourceProj.getUnits() == _Units.default.TILE_PIXELS ? function (inCoordinates, outCoordinates, stride) {
      var pixelExtent = sourceProj.getExtent();
      var projectedExtent = sourceProj.getWorldExtent();
      var scale = (0, _extent.getHeight)(projectedExtent) / (0, _extent.getHeight)(pixelExtent);
      (0, _transform2.compose)(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
      (0, _transform.transform2D)(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
      return (0, _proj.getTransform)(sourceProj, destination)(inCoordinates, outCoordinates, stride);
    } : (0, _proj.getTransform)(sourceProj, destination);
    this.applyTransform(transformFn);
    return this;
  };

  return Geometry;
}(_Object.default);

var _default = Geometry;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","../Object.js":"node_modules/ol/Object.js","../extent.js":"node_modules/ol/extent.js","./flat/transform.js":"node_modules/ol/geom/flat/transform.js","../proj.js":"node_modules/ol/proj.js","../proj/Units.js":"node_modules/ol/proj/Units.js","../transform.js":"node_modules/ol/transform.js","../functions.js":"node_modules/ol/functions.js"}],"node_modules/ol/geom/GeometryCollection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _events = require("../events.js");

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _extent = require("../extent.js");

var _Geometry = _interopRequireDefault(require("./Geometry.js"));

var _GeometryType = _interopRequireDefault(require("./GeometryType.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/GeometryCollection
 */


/**
 * @classdesc
 * An array of {@link module:ol/geom/Geometry} objects.
 *
 * @api
 */
var GeometryCollection =
/** @class */
function (_super) {
  __extends(GeometryCollection, _super);
  /**
   * @param {Array<Geometry>=} opt_geometries Geometries.
   */


  function GeometryCollection(opt_geometries) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {Array<Geometry>}
     */


    _this.geometries_ = opt_geometries ? opt_geometries : null;
    /**
     * @type {Array<import("../events.js").EventsKey>}
     */

    _this.changeEventsKeys_ = [];

    _this.listenGeometriesChange_();

    return _this;
  }
  /**
   * @private
   */


  GeometryCollection.prototype.unlistenGeometriesChange_ = function () {
    this.changeEventsKeys_.forEach(_events.unlistenByKey);
    this.changeEventsKeys_.length = 0;
  };
  /**
   * @private
   */


  GeometryCollection.prototype.listenGeometriesChange_ = function () {
    if (!this.geometries_) {
      return;
    }

    for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {
      this.changeEventsKeys_.push((0, _events.listen)(this.geometries_[i], _EventType.default.CHANGE, this.changed, this));
    }
  };
  /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @override
   * @api
   */


  GeometryCollection.prototype.clone = function () {
    var geometryCollection = new GeometryCollection(null);
    geometryCollection.setGeometries(this.geometries_);
    return geometryCollection;
  };
  /**
   * @inheritDoc
   */


  GeometryCollection.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
    }

    return minSquaredDistance;
  };
  /**
   * @inheritDoc
   */


  GeometryCollection.prototype.containsXY = function (x, y) {
    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].containsXY(x, y)) {
        return true;
      }
    }

    return false;
  };
  /**
   * @inheritDoc
   */


  GeometryCollection.prototype.computeExtent = function (extent) {
    (0, _extent.createOrUpdateEmpty)(extent);
    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      (0, _extent.extend)(extent, geometries[i].getExtent());
    }

    return extent;
  };
  /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */


  GeometryCollection.prototype.getGeometries = function () {
    return cloneGeometries(this.geometries_);
  };
  /**
   * @return {Array<Geometry>} Geometries.
   */


  GeometryCollection.prototype.getGeometriesArray = function () {
    return this.geometries_;
  };
  /**
   * @return {Array<Geometry>} Geometries.
   */


  GeometryCollection.prototype.getGeometriesArrayRecursive = function () {
    /** @type {Array<Geometry>} */
    var geometriesArray = [];
    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].getType() === this.getType()) {
        geometriesArray = geometriesArray.concat(
        /** @type {GeometryCollection} */
        geometries[i].getGeometriesArrayRecursive());
      } else {
        geometriesArray.push(geometries[i]);
      }
    }

    return geometriesArray;
  };
  /**
   * @inheritDoc
   */


  GeometryCollection.prototype.getSimplifiedGeometry = function (squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }

    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }

    var simplifiedGeometries = [];
    var geometries = this.geometries_;
    var simplified = false;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      var geometry = geometries[i];
      var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
      simplifiedGeometries.push(simplifiedGeometry);

      if (simplifiedGeometry !== geometry) {
        simplified = true;
      }
    }

    if (simplified) {
      var simplifiedGeometryCollection = new GeometryCollection(null);
      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
      return simplifiedGeometryCollection;
    } else {
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  };
  /**
   * @inheritDoc
   * @api
   */


  GeometryCollection.prototype.getType = function () {
    return _GeometryType.default.GEOMETRY_COLLECTION;
  };
  /**
   * @inheritDoc
   * @api
   */


  GeometryCollection.prototype.intersectsExtent = function (extent) {
    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].intersectsExtent(extent)) {
        return true;
      }
    }

    return false;
  };
  /**
   * @return {boolean} Is empty.
   */


  GeometryCollection.prototype.isEmpty = function () {
    return this.geometries_.length === 0;
  };
  /**
   * @inheritDoc
   * @api
   */


  GeometryCollection.prototype.rotate = function (angle, anchor) {
    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].rotate(angle, anchor);
    }

    this.changed();
  };
  /**
   * @inheritDoc
   * @api
   */


  GeometryCollection.prototype.scale = function (sx, opt_sy, opt_anchor) {
    var anchor = opt_anchor;

    if (!anchor) {
      anchor = (0, _extent.getCenter)(this.getExtent());
    }

    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].scale(sx, opt_sy, anchor);
    }

    this.changed();
  };
  /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */


  GeometryCollection.prototype.setGeometries = function (geometries) {
    this.setGeometriesArray(cloneGeometries(geometries));
  };
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */


  GeometryCollection.prototype.setGeometriesArray = function (geometries) {
    this.unlistenGeometriesChange_();
    this.geometries_ = geometries;
    this.listenGeometriesChange_();
    this.changed();
  };
  /**
   * @inheritDoc
   * @api
   */


  GeometryCollection.prototype.applyTransform = function (transformFn) {
    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].applyTransform(transformFn);
    }

    this.changed();
  };
  /**
   * @inheritDoc
   * @api
   */


  GeometryCollection.prototype.translate = function (deltaX, deltaY) {
    var geometries = this.geometries_;

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].translate(deltaX, deltaY);
    }

    this.changed();
  };
  /**
   * @inheritDoc
   */


  GeometryCollection.prototype.disposeInternal = function () {
    this.unlistenGeometriesChange_();

    _super.prototype.disposeInternal.call(this);
  };

  return GeometryCollection;
}(_Geometry.default);
/**
 * @param {Array<Geometry>} geometries Geometries.
 * @return {Array<Geometry>} Cloned geometries.
 */


function cloneGeometries(geometries) {
  var clonedGeometries = [];

  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    clonedGeometries.push(geometries[i].clone());
  }

  return clonedGeometries;
}

var _default = GeometryCollection;
exports.default = _default;
},{"../events.js":"node_modules/ol/events.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../extent.js":"node_modules/ol/extent.js","./Geometry.js":"node_modules/ol/geom/Geometry.js","./GeometryType.js":"node_modules/ol/geom/GeometryType.js"}],"node_modules/ol/geom/GeometryLayout.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/geom/GeometryLayout
 */

/**
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available. Supported values are `'XY'`,
 * `'XYZ'`, `'XYM'`, `'XYZM'`.
 * @enum {string}
 */
var _default = {
  XY: 'XY',
  XYZ: 'XYZ',
  XYM: 'XYM',
  XYZM: 'XYZM'
};
exports.default = _default;
},{}],"node_modules/ol/geom/SimpleGeometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStrideForLayout = getStrideForLayout;
exports.transformGeom2D = transformGeom2D;
exports.default = void 0;

var _util = require("../util.js");

var _extent = require("../extent.js");

var _Geometry = _interopRequireDefault(require("./Geometry.js"));

var _GeometryLayout = _interopRequireDefault(require("./GeometryLayout.js"));

var _transform = require("./flat/transform.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/SimpleGeometry
 */


/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */
var SimpleGeometry =
/** @class */
function (_super) {
  __extends(SimpleGeometry, _super);

  function SimpleGeometry() {
    var _this = _super.call(this) || this;
    /**
     * @protected
     * @type {GeometryLayout}
     */


    _this.layout = _GeometryLayout.default.XY;
    /**
     * @protected
     * @type {number}
     */

    _this.stride = 2;
    /**
     * @protected
     * @type {Array<number>}
     */

    _this.flatCoordinates = null;
    return _this;
  }
  /**
   * @inheritDoc
   */


  SimpleGeometry.prototype.computeExtent = function (extent) {
    return (0, _extent.createOrUpdateFromFlatCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
  };
  /**
   * @abstract
   * @return {Array<*>} Coordinates.
   */


  SimpleGeometry.prototype.getCoordinates = function () {
    return (0, _util.abstract)();
  };
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */


  SimpleGeometry.prototype.getFirstCoordinate = function () {
    return this.flatCoordinates.slice(0, this.stride);
  };
  /**
   * @return {Array<number>} Flat coordinates.
   */


  SimpleGeometry.prototype.getFlatCoordinates = function () {
    return this.flatCoordinates;
  };
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */


  SimpleGeometry.prototype.getLastCoordinate = function () {
    return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
  };
  /**
   * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.
   * @return {GeometryLayout} Layout.
   * @api
   */


  SimpleGeometry.prototype.getLayout = function () {
    return this.layout;
  };
  /**
   * @inheritDoc
   */


  SimpleGeometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    } // If squaredTolerance is negative or if we know that simplification will not
    // have any effect then just return this.


    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }

    var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
    var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();

    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      return simplifiedGeometry;
    } else {
      // Simplification did not actually remove any coordinates.  We now know
      // that any calls to getSimplifiedGeometry with a squaredTolerance less
      // than or equal to the current squaredTolerance will also not have any
      // effect.  This allows us to short circuit simplification (saving CPU
      // cycles) and prevents the cache of simplified geometries from filling
      // up with useless identical copies of this geometry (saving memory).
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  };
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */


  SimpleGeometry.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    return this;
  };
  /**
   * @return {number} Stride.
   */


  SimpleGeometry.prototype.getStride = function () {
    return this.stride;
  };
  /**
   * @param {GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */


  SimpleGeometry.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  };
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   */


  SimpleGeometry.prototype.setCoordinates = function (coordinates, opt_layout) {
    (0, _util.abstract)();
  };
  /**
   * @param {GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */


  SimpleGeometry.prototype.setLayout = function (layout, coordinates, nesting) {
    /** @type {number} */
    var stride;

    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (var i = 0; i < nesting; ++i) {
        if (coordinates.length === 0) {
          this.layout = _GeometryLayout.default.XY;
          this.stride = 2;
          return;
        } else {
          coordinates =
          /** @type {Array} */
          coordinates[0];
        }
      }

      stride = coordinates.length;
      layout = getLayoutForStride(stride);
    }

    this.layout = layout;
    this.stride = stride;
  };
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */


  SimpleGeometry.prototype.applyTransform = function (transformFn) {
    if (this.flatCoordinates) {
      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
      this.changed();
    }
  };
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */


  SimpleGeometry.prototype.rotate = function (angle, anchor) {
    var flatCoordinates = this.getFlatCoordinates();

    if (flatCoordinates) {
      var stride = this.getStride();
      (0, _transform.rotate)(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
      this.changed();
    }
  };
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
    * @param {number} sx The scaling factor in the x-direction.
   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to
   *     sx).
   * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */


  SimpleGeometry.prototype.scale = function (sx, opt_sy, opt_anchor) {
    var sy = opt_sy;

    if (sy === undefined) {
      sy = sx;
    }

    var anchor = opt_anchor;

    if (!anchor) {
      anchor = (0, _extent.getCenter)(this.getExtent());
    }

    var flatCoordinates = this.getFlatCoordinates();

    if (flatCoordinates) {
      var stride = this.getStride();
      (0, _transform.scale)(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
      this.changed();
    }
  };
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */


  SimpleGeometry.prototype.translate = function (deltaX, deltaY) {
    var flatCoordinates = this.getFlatCoordinates();

    if (flatCoordinates) {
      var stride = this.getStride();
      (0, _transform.translate)(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
      this.changed();
    }
  };

  return SimpleGeometry;
}(_Geometry.default);
/**
 * @param {number} stride Stride.
 * @return {GeometryLayout} layout Layout.
 */


function getLayoutForStride(stride) {
  var layout;

  if (stride == 2) {
    layout = _GeometryLayout.default.XY;
  } else if (stride == 3) {
    layout = _GeometryLayout.default.XYZ;
  } else if (stride == 4) {
    layout = _GeometryLayout.default.XYZM;
  }

  return (
    /** @type {GeometryLayout} */
    layout
  );
}
/**
 * @param {GeometryLayout} layout Layout.
 * @return {number} Stride.
 */


function getStrideForLayout(layout) {
  var stride;

  if (layout == _GeometryLayout.default.XY) {
    stride = 2;
  } else if (layout == _GeometryLayout.default.XYZ || layout == _GeometryLayout.default.XYM) {
    stride = 3;
  } else if (layout == _GeometryLayout.default.XYZM) {
    stride = 4;
  }

  return (
    /** @type {number} */
    stride
  );
}
/**
 * @param {SimpleGeometry} simpleGeometry Simple geometry.
 * @param {import("../transform.js").Transform} transform Transform.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed flat coordinates.
 */


function transformGeom2D(simpleGeometry, transform, opt_dest) {
  var flatCoordinates = simpleGeometry.getFlatCoordinates();

  if (!flatCoordinates) {
    return null;
  } else {
    var stride = simpleGeometry.getStride();
    return (0, _transform.transform2D)(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);
  }
}

var _default = SimpleGeometry;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","../extent.js":"node_modules/ol/extent.js","./Geometry.js":"node_modules/ol/geom/Geometry.js","./GeometryLayout.js":"node_modules/ol/geom/GeometryLayout.js","./flat/transform.js":"node_modules/ol/geom/flat/transform.js"}],"node_modules/ol/geom/flat/closest.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.maxSquaredDelta = maxSquaredDelta;
exports.arrayMaxSquaredDelta = arrayMaxSquaredDelta;
exports.multiArrayMaxSquaredDelta = multiArrayMaxSquaredDelta;
exports.assignClosestPoint = assignClosestPoint;
exports.assignClosestArrayPoint = assignClosestArrayPoint;
exports.assignClosestMultiArrayPoint = assignClosestMultiArrayPoint;

var _math = require("../../math.js");

/**
 * @module ol/geom/flat/closest
 */

/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 */
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  var x1 = flatCoordinates[offset1];
  var y1 = flatCoordinates[offset1 + 1];
  var dx = flatCoordinates[offset2] - x1;
  var dy = flatCoordinates[offset2 + 1] - y1;
  var offset;

  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (var i = 0; i < stride; ++i) {
        closestPoint[i] = (0, _math.lerp)(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
      }

      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }

  for (var i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset + i];
  }

  closestPoint.length = stride;
}
/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */


function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];

  for (offset += stride; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    var squaredDelta = (0, _math.squaredDistance)(x1, y1, x2, y2);

    if (squaredDelta > max) {
      max = squaredDelta;
    }

    x1 = x2;
    y1 = y2;
  }

  return max;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */


function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
    offset = end;
  }

  return max;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */


function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
    offset = ends[ends.length - 1];
  }

  return max;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */


function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  if (offset == end) {
    return minSquaredDistance;
  }

  var i, squaredDistance;

  if (maxDelta === 0) {
    // All points are identical, so just test the first point.
    squaredDistance = (0, _math.squaredDistance)(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);

    if (squaredDistance < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }

      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  }

  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var index = offset + stride;

  while (index < end) {
    assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
    squaredDistance = (0, _math.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);

    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;

      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }

      closestPoint.length = stride;
      index += stride;
    } else {
      // Skip ahead multiple points, because we know that all the skipped
      // points cannot be any closer than the closest point we have found so
      // far.  We know this because we know how close the current point is, how
      // close the closest point we have found so far is, and the maximum
      // distance between consecutive points.  For example, if we're currently
      // at distance 10, the best we've found so far is 3, and that the maximum
      // distance between consecutive points is 2, then we'll need to skip at
      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
      // finding a closer point.  We use Math.max(..., 1) to ensure that we
      // always advance at least one point, to avoid an infinite loop.
      index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
    }
  }

  if (isRing) {
    // Check the closing segment.
    assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
    squaredDistance = (0, _math.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);

    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;

      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }

      closestPoint.length = stride;
    }
  }

  return minSquaredDistance;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */


function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = end;
  }

  return minSquaredDistance;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */


function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = ends[ends.length - 1];
  }

  return minSquaredDistance;
}
},{"../../math.js":"node_modules/ol/math.js"}],"node_modules/ol/geom/flat/deflate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deflateCoordinate = deflateCoordinate;
exports.deflateCoordinates = deflateCoordinates;
exports.deflateCoordinatesArray = deflateCoordinatesArray;
exports.deflateMultiCoordinatesArray = deflateMultiCoordinatesArray;

/**
 * @module ol/geom/flat/deflate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (var i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }

  return offset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */


function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    var coordinate = coordinates[i];

    for (var j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }

  return offset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array<number>=} opt_ends Ends.
 * @return {Array<number>} Ends.
 */


function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {
  var ends = opt_ends ? opt_ends : [];
  var i = 0;

  for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
    var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);
    ends[i++] = end;
    offset = end;
  }

  ends.length = i;
  return ends;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array<Array<number>>=} opt_endss Endss.
 * @return {Array<Array<number>>} Endss.
 */


function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {
  var endss = opt_endss ? opt_endss : [];
  var i = 0;

  for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
    var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }

  endss.length = i;
  return endss;
}
},{}],"node_modules/ol/geom/flat/inflate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inflateCoordinates = inflateCoordinates;
exports.inflateCoordinatesArray = inflateCoordinatesArray;
exports.inflateMultiCoordinatesArray = inflateMultiCoordinatesArray;

/**
 * @module ol/geom/flat/inflate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<import("../../coordinate.js").Coordinate>=} opt_coordinates Coordinates.
 * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
 */
function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {
  var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    coordinates[i++] = flatCoordinates.slice(j, j + stride);
  }

  coordinates.length = i;
  return coordinates;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>=} opt_coordinatess Coordinatess.
 * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
 */


function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {
  var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
  var i = 0;

  for (var j = 0, jj = ends.length; j < jj; ++j) {
    var end = ends[j];
    coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
    offset = end;
  }

  coordinatess.length = i;
  return coordinatess;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>=} opt_coordinatesss
 *     Coordinatesss.
 * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
 */


function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
  var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
  var i = 0;

  for (var j = 0, jj = endss.length; j < jj; ++j) {
    var ends = endss[j];
    coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
    offset = ends[ends.length - 1];
  }

  coordinatesss.length = i;
  return coordinatesss;
}
},{}],"node_modules/ol/geom/flat/interpolate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interpolatePoint = interpolatePoint;
exports.lineStringCoordinateAtM = lineStringCoordinateAtM;
exports.lineStringsCoordinateAtM = lineStringsCoordinateAtM;

var _array = require("../../array.js");

var _math = require("../../math.js");

/**
 * @module ol/geom/flat/interpolate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Destination.
 */
function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest) {
  var pointX = NaN;
  var pointY = NaN;
  var n = (end - offset) / stride;

  if (n === 1) {
    pointX = flatCoordinates[offset];
    pointY = flatCoordinates[offset + 1];
  } else if (n == 2) {
    pointX = (1 - fraction) * flatCoordinates[offset] + fraction * flatCoordinates[offset + stride];
    pointY = (1 - fraction) * flatCoordinates[offset + 1] + fraction * flatCoordinates[offset + stride + 1];
  } else if (n !== 0) {
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];
    var length_1 = 0;
    var cumulativeLengths = [0];

    for (var i = offset + stride; i < end; i += stride) {
      var x2 = flatCoordinates[i];
      var y2 = flatCoordinates[i + 1];
      length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length_1);
      x1 = x2;
      y1 = y2;
    }

    var target = fraction * length_1;
    var index = (0, _array.binarySearch)(cumulativeLengths, target);

    if (index < 0) {
      var t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
      var o = offset + (-index - 2) * stride;
      pointX = (0, _math.lerp)(flatCoordinates[o], flatCoordinates[o + stride], t);
      pointY = (0, _math.lerp)(flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);
    } else {
      pointX = flatCoordinates[offset + index * stride];
      pointY = flatCoordinates[offset + index * stride + 1];
    }
  }

  if (opt_dest) {
    opt_dest[0] = pointX;
    opt_dest[1] = pointY;
    return opt_dest;
  } else {
    return [pointX, pointY];
  }
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {import("../../coordinate.js").Coordinate} Coordinate.
 */


function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
  if (end == offset) {
    return null;
  }

  var coordinate;

  if (m < flatCoordinates[offset + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset, offset + stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  } else if (flatCoordinates[end - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  } // FIXME use O(1) search


  if (m == flatCoordinates[offset + stride - 1]) {
    return flatCoordinates.slice(offset, offset + stride);
  }

  var lo = offset / stride;
  var hi = end / stride;

  while (lo < hi) {
    var mid = lo + hi >> 1;

    if (m < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }

  var m0 = flatCoordinates[lo * stride - 1];

  if (m == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }

  var m1 = flatCoordinates[(lo + 1) * stride - 1];
  var t = (m - m0) / (m1 - m0);
  coordinate = [];

  for (var i = 0; i < stride - 1; ++i) {
    coordinate.push((0, _math.lerp)(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
  }

  coordinate.push(m);
  return coordinate;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {import("../../coordinate.js").Coordinate} Coordinate.
 */


function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
  if (interpolate) {
    return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
  }

  var coordinate;

  if (m < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }

  if (flatCoordinates[flatCoordinates.length - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];

    if (offset == end) {
      continue;
    }

    if (m < flatCoordinates[offset + stride - 1]) {
      return null;
    } else if (m <= flatCoordinates[end - 1]) {
      return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
    }

    offset = end;
  }

  return null;
}
},{"../../array.js":"node_modules/ol/array.js","../../math.js":"node_modules/ol/math.js"}],"node_modules/ol/geom/flat/contains.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linearRingContainsExtent = linearRingContainsExtent;
exports.linearRingContainsXY = linearRingContainsXY;
exports.linearRingsContainsXY = linearRingsContainsXY;
exports.linearRingssContainsXY = linearRingssContainsXY;

var _extent = require("../../extent.js");

/**
 * @module ol/geom/flat/contains
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} Contains extent.
 */
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
  var outside = (0, _extent.forEachCorner)(extent,
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains (x, y).
   */
  function (coordinate) {
    return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
  });
  return !outside;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */


function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
  // http://geomalgorithms.com/a03-_inclusion.html
  // Copyright 2000 softSurfer, 2012 Dan Sunday
  // This code may be freely used and modified for any purpose
  // providing that this copyright notice is included with it.
  // SoftSurfer makes no warranty for this code, and cannot be held
  // liable for any real or imagined damage resulting from its use.
  // Users of this code must verify correctness for their application.
  var wn = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];

    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }

    x1 = x2;
    y1 = y2;
  }

  return wn !== 0;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */


function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }

  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }

  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }

  return true;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */


function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
  if (endss.length === 0) {
    return false;
  }

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
      return true;
    }

    offset = ends[ends.length - 1];
  }

  return false;
}
},{"../../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/geom/flat/segments.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forEach = forEach;

/**
 * @module ol/geom/flat/segments
 */

/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
 *     called for each segment.
 * @return {T|boolean} Value.
 * @template T
 */
function forEach(flatCoordinates, offset, end, stride, callback) {
  var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
  var point2 = [];
  var ret;

  for (; offset + stride < end; offset += stride) {
    point2[0] = flatCoordinates[offset + stride];
    point2[1] = flatCoordinates[offset + stride + 1];
    ret = callback(point1, point2);

    if (ret) {
      return ret;
    }

    point1[0] = point2[0];
    point1[1] = point2[1];
  }

  return false;
}
},{}],"node_modules/ol/geom/flat/intersectsextent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.intersectsLineString = intersectsLineString;
exports.intersectsLineStringArray = intersectsLineStringArray;
exports.intersectsLinearRing = intersectsLinearRing;
exports.intersectsLinearRingArray = intersectsLinearRingArray;
exports.intersectsLinearRingMultiArray = intersectsLinearRingMultiArray;

var _extent = require("../../extent.js");

var _contains = require("./contains.js");

var _segments = require("./segments.js");

/**
 * @module ol/geom/flat/intersectsextent
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
  var coordinatesExtent = (0, _extent.extendFlatCoordinates)((0, _extent.createEmpty)(), flatCoordinates, offset, end, stride);

  if (!(0, _extent.intersects)(extent, coordinatesExtent)) {
    return false;
  }

  if ((0, _extent.containsExtent)(extent, coordinatesExtent)) {
    return true;
  }

  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }

  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }

  return (0, _segments.forEach)(flatCoordinates, offset, end, stride,
  /**
   * @param {import("../../coordinate.js").Coordinate} point1 Start point.
   * @param {import("../../coordinate.js").Coordinate} point2 End point.
   * @return {boolean} `true` if the segment and the extent intersect,
   *     `false` otherwise.
   */
  function (point1, point2) {
    return (0, _extent.intersectsSegment)(extent, point1, point2);
  });
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */


function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {
      return true;
    }

    offset = ends[i];
  }

  return false;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */


function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }

  if ((0, _contains.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
    return true;
  }

  if ((0, _contains.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
    return true;
  }

  if ((0, _contains.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
    return true;
  }

  if ((0, _contains.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
    return true;
  }

  return false;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */


function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }

  if (ends.length === 1) {
    return true;
  }

  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if ((0, _contains.linearRingContainsExtent)(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
      if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
        return false;
      }
    }
  }

  return true;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */


function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {
      return true;
    }

    offset = ends[ends.length - 1];
  }

  return false;
}
},{"../../extent.js":"node_modules/ol/extent.js","./contains.js":"node_modules/ol/geom/flat/contains.js","./segments.js":"node_modules/ol/geom/flat/segments.js"}],"node_modules/ol/geom/flat/length.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lineStringLength = lineStringLength;
exports.linearRingLength = linearRingLength;

/**
 * @module ol/geom/flat/length
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */
function lineStringLength(flatCoordinates, offset, end, stride) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  var length = 0;

  for (var i = offset + stride; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }

  return length;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */


function linearRingLength(flatCoordinates, offset, end, stride) {
  var perimeter = lineStringLength(flatCoordinates, offset, end, stride);
  var dx = flatCoordinates[end - stride] - flatCoordinates[offset];
  var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
  perimeter += Math.sqrt(dx * dx + dy * dy);
  return perimeter;
}
},{}],"node_modules/ol/geom/flat/simplify.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.simplifyLineString = simplifyLineString;
exports.douglasPeucker = douglasPeucker;
exports.douglasPeuckerArray = douglasPeuckerArray;
exports.douglasPeuckerMultiArray = douglasPeuckerMultiArray;
exports.radialDistance = radialDistance;
exports.snap = snap;
exports.quantize = quantize;
exports.quantizeArray = quantizeArray;
exports.quantizeMultiArray = quantizeMultiArray;

var _math = require("../../math.js");

/**
 * @module ol/geom/flat/simplify
 */
// Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array<number>=} opt_simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @return {Array<number>} Simplified line string.
 */
function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {
  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ? opt_simplifiedFlatCoordinates : [];

  if (!highQuality) {
    end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    flatCoordinates = simplifiedFlatCoordinates;
    offset = 0;
    stride = 2;
  }

  simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  return simplifiedFlatCoordinates;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */


function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  var n = (end - offset) / stride;

  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }

    return simplifiedOffset;
  }
  /** @type {Array<number>} */


  var markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  /** @type {Array<number>} */

  var stack = [offset, end - stride];
  var index = 0;

  while (stack.length > 0) {
    var last = stack.pop();
    var first = stack.pop();
    var maxSquaredDistance = 0;
    var x1 = flatCoordinates[first];
    var y1 = flatCoordinates[first + 1];
    var x2 = flatCoordinates[last];
    var y2 = flatCoordinates[last + 1];

    for (var i = first + stride; i < last; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];
      var squaredDistance_1 = (0, _math.squaredSegmentDistance)(x, y, x1, y1, x2, y2);

      if (squaredDistance_1 > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance_1;
      }
    }

    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;

      if (first + stride < index) {
        stack.push(first, index);
      }

      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }

  for (var i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
    }
  }

  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */


function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }

  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */


function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }

  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */


function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (end <= offset + stride) {
    // zero or one point, no simplification possible, so copy and return
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }

    return simplifiedOffset;
  }

  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1]; // copy first point

  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  var x2 = x1;
  var y2 = y1;

  for (offset += stride; offset < end; offset += stride) {
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];

    if ((0, _math.squaredDistance)(x1, y1, x2, y2) > squaredTolerance) {
      // copy point at offset
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }

  if (x2 != x1 || y2 != y1) {
    // copy last point
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }

  return simplifiedOffset;
}
/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */


function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */


function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  // do nothing if the line is empty
  if (offset == end) {
    return simplifiedOffset;
  } // snap the first coordinate (P1)


  var x1 = snap(flatCoordinates[offset], tolerance);
  var y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride; // add the first coordinate to the output

  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1; // find the next coordinate that does not snap to the same value as the first
  // coordinate (P2)

  var x2, y2;

  do {
    x2 = snap(flatCoordinates[offset], tolerance);
    y2 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;

    if (offset == end) {
      // all coordinates snap to the same value, the line collapses to a point
      // push the last snapped value anyway to ensure that the output contains
      // at least two points
      // FIXME should we really return at least two points anyway?
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);

  while (offset < end) {
    // snap the next coordinate (P3)
    var x3 = snap(flatCoordinates[offset], tolerance);
    var y3 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride; // skip P3 if it is equal to P2

    if (x3 == x2 && y3 == y2) {
      continue;
    } // calculate the delta between P1 and P2


    var dx1 = x2 - x1;
    var dy1 = y2 - y1; // calculate the delta between P3 and P1

    var dx2 = x3 - x1;
    var dy2 = y3 - y1; // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
    // P1 in the same direction then P2 is on the straight line between P1 and
    // P3

    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      // discard P2 and set P2 = P3
      x2 = x3;
      y2 = y3;
      continue;
    } // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
    // between P3 and P1 or on the opposite half of the line to P2.  add P2,
    // and continue with P1 = P2 and P2 = P3


    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  } // add the last point (P2)


  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */


function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }

  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */


function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }

  return simplifiedOffset;
}
},{"../../math.js":"node_modules/ol/math.js"}],"node_modules/ol/geom/LineString.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _array = require("../array.js");

var _extent = require("../extent.js");

var _GeometryLayout = _interopRequireDefault(require("./GeometryLayout.js"));

var _GeometryType = _interopRequireDefault(require("./GeometryType.js"));

var _SimpleGeometry = _interopRequireDefault(require("./SimpleGeometry.js"));

var _closest = require("./flat/closest.js");

var _deflate = require("./flat/deflate.js");

var _inflate = require("./flat/inflate.js");

var _interpolate = require("./flat/interpolate.js");

var _intersectsextent = require("./flat/intersectsextent.js");

var _length = require("./flat/length.js");

var _segments = require("./flat/segments.js");

var _simplify = require("./flat/simplify.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/LineString
 */


/**
 * @classdesc
 * Linestring geometry.
 *
 * @api
 */
var LineString =
/** @class */
function (_super) {
  __extends(LineString, _super);
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
   * @param {GeometryLayout=} opt_layout Layout.
   */


  function LineString(coordinates, opt_layout) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */


    _this.flatMidpoint_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.flatMidpointRevision_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDeltaRevision_ = -1;

    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);
    } else {
      _this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      coordinates, opt_layout);
    }

    return _this;
  }
  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */


  LineString.prototype.appendCoordinate = function (coordinate) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = coordinate.slice();
    } else {
      (0, _array.extend)(this.flatCoordinates, coordinate);
    }

    this.changed();
  };
  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @override
   * @api
   */


  LineString.prototype.clone = function () {
    return new LineString(this.flatCoordinates.slice(), this.layout);
  };
  /**
   * @inheritDoc
   */


  LineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt((0, _closest.maxSquaredDelta)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }

    return (0, _closest.assignClosestPoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
  };
  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */


  LineString.prototype.forEachSegment = function (callback) {
    return (0, _segments.forEach)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
  };
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate} Coordinate.
   * @api
   */


  LineString.prototype.getCoordinateAtM = function (m, opt_extrapolate) {
    if (this.layout != _GeometryLayout.default.XYM && this.layout != _GeometryLayout.default.XYZM) {
      return null;
    }

    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
    return (0, _interpolate.lineStringCoordinateAtM)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
  };
  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @override
   * @api
   */


  LineString.prototype.getCoordinates = function () {
    return (0, _inflate.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate=} opt_dest Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */


  LineString.prototype.getCoordinateAt = function (fraction, opt_dest) {
    return (0, _interpolate.interpolatePoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest);
  };
  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */


  LineString.prototype.getLength = function () {
    return (0, _length.lineStringLength)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  /**
   * @return {Array<number>} Flat midpoint.
   */


  LineString.prototype.getFlatMidpoint = function () {
    if (this.flatMidpointRevision_ != this.getRevision()) {
      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
      this.flatMidpointRevision_ = this.getRevision();
    }

    return this.flatMidpoint_;
  };
  /**
   * @inheritDoc
   */


  LineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = (0, _simplify.douglasPeucker)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    return new LineString(simplifiedFlatCoordinates, _GeometryLayout.default.XY);
  };
  /**
   * @inheritDoc
   * @api
   */


  LineString.prototype.getType = function () {
    return _GeometryType.default.LINE_STRING;
  };
  /**
   * @inheritDoc
   * @api
   */


  LineString.prototype.intersectsExtent = function (extent) {
    return (0, _intersectsextent.intersectsLineString)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
  };
  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */


  LineString.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = (0, _deflate.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return LineString;
}(_SimpleGeometry.default);

var _default = LineString;
exports.default = _default;
},{"../array.js":"node_modules/ol/array.js","../extent.js":"node_modules/ol/extent.js","./GeometryLayout.js":"node_modules/ol/geom/GeometryLayout.js","./GeometryType.js":"node_modules/ol/geom/GeometryType.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","./flat/closest.js":"node_modules/ol/geom/flat/closest.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","./flat/interpolate.js":"node_modules/ol/geom/flat/interpolate.js","./flat/intersectsextent.js":"node_modules/ol/geom/flat/intersectsextent.js","./flat/length.js":"node_modules/ol/geom/flat/length.js","./flat/segments.js":"node_modules/ol/geom/flat/segments.js","./flat/simplify.js":"node_modules/ol/geom/flat/simplify.js"}],"node_modules/ol/geom/MultiLineString.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _array = require("../array.js");

var _extent = require("../extent.js");

var _GeometryLayout = _interopRequireDefault(require("./GeometryLayout.js"));

var _GeometryType = _interopRequireDefault(require("./GeometryType.js"));

var _LineString = _interopRequireDefault(require("./LineString.js"));

var _SimpleGeometry = _interopRequireDefault(require("./SimpleGeometry.js"));

var _closest = require("./flat/closest.js");

var _deflate = require("./flat/deflate.js");

var _inflate = require("./flat/inflate.js");

var _interpolate = require("./flat/interpolate.js");

var _intersectsextent = require("./flat/intersectsextent.js");

var _simplify = require("./flat/simplify.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/MultiLineString
 */


/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @api
 */
var MultiLineString =
/** @class */
function (_super) {
  __extends(MultiLineString, _super);
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `opt_layout` and `opt_ends` are also accepted.)
   * @param {GeometryLayout=} opt_layout Layout.
   * @param {Array<number>=} opt_ends Flat coordinate ends for internal use.
   */


  function MultiLineString(coordinates, opt_layout, opt_ends) {
    var _this = _super.call(this) || this;
    /**
     * @type {Array<number>}
     * @private
     */


    _this.ends_ = [];
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDeltaRevision_ = -1;

    if (Array.isArray(coordinates[0])) {
      _this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      coordinates, opt_layout);
    } else if (opt_layout !== undefined && opt_ends) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);

      _this.ends_ = opt_ends;
    } else {
      var layout = _this.getLayout();

      var lineStrings =
      /** @type {Array<LineString>} */
      coordinates;
      var flatCoordinates = [];
      var ends = [];

      for (var i = 0, ii = lineStrings.length; i < ii; ++i) {
        var lineString = lineStrings[i];

        if (i === 0) {
          layout = lineString.getLayout();
        }

        (0, _array.extend)(flatCoordinates, lineString.getFlatCoordinates());
        ends.push(flatCoordinates.length);
      }

      _this.setFlatCoordinates(layout, flatCoordinates);

      _this.ends_ = ends;
    }

    return _this;
  }
  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */


  MultiLineString.prototype.appendLineString = function (lineString) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = lineString.getFlatCoordinates().slice();
    } else {
      (0, _array.extend)(this.flatCoordinates, lineString.getFlatCoordinates().slice());
    }

    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  };
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @override
   * @api
   */


  MultiLineString.prototype.clone = function () {
    return new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
  };
  /**
   * @inheritDoc
   */


  MultiLineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt((0, _closest.arrayMaxSquaredDelta)(this.flatCoordinates, 0, this.ends_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }

    return (0, _closest.assignClosestArrayPoint)(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
  };
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `opt_interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `opt_interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
   * @param {boolean=} opt_interpolate Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate} Coordinate.
   * @api
   */


  MultiLineString.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {
    if (this.layout != _GeometryLayout.default.XYM && this.layout != _GeometryLayout.default.XYZM || this.flatCoordinates.length === 0) {
      return null;
    }

    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
    var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;
    return (0, _interpolate.lineStringsCoordinateAtM)(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
  };
  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @override
   * @api
   */


  MultiLineString.prototype.getCoordinates = function () {
    return (0, _inflate.inflateCoordinatesArray)(this.flatCoordinates, 0, this.ends_, this.stride);
  };
  /**
   * @return {Array<number>} Ends.
   */


  MultiLineString.prototype.getEnds = function () {
    return this.ends_;
  };
  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */


  MultiLineString.prototype.getLineString = function (index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }

    return new _LineString.default(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
  };
  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */


  MultiLineString.prototype.getLineStrings = function () {
    var flatCoordinates = this.flatCoordinates;
    var ends = this.ends_;
    var layout = this.layout;
    /** @type {Array<LineString>} */

    var lineStrings = [];
    var offset = 0;

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var lineString = new _LineString.default(flatCoordinates.slice(offset, end), layout);
      lineStrings.push(lineString);
      offset = end;
    }

    return lineStrings;
  };
  /**
   * @return {Array<number>} Flat midpoints.
   */


  MultiLineString.prototype.getFlatMidpoints = function () {
    var midpoints = [];
    var flatCoordinates = this.flatCoordinates;
    var offset = 0;
    var ends = this.ends_;
    var stride = this.stride;

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var midpoint = (0, _interpolate.interpolatePoint)(flatCoordinates, offset, end, stride, 0.5);
      (0, _array.extend)(midpoints, midpoint);
      offset = end;
    }

    return midpoints;
  };
  /**
   * @inheritDoc
   */


  MultiLineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEnds = [];
    simplifiedFlatCoordinates.length = (0, _simplify.douglasPeuckerArray)(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
    return new MultiLineString(simplifiedFlatCoordinates, _GeometryLayout.default.XY, simplifiedEnds);
  };
  /**
   * @inheritDoc
   * @api
   */


  MultiLineString.prototype.getType = function () {
    return _GeometryType.default.MULTI_LINE_STRING;
  };
  /**
   * @inheritDoc
   * @api
   */


  MultiLineString.prototype.intersectsExtent = function (extent) {
    return (0, _intersectsextent.intersectsLineStringArray)(this.flatCoordinates, 0, this.ends_, this.stride, extent);
  };
  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */


  MultiLineString.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 2);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    var ends = (0, _deflate.deflateCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  };

  return MultiLineString;
}(_SimpleGeometry.default);

var _default = MultiLineString;
exports.default = _default;
},{"../array.js":"node_modules/ol/array.js","../extent.js":"node_modules/ol/extent.js","./GeometryLayout.js":"node_modules/ol/geom/GeometryLayout.js","./GeometryType.js":"node_modules/ol/geom/GeometryType.js","./LineString.js":"node_modules/ol/geom/LineString.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","./flat/closest.js":"node_modules/ol/geom/flat/closest.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","./flat/interpolate.js":"node_modules/ol/geom/flat/interpolate.js","./flat/intersectsextent.js":"node_modules/ol/geom/flat/intersectsextent.js","./flat/simplify.js":"node_modules/ol/geom/flat/simplify.js"}],"node_modules/ol/geom/Point.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extent = require("../extent.js");

var _GeometryType = _interopRequireDefault(require("./GeometryType.js"));

var _SimpleGeometry = _interopRequireDefault(require("./SimpleGeometry.js"));

var _deflate = require("./flat/deflate.js");

var _math = require("../math.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/Point
 */


/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */
var Point =
/** @class */
function (_super) {
  __extends(Point, _super);
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   */


  function Point(coordinates, opt_layout) {
    var _this = _super.call(this) || this;

    _this.setCoordinates(coordinates, opt_layout);

    return _this;
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @override
   * @api
   */


  Point.prototype.clone = function () {
    var point = new Point(this.flatCoordinates.slice(), this.layout);
    return point;
  };
  /**
   * @inheritDoc
   */


  Point.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    var flatCoordinates = this.flatCoordinates;
    var squaredDistance = (0, _math.squaredDistance)(x, y, flatCoordinates[0], flatCoordinates[1]);

    if (squaredDistance < minSquaredDistance) {
      var stride = this.stride;

      for (var i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }

      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  };
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @override
   * @api
   */


  Point.prototype.getCoordinates = function () {
    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
  };
  /**
   * @inheritDoc
   */


  Point.prototype.computeExtent = function (extent) {
    return (0, _extent.createOrUpdateFromCoordinate)(this.flatCoordinates, extent);
  };
  /**
   * @inheritDoc
   * @api
   */


  Point.prototype.getType = function () {
    return _GeometryType.default.POINT;
  };
  /**
   * @inheritDoc
   * @api
   */


  Point.prototype.intersectsExtent = function (extent) {
    return (0, _extent.containsXY)(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
  };
  /**
   * @inheritDoc
   * @api
   */


  Point.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 0);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = (0, _deflate.deflateCoordinate)(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return Point;
}(_SimpleGeometry.default);

var _default = Point;
exports.default = _default;
},{"../extent.js":"node_modules/ol/extent.js","./GeometryType.js":"node_modules/ol/geom/GeometryType.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","../math.js":"node_modules/ol/math.js"}],"node_modules/ol/geom/MultiPoint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _array = require("../array.js");

var _extent = require("../extent.js");

var _GeometryType = _interopRequireDefault(require("./GeometryType.js"));

var _Point = _interopRequireDefault(require("./Point.js"));

var _SimpleGeometry = _interopRequireDefault(require("./SimpleGeometry.js"));

var _deflate = require("./flat/deflate.js");

var _inflate = require("./flat/inflate.js");

var _math = require("../math.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/MultiPoint
 */


/**
 * @classdesc
 * Multi-point geometry.
 *
 * @api
 */
var MultiPoint =
/** @class */
function (_super) {
  __extends(MultiPoint, _super);
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   */


  function MultiPoint(coordinates, opt_layout) {
    var _this = _super.call(this) || this;

    if (opt_layout && !Array.isArray(coordinates[0])) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);
    } else {
      _this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      coordinates, opt_layout);
    }

    return _this;
  }
  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */


  MultiPoint.prototype.appendPoint = function (point) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = point.getFlatCoordinates().slice();
    } else {
      (0, _array.extend)(this.flatCoordinates, point.getFlatCoordinates());
    }

    this.changed();
  };
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @override
   * @api
   */


  MultiPoint.prototype.clone = function () {
    var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
    return multiPoint;
  };
  /**
   * @inheritDoc
   */


  MultiPoint.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    var flatCoordinates = this.flatCoordinates;
    var stride = this.stride;

    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var squaredDistance = (0, _math.squaredDistance)(x, y, flatCoordinates[i], flatCoordinates[i + 1]);

      if (squaredDistance < minSquaredDistance) {
        minSquaredDistance = squaredDistance;

        for (var j = 0; j < stride; ++j) {
          closestPoint[j] = flatCoordinates[i + j];
        }

        closestPoint.length = stride;
      }
    }

    return minSquaredDistance;
  };
  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @override
   * @api
   */


  MultiPoint.prototype.getCoordinates = function () {
    return (0, _inflate.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */


  MultiPoint.prototype.getPoint = function (index) {
    var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;

    if (index < 0 || n <= index) {
      return null;
    }

    return new _Point.default(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
  };
  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */


  MultiPoint.prototype.getPoints = function () {
    var flatCoordinates = this.flatCoordinates;
    var layout = this.layout;
    var stride = this.stride;
    /** @type {Array<Point>} */

    var points = [];

    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var point = new _Point.default(flatCoordinates.slice(i, i + stride), layout);
      points.push(point);
    }

    return points;
  };
  /**
   * @inheritDoc
   * @api
   */


  MultiPoint.prototype.getType = function () {
    return _GeometryType.default.MULTI_POINT;
  };
  /**
   * @inheritDoc
   * @api
   */


  MultiPoint.prototype.intersectsExtent = function (extent) {
    var flatCoordinates = this.flatCoordinates;
    var stride = this.stride;

    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];

      if ((0, _extent.containsXY)(extent, x, y)) {
        return true;
      }
    }

    return false;
  };
  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   * @override
   * @api
   */


  MultiPoint.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = (0, _deflate.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return MultiPoint;
}(_SimpleGeometry.default);

var _default = MultiPoint;
exports.default = _default;
},{"../array.js":"node_modules/ol/array.js","../extent.js":"node_modules/ol/extent.js","./GeometryType.js":"node_modules/ol/geom/GeometryType.js","./Point.js":"node_modules/ol/geom/Point.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","../math.js":"node_modules/ol/math.js"}],"node_modules/ol/geom/flat/area.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linearRing = linearRing;
exports.linearRings = linearRings;
exports.linearRingss = linearRingss;

/**
 * @module ol/geom/flat/area
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRing(flatCoordinates, offset, end, stride) {
  var twiceArea = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }

  return twiceArea / 2;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */


function linearRings(flatCoordinates, offset, ends, stride) {
  var area = 0;

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }

  return area;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */


function linearRingss(flatCoordinates, offset, endss, stride) {
  var area = 0;

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    area += linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }

  return area;
}
},{}],"node_modules/ol/geom/LinearRing.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extent = require("../extent.js");

var _GeometryLayout = _interopRequireDefault(require("./GeometryLayout.js"));

var _GeometryType = _interopRequireDefault(require("./GeometryType.js"));

var _SimpleGeometry = _interopRequireDefault(require("./SimpleGeometry.js"));

var _area = require("./flat/area.js");

var _closest = require("./flat/closest.js");

var _deflate = require("./flat/deflate.js");

var _inflate = require("./flat/inflate.js");

var _simplify = require("./flat/simplify.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/LinearRing
 */


/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @api
 */
var LinearRing =
/** @class */
function (_super) {
  __extends(LinearRing, _super);
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
   * @param {GeometryLayout=} opt_layout Layout.
   */


  function LinearRing(coordinates, opt_layout) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {number}
     */


    _this.maxDelta_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDeltaRevision_ = -1;

    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);
    } else {
      _this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      coordinates, opt_layout);
    }

    return _this;
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @override
   * @api
   */


  LinearRing.prototype.clone = function () {
    return new LinearRing(this.flatCoordinates.slice(), this.layout);
  };
  /**
   * @inheritDoc
   */


  LinearRing.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt((0, _closest.maxSquaredDelta)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }

    return (0, _closest.assignClosestPoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */


  LinearRing.prototype.getArea = function () {
    return (0, _area.linearRing)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @override
   * @api
   */


  LinearRing.prototype.getCoordinates = function () {
    return (0, _inflate.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  /**
   * @inheritDoc
   */


  LinearRing.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = (0, _simplify.douglasPeucker)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    return new LinearRing(simplifiedFlatCoordinates, _GeometryLayout.default.XY);
  };
  /**
   * @inheritDoc
   * @api
   */


  LinearRing.prototype.getType = function () {
    return _GeometryType.default.LINEAR_RING;
  };
  /**
   * @inheritDoc
   */


  LinearRing.prototype.intersectsExtent = function (extent) {
    return false;
  };
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */


  LinearRing.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = (0, _deflate.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return LinearRing;
}(_SimpleGeometry.default);

var _default = LinearRing;
exports.default = _default;
},{"../extent.js":"node_modules/ol/extent.js","./GeometryLayout.js":"node_modules/ol/geom/GeometryLayout.js","./GeometryType.js":"node_modules/ol/geom/GeometryType.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","./flat/area.js":"node_modules/ol/geom/flat/area.js","./flat/closest.js":"node_modules/ol/geom/flat/closest.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","./flat/simplify.js":"node_modules/ol/geom/flat/simplify.js"}],"node_modules/ol/geom/flat/interiorpoint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInteriorPointOfArray = getInteriorPointOfArray;
exports.getInteriorPointsOfMultiArray = getInteriorPointsOfMultiArray;

var _array = require("../../array.js");

var _contains = require("./contains.js");

/**
 * @module ol/geom/flat/interiorpoint
 */

/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
  var i, ii, x, x1, x2, y1, y2;
  var y = flatCenters[flatCentersOffset + 1];
  /** @type {Array<number>} */

  var intersections = []; // Calculate intersections with the horizontal line

  for (var r = 0, rr = ends.length; r < rr; ++r) {
    var end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];

    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];

      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }

      x1 = x2;
      y1 = y2;
    }
  } // Find the longest segment of the horizontal line that has its center point
  // inside the linear ring.


  var pointX = NaN;
  var maxSegmentLength = -Infinity;
  intersections.sort(_array.numberSafeCompareFunction);
  x1 = intersections[0];

  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    var segmentLength = Math.abs(x2 - x1);

    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;

      if ((0, _contains.linearRingsContainsXY)(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }

    x1 = x2;
  }

  if (isNaN(pointX)) {
    // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
  }

  if (opt_dest) {
    opt_dest.push(pointX, y, maxSegmentLength);
    return opt_dest;
  } else {
    return [pointX, y, maxSegmentLength];
  }
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @return {Array<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */


function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
  var interiorPoints = [];

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
    offset = ends[ends.length - 1];
  }

  return interiorPoints;
}
},{"../../array.js":"node_modules/ol/array.js","./contains.js":"node_modules/ol/geom/flat/contains.js"}],"node_modules/ol/geom/flat/reverse.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.coordinates = coordinates;

/**
 * @module ol/geom/flat/reverse
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (var i = 0; i < stride; ++i) {
      var tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }

    offset += stride;
    end -= stride;
  }
}
},{}],"node_modules/ol/geom/flat/orient.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linearRingIsClockwise = linearRingIsClockwise;
exports.linearRingsAreOriented = linearRingsAreOriented;
exports.linearRingssAreOriented = linearRingssAreOriented;
exports.orientLinearRings = orientLinearRings;
exports.orientLinearRingsArray = orientLinearRingsArray;

var _reverse = require("./reverse.js");

/**
 * @module ol/geom/flat/orient
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} Is clockwise.
 */
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  // http://tinyurl.com/clockwise-method
  // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp
  var edge = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }

  return edge > 0;
}
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */


function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);

    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }

    offset = end;
  }

  return true;
}
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */


function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {
      return false;
    }

    if (ends.length) {
      offset = ends[ends.length - 1];
    }
  }

  return true;
}
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */


function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;

    if (reverse) {
      (0, _reverse.coordinates)(flatCoordinates, offset, end, stride);
    }

    offset = end;
  }

  return offset;
}
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */


function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);
  }

  return offset;
}
},{"./reverse.js":"node_modules/ol/geom/flat/reverse.js"}],"node_modules/ol/geom/Polygon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.circular = circular;
exports.fromExtent = fromExtent;
exports.fromCircle = fromCircle;
exports.makeRegular = makeRegular;
exports.default = void 0;

var _array = require("../array.js");

var _extent = require("../extent.js");

var _GeometryLayout = _interopRequireDefault(require("./GeometryLayout.js"));

var _GeometryType = _interopRequireDefault(require("./GeometryType.js"));

var _LinearRing = _interopRequireDefault(require("./LinearRing.js"));

var _Point = _interopRequireDefault(require("./Point.js"));

var _SimpleGeometry = _interopRequireDefault(require("./SimpleGeometry.js"));

var _sphere = require("../sphere.js");

var _area = require("./flat/area.js");

var _closest = require("./flat/closest.js");

var _contains = require("./flat/contains.js");

var _deflate = require("./flat/deflate.js");

var _inflate = require("./flat/inflate.js");

var _interiorpoint = require("./flat/interiorpoint.js");

var _intersectsextent = require("./flat/intersectsextent.js");

var _orient = require("./flat/orient.js");

var _simplify = require("./flat/simplify.js");

var _math = require("../math.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/Polygon
 */


/**
 * @classdesc
 * Polygon geometry.
 *
 * @api
 */
var Polygon =
/** @class */
function (_super) {
  __extends(Polygon, _super);
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `opt_layout` and `opt_ends` are also accepted.)
   * @param {GeometryLayout=} opt_layout Layout.
   * @param {Array<number>=} opt_ends Ends (for internal use with flat coordinates).
   */


  function Polygon(coordinates, opt_layout, opt_ends) {
    var _this = _super.call(this) || this;
    /**
     * @type {Array<number>}
     * @private
     */


    _this.ends_ = [];
    /**
     * @private
     * @type {number}
     */

    _this.flatInteriorPointRevision_ = -1;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */

    _this.flatInteriorPoint_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDeltaRevision_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.orientedRevision_ = -1;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.orientedFlatCoordinates_ = null;

    if (opt_layout !== undefined && opt_ends) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);

      _this.ends_ = opt_ends;
    } else {
      _this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      coordinates, opt_layout);
    }

    return _this;
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */


  Polygon.prototype.appendLinearRing = function (linearRing) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = linearRing.getFlatCoordinates().slice();
    } else {
      (0, _array.extend)(this.flatCoordinates, linearRing.getFlatCoordinates());
    }

    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  };
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @override
   * @api
   */


  Polygon.prototype.clone = function () {
    return new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
  };
  /**
   * @inheritDoc
   */


  Polygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt((0, _closest.arrayMaxSquaredDelta)(this.flatCoordinates, 0, this.ends_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }

    return (0, _closest.assignClosestArrayPoint)(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };
  /**
   * @inheritDoc
   */


  Polygon.prototype.containsXY = function (x, y) {
    return (0, _contains.linearRingsContainsXY)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
  };
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */


  Polygon.prototype.getArea = function () {
    return (0, _area.linearRings)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
  };
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean=} opt_right Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @override
   * @api
   */


  Polygon.prototype.getCoordinates = function (opt_right) {
    var flatCoordinates;

    if (opt_right !== undefined) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      (0, _orient.orientLinearRings)(flatCoordinates, 0, this.ends_, this.stride, opt_right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }

    return (0, _inflate.inflateCoordinatesArray)(flatCoordinates, 0, this.ends_, this.stride);
  };
  /**
   * @return {Array<number>} Ends.
   */


  Polygon.prototype.getEnds = function () {
    return this.ends_;
  };
  /**
   * @return {Array<number>} Interior point.
   */


  Polygon.prototype.getFlatInteriorPoint = function () {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      var flatCenter = (0, _extent.getCenter)(this.getExtent());
      this.flatInteriorPoint_ = (0, _interiorpoint.getInteriorPointOfArray)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
      this.flatInteriorPointRevision_ = this.getRevision();
    }

    return this.flatInteriorPoint_;
  };
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */


  Polygon.prototype.getInteriorPoint = function () {
    return new _Point.default(this.getFlatInteriorPoint(), _GeometryLayout.default.XYM);
  };
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */


  Polygon.prototype.getLinearRingCount = function () {
    return this.ends_.length;
  };
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing} Linear ring.
   * @api
   */


  Polygon.prototype.getLinearRing = function (index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }

    return new _LinearRing.default(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
  };
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */


  Polygon.prototype.getLinearRings = function () {
    var layout = this.layout;
    var flatCoordinates = this.flatCoordinates;
    var ends = this.ends_;
    var linearRings = [];
    var offset = 0;

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var linearRing = new _LinearRing.default(flatCoordinates.slice(offset, end), layout);
      linearRings.push(linearRing);
      offset = end;
    }

    return linearRings;
  };
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */


  Polygon.prototype.getOrientedFlatCoordinates = function () {
    if (this.orientedRevision_ != this.getRevision()) {
      var flatCoordinates = this.flatCoordinates;

      if ((0, _orient.linearRingsAreOriented)(flatCoordinates, 0, this.ends_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = (0, _orient.orientLinearRings)(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
      }

      this.orientedRevision_ = this.getRevision();
    }

    return this.orientedFlatCoordinates_;
  };
  /**
   * @inheritDoc
   */


  Polygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEnds = [];
    simplifiedFlatCoordinates.length = (0, _simplify.quantizeArray)(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
    return new Polygon(simplifiedFlatCoordinates, _GeometryLayout.default.XY, simplifiedEnds);
  };
  /**
   * @inheritDoc
   * @api
   */


  Polygon.prototype.getType = function () {
    return _GeometryType.default.POLYGON;
  };
  /**
   * @inheritDoc
   * @api
   */


  Polygon.prototype.intersectsExtent = function (extent) {
    return (0, _intersectsextent.intersectsLinearRingArray)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
  };
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */


  Polygon.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 2);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    var ends = (0, _deflate.deflateCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  };

  return Polygon;
}(_SimpleGeometry.default);

var _default = Polygon;
/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {import("../coordinate.js").Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices.
 * @param {number=} opt_n Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @param {number=} opt_sphereRadius Optional radius for the sphere (defaults to
 *     the Earth's mean radius using the WGS84 ellipsoid).
 * @return {Polygon} The "circular" polygon.
 * @api
 */

exports.default = _default;

function circular(center, radius, opt_n, opt_sphereRadius) {
  var n = opt_n ? opt_n : 32;
  /** @type {Array<number>} */

  var flatCoordinates = [];

  for (var i = 0; i < n; ++i) {
    (0, _array.extend)(flatCoordinates, (0, _sphere.offset)(center, radius, 2 * Math.PI * i / n, opt_sphereRadius));
  }

  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  return new Polygon(flatCoordinates, _GeometryLayout.default.XY, [flatCoordinates.length]);
}
/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {import("../extent.js").Extent} extent The extent.
 * @return {Polygon} The polygon.
 * @api
 */


function fromExtent(extent) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var flatCoordinates = [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];
  return new Polygon(flatCoordinates, _GeometryLayout.default.XY, [flatCoordinates.length]);
}
/**
 * Create a regular polygon from a circle.
 * @param {import("./Circle.js").default} circle Circle geometry.
 * @param {number=} opt_sides Number of sides of the polygon. Default is 32.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 * @return {Polygon} Polygon geometry.
 * @api
 */


function fromCircle(circle, opt_sides, opt_angle) {
  var sides = opt_sides ? opt_sides : 32;
  var stride = circle.getStride();
  var layout = circle.getLayout();
  var center = circle.getCenter();
  var arrayLength = stride * (sides + 1);
  var flatCoordinates = new Array(arrayLength);

  for (var i = 0; i < arrayLength; i += stride) {
    flatCoordinates[i] = 0;
    flatCoordinates[i + 1] = 0;

    for (var j = 2; j < stride; j++) {
      flatCoordinates[i + j] = center[j];
    }
  }

  var ends = [flatCoordinates.length];
  var polygon = new Polygon(flatCoordinates, layout, ends);
  makeRegular(polygon, center, circle.getRadius(), opt_angle);
  return polygon;
}
/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {Polygon} polygon Polygon geometry.
 * @param {import("../coordinate.js").Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 */


function makeRegular(polygon, center, radius, opt_angle) {
  var flatCoordinates = polygon.getFlatCoordinates();
  var stride = polygon.getStride();
  var sides = flatCoordinates.length / stride - 1;
  var startAngle = opt_angle ? opt_angle : 0;

  for (var i = 0; i <= sides; ++i) {
    var offset = i * stride;
    var angle = startAngle + (0, _math.modulo)(i, sides) * 2 * Math.PI / sides;
    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
  }

  polygon.changed();
}
},{"../array.js":"node_modules/ol/array.js","../extent.js":"node_modules/ol/extent.js","./GeometryLayout.js":"node_modules/ol/geom/GeometryLayout.js","./GeometryType.js":"node_modules/ol/geom/GeometryType.js","./LinearRing.js":"node_modules/ol/geom/LinearRing.js","./Point.js":"node_modules/ol/geom/Point.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","../sphere.js":"node_modules/ol/sphere.js","./flat/area.js":"node_modules/ol/geom/flat/area.js","./flat/closest.js":"node_modules/ol/geom/flat/closest.js","./flat/contains.js":"node_modules/ol/geom/flat/contains.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","./flat/interiorpoint.js":"node_modules/ol/geom/flat/interiorpoint.js","./flat/intersectsextent.js":"node_modules/ol/geom/flat/intersectsextent.js","./flat/orient.js":"node_modules/ol/geom/flat/orient.js","./flat/simplify.js":"node_modules/ol/geom/flat/simplify.js","../math.js":"node_modules/ol/math.js"}],"node_modules/ol/geom/flat/center.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linearRingss = linearRingss;

var _extent = require("../../extent.js");

/**
 * @module ol/geom/flat/center
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array<number>} Flat centers.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
  var flatCenters = [];
  var extent = (0, _extent.createEmpty)();

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    extent = (0, _extent.createOrUpdateFromFlatCoordinates)(flatCoordinates, offset, ends[0], stride);
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }

  return flatCenters;
}
},{"../../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/geom/MultiPolygon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _array = require("../array.js");

var _extent = require("../extent.js");

var _GeometryLayout = _interopRequireDefault(require("./GeometryLayout.js"));

var _GeometryType = _interopRequireDefault(require("./GeometryType.js"));

var _MultiPoint = _interopRequireDefault(require("./MultiPoint.js"));

var _Polygon = _interopRequireDefault(require("./Polygon.js"));

var _SimpleGeometry = _interopRequireDefault(require("./SimpleGeometry.js"));

var _area = require("./flat/area.js");

var _center = require("./flat/center.js");

var _closest = require("./flat/closest.js");

var _contains = require("./flat/contains.js");

var _deflate = require("./flat/deflate.js");

var _inflate = require("./flat/inflate.js");

var _interiorpoint = require("./flat/interiorpoint.js");

var _intersectsextent = require("./flat/intersectsextent.js");

var _orient = require("./flat/orient.js");

var _simplify = require("./flat/simplify.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/MultiPolygon
 */


/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @api
 */
var MultiPolygon =
/** @class */
function (_super) {
  __extends(MultiPolygon, _super);
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.
   * @param {GeometryLayout=} opt_layout Layout.
   * @param {Array<Array<number>>=} opt_endss Array of ends for internal use with flat coordinates.
   */


  function MultiPolygon(coordinates, opt_layout, opt_endss) {
    var _this = _super.call(this) || this;
    /**
     * @type {Array<Array<number>>}
     * @private
     */


    _this.endss_ = [];
    /**
     * @private
     * @type {number}
     */

    _this.flatInteriorPointsRevision_ = -1;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.flatInteriorPoints_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDeltaRevision_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.orientedRevision_ = -1;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.orientedFlatCoordinates_ = null;

    if (!opt_endss && !Array.isArray(coordinates[0])) {
      var layout = _this.getLayout();

      var polygons =
      /** @type {Array<Polygon>} */
      coordinates;
      var flatCoordinates = [];
      var endss = [];

      for (var i = 0, ii = polygons.length; i < ii; ++i) {
        var polygon = polygons[i];

        if (i === 0) {
          layout = polygon.getLayout();
        }

        var offset = flatCoordinates.length;
        var ends = polygon.getEnds();

        for (var j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] += offset;
        }

        (0, _array.extend)(flatCoordinates, polygon.getFlatCoordinates());
        endss.push(ends);
      }

      opt_layout = layout;
      coordinates = flatCoordinates;
      opt_endss = endss;
    }

    if (opt_layout !== undefined && opt_endss) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);

      _this.endss_ = opt_endss;
    } else {
      _this.setCoordinates(
      /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
      coordinates, opt_layout);
    }

    return _this;
  }
  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */


  MultiPolygon.prototype.appendPolygon = function (polygon) {
    /** @type {Array<number>} */
    var ends;

    if (!this.flatCoordinates) {
      this.flatCoordinates = polygon.getFlatCoordinates().slice();
      ends = polygon.getEnds().slice();
      this.endss_.push();
    } else {
      var offset = this.flatCoordinates.length;
      (0, _array.extend)(this.flatCoordinates, polygon.getFlatCoordinates());
      ends = polygon.getEnds().slice();

      for (var i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] += offset;
      }
    }

    this.endss_.push(ends);
    this.changed();
  };
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @override
   * @api
   */


  MultiPolygon.prototype.clone = function () {
    var len = this.endss_.length;
    var newEndss = new Array(len);

    for (var i = 0; i < len; ++i) {
      newEndss[i] = this.endss_[i].slice();
    }

    return new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);
  };
  /**
   * @inheritDoc
   */


  MultiPolygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt((0, _closest.multiArrayMaxSquaredDelta)(this.flatCoordinates, 0, this.endss_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }

    return (0, _closest.assignClosestMultiArrayPoint)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };
  /**
   * @inheritDoc
   */


  MultiPolygon.prototype.containsXY = function (x, y) {
    return (0, _contains.linearRingssContainsXY)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
  };
  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */


  MultiPolygon.prototype.getArea = function () {
    return (0, _area.linearRingss)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
  };
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean=} opt_right Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @override
   * @api
   */


  MultiPolygon.prototype.getCoordinates = function (opt_right) {
    var flatCoordinates;

    if (opt_right !== undefined) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      (0, _orient.orientLinearRingsArray)(flatCoordinates, 0, this.endss_, this.stride, opt_right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }

    return (0, _inflate.inflateMultiCoordinatesArray)(flatCoordinates, 0, this.endss_, this.stride);
  };
  /**
   * @return {Array<Array<number>>} Endss.
   */


  MultiPolygon.prototype.getEndss = function () {
    return this.endss_;
  };
  /**
   * @return {Array<number>} Flat interior points.
   */


  MultiPolygon.prototype.getFlatInteriorPoints = function () {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      var flatCenters = (0, _center.linearRingss)(this.flatCoordinates, 0, this.endss_, this.stride);
      this.flatInteriorPoints_ = (0, _interiorpoint.getInteriorPointsOfMultiArray)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
      this.flatInteriorPointsRevision_ = this.getRevision();
    }

    return this.flatInteriorPoints_;
  };
  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */


  MultiPolygon.prototype.getInteriorPoints = function () {
    return new _MultiPoint.default(this.getFlatInteriorPoints().slice(), _GeometryLayout.default.XYM);
  };
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */


  MultiPolygon.prototype.getOrientedFlatCoordinates = function () {
    if (this.orientedRevision_ != this.getRevision()) {
      var flatCoordinates = this.flatCoordinates;

      if ((0, _orient.linearRingssAreOriented)(flatCoordinates, 0, this.endss_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = (0, _orient.orientLinearRingsArray)(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
      }

      this.orientedRevision_ = this.getRevision();
    }

    return this.orientedFlatCoordinates_;
  };
  /**
   * @inheritDoc
   */


  MultiPolygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEndss = [];
    simplifiedFlatCoordinates.length = (0, _simplify.quantizeMultiArray)(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
    return new MultiPolygon(simplifiedFlatCoordinates, _GeometryLayout.default.XY, simplifiedEndss);
  };
  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */


  MultiPolygon.prototype.getPolygon = function (index) {
    if (index < 0 || this.endss_.length <= index) {
      return null;
    }

    var offset;

    if (index === 0) {
      offset = 0;
    } else {
      var prevEnds = this.endss_[index - 1];
      offset = prevEnds[prevEnds.length - 1];
    }

    var ends = this.endss_[index].slice();
    var end = ends[ends.length - 1];

    if (offset !== 0) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] -= offset;
      }
    }

    return new _Polygon.default(this.flatCoordinates.slice(offset, end), this.layout, ends);
  };
  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */


  MultiPolygon.prototype.getPolygons = function () {
    var layout = this.layout;
    var flatCoordinates = this.flatCoordinates;
    var endss = this.endss_;
    var polygons = [];
    var offset = 0;

    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i].slice();
      var end = ends[ends.length - 1];

      if (offset !== 0) {
        for (var j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] -= offset;
        }
      }

      var polygon = new _Polygon.default(flatCoordinates.slice(offset, end), layout, ends);
      polygons.push(polygon);
      offset = end;
    }

    return polygons;
  };
  /**
   * @inheritDoc
   * @api
   */


  MultiPolygon.prototype.getType = function () {
    return _GeometryType.default.MULTI_POLYGON;
  };
  /**
   * @inheritDoc
   * @api
   */


  MultiPolygon.prototype.intersectsExtent = function (extent) {
    return (0, _intersectsextent.intersectsLinearRingMultiArray)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
  };
  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */


  MultiPolygon.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 3);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    var endss = (0, _deflate.deflateMultiCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);

    if (endss.length === 0) {
      this.flatCoordinates.length = 0;
    } else {
      var lastEnds = endss[endss.length - 1];
      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
    }

    this.changed();
  };

  return MultiPolygon;
}(_SimpleGeometry.default);

var _default = MultiPolygon;
exports.default = _default;
},{"../array.js":"node_modules/ol/array.js","../extent.js":"node_modules/ol/extent.js","./GeometryLayout.js":"node_modules/ol/geom/GeometryLayout.js","./GeometryType.js":"node_modules/ol/geom/GeometryType.js","./MultiPoint.js":"node_modules/ol/geom/MultiPoint.js","./Polygon.js":"node_modules/ol/geom/Polygon.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","./flat/area.js":"node_modules/ol/geom/flat/area.js","./flat/center.js":"node_modules/ol/geom/flat/center.js","./flat/closest.js":"node_modules/ol/geom/flat/closest.js","./flat/contains.js":"node_modules/ol/geom/flat/contains.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","./flat/interiorpoint.js":"node_modules/ol/geom/flat/interiorpoint.js","./flat/intersectsextent.js":"node_modules/ol/geom/flat/intersectsextent.js","./flat/orient.js":"node_modules/ol/geom/flat/orient.js","./flat/simplify.js":"node_modules/ol/geom/flat/simplify.js"}],"node_modules/ol/format/GeoJSON.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _asserts = require("../asserts.js");

var _Feature = _interopRequireDefault(require("../Feature.js"));

var _Feature2 = require("./Feature.js");

var _JSONFeature = _interopRequireDefault(require("./JSONFeature.js"));

var _GeometryCollection = _interopRequireDefault(require("../geom/GeometryCollection.js"));

var _LineString = _interopRequireDefault(require("../geom/LineString.js"));

var _MultiLineString = _interopRequireDefault(require("../geom/MultiLineString.js"));

var _MultiPoint = _interopRequireDefault(require("../geom/MultiPoint.js"));

var _MultiPolygon = _interopRequireDefault(require("../geom/MultiPolygon.js"));

var _Point = _interopRequireDefault(require("../geom/Point.js"));

var _Polygon = _interopRequireDefault(require("../geom/Polygon.js"));

var _obj = require("../obj.js");

var _proj = require("../proj.js");

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/format/GeoJSON
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {import("geojson").GeoJSON} GeoJSONObject
 * @typedef {import("geojson").Feature} GeoJSONFeature
 * @typedef {import("geojson").FeatureCollection} GeoJSONFeatureCollection
 * @typedef {import("geojson").Geometry} GeoJSONGeometry
 * @typedef {import("geojson").Point} GeoJSONPoint
 * @typedef {import("geojson").LineString} GeoJSONLineString
 * @typedef {import("geojson").Polygon} GeoJSONPolygon
 * @typedef {import("geojson").MultiPoint} GeoJSONMultiPoint
 * @typedef {import("geojson").MultiLineString} GeoJSONMultiLineString
 * @typedef {import("geojson").MultiPolygon} GeoJSONMultiPolygon
 * @typedef {import("geojson").GeometryCollection} GeoJSONGeometryCollection
 */

/**
 * @typedef {Object} Options
 * @property {import("../proj.js").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection for features read or
 * written by the format.  Options passed to read or write methods will take precedence.
 * @property {string} [geometryName] Geometry name to use when creating features.
 * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include
 * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader
 * will look for that field to set the geometry name. If both this field is set to `true`
 * and a `geometryName` is provided, the `geometryName` will take precedence.
 */

/**
 * @classdesc
 * Feature format for reading and writing data in the GeoJSON format.
 *
  * @api
 */
var GeoJSON =
/** @class */
function (_super) {
  __extends(GeoJSON, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function GeoJSON(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this) || this;
    /**
     * @inheritDoc
     */

    _this.dataProjection = (0, _proj.get)(options.dataProjection ? options.dataProjection : 'EPSG:4326');

    if (options.featureProjection) {
      _this.defaultFeatureProjection = (0, _proj.get)(options.featureProjection);
    }
    /**
     * Name of the geometry attribute for features.
     * @type {string|undefined}
     * @private
     */


    _this.geometryName_ = options.geometryName;
    /**
     * Look for the geometry name in the feature GeoJSON
     * @type {boolean|undefined}
     * @private
     */

    _this.extractGeometryName_ = options.extractGeometryName;
    return _this;
  }
  /**
   * @inheritDoc
   */


  GeoJSON.prototype.readFeatureFromObject = function (object, opt_options) {
    /**
     * @type {GeoJSONFeature}
     */
    var geoJSONFeature = null;

    if (object['type'] === 'Feature') {
      geoJSONFeature =
      /** @type {GeoJSONFeature} */
      object;
    } else {
      geoJSONFeature = {
        'type': 'Feature',
        'geometry':
        /** @type {GeoJSONGeometry} */
        object,
        'properties': null
      };
    }

    var geometry = readGeometry(geoJSONFeature['geometry'], opt_options);
    var feature = new _Feature.default();

    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    } else if (this.extractGeometryName_ && 'geometry_name' in geoJSONFeature !== undefined) {
      feature.setGeometryName(geoJSONFeature['geometry_name']);
    }

    feature.setGeometry(geometry);

    if ('id' in geoJSONFeature) {
      feature.setId(geoJSONFeature['id']);
    }

    if (geoJSONFeature['properties']) {
      feature.setProperties(geoJSONFeature['properties'], true);
    }

    return feature;
  };
  /**
   * @inheritDoc
   */


  GeoJSON.prototype.readFeaturesFromObject = function (object, opt_options) {
    var geoJSONObject =
    /** @type {GeoJSONObject} */
    object;
    /** @type {Array<import("../Feature.js").default>} */

    var features = null;

    if (geoJSONObject['type'] === 'FeatureCollection') {
      var geoJSONFeatureCollection =
      /** @type {GeoJSONFeatureCollection} */
      object;
      features = [];
      var geoJSONFeatures = geoJSONFeatureCollection['features'];

      for (var i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
        features.push(this.readFeatureFromObject(geoJSONFeatures[i], opt_options));
      }
    } else {
      features = [this.readFeatureFromObject(object, opt_options)];
    }

    return features;
  };
  /**
   * @inheritDoc
   */


  GeoJSON.prototype.readGeometryFromObject = function (object, opt_options) {
    return readGeometry(
    /** @type {GeoJSONGeometry} */
    object, opt_options);
  };
  /**
   * @inheritDoc
   */


  GeoJSON.prototype.readProjectionFromObject = function (object) {
    var crs = object['crs'];
    var projection;

    if (crs) {
      if (crs['type'] == 'name') {
        projection = (0, _proj.get)(crs['properties']['name']);
      } else if (crs['type'] === 'EPSG') {
        projection = (0, _proj.get)('EPSG:' + crs['properties']['code']);
      } else {
        (0, _asserts.assert)(false, 36); // Unknown SRS type
      }
    } else {
      projection = this.dataProjection;
    }

    return (
      /** @type {import("../proj/Projection.js").default} */
      projection
    );
  };
  /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {GeoJSONFeature} Object.
   * @override
   * @api
   */


  GeoJSON.prototype.writeFeatureObject = function (feature, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    /** @type {GeoJSONFeature} */

    var object = {
      'type': 'Feature',
      geometry: null,
      properties: null
    };
    var id = feature.getId();

    if (id !== undefined) {
      object.id = id;
    }

    var geometry = feature.getGeometry();

    if (geometry) {
      object.geometry = writeGeometry(geometry, opt_options);
    }

    var properties = feature.getProperties();
    delete properties[feature.getGeometryName()];

    if (!(0, _obj.isEmpty)(properties)) {
      object.properties = properties;
    }

    return object;
  };
  /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @override
   * @api
   */


  GeoJSON.prototype.writeFeaturesObject = function (features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var objects = [];

    for (var i = 0, ii = features.length; i < ii; ++i) {
      objects.push(this.writeFeatureObject(features[i], opt_options));
    }

    return {
      type: 'FeatureCollection',
      features: objects
    };
  };
  /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @override
   * @api
   */


  GeoJSON.prototype.writeGeometryObject = function (geometry, opt_options) {
    return writeGeometry(geometry, this.adaptOptions(opt_options));
  };

  return GeoJSON;
}(_JSONFeature.default);
/**
 * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
 * @return {import("../geom/Geometry.js").default} Geometry.
 */


function readGeometry(object, opt_options) {
  if (!object) {
    return null;
  }
  /**
   * @type {import("../geom/Geometry.js").default}
   */


  var geometry;

  switch (object['type']) {
    case _GeometryType.default.POINT:
      {
        geometry = readPointGeometry(
        /** @type {GeoJSONPoint} */
        object);
        break;
      }

    case _GeometryType.default.LINE_STRING:
      {
        geometry = readLineStringGeometry(
        /** @type {GeoJSONLineString} */
        object);
        break;
      }

    case _GeometryType.default.POLYGON:
      {
        geometry = readPolygonGeometry(
        /** @type {GeoJSONPolygon} */
        object);
        break;
      }

    case _GeometryType.default.MULTI_POINT:
      {
        geometry = readMultiPointGeometry(
        /** @type {GeoJSONMultiPoint} */
        object);
        break;
      }

    case _GeometryType.default.MULTI_LINE_STRING:
      {
        geometry = readMultiLineStringGeometry(
        /** @type {GeoJSONMultiLineString} */
        object);
        break;
      }

    case _GeometryType.default.MULTI_POLYGON:
      {
        geometry = readMultiPolygonGeometry(
        /** @type {GeoJSONMultiPolygon} */
        object);
        break;
      }

    case _GeometryType.default.GEOMETRY_COLLECTION:
      {
        geometry = readGeometryCollectionGeometry(
        /** @type {GeoJSONGeometryCollection} */
        object);
        break;
      }

    default:
      {
        throw new Error('Unsupported GeoJSON type: ' + object.type);
      }
  }

  return (0, _Feature2.transformGeometryWithOptions)(geometry, false, opt_options);
}
/**
 * @param {GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
 * @return {GeometryCollection} Geometry collection.
 */


function readGeometryCollectionGeometry(object, opt_options) {
  var geometries = object['geometries'].map(
  /**
   * @param {GeoJSONGeometry} geometry Geometry.
   * @return {import("../geom/Geometry.js").default} geometry Geometry.
   */
  function (geometry) {
    return readGeometry(geometry, opt_options);
  });
  return new _GeometryCollection.default(geometries);
}
/**
 * @param {GeoJSONPoint} object Object.
 * @return {Point} Point.
 */


function readPointGeometry(object) {
  return new _Point.default(object['coordinates']);
}
/**
 * @param {GeoJSONLineString} object Object.
 * @return {LineString} LineString.
 */


function readLineStringGeometry(object) {
  return new _LineString.default(object['coordinates']);
}
/**
 * @param {GeoJSONMultiLineString} object Object.
 * @return {MultiLineString} MultiLineString.
 */


function readMultiLineStringGeometry(object) {
  return new _MultiLineString.default(object['coordinates']);
}
/**
 * @param {GeoJSONMultiPoint} object Object.
 * @return {MultiPoint} MultiPoint.
 */


function readMultiPointGeometry(object) {
  return new _MultiPoint.default(object['coordinates']);
}
/**
 * @param {GeoJSONMultiPolygon} object Object.
 * @return {MultiPolygon} MultiPolygon.
 */


function readMultiPolygonGeometry(object) {
  return new _MultiPolygon.default(object['coordinates']);
}
/**
 * @param {GeoJSONPolygon} object Object.
 * @return {Polygon} Polygon.
 */


function readPolygonGeometry(object) {
  return new _Polygon.default(object['coordinates']);
}
/**
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


function writeGeometry(geometry, opt_options) {
  geometry = (0, _Feature2.transformGeometryWithOptions)(geometry, true, opt_options);
  var type = geometry.getType();
  /** @type {GeoJSONGeometry} */

  var geoJSON;

  switch (type) {
    case _GeometryType.default.POINT:
      {
        geoJSON = writePointGeometry(
        /** @type {Point} */
        geometry, opt_options);
        break;
      }

    case _GeometryType.default.LINE_STRING:
      {
        geoJSON = writeLineStringGeometry(
        /** @type {LineString} */
        geometry, opt_options);
        break;
      }

    case _GeometryType.default.POLYGON:
      {
        geoJSON = writePolygonGeometry(
        /** @type {Polygon} */
        geometry, opt_options);
        break;
      }

    case _GeometryType.default.MULTI_POINT:
      {
        geoJSON = writeMultiPointGeometry(
        /** @type {MultiPoint} */
        geometry, opt_options);
        break;
      }

    case _GeometryType.default.MULTI_LINE_STRING:
      {
        geoJSON = writeMultiLineStringGeometry(
        /** @type {MultiLineString} */
        geometry, opt_options);
        break;
      }

    case _GeometryType.default.MULTI_POLYGON:
      {
        geoJSON = writeMultiPolygonGeometry(
        /** @type {MultiPolygon} */
        geometry, opt_options);
        break;
      }

    case _GeometryType.default.GEOMETRY_COLLECTION:
      {
        geoJSON = writeGeometryCollectionGeometry(
        /** @type {GeometryCollection} */
        geometry, opt_options);
        break;
      }

    case _GeometryType.default.CIRCLE:
      {
        geoJSON = {
          type: 'GeometryCollection',
          geometries: []
        };
        break;
      }

    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }

  return geoJSON;
}
/**
 * @param {GeometryCollection} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
 * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.
 */


function writeGeometryCollectionGeometry(geometry, opt_options) {
  var geometries = geometry.getGeometriesArray().map(function (geometry) {
    var options = (0, _obj.assign)({}, opt_options);
    delete options.featureProjection;
    return writeGeometry(geometry, options);
  });
  return {
    type: 'GeometryCollection',
    geometries: geometries
  };
}
/**
 * @param {LineString} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


function writeLineStringGeometry(geometry, opt_options) {
  return {
    type: 'LineString',
    coordinates: geometry.getCoordinates()
  };
}
/**
 * @param {MultiLineString} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


function writeMultiLineStringGeometry(geometry, opt_options) {
  return {
    type: 'MultiLineString',
    coordinates: geometry.getCoordinates()
  };
}
/**
 * @param {MultiPoint} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


function writeMultiPointGeometry(geometry, opt_options) {
  return {
    type: 'MultiPoint',
    coordinates: geometry.getCoordinates()
  };
}
/**
 * @param {MultiPolygon} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


function writeMultiPolygonGeometry(geometry, opt_options) {
  var right;

  if (opt_options) {
    right = opt_options.rightHanded;
  }

  return {
    type: 'MultiPolygon',
    coordinates: geometry.getCoordinates(right)
  };
}
/**
 * @param {Point} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


function writePointGeometry(geometry, opt_options) {
  return {
    type: 'Point',
    coordinates: geometry.getCoordinates()
  };
}
/**
 * @param {Polygon} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */


function writePolygonGeometry(geometry, opt_options) {
  var right;

  if (opt_options) {
    right = opt_options.rightHanded;
  }

  return {
    type: 'Polygon',
    coordinates: geometry.getCoordinates(right)
  };
}

var _default = GeoJSON;
exports.default = _default;
},{"../asserts.js":"node_modules/ol/asserts.js","../Feature.js":"node_modules/ol/Feature.js","./Feature.js":"node_modules/ol/format/Feature.js","./JSONFeature.js":"node_modules/ol/format/JSONFeature.js","../geom/GeometryCollection.js":"node_modules/ol/geom/GeometryCollection.js","../geom/LineString.js":"node_modules/ol/geom/LineString.js","../geom/MultiLineString.js":"node_modules/ol/geom/MultiLineString.js","../geom/MultiPoint.js":"node_modules/ol/geom/MultiPoint.js","../geom/MultiPolygon.js":"node_modules/ol/geom/MultiPolygon.js","../geom/Point.js":"node_modules/ol/geom/Point.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js","../obj.js":"node_modules/ol/obj.js","../proj.js":"node_modules/ol/proj.js","../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js"}],"node_modules/ol/CollectionEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/CollectionEventType
 */

/**
 * @enum {string}
 */
var _default = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: 'add',

  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: 'remove'
};
exports.default = _default;
},{}],"node_modules/ol/Collection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CollectionEvent = void 0;

var _AssertionError = _interopRequireDefault(require("./AssertionError.js"));

var _CollectionEventType = _interopRequireDefault(require("./CollectionEventType.js"));

var _Object = _interopRequireDefault(require("./Object.js"));

var _Event = _interopRequireDefault(require("./events/Event.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/Collection
 */


/**
 * @enum {string}
 * @private
 */
var Property = {
  LENGTH: 'length'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
 * type.
 */

var CollectionEvent =
/** @class */
function (_super) {
  __extends(CollectionEvent, _super);
  /**
   * @param {CollectionEventType} type Type.
   * @param {*=} opt_element Element.
   * @param {number=} opt_index The index of the added or removed element.
   */


  function CollectionEvent(type, opt_element, opt_index) {
    var _this = _super.call(this, type) || this;
    /**
     * The element that is added to or removed from the collection.
     * @type {*}
     * @api
     */


    _this.element = opt_element;
    /**
     * The index of the added or removed element.
     * @type {number}
     * @api
     */

    _this.index = opt_index;
    return _this;
  }

  return CollectionEvent;
}(_Event.default);

exports.CollectionEvent = CollectionEvent;

/**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */

/**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @fires CollectionEvent
 *
 * @template T
 * @api
 */
var Collection =
/** @class */
function (_super) {
  __extends(Collection, _super);
  /**
   * @param {Array<T>=} opt_array Array.
   * @param {Options=} opt_options Collection options.
   */


  function Collection(opt_array, opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options || {};
    /**
     * @private
     * @type {boolean}
     */

    _this.unique_ = !!options.unique;
    /**
     * @private
     * @type {!Array<T>}
     */

    _this.array_ = opt_array ? opt_array : [];

    if (_this.unique_) {
      for (var i = 0, ii = _this.array_.length; i < ii; ++i) {
        _this.assertUnique_(_this.array_[i], i);
      }
    }

    _this.updateLength_();

    return _this;
  }
  /**
   * Remove all elements from the collection.
   * @api
   */


  Collection.prototype.clear = function () {
    while (this.getLength() > 0) {
      this.pop();
    }
  };
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */


  Collection.prototype.extend = function (arr) {
    for (var i = 0, ii = arr.length; i < ii; ++i) {
      this.push(arr[i]);
    }

    return this;
  };
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */


  Collection.prototype.forEach = function (f) {
    var array = this.array_;

    for (var i = 0, ii = array.length; i < ii; ++i) {
      f(array[i], i, array);
    }
  };
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */


  Collection.prototype.getArray = function () {
    return this.array_;
  };
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */


  Collection.prototype.item = function (index) {
    return this.array_[index];
  };
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */


  Collection.prototype.getLength = function () {
    return this.get(Property.LENGTH);
  };
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */


  Collection.prototype.insertAt = function (index, elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }

    this.array_.splice(index, 0, elem);
    this.updateLength_();
    this.dispatchEvent(new CollectionEvent(_CollectionEventType.default.ADD, elem, index));
  };
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */


  Collection.prototype.pop = function () {
    return this.removeAt(this.getLength() - 1);
  };
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */


  Collection.prototype.push = function (elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }

    var n = this.getLength();
    this.insertAt(n, elem);
    return this.getLength();
  };
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */


  Collection.prototype.remove = function (elem) {
    var arr = this.array_;

    for (var i = 0, ii = arr.length; i < ii; ++i) {
      if (arr[i] === elem) {
        return this.removeAt(i);
      }
    }

    return undefined;
  };
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */


  Collection.prototype.removeAt = function (index) {
    var prev = this.array_[index];
    this.array_.splice(index, 1);
    this.updateLength_();
    this.dispatchEvent(new CollectionEvent(_CollectionEventType.default.REMOVE, prev, index));
    return prev;
  };
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */


  Collection.prototype.setAt = function (index, elem) {
    var n = this.getLength();

    if (index < n) {
      if (this.unique_) {
        this.assertUnique_(elem, index);
      }

      var prev = this.array_[index];
      this.array_[index] = elem;
      this.dispatchEvent(new CollectionEvent(_CollectionEventType.default.REMOVE, prev, index));
      this.dispatchEvent(new CollectionEvent(_CollectionEventType.default.ADD, elem, index));
    } else {
      for (var j = n; j < index; ++j) {
        this.insertAt(j, undefined);
      }

      this.insertAt(index, elem);
    }
  };
  /**
   * @private
   */


  Collection.prototype.updateLength_ = function () {
    this.set(Property.LENGTH, this.array_.length);
  };
  /**
   * @private
   * @param {T} elem Element.
   * @param {number=} opt_except Optional index to ignore.
   */


  Collection.prototype.assertUnique_ = function (elem, opt_except) {
    for (var i = 0, ii = this.array_.length; i < ii; ++i) {
      if (this.array_[i] === elem && i !== opt_except) {
        throw new _AssertionError.default(58);
      }
    }
  };

  return Collection;
}(_Object.default);

var _default = Collection;
exports.default = _default;
},{"./AssertionError.js":"node_modules/ol/AssertionError.js","./CollectionEventType.js":"node_modules/ol/CollectionEventType.js","./Object.js":"node_modules/ol/Object.js","./events/Event.js":"node_modules/ol/events/Event.js"}],"node_modules/ol/MapEvent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Event = _interopRequireDefault(require("./events/Event.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/MapEvent
 */


/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map event.
 */
var MapEvent =
/** @class */
function (_super) {
  __extends(MapEvent, _super);
  /**
   * @param {string} type Event type.
   * @param {import("./PluggableMap.js").default} map Map.
   * @param {?import("./PluggableMap.js").FrameState=} opt_frameState Frame state.
   */


  function MapEvent(type, map, opt_frameState) {
    var _this = _super.call(this, type) || this;
    /**
     * The map where the event occurred.
     * @type {import("./PluggableMap.js").default}
     * @api
     */


    _this.map = map;
    /**
     * The frame state at the time of the event.
     * @type {?import("./PluggableMap.js").FrameState}
     * @api
     */

    _this.frameState = opt_frameState !== undefined ? opt_frameState : null;
    return _this;
  }

  return MapEvent;
}(_Event.default);

var _default = MapEvent;
exports.default = _default;
},{"./events/Event.js":"node_modules/ol/events/Event.js"}],"node_modules/ol/MapBrowserEvent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MapEvent = _interopRequireDefault(require("./MapEvent.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/MapBrowserEvent
 */


/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map browser event.
 */
var MapBrowserEvent =
/** @class */
function (_super) {
  __extends(MapBrowserEvent, _super);
  /**
   * @param {string} type Event type.
   * @param {import("./PluggableMap.js").default} map Map.
   * @param {Event} browserEvent Browser event.
   * @param {boolean=} opt_dragging Is the map currently being dragged?
   * @param {?import("./PluggableMap.js").FrameState=} opt_frameState Frame state.
   */


  function MapBrowserEvent(type, map, browserEvent, opt_dragging, opt_frameState) {
    var _this = _super.call(this, type, map, opt_frameState) || this;
    /**
     * The original browser event.
     * @const
     * @type {Event}
     * @api
     */


    _this.originalEvent = browserEvent;
    /**
     * The map pixel relative to the viewport corresponding to the original browser event.
     * @type {?import("./pixel.js").Pixel}
     */

    _this.pixel_ = null;
    /**
     * The coordinate in the user projection corresponding to the original browser event.
     * @type {?import("./coordinate.js").Coordinate}
     */

    _this.coordinate_ = null;
    /**
     * Indicates if the map is currently being dragged. Only set for
     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
     *
     * @type {boolean}
     * @api
     */

    _this.dragging = opt_dragging !== undefined ? opt_dragging : false;
    return _this;
  }

  Object.defineProperty(MapBrowserEvent.prototype, "pixel", {
    /**
     * The map pixel relative to the viewport corresponding to the original browser event.
     * @type {import("./pixel.js").Pixel}
     * @api
     */
    get: function () {
      if (!this.pixel_) {
        this.pixel_ = this.map.getEventPixel(this.originalEvent);
      }

      return this.pixel_;
    },
    set: function (pixel) {
      this.pixel_ = pixel;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MapBrowserEvent.prototype, "coordinate", {
    /**
     * The coordinate corresponding to the original browser event.  This will be in the user
     * projection if one is set.  Otherwise it will be in the view projection.
     * @type {import("./coordinate.js").Coordinate}
     * @api
     */
    get: function () {
      if (!this.coordinate_) {
        this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
      }

      return this.coordinate_;
    },
    set: function (coordinate) {
      this.coordinate_ = coordinate;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @override
   * @api
   */

  MapBrowserEvent.prototype.preventDefault = function () {
    _super.prototype.preventDefault.call(this);

    this.originalEvent.preventDefault();
  };
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @override
   * @api
   */


  MapBrowserEvent.prototype.stopPropagation = function () {
    _super.prototype.stopPropagation.call(this);

    this.originalEvent.stopPropagation();
  };

  return MapBrowserEvent;
}(_MapEvent.default);

var _default = MapBrowserEvent;
exports.default = _default;
},{"./MapEvent.js":"node_modules/ol/MapEvent.js"}],"node_modules/elm-pep/dist/elm-pep.js":[function(require,module,exports) {
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/
// Variable to hold current primary touch event identifier.
// iOS needs this since it does not attribute
// identifier 0 to primary touch event.
var primaryTouchId = null;
// Variable to hold mouse pointer captures.
var mouseCaptureTarget = null;
if (!("PointerEvent" in window)) {
    // Define {set,release}PointerCapture
    definePointerCapture();
    // Create Pointer polyfill from mouse events only on non-touch device
    if (!("TouchEvent" in window)) {
        addMouseToPointerListener(document, "mousedown", "pointerdown");
        addMouseToPointerListener(document, "mousemove", "pointermove");
        addMouseToPointerListener(document, "mouseup", "pointerup");
    }
    // Define Pointer polyfill from touch events
    addTouchToPointerListener(document, "touchstart", "pointerdown");
    addTouchToPointerListener(document, "touchmove", "pointermove");
    addTouchToPointerListener(document, "touchend", "pointerup");
}
// Function defining {set,release}PointerCapture from {set,releas}Capture
function definePointerCapture() {
    Element.prototype.setPointerCapture = Element.prototype.setCapture;
    Element.prototype.releasePointerCapture = Element.prototype.releaseCapture;
}
// Function converting a Mouse event to a Pointer event.
function addMouseToPointerListener(target, mouseType, pointerType) {
    target.addEventListener(mouseType, function (mouseEvent) {
        var pointerEvent = new MouseEvent(pointerType, mouseEvent);
        pointerEvent.pointerId = 1;
        pointerEvent.isPrimary = true;
        pointerEvent.pointerType = "mouse";
        pointerEvent.width = 1;
        pointerEvent.height = 1;
        pointerEvent.tiltX = 0;
        pointerEvent.tiltY = 0;
        // pressure is 0.5 if a button is holded
        "buttons" in mouseEvent && mouseEvent.buttons !== 0
            ? (pointerEvent.pressure = 0.5)
            : (pointerEvent.pressure = 0);
        // if already capturing mouse event, transfer target
        // and don't forget implicit release on mouseup.
        var target = mouseEvent.target;
        if (mouseCaptureTarget !== null) {
            target = mouseCaptureTarget;
            if (mouseType === "mouseup") {
                mouseCaptureTarget = null;
            }
        }
        target.dispatchEvent(pointerEvent);
        if (pointerEvent.defaultPrevented) {
            mouseEvent.preventDefault();
        }
    });
}
// Function converting a Touch event to a Pointer event.
function addTouchToPointerListener(target, touchType, pointerType) {
    target.addEventListener(touchType, function (touchEvent) {
        var changedTouches = touchEvent.changedTouches;
        var nbTouches = changedTouches.length;
        for (var t = 0; t < nbTouches; t++) {
            var pointerEvent = new CustomEvent(pointerType, {
                bubbles: true,
                cancelable: true
            });
            pointerEvent.ctrlKey = touchEvent.ctrlKey;
            pointerEvent.shiftKey = touchEvent.shiftKey;
            pointerEvent.altKey = touchEvent.altKey;
            pointerEvent.metaKey = touchEvent.metaKey;
            var touch = changedTouches.item(t);
            pointerEvent.clientX = touch.clientX;
            pointerEvent.clientY = touch.clientY;
            pointerEvent.screenX = touch.screenX;
            pointerEvent.screenY = touch.screenY;
            pointerEvent.pageX = touch.pageX;
            pointerEvent.pageY = touch.pageY;
            var rect = touch.target.getBoundingClientRect();
            pointerEvent.offsetX = touch.clientX - rect.left;
            pointerEvent.offsetY = touch.clientY - rect.top;
            pointerEvent.pointerId = 1 + touch.identifier;
            // Default values for standard MouseEvent fields.
            pointerEvent.button = 0;
            pointerEvent.buttons = 1;
            pointerEvent.movementX = 0;
            pointerEvent.movementY = 0;
            pointerEvent.region = null;
            pointerEvent.relatedTarget = null;
            pointerEvent.x = pointerEvent.clientX;
            pointerEvent.y = pointerEvent.clientY;
            // Pointer event details
            pointerEvent.pointerType = "touch";
            pointerEvent.width = 1;
            pointerEvent.height = 1;
            pointerEvent.tiltX = 0;
            pointerEvent.tiltY = 0;
            pointerEvent.pressure = 1;
            // First touch is the primary pointer event.
            if (touchType === "touchstart" && primaryTouchId === null) {
                primaryTouchId = touch.identifier;
            }
            pointerEvent.isPrimary = touch.identifier === primaryTouchId;
            // If first touch ends, reset primary touch id.
            if (touchType === "touchend" && pointerEvent.isPrimary) {
                primaryTouchId = null;
            }
            touchEvent.target.dispatchEvent(pointerEvent);
            if (pointerEvent.defaultPrevented) {
                touchEvent.preventDefault();
            }
        }
    });
}

},{}],"node_modules/ol/has.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PASSIVE_EVENT_LISTENERS = exports.IMAGE_DECODE = exports.WORKER_OFFSCREEN_CANVAS = exports.DEVICE_PIXEL_RATIO = exports.MAC = exports.WEBKIT = exports.SAFARI = exports.FIREFOX = void 0;

/**
 * @module ol/has
 */
var ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';
/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */

var FIREFOX = ua.indexOf('firefox') !== -1;
/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */

exports.FIREFOX = FIREFOX;
var SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;
/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */

exports.SAFARI = SAFARI;
var WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;
/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */

exports.WEBKIT = WEBKIT;
var MAC = ua.indexOf('macintosh') !== -1;
/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */

exports.MAC = MAC;
var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;
/**
 * The execution context is a worker with OffscreenCanvas available.
 * @const
 * @type {boolean}
 */

exports.DEVICE_PIXEL_RATIO = DEVICE_PIXEL_RATIO;
var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== 'undefined' && typeof OffscreenCanvas !== 'undefined' && self instanceof WorkerGlobalScope; //eslint-disable-line

/**
 * Image.prototype.decode() is supported.
 * @type {boolean}
 */

exports.WORKER_OFFSCREEN_CANVAS = WORKER_OFFSCREEN_CANVAS;
var IMAGE_DECODE = typeof Image !== 'undefined' && Image.prototype.decode;
/**
 * @type {boolean}
 */

exports.IMAGE_DECODE = IMAGE_DECODE;

var PASSIVE_EVENT_LISTENERS = function () {
  var passive = false;

  try {
    var options = Object.defineProperty({}, 'passive', {
      get: function () {
        passive = true;
      }
    });
    window.addEventListener('_', null, options);
    window.removeEventListener('_', null, options);
  } catch (error) {// passive not supported
  }

  return passive;
}();

exports.PASSIVE_EVENT_LISTENERS = PASSIVE_EVENT_LISTENERS;
},{}],"node_modules/ol/MapBrowserEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventType = _interopRequireDefault(require("./events/EventType.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/MapBrowserEventType
 */

/**
 * Constants for event names.
 * @enum {string}
 */
var _default = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: 'singleclick',

  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: _EventType.default.CLICK,

  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: _EventType.default.DBLCLICK,

  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: 'pointerdrag',

  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
};
exports.default = _default;
},{"./events/EventType.js":"node_modules/ol/events/EventType.js"}],"node_modules/ol/MapBrowserPointerEvent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MapBrowserEvent = _interopRequireDefault(require("./MapBrowserEvent.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/MapBrowserPointerEvent
 */


var MapBrowserPointerEvent =
/** @class */
function (_super) {
  __extends(MapBrowserPointerEvent, _super);
  /**
   * @param {string} type Event type.
   * @param {import("./PluggableMap.js").default} map Map.
   * @param {PointerEvent} pointerEvent Pointer event.
   * @param {boolean=} opt_dragging Is the map currently being dragged?
   * @param {?import("./PluggableMap.js").FrameState=} opt_frameState Frame state.
   */


  function MapBrowserPointerEvent(type, map, pointerEvent, opt_dragging, opt_frameState) {
    var _this = _super.call(this, type, map, pointerEvent, opt_dragging, opt_frameState) || this;
    /**
     * @const
     * @type {PointerEvent}
     */


    _this.pointerEvent = pointerEvent;
    return _this;
  }

  return MapBrowserPointerEvent;
}(_MapBrowserEvent.default);

var _default = MapBrowserPointerEvent;
exports.default = _default;
},{"./MapBrowserEvent.js":"node_modules/ol/MapBrowserEvent.js"}],"node_modules/ol/pointer/EventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/pointer/EventType
 */

/**
 * Constants for event names.
 * @enum {string}
 */
var _default = {
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
};
exports.default = _default;
},{}],"node_modules/ol/MapBrowserEventHandler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("elm-pep");

var _has = require("./has.js");

var _MapBrowserEventType = _interopRequireDefault(require("./MapBrowserEventType.js"));

var _MapBrowserPointerEvent = _interopRequireDefault(require("./MapBrowserPointerEvent.js"));

var _events = require("./events.js");

var _Target = _interopRequireDefault(require("./events/Target.js"));

var _EventType = _interopRequireDefault(require("./pointer/EventType.js"));

var _EventType2 = _interopRequireDefault(require("./events/EventType.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/MapBrowserEventHandler
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var MapBrowserEventHandler =
/** @class */
function (_super) {
  __extends(MapBrowserEventHandler, _super);
  /**
   * @param {import("./PluggableMap.js").default} map The map with the viewport to listen to events on.
   * @param {number=} moveTolerance The minimal distance the pointer must travel to trigger a move.
   */


  function MapBrowserEventHandler(map, moveTolerance) {
    var _this = _super.call(this, map) || this;
    /**
     * This is the element that we will listen to the real events on.
     * @type {import("./PluggableMap.js").default}
     * @private
     */


    _this.map_ = map;
    /**
     * @type {any}
     * @private
     */

    _this.clickTimeoutId_;
    /**
     * @type {boolean}
     * @private
     */

    _this.dragging_ = false;
    /**
     * @type {!Array<import("./events.js").EventsKey>}
     * @private
     */

    _this.dragListenerKeys_ = [];
    /**
     * @type {number}
     * @private
     */

    _this.moveTolerance_ = moveTolerance ? moveTolerance * _has.DEVICE_PIXEL_RATIO : _has.DEVICE_PIXEL_RATIO;
    /**
     * The most recent "down" type event (or null if none have occurred).
     * Set on pointerdown.
     * @type {PointerEvent}
     * @private
     */

    _this.down_ = null;

    var element = _this.map_.getViewport();
    /**
     * @type {number}
     * @private
     */


    _this.activePointers_ = 0;
    /**
     * @type {!Object<number, boolean>}
     * @private
     */

    _this.trackedTouches_ = {};
    _this.element_ = element;
    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */

    _this.pointerdownListenerKey_ = (0, _events.listen)(element, _EventType.default.POINTERDOWN, _this.handlePointerDown_, _this);
    /**
     * @type {PointerEvent}
     * @private
     */

    _this.originalPointerMoveEvent_;
    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */

    _this.relayedListenerKey_ = (0, _events.listen)(element, _EventType.default.POINTERMOVE, _this.relayEvent_, _this);
    /**
     * @private
     */

    _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);

    _this.element_.addEventListener(_EventType2.default.TOUCHMOVE, _this.boundHandleTouchMove_, _has.PASSIVE_EVENT_LISTENERS ? {
      passive: false
    } : false);

    return _this;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.emulateClick_ = function (pointerEvent) {
    var newEvent = new _MapBrowserPointerEvent.default(_MapBrowserEventType.default.CLICK, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);

    if (this.clickTimeoutId_ !== undefined) {
      // double-click
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = undefined;
      newEvent = new _MapBrowserPointerEvent.default(_MapBrowserEventType.default.DBLCLICK, this.map_, pointerEvent);
      this.dispatchEvent(newEvent);
    } else {
      // click
      this.clickTimeoutId_ = setTimeout(function () {
        this.clickTimeoutId_ = undefined;
        var newEvent = new _MapBrowserPointerEvent.default(_MapBrowserEventType.default.SINGLECLICK, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
      }.bind(this), 250);
    }
  };
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.updateActivePointers_ = function (pointerEvent) {
    var event = pointerEvent;

    if (event.type == _MapBrowserEventType.default.POINTERUP || event.type == _MapBrowserEventType.default.POINTERCANCEL) {
      delete this.trackedTouches_[event.pointerId];
    } else if (event.type == _MapBrowserEventType.default.POINTERDOWN) {
      this.trackedTouches_[event.pointerId] = true;
    }

    this.activePointers_ = Object.keys(this.trackedTouches_).length;
  };
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.handlePointerUp_ = function (pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    var newEvent = new _MapBrowserPointerEvent.default(_MapBrowserEventType.default.POINTERUP, this.map_, pointerEvent);
    this.dispatchEvent(newEvent); // We emulate click events on left mouse button click, touch contact, and pen
    // contact. isMouseActionButton returns true in these cases (evt.button is set
    // to 0).
    // See http://www.w3.org/TR/pointerevents/#button-states
    // We only fire click, singleclick, and doubleclick if nobody has called
    // event.stopPropagation() or event.preventDefault().

    if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
      this.emulateClick_(this.down_);
    }

    if (this.activePointers_ === 0) {
      this.dragListenerKeys_.forEach(_events.unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
    }
  };
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */


  MapBrowserEventHandler.prototype.isMouseActionButton_ = function (pointerEvent) {
    return pointerEvent.button === 0;
  };
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.handlePointerDown_ = function (pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    var newEvent = new _MapBrowserPointerEvent.default(_MapBrowserEventType.default.POINTERDOWN, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);
    this.down_ = pointerEvent;

    if (this.dragListenerKeys_.length === 0) {
      this.dragListenerKeys_.push((0, _events.listen)(document, _MapBrowserEventType.default.POINTERMOVE, this.handlePointerMove_, this), (0, _events.listen)(document, _MapBrowserEventType.default.POINTERUP, this.handlePointerUp_, this),
      /* Note that the listener for `pointercancel is set up on
       * `pointerEventHandler_` and not `documentPointerEventHandler_` like
       * the `pointerup` and `pointermove` listeners.
       *
       * The reason for this is the following: `TouchSource.vacuumTouches_()`
       * issues `pointercancel` events, when there was no `touchend` for a
       * `touchstart`. Now, let's say a first `touchstart` is registered on
       * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
       * But `documentPointerEventHandler_` doesn't know about the first
       * `touchstart`. If there is no `touchend` for the `touchstart`, we can
       * only receive a `touchcancel` from `pointerEventHandler_`, because it is
       * only registered there.
       */
      (0, _events.listen)(this.element_, _MapBrowserEventType.default.POINTERCANCEL, this.handlePointerUp_, this));
    }
  };
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.handlePointerMove_ = function (pointerEvent) {
    // Between pointerdown and pointerup, pointermove events are triggered.
    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
    // moved a significant distance.
    if (this.isMoving_(pointerEvent)) {
      this.dragging_ = true;
      var newEvent = new _MapBrowserPointerEvent.default(_MapBrowserEventType.default.POINTERDRAG, this.map_, pointerEvent, this.dragging_);
      this.dispatchEvent(newEvent);
    }
  };
  /**
   * Wrap and relay a pointer event.  Note that this requires that the type
   * string for the MapBrowserPointerEvent matches the PointerEvent type.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.relayEvent_ = function (pointerEvent) {
    this.originalPointerMoveEvent_ = pointerEvent;
    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(new _MapBrowserPointerEvent.default(pointerEvent.type, this.map_, pointerEvent, dragging));
  };
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */


  MapBrowserEventHandler.prototype.handleTouchMove_ = function (event) {
    // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`
    // may not be initialized yet when we get here on a platform without native pointer events.
    if (!this.originalPointerMoveEvent_ || this.originalPointerMoveEvent_.defaultPrevented) {
      event.preventDefault();
    }
  };
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */


  MapBrowserEventHandler.prototype.isMoving_ = function (pointerEvent) {
    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
  };
  /**
   * @inheritDoc
   */


  MapBrowserEventHandler.prototype.disposeInternal = function () {
    if (this.relayedListenerKey_) {
      (0, _events.unlistenByKey)(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }

    this.element_.removeEventListener(_EventType2.default.TOUCHMOVE, this.boundHandleTouchMove_);

    if (this.pointerdownListenerKey_) {
      (0, _events.unlistenByKey)(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }

    this.dragListenerKeys_.forEach(_events.unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.element_ = null;

    _super.prototype.disposeInternal.call(this);
  };

  return MapBrowserEventHandler;
}(_Target.default);

var _default = MapBrowserEventHandler;
exports.default = _default;
},{"elm-pep":"node_modules/elm-pep/dist/elm-pep.js","./has.js":"node_modules/ol/has.js","./MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","./MapBrowserPointerEvent.js":"node_modules/ol/MapBrowserPointerEvent.js","./events.js":"node_modules/ol/events.js","./events/Target.js":"node_modules/ol/events/Target.js","./pointer/EventType.js":"node_modules/ol/pointer/EventType.js","./events/EventType.js":"node_modules/ol/events/EventType.js"}],"node_modules/ol/MapEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/MapEventType
 */

/**
 * @enum {string}
 */
var _default = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: 'movestart',

  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: 'moveend'
};
exports.default = _default;
},{}],"node_modules/ol/MapProperty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/MapProperty
 */

/**
 * @enum {string}
 */
var _default = {
  LAYERGROUP: 'layergroup',
  SIZE: 'size',
  TARGET: 'target',
  VIEW: 'view'
};
exports.default = _default;
},{}],"node_modules/ol/render/EventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/render/EventType
 */

/**
 * @enum {string}
 */
var _default = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: 'prerender',

  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered before layers are rendered.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: 'precompose',

  /**
   * Triggered after all layers are rendered.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: 'postcompose',

  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: 'rendercomplete'
};
exports.default = _default;
},{}],"node_modules/ol/TileState.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/TileState
 */

/**
 * @enum {number}
 */
var _default = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,

  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};
exports.default = _default;
},{}],"node_modules/ol/structs/PriorityQueue.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DROP = void 0;

var _asserts = require("../asserts.js");

var _obj = require("../obj.js");

/**
 * @module ol/structs/PriorityQueue
 */

/**
 * @type {number}
 */
var DROP = Infinity;
/**
 * @classdesc
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * See http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html
 * and http://hg.python.org/cpython/file/2.7/Lib/heapq.py.
 *
 * @template T
 */

exports.DROP = DROP;

var PriorityQueue =
/** @class */
function () {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  function PriorityQueue(priorityFunction, keyFunction) {
    /**
     * @type {function(T): number}
     * @private
     */
    this.priorityFunction_ = priorityFunction;
    /**
     * @type {function(T): string}
     * @private
     */

    this.keyFunction_ = keyFunction;
    /**
     * @type {Array<T>}
     * @private
     */

    this.elements_ = [];
    /**
     * @type {Array<number>}
     * @private
     */

    this.priorities_ = [];
    /**
     * @type {!Object<string, boolean>}
     * @private
     */

    this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */


  PriorityQueue.prototype.clear = function () {
    this.elements_.length = 0;
    this.priorities_.length = 0;
    (0, _obj.clear)(this.queuedElements_);
  };
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */


  PriorityQueue.prototype.dequeue = function () {
    var elements = this.elements_;
    var priorities = this.priorities_;
    var element = elements[0];

    if (elements.length == 1) {
      elements.length = 0;
      priorities.length = 0;
    } else {
      elements[0] = elements.pop();
      priorities[0] = priorities.pop();
      this.siftUp_(0);
    }

    var elementKey = this.keyFunction_(element);
    delete this.queuedElements_[elementKey];
    return element;
  };
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */


  PriorityQueue.prototype.enqueue = function (element) {
    (0, _asserts.assert)(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue

    var priority = this.priorityFunction_(element);

    if (priority != DROP) {
      this.elements_.push(element);
      this.priorities_.push(priority);
      this.queuedElements_[this.keyFunction_(element)] = true;
      this.siftDown_(0, this.elements_.length - 1);
      return true;
    }

    return false;
  };
  /**
   * @return {number} Count.
   */


  PriorityQueue.prototype.getCount = function () {
    return this.elements_.length;
  };
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */


  PriorityQueue.prototype.getLeftChildIndex_ = function (index) {
    return index * 2 + 1;
  };
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */


  PriorityQueue.prototype.getRightChildIndex_ = function (index) {
    return index * 2 + 2;
  };
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */


  PriorityQueue.prototype.getParentIndex_ = function (index) {
    return index - 1 >> 1;
  };
  /**
   * Make this a heap. O(N).
   * @private
   */


  PriorityQueue.prototype.heapify_ = function () {
    var i;

    for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
      this.siftUp_(i);
    }
  };
  /**
   * @return {boolean} Is empty.
   */


  PriorityQueue.prototype.isEmpty = function () {
    return this.elements_.length === 0;
  };
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */


  PriorityQueue.prototype.isKeyQueued = function (key) {
    return key in this.queuedElements_;
  };
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */


  PriorityQueue.prototype.isQueued = function (element) {
    return this.isKeyQueued(this.keyFunction_(element));
  };
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */


  PriorityQueue.prototype.siftUp_ = function (index) {
    var elements = this.elements_;
    var priorities = this.priorities_;
    var count = elements.length;
    var element = elements[index];
    var priority = priorities[index];
    var startIndex = index;

    while (index < count >> 1) {
      var lIndex = this.getLeftChildIndex_(index);
      var rIndex = this.getRightChildIndex_(index);
      var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
      elements[index] = elements[smallerChildIndex];
      priorities[index] = priorities[smallerChildIndex];
      index = smallerChildIndex;
    }

    elements[index] = element;
    priorities[index] = priority;
    this.siftDown_(startIndex, index);
  };
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */


  PriorityQueue.prototype.siftDown_ = function (startIndex, index) {
    var elements = this.elements_;
    var priorities = this.priorities_;
    var element = elements[index];
    var priority = priorities[index];

    while (index > startIndex) {
      var parentIndex = this.getParentIndex_(index);

      if (priorities[parentIndex] > priority) {
        elements[index] = elements[parentIndex];
        priorities[index] = priorities[parentIndex];
        index = parentIndex;
      } else {
        break;
      }
    }

    elements[index] = element;
    priorities[index] = priority;
  };
  /**
   * FIXME empty description for jsdoc
   */


  PriorityQueue.prototype.reprioritize = function () {
    var priorityFunction = this.priorityFunction_;
    var elements = this.elements_;
    var priorities = this.priorities_;
    var index = 0;
    var n = elements.length;
    var element, i, priority;

    for (i = 0; i < n; ++i) {
      element = elements[i];
      priority = priorityFunction(element);

      if (priority == DROP) {
        delete this.queuedElements_[this.keyFunction_(element)];
      } else {
        priorities[index] = priority;
        elements[index++] = element;
      }
    }

    elements.length = index;
    priorities.length = index;
    this.heapify_();
  };

  return PriorityQueue;
}();

var _default = PriorityQueue;
exports.default = _default;
},{"../asserts.js":"node_modules/ol/asserts.js","../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/TileQueue.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTilePriority = getTilePriority;
exports.default = void 0;

var _TileState = _interopRequireDefault(require("./TileState.js"));

var _EventType = _interopRequireDefault(require("./events/EventType.js"));

var _PriorityQueue = _interopRequireWildcard(require("./structs/PriorityQueue.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/TileQueue
 */


/**
 * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
 */
var TileQueue =
/** @class */
function (_super) {
  __extends(TileQueue, _super);
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */


  function TileQueue(tilePriorityFunction, tileChangeCallback) {
    var _this = _super.call(this,
    /**
     * @param {Array} element Element.
     * @return {number} Priority.
     */
    function (element) {
      return tilePriorityFunction.apply(null, element);
    },
    /**
     * @param {Array} element Element.
     * @return {string} Key.
     */
    function (element) {
      return (
        /** @type {import("./Tile.js").default} */
        element[0].getKey()
      );
    }) || this;
    /** @private */


    _this.boundHandleTileChange_ = _this.handleTileChange.bind(_this);
    /**
     * @private
     * @type {function(): ?}
     */

    _this.tileChangeCallback_ = tileChangeCallback;
    /**
     * @private
     * @type {number}
     */

    _this.tilesLoading_ = 0;
    /**
     * @private
     * @type {!Object<string,boolean>}
     */

    _this.tilesLoadingKeys_ = {};
    return _this;
  }
  /**
   * @inheritDoc
   */


  TileQueue.prototype.enqueue = function (element) {
    var added = _super.prototype.enqueue.call(this, element);

    if (added) {
      var tile = element[0];
      tile.addEventListener(_EventType.default.CHANGE, this.boundHandleTileChange_);
    }

    return added;
  };
  /**
   * @return {number} Number of tiles loading.
   */


  TileQueue.prototype.getTilesLoading = function () {
    return this.tilesLoading_;
  };
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */


  TileQueue.prototype.handleTileChange = function (event) {
    var tile =
    /** @type {import("./Tile.js").default} */
    event.target;
    var state = tile.getState();

    if (tile.hifi && state === _TileState.default.LOADED || state === _TileState.default.ERROR || state === _TileState.default.EMPTY) {
      tile.removeEventListener(_EventType.default.CHANGE, this.boundHandleTileChange_);
      var tileKey = tile.getKey();

      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }

      this.tileChangeCallback_();
    }
  };
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */


  TileQueue.prototype.loadMoreTiles = function (maxTotalLoading, maxNewLoads) {
    var newLoads = 0;
    var state, tile, tileKey;

    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
      tile =
      /** @type {import("./Tile.js").default} */
      this.dequeue()[0];
      tileKey = tile.getKey();
      state = tile.getState();

      if (state === _TileState.default.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile.load();
      }
    }
  };

  return TileQueue;
}(_PriorityQueue.default);

var _default = TileQueue;
/**
 * @param {import('./PluggableMap.js').FrameState} frameState Frame state.
 * @param {import("./Tile.js").default} tile Tile.
 * @param {string} tileSourceKey Tile source key.
 * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
 * @param {number} tileResolution Tile resolution.
 * @return {number} Tile priority.
 */

exports.default = _default;

function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
  // Filter out tiles at higher zoom levels than the current zoom level, or that
  // are outside the visible extent.
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return _PriorityQueue.DROP;
  }

  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return _PriorityQueue.DROP;
  } // Prioritize the highest zoom level tiles closest to the focus.
  // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
  // Within a zoom level, tiles are prioritized by the distance in pixels between
  // the center of the tile and the center of the viewport.  The factor of 65536
  // means that the prioritization should behave as desired for tiles up to
  // 65536 * Math.log(2) = 45426 pixels from the focus.


  var center = frameState.viewState.center;
  var deltaX = tileCenter[0] - center[0];
  var deltaY = tileCenter[1] - center[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}
},{"./TileState.js":"node_modules/ol/TileState.js","./events/EventType.js":"node_modules/ol/events/EventType.js","./structs/PriorityQueue.js":"node_modules/ol/structs/PriorityQueue.js"}],"node_modules/ol/tilegrid/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_TILE_SIZE = exports.DEFAULT_MAX_ZOOM = void 0;

/**
 * @module ol/tilegrid/common
 */

/**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */
var DEFAULT_MAX_ZOOM = 42;
/**
 * Default tile size.
 * @type {number}
 */

exports.DEFAULT_MAX_ZOOM = DEFAULT_MAX_ZOOM;
var DEFAULT_TILE_SIZE = 256;
exports.DEFAULT_TILE_SIZE = DEFAULT_TILE_SIZE;
},{}],"node_modules/ol/centerconstraint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createExtent = createExtent;
exports.none = none;

var _math = require("./math.js");

/**
 * @module ol/centerconstraint
 */

/**
 * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=): (import("./coordinate.js").Coordinate|undefined)} Type
 */

/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
 * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
 * (only during interaction and animation).
 * @return {Type} The constraint.
 */
function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function (center, resolution, size, opt_isMoving) {
      if (center) {
        var viewWidth = onlyCenter ? 0 : size[0] * resolution;
        var viewHeight = onlyCenter ? 0 : size[1] * resolution;
        var minX = extent[0] + viewWidth / 2;
        var maxX = extent[2] - viewWidth / 2;
        var minY = extent[1] + viewHeight / 2;
        var maxY = extent[3] - viewHeight / 2; // note: when zooming out of bounds, min and max values for x and y may
        // end up inverted (min > max); this has to be accounted for

        if (minX > maxX) {
          minX = (maxX + minX) / 2;
          maxX = minX;
        }

        if (minY > maxY) {
          minY = (maxY + minY) / 2;
          maxY = minY;
        }

        var x = (0, _math.clamp)(center[0], minX, maxX);
        var y = (0, _math.clamp)(center[1], minY, maxY);
        var ratio = 30 * resolution; // during an interaction, allow some overscroll

        if (opt_isMoving && smooth) {
          x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
          y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
        }

        return [x, y];
      } else {
        return undefined;
      }
    }
  );
}
/**
 * @param {import("./coordinate.js").Coordinate=} center Center.
 * @return {import("./coordinate.js").Coordinate|undefined} Center.
 */


function none(center) {
  return center;
}
},{"./math.js":"node_modules/ol/math.js"}],"node_modules/ol/resolutionconstraint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSnapToResolutions = createSnapToResolutions;
exports.createSnapToPower = createSnapToPower;
exports.createMinMaxResolution = createMinMaxResolution;

var _array = require("./array.js");

var _extent = require("./extent.js");

var _math = require("./math.js");

/**
 * @module ol/resolutionconstraint
 */

/**
 * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
 */

/**
 * Returns a modified resolution taking into account the viewport size and maximum
 * allowed extent.
 * @param {number} resolution Resolution
 * @param {import("./extent.js").Extent=} maxExtent Maximum allowed extent.
 * @param {import("./size.js").Size} viewportSize Viewport size.
 * @param {boolean} showFullExtent Whether to show the full extent.
 * @return {number} Capped resolution.
 */
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  var xResolution = (0, _extent.getWidth)(maxExtent) / viewportSize[0];
  var yResolution = (0, _extent.getHeight)(maxExtent) / viewportSize[1];

  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }

  return Math.min(resolution, Math.min(xResolution, yResolution));
}
/**
 * Returns a modified resolution to be between maxResolution and minResolution while
 * still allowing the value to be slightly out of bounds.
 * Note: the computation is based on the logarithm function (ln):
 *  - at 1, ln(x) is 0
 *  - above 1, ln(x) keeps increasing but at a much slower pace than x
 * The final result is clamped to prevent getting too far away from bounds.
 * @param {number} resolution Resolution.
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @return {number} Smoothed resolution.
 */


function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  var result = Math.min(resolution, maxResolution);
  var ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;

  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }

  return (0, _math.clamp)(result, minResolution / 2, maxResolution * 2);
}
/**
 * @param {Array<number>} resolutions Resolutions.
 * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
 * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */


function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, opt_isMoving) {
      if (resolution !== undefined) {
        var maxResolution = resolutions[0];
        var minResolution = resolutions[resolutions.length - 1];
        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution; // during interacting or animating, allow intermediary values

        if (opt_isMoving) {
          var smooth = opt_smooth !== undefined ? opt_smooth : true;

          if (!smooth) {
            return (0, _math.clamp)(resolution, minResolution, cappedMaxRes);
          }

          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        }

        var capped = Math.min(cappedMaxRes, resolution);
        var z = Math.floor((0, _array.linearFindNearest)(resolutions, capped, direction));

        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
          return resolutions[z + 1];
        }

        return resolutions[z];
      } else {
        return undefined;
      }
    }
  );
}
/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number=} opt_minResolution Minimum resolution.
 * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
 * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */


function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, opt_isMoving) {
      if (resolution !== undefined) {
        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
        var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0; // during interacting or animating, allow intermediary values

        if (opt_isMoving) {
          var smooth = opt_smooth !== undefined ? opt_smooth : true;

          if (!smooth) {
            return (0, _math.clamp)(resolution, minResolution, cappedMaxRes);
          }

          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        }

        var tolerance = 1e-9;
        var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
        var offset = -direction * (0.5 - tolerance) + 0.5;
        var capped = Math.min(cappedMaxRes, resolution);
        var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
        var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        var newResolution = maxResolution / Math.pow(power, zoomLevel);
        return (0, _math.clamp)(newResolution, minResolution, cappedMaxRes);
      } else {
        return undefined;
      }
    }
  );
}
/**
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
 * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */


function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, opt_isMoving) {
      if (resolution !== undefined) {
        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
        var smooth = opt_smooth !== undefined ? opt_smooth : true;

        if (!smooth || !opt_isMoving) {
          return (0, _math.clamp)(resolution, minResolution, cappedMaxRes);
        }

        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
      } else {
        return undefined;
      }
    }
  );
}
},{"./array.js":"node_modules/ol/array.js","./extent.js":"node_modules/ol/extent.js","./math.js":"node_modules/ol/math.js"}],"node_modules/ol/rotationconstraint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.disable = disable;
exports.none = none;
exports.createSnapToN = createSnapToN;
exports.createSnapToZero = createSnapToZero;

var _math = require("./math.js");

/**
 * @module ol/rotationconstraint
 */

/**
 * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
 */

/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */
function disable(rotation) {
  if (rotation !== undefined) {
    return 0;
  } else {
    return undefined;
  }
}
/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */


function none(rotation) {
  if (rotation !== undefined) {
    return rotation;
  } else {
    return undefined;
  }
}
/**
 * @param {number} n N.
 * @return {Type} Rotation constraint.
 */


function createSnapToN(n) {
  var theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function (rotation, opt_isMoving) {
      if (opt_isMoving) {
        return rotation;
      }

      if (rotation !== undefined) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      } else {
        return undefined;
      }
    }
  );
}
/**
 * @param {number=} opt_tolerance Tolerance.
 * @return {Type} Rotation constraint.
 */


function createSnapToZero(opt_tolerance) {
  var tolerance = opt_tolerance || (0, _math.toRadians)(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function (rotation, opt_isMoving) {
      if (opt_isMoving) {
        return rotation;
      }

      if (rotation !== undefined) {
        if (Math.abs(rotation) <= tolerance) {
          return 0;
        } else {
          return rotation;
        }
      } else {
        return undefined;
      }
    }
  );
}
},{"./math.js":"node_modules/ol/math.js"}],"node_modules/ol/ViewHint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/ViewHint
 */

/**
 * @enum {number}
 */
var _default = {
  ANIMATING: 0,
  INTERACTING: 1
};
exports.default = _default;
},{}],"node_modules/ol/ViewProperty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/ViewProperty
 */

/**
 * @enum {string}
 */
var _default = {
  CENTER: 'center',
  RESOLUTION: 'resolution',
  ROTATION: 'rotation'
};
exports.default = _default;
},{}],"node_modules/ol/string.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.padNumber = padNumber;
exports.compareVersions = compareVersions;

/**
 * @module ol/string
 */

/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number=} opt_precision Precision of the output string (i.e. number of decimal places)
 * @returns {string} Formatted string
 */
function padNumber(number, width, opt_precision) {
  var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;
  var decimal = numberString.indexOf('.');
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;
}
/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @returns {number} Value
 */


function compareVersions(v1, v2) {
  var s1 = ('' + v1).split('.');
  var s2 = ('' + v2).split('.');

  for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
    var n1 = parseInt(s1[i] || '0', 10);
    var n2 = parseInt(s2[i] || '0', 10);

    if (n1 > n2) {
      return 1;
    }

    if (n2 > n1) {
      return -1;
    }
  }

  return 0;
}
},{}],"node_modules/ol/coordinate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.closestOnCircle = closestOnCircle;
exports.closestOnSegment = closestOnSegment;
exports.createStringXY = createStringXY;
exports.degreesToStringHDMS = degreesToStringHDMS;
exports.format = format;
exports.equals = equals;
exports.rotate = rotate;
exports.scale = scale;
exports.squaredDistance = squaredDistance;
exports.distance = distance;
exports.squaredDistanceToSegment = squaredDistanceToSegment;
exports.toStringHDMS = toStringHDMS;
exports.toStringXY = toStringXY;
exports.wrapX = wrapX;

var _math = require("./math.js");

var _string = require("./string.js");

var _extent = require("./extent.js");

/**
 * @module ol/coordinate
 */

/**
 * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */

/**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */

/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */
function add(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}
/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */


function closestOnCircle(coordinate, circle) {
  var r = circle.getRadius();
  var center = circle.getCenter();
  var x0 = center[0];
  var y0 = center[1];
  var x1 = coordinate[0];
  var y1 = coordinate[1];
  var dx = x1 - x0;
  var dy = y1 - y0;

  if (dx === 0 && dy === 0) {
    dx = 1;
  }

  var d = Math.sqrt(dx * dx + dy * dy);
  var x = x0 + r * dx / d;
  var y = y0 + r * dy / d;
  return [x, y];
}
/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */


function closestOnSegment(coordinate, segment) {
  var x0 = coordinate[0];
  var y0 = coordinate[1];
  var start = segment[0];
  var end = segment[1];
  var x1 = start[0];
  var y1 = start[1];
  var x2 = end[0];
  var y2 = end[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
  var x, y;

  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }

  return [x, y];
}
/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY();
 *     var out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY(2);
 *     var out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */


function createStringXY(opt_fractionDigits) {
  return (
    /**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */
    function (coordinate) {
      return toStringXY(coordinate, opt_fractionDigits);
    }
  );
}
/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */


function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {
  var normalizedDegrees = (0, _math.modulo)(degrees + 180, 360) - 180;
  var x = Math.abs(3600 * normalizedDegrees);
  var dflPrecision = opt_fractionDigits || 0;
  var precision = Math.pow(10, dflPrecision);
  var deg = Math.floor(x / 3600);
  var min = Math.floor((x - deg * 3600) / 60);
  var sec = x - deg * 3600 - min * 60;
  sec = Math.ceil(sec * precision) / precision;

  if (sec >= 60) {
    sec = 0;
    min += 1;
  }

  if (min >= 60) {
    min = 0;
    deg += 1;
  }

  return deg + '\u00b0 ' + (0, _string.padNumber)(min, 2) + '\u2032 ' + (0, _string.padNumber)(sec, 2, dflPrecision) + '\u2033' + (normalizedDegrees == 0 ? '' : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));
}
/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */


function format(coordinate, template, opt_fractionDigits) {
  if (coordinate) {
    return template.replace('{x}', coordinate[0].toFixed(opt_fractionDigits)).replace('{y}', coordinate[1].toFixed(opt_fractionDigits));
  } else {
    return '';
  }
}
/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */


function equals(coordinate1, coordinate2) {
  var equals = true;

  for (var i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals = false;
      break;
    }
  }

  return equals;
}
/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */


function rotate(coordinate, angle) {
  var cosAngle = Math.cos(angle);
  var sinAngle = Math.sin(angle);
  var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}
/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */


function scale(coordinate, scale) {
  coordinate[0] *= scale;
  coordinate[1] *= scale;
  return coordinate;
}
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */


function squaredDistance(coord1, coord2) {
  var dx = coord1[0] - coord2[0];
  var dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
}
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */


function distance(coord1, coord2) {
  return Math.sqrt(squaredDistance(coord1, coord2));
}
/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */


function squaredDistanceToSegment(coordinate, segment) {
  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));
}
/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */


function toStringHDMS(coordinate, opt_fractionDigits) {
  if (coordinate) {
    return degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) + ' ' + degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits);
  } else {
    return '';
  }
}
/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */


function toStringXY(coordinate, opt_fractionDigits) {
  return format(coordinate, '{x}, {y}', opt_fractionDigits);
}
/**
 * Modifies the provided coordinate in-place to be within the real world
 * extent. The lower projection extent boundary is inclusive, the upper one
 * exclusive.
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Coordinate} The coordinate within the real world extent.
 */


function wrapX(coordinate, projection) {
  var projectionExtent = projection.getExtent();

  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] >= projectionExtent[2])) {
    var worldWidth = (0, _extent.getWidth)(projectionExtent);
    var worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / worldWidth);
    coordinate[0] -= worldsAway * worldWidth;
  }

  return coordinate;
}
},{"./math.js":"node_modules/ol/math.js","./string.js":"node_modules/ol/string.js","./extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/easing.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.easeIn = easeIn;
exports.easeOut = easeOut;
exports.inAndOut = inAndOut;
exports.linear = linear;
exports.upAndDown = upAndDown;

/**
 * @module ol/easing
 */

/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeIn(t) {
  return Math.pow(t, 3);
}
/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */


function easeOut(t) {
  return 1 - easeIn(1 - t);
}
/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */


function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}
/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */


function linear(t) {
  return t;
}
/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing~inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */


function upAndDown(t) {
  if (t < 0.5) {
    return inAndOut(2 * t);
  } else {
    return 1 - inAndOut(2 * (t - 0.5));
  }
}
},{}],"node_modules/ol/View.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCenterConstraint = createCenterConstraint;
exports.createResolutionConstraint = createResolutionConstraint;
exports.createRotationConstraint = createRotationConstraint;
exports.isNoopAnimation = isNoopAnimation;
exports.default = void 0;

var _common = require("./tilegrid/common.js");

var _functions = require("./functions.js");

var _centerconstraint = require("./centerconstraint.js");

var _Object = _interopRequireDefault(require("./Object.js"));

var _resolutionconstraint = require("./resolutionconstraint.js");

var _rotationconstraint = require("./rotationconstraint.js");

var _ViewHint = _interopRequireDefault(require("./ViewHint.js"));

var _ViewProperty = _interopRequireDefault(require("./ViewProperty.js"));

var _array = require("./array.js");

var _asserts = require("./asserts.js");

var _coordinate = require("./coordinate.js");

var _easing = require("./easing.js");

var _extent = require("./extent.js");

var _GeometryType = _interopRequireDefault(require("./geom/GeometryType.js"));

var _Polygon = require("./geom/Polygon.js");

var _math = require("./math.js");

var _obj = require("./obj.js");

var _proj = require("./proj.js");

var _Units = _interopRequireDefault(require("./proj/Units.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/View
 */


/**
 * An animation configuration
 *
 * @typedef {Object} Animation
 * @property {import("./coordinate.js").Coordinate} [sourceCenter]
 * @property {import("./coordinate.js").Coordinate} [targetCenter]
 * @property {number} [sourceResolution]
 * @property {number} [targetResolution]
 * @property {number} [sourceRotation]
 * @property {number} [targetRotation]
 * @property {import("./coordinate.js").Coordinate} [anchor]
 * @property {number} start
 * @property {number} duration
 * @property {boolean} complete
 * @property {function(number):number} easing
 * @property {function(boolean)} callback
 */

/**
 * @typedef {Object} Constraints
 * @property {import("./centerconstraint.js").Type} center
 * @property {import("./resolutionconstraint.js").Type} resolution
 * @property {import("./rotationconstraint.js").Type} rotation
 */

/**
 * @typedef {Object} FitOptions
 * @property {import("./size.js").Size} [size] The size in pixels of the box to fit
 * the extent into. Default is the current size of the first map in the DOM that
 * uses this view, or `[100, 100]` if no such map is found.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
 * cleared inside the view. Values in the array are top, right, bottom and left
 * padding.
 * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
 * get the nearest extent instead of the closest that actually fits the view.
 * @property {number} [minResolution=0] Minimum resolution that we zoom to.
 * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
 * `minResolution` is given, this property is ignored.
 * @property {number} [duration] The duration of the animation in milliseconds.
 * By default, there is no animation to the target extent.
 * @property {function(number):number} [easing] The easing function used during
 * the animation (defaults to {@link module:ol/easing~inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 * @property {function(boolean)} [callback] Function called when the view is in
 * its final position. The callback will be called with `true` if the animation
 * series completed on its own or `false` if it was cancelled.
 */

/**
 * @typedef {Object} ViewOptions
 * @property {import("./coordinate.js").Coordinate} [center] The initial center for
 * the view. If a user projection is not set, the coordinate system for the center is
 * specified with the `projection` option. Layer sources will not be fetched if this
 * is not set, but the center can be set later with {@link #setCenter}.
 * @property {boolean|number} [constrainRotation=true] Rotation constraint.
 * `false` means no constraint. `true` means no constraint, but snap to zero
 * near zero. A number constrains the rotation to that number of values. For
 * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
 * @property {boolean} [enableRotation=true] Enable rotation.
 * If `false`, a rotation constraint that always sets the rotation to zero is
 * used. The `constrainRotation` option has no effect if `enableRotation` is
 * `false`.
 * @property {import("./extent.js").Extent} [extent] The extent that constrains the
 * view, in other words, nothing outside of this extent can be visible on the map.
 * @property {boolean} [constrainOnlyCenter=false] If true, the extent
 * constraint will only apply to the view center and not the whole extent.
 * @property {boolean} [smoothExtentConstraint=true] If true, the extent
 * constraint will be applied smoothly, i.e. allow the view to go slightly outside
 * of the given `extent`.
 * @property {number} [maxResolution] The maximum resolution used to determine
 * the resolution constraint. It is used together with `minResolution` (or
 * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
 * that the projection's validity extent fits in a 256x256 px tile. If the
 * projection is Spherical Mercator (the default) then `maxResolution` defaults
 * to `40075016.68557849 / 256 = 156543.03392804097`.
 * @property {number} [minResolution] The minimum resolution used to determine
 * the resolution constraint.  It is used together with `maxResolution` (or
 * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
 * zoom levels (with a factor of 2). If the projection is Spherical Mercator
 * (the default) then `minResolution` defaults to
 * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
 * @property {number} [maxZoom=28] The maximum zoom level used to determine the
 * resolution constraint. It is used together with `minZoom` (or
 * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
 * provided, it is given precedence over `maxZoom`.
 * @property {number} [minZoom=0] The minimum zoom level used to determine the
 * resolution constraint. It is used together with `maxZoom` (or
 * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
 * provided, it is given precedence over `minZoom`.
 * @property {boolean} [multiWorld=false] If `false` the view is constrained so
 * only one world is visible, and you cannot pan off the edge.  If `true` the map
 * may show multiple worlds at low zoom levels.  Only used if the `projection` is
 * global.  Note that if `extent` is also provided it is given precedence.
 * @property {boolean} [constrainResolution=false] If true, the view will always
 * animate to the closest zoom level after an interaction; false means
 * intermediary zoom levels are allowed.
 * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
 * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
 * the given resolution or zoom bounds.
 * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
 * show the full configured extent. By default, when a view is configured with an
 * extent, users will not be able to zoom out so the viewport exceeds the extent in
 * either dimension. This means the full extent may not be visible if the viewport
 * is taller or wider than the aspect ratio of the configured extent. If
 * showFullExtent is true, the user will be able to zoom out so that the viewport
 * exceeds the height or width of the configured extent, but not both, allowing the
 * full extent to be shown.
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
 * projection. The default is Spherical Mercator.
 * @property {number} [resolution] The initial resolution for the view. The
 * units are `projection` units per pixel (e.g. meters per pixel). An
 * alternative to setting this is to set `zoom`. Layer sources will not be
 * fetched if neither this nor `zoom` are defined, but they can be set later
 * with {@link #setZoom} or {@link #setResolution}.
 * @property {Array<number>} [resolutions] Resolutions to determine the
 * resolution constraint. If set the `maxResolution`, `minResolution`,
 * `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
 * @property {number} [rotation=0] The initial rotation for the view in radians
 * (positive rotation clockwise, 0 means North).
 * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
 * level used to calculate the initial resolution for the view.
 * @property {number} [zoomFactor=2] The zoom factor used to compute the
 * corresponding resolution.
 */

/**
 * @typedef {Object} AnimationOptions
 * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
 * the animation.
 * @property {number} [zoom] The zoom level of the view at the end of the
 * animation. This takes precedence over `resolution`.
 * @property {number} [resolution] The resolution of the view at the end
 * of the animation.  If `zoom` is also provided, this option will be ignored.
 * @property {number} [rotation] The rotation of the view at the end of
 * the animation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
 * during a rotation or resolution animation.
 * @property {number} [duration=1000] The duration of the animation in milliseconds.
 * @property {function(number):number} [easing] The easing function used
 * during the animation (defaults to {@link module:ol/easing~inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 */

/**
 * @typedef {Object} State
 * @property {import("./coordinate.js").Coordinate} center
 * @property {import("./proj/Projection.js").default} projection
 * @property {number} resolution
 * @property {number} rotation
 * @property {number} zoom
 */

/**
 * Default min zoom level for the map view.
 * @type {number}
 */
var DEFAULT_MIN_ZOOM = 0;
/**
 * @classdesc
 * A View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * A View has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Spherical Mercator (EPSG:3857).
 *
 * ### The view states
 *
 * A View is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * The `zoom` state is actually not saved on the view: all computations
 * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
 * methods are available, as well as `getResolutionForZoom` and
 * `getZoomForResolution` to switch from one system to the other.
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view, but any constraint defined in the constructor will
 * be applied along the way.
 *
 * A View object can have a *resolution constraint*, a *rotation constraint*
 * and a *center constraint*.
 *
 * The *resolution constraint* typically restricts min/max values and
 * snaps to specific resolutions. It is determined by the following
 * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
 * If `resolutions` is set, the other three options are ignored. See
 * documentation for each option for more information. By default, the view
 * only has a min/max restriction and allow intermediary zoom levels when
 * pinch-zooming for example.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default rotation is allowed and its value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the view center is not constrained at all.
 *
 * ### Changing the view state
 *
 * It is important to note that `setZoom`, `setResolution`, `setCenter` and
 * `setRotation` are subject to the above mentioned constraints. As such, it
 * may sometimes not be possible to know in advance the resulting state of the
 * View. For example, calling `setResolution(10)` does not guarantee that
 * `getResolution()` will return `10`.
 *
 * A consequence of this is that, when applying a delta on the view state, one
 * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
 * rather than the corresponding setters. This will let view do its internal
 * computations. Besides, the `adjust*` methods also take an `opt_anchor`
 * argument which allows specifying an origin for the transformation.
 *
 * ### Interacting with the view
 *
 * View constraints are usually only applied when the view is *at rest*, meaning that
 * no interaction or animation is ongoing. As such, if the user puts the view in a
 * state that is not equivalent to a constrained one (e.g. rotating the view when
 * the snap angle is 0), an animation will be triggered at the interaction end to
 * put back the view to a stable state;
 *
 * @api
 */

var View =
/** @class */
function (_super) {
  __extends(View, _super);
  /**
   * @param {ViewOptions=} opt_options View options.
   */


  function View(opt_options) {
    var _this = _super.call(this) || this;

    var options = (0, _obj.assign)({}, opt_options);
    /**
     * @private
     * @type {Array<number>}
     */

    _this.hints_ = [0, 0];
    /**
     * @private
     * @type {Array<Array<Animation>>}
     */

    _this.animations_ = [];
    /**
     * @private
     * @type {number|undefined}
     */

    _this.updateAnimationKey_;
    /**
     * @private
     * @const
     * @type {import("./proj/Projection.js").default}
     */

    _this.projection_ = (0, _proj.createProjection)(options.projection, 'EPSG:3857');
    /**
     * @private
     * @type {import("./size.js").Size}
     */

    _this.viewportSize_ = [100, 100];
    /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */

    _this.targetCenter_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.targetResolution_;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.targetRotation_;
    /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */

    _this.cancelAnchor_ = undefined;

    if (options.center) {
      options.center = (0, _proj.fromUserCoordinate)(options.center, _this.projection_);
    }

    if (options.extent) {
      options.extent = (0, _proj.fromUserExtent)(options.extent, _this.projection_);
    }

    _this.applyOptions_(options);

    return _this;
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */


  View.prototype.applyOptions_ = function (options) {
    /**
     * @type {Object<string, *>}
     */
    var properties = {};
    var resolutionConstraintInfo = createResolutionConstraint(options);
    /**
     * @private
     * @type {number}
     */

    this.maxResolution_ = resolutionConstraintInfo.maxResolution;
    /**
     * @private
     * @type {number}
     */

    this.minResolution_ = resolutionConstraintInfo.minResolution;
    /**
     * @private
     * @type {number}
     */

    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
    /**
     * @private
     * @type {Array<number>|undefined}
     */

    this.resolutions_ = options.resolutions;
    /**
     * @private
     * @type {number}
     */

    this.minZoom_ = resolutionConstraintInfo.minZoom;
    var centerConstraint = createCenterConstraint(options);
    var resolutionConstraint = resolutionConstraintInfo.constraint;
    var rotationConstraint = createRotationConstraint(options);
    /**
     * @private
     * @type {Constraints}
     */

    this.constraints_ = {
      center: centerConstraint,
      resolution: resolutionConstraint,
      rotation: rotationConstraint
    };
    this.setRotation(options.rotation !== undefined ? options.rotation : 0);
    this.setCenterInternal(options.center !== undefined ? options.center : null);

    if (options.resolution !== undefined) {
      this.setResolution(options.resolution);
    } else if (options.zoom !== undefined) {
      this.setZoom(options.zoom);
    }

    this.setProperties(properties);
    /**
     * @private
     * @type {ViewOptions}
     */

    this.options_ = options;
  };
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */


  View.prototype.getUpdatedOptions_ = function (newOptions) {
    var options = (0, _obj.assign)({}, this.options_); // preserve resolution (or zoom)

    if (options.resolution !== undefined) {
      options.resolution = this.getResolution();
    } else {
      options.zoom = this.getZoom();
    } // preserve center


    options.center = this.getCenterInternal(); // preserve rotation

    options.rotation = this.getRotation();
    return (0, _obj.assign)({}, options, newOptions);
  };
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */


  View.prototype.animate = function (var_args) {
    if (this.isDef() && !this.getAnimating()) {
      this.resolveConstraints(0);
    }

    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; ++i) {
      var options = arguments[i];

      if (options.center) {
        options = (0, _obj.assign)({}, options);
        options.center = (0, _proj.fromUserCoordinate)(options.center, this.getProjection());
      }

      if (options.anchor) {
        options = (0, _obj.assign)({}, options);
        options.anchor = (0, _proj.fromUserCoordinate)(options.anchor, this.getProjection());
      }

      args[i] = options;
    }

    this.animateInternal.apply(this, args);
  };
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */


  View.prototype.animateInternal = function (var_args) {
    var animationCount = arguments.length;
    var callback;

    if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
      callback = arguments[animationCount - 1];
      --animationCount;
    }

    if (!this.isDef()) {
      // if view properties are not yet set, shortcut to the final state
      var state = arguments[animationCount - 1];

      if (state.center) {
        this.setCenterInternal(state.center);
      }

      if (state.zoom !== undefined) {
        this.setZoom(state.zoom);
      }

      if (state.rotation !== undefined) {
        this.setRotation(state.rotation);
      }

      if (callback) {
        animationCallback(callback, true);
      }

      return;
    }

    var start = Date.now();
    var center = this.targetCenter_.slice();
    var resolution = this.targetResolution_;
    var rotation = this.targetRotation_;
    var series = [];

    for (var i = 0; i < animationCount; ++i) {
      var options =
      /** @type {AnimationOptions} */
      arguments[i];
      var animation = {
        start: start,
        complete: false,
        anchor: options.anchor,
        duration: options.duration !== undefined ? options.duration : 1000,
        easing: options.easing || _easing.inAndOut,
        callback: callback
      };

      if (options.center) {
        animation.sourceCenter = center;
        animation.targetCenter = options.center.slice();
        center = animation.targetCenter;
      }

      if (options.zoom !== undefined) {
        animation.sourceResolution = resolution;
        animation.targetResolution = this.getResolutionForZoom(options.zoom);
        resolution = animation.targetResolution;
      } else if (options.resolution) {
        animation.sourceResolution = resolution;
        animation.targetResolution = options.resolution;
        resolution = animation.targetResolution;
      }

      if (options.rotation !== undefined) {
        animation.sourceRotation = rotation;
        var delta = (0, _math.modulo)(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
        animation.targetRotation = rotation + delta;
        rotation = animation.targetRotation;
      } // check if animation is a no-op


      if (isNoopAnimation(animation)) {
        animation.complete = true; // we still push it onto the series for callback handling
      } else {
        start += animation.duration;
      }

      series.push(animation);
    }

    this.animations_.push(series);
    this.setHint(_ViewHint.default.ANIMATING, 1);
    this.updateAnimations_();
  };
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */


  View.prototype.getAnimating = function () {
    return this.hints_[_ViewHint.default.ANIMATING] > 0;
  };
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */


  View.prototype.getInteracting = function () {
    return this.hints_[_ViewHint.default.INTERACTING] > 0;
  };
  /**
   * Cancel any ongoing animations.
   * @api
   */


  View.prototype.cancelAnimations = function () {
    this.setHint(_ViewHint.default.ANIMATING, -this.hints_[_ViewHint.default.ANIMATING]);
    var anchor;

    for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
      var series = this.animations_[i];

      if (series[0].callback) {
        animationCallback(series[0].callback, false);
      }

      if (!anchor) {
        for (var j = 0, jj = series.length; j < jj; ++j) {
          var animation = series[j];

          if (!animation.complete) {
            anchor = animation.anchor;
            break;
          }
        }
      }
    }

    this.animations_.length = 0;
    this.cancelAnchor_ = anchor;
  };
  /**
   * Update all animations.
   */


  View.prototype.updateAnimations_ = function () {
    if (this.updateAnimationKey_ !== undefined) {
      cancelAnimationFrame(this.updateAnimationKey_);
      this.updateAnimationKey_ = undefined;
    }

    if (!this.getAnimating()) {
      return;
    }

    var now = Date.now();
    var more = false;

    for (var i = this.animations_.length - 1; i >= 0; --i) {
      var series = this.animations_[i];
      var seriesComplete = true;

      for (var j = 0, jj = series.length; j < jj; ++j) {
        var animation = series[j];

        if (animation.complete) {
          continue;
        }

        var elapsed = now - animation.start;
        var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;

        if (fraction >= 1) {
          animation.complete = true;
          fraction = 1;
        } else {
          seriesComplete = false;
        }

        var progress = animation.easing(fraction);

        if (animation.sourceCenter) {
          var x0 = animation.sourceCenter[0];
          var y0 = animation.sourceCenter[1];
          var x1 = animation.targetCenter[0];
          var y1 = animation.targetCenter[1];
          var x = x0 + progress * (x1 - x0);
          var y = y0 + progress * (y1 - y0);
          this.targetCenter_ = [x, y];
        }

        if (animation.sourceResolution && animation.targetResolution) {
          var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);

          if (animation.anchor) {
            var size = this.getViewportSize_(this.getRotation());
            var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
            this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
          }

          this.targetResolution_ = resolution;
          this.applyTargetState_(true);
        }

        if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
          var rotation = progress === 1 ? (0, _math.modulo)(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);

          if (animation.anchor) {
            var constrainedRotation = this.constraints_.rotation(rotation, true);
            this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
          }

          this.targetRotation_ = rotation;
        }

        this.applyTargetState_(true);
        more = true;

        if (!animation.complete) {
          break;
        }
      }

      if (seriesComplete) {
        this.animations_[i] = null;
        this.setHint(_ViewHint.default.ANIMATING, -1);
        var callback = series[0].callback;

        if (callback) {
          animationCallback(callback, true);
        }
      }
    } // prune completed series


    this.animations_ = this.animations_.filter(Boolean);

    if (more && this.updateAnimationKey_ === undefined) {
      this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
    }
  };
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */


  View.prototype.calculateCenterRotate = function (rotation, anchor) {
    var center;
    var currentCenter = this.getCenterInternal();

    if (currentCenter !== undefined) {
      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
      (0, _coordinate.rotate)(center, rotation - this.getRotation());
      (0, _coordinate.add)(center, anchor);
    }

    return center;
  };
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */


  View.prototype.calculateCenterZoom = function (resolution, anchor) {
    var center;
    var currentCenter = this.getCenterInternal();
    var currentResolution = this.getResolution();

    if (currentCenter !== undefined && currentResolution !== undefined) {
      var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
      var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
      center = [x, y];
    }

    return center;
  };
  /**
   * Returns the current viewport size.
   * @private
   * @param {number=} opt_rotation Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */


  View.prototype.getViewportSize_ = function (opt_rotation) {
    var size = this.viewportSize_;

    if (opt_rotation) {
      var w = size[0];
      var h = size[1];
      return [Math.abs(w * Math.cos(opt_rotation)) + Math.abs(h * Math.sin(opt_rotation)), Math.abs(w * Math.sin(opt_rotation)) + Math.abs(h * Math.cos(opt_rotation))];
    } else {
      return size;
    }
  };
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * @param {import("./size.js").Size=} opt_size Viewport size; if undefined, [100, 100] is assumed
   */


  View.prototype.setViewportSize = function (opt_size) {
    this.viewportSize_ = Array.isArray(opt_size) ? opt_size.slice() : [100, 100];
    this.resolveConstraints(0);
  };
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */


  View.prototype.getCenter = function () {
    var center = this.getCenterInternal();

    if (!center) {
      return center;
    }

    return (0, _proj.toUserCoordinate)(center, this.getProjection());
  };
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */


  View.prototype.getCenterInternal = function () {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(_ViewProperty.default.CENTER)
    );
  };
  /**
   * @return {Constraints} Constraints.
   */


  View.prototype.getConstraints = function () {
    return this.constraints_;
  };
  /**
   * @return {boolean} Resolution constraint is set
   */


  View.prototype.getConstrainResolution = function () {
    return this.options_.constrainResolution;
  };
  /**
   * @param {Array<number>=} opt_hints Destination array.
   * @return {Array<number>} Hint.
   */


  View.prototype.getHints = function (opt_hints) {
    if (opt_hints !== undefined) {
      opt_hints[0] = this.hints_[0];
      opt_hints[1] = this.hints_[1];
      return opt_hints;
    } else {
      return this.hints_.slice();
    }
  };
  /**
   * Calculate the extent for the current view state and the passed size.
   * The size is the pixel dimensions of the box into which the calculated extent
   * should fit. In most cases you want to get the extent of the entire map,
   * that is `map.getSize()`.
   * @param {import("./size.js").Size=} opt_size Box pixel size. If not provided, the size
   * of the map that uses this view will be used.
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */


  View.prototype.calculateExtent = function (opt_size) {
    var extent = this.calculateExtentInternal(opt_size);
    return (0, _proj.toUserExtent)(extent, this.getProjection());
  };
  /**
   * @param {import("./size.js").Size=} opt_size Box pixel size. If not provided, the size of the
   * first map that uses this view will be used.
   * @return {import("./extent.js").Extent} Extent.
   */


  View.prototype.calculateExtentInternal = function (opt_size) {
    var size = opt_size || this.getViewportSize_();
    var center =
    /** @type {!import("./coordinate.js").Coordinate} */
    this.getCenterInternal();
    (0, _asserts.assert)(center, 1); // The view center is not defined

    var resolution =
    /** @type {!number} */
    this.getResolution();
    (0, _asserts.assert)(resolution !== undefined, 2); // The view resolution is not defined

    var rotation =
    /** @type {!number} */
    this.getRotation();
    (0, _asserts.assert)(rotation !== undefined, 3); // The view rotation is not defined

    return (0, _extent.getForViewAndSize)(center, resolution, rotation, size);
  };
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */


  View.prototype.getMaxResolution = function () {
    return this.maxResolution_;
  };
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */


  View.prototype.getMinResolution = function () {
    return this.minResolution_;
  };
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */


  View.prototype.getMaxZoom = function () {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  };
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */


  View.prototype.setMaxZoom = function (zoom) {
    this.applyOptions_(this.getUpdatedOptions_({
      maxZoom: zoom
    }));
  };
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */


  View.prototype.getMinZoom = function () {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  };
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */


  View.prototype.setMinZoom = function (zoom) {
    this.applyOptions_(this.getUpdatedOptions_({
      minZoom: zoom
    }));
  };
  /**
   * Set whether the view shoud allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */


  View.prototype.setConstrainResolution = function (enabled) {
    this.applyOptions_(this.getUpdatedOptions_({
      constrainResolution: enabled
    }));
  };
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */


  View.prototype.getProjection = function () {
    return this.projection_;
  };
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */


  View.prototype.getResolution = function () {
    return (
      /** @type {number|undefined} */
      this.get(_ViewProperty.default.RESOLUTION)
    );
  };
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */


  View.prototype.getResolutions = function () {
    return this.resolutions_;
  };
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size=} opt_size Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */


  View.prototype.getResolutionForExtent = function (extent, opt_size) {
    return this.getResolutionForExtentInternal((0, _proj.fromUserExtent)(extent, this.getProjection()), opt_size);
  };
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size=} opt_size Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */


  View.prototype.getResolutionForExtentInternal = function (extent, opt_size) {
    var size = opt_size || this.getViewportSize_();
    var xResolution = (0, _extent.getWidth)(extent) / size[0];
    var yResolution = (0, _extent.getHeight)(extent) / size[1];
    return Math.max(xResolution, yResolution);
  };
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number=} opt_power Power.
   * @return {function(number): number} Resolution for value function.
   */


  View.prototype.getResolutionForValueFunction = function (opt_power) {
    var power = opt_power || 2;
    var maxResolution = this.getConstrainedResolution(this.maxResolution_);
    var minResolution = this.minResolution_;
    var max = Math.log(maxResolution / minResolution) / Math.log(power);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function (value) {
        var resolution = maxResolution / Math.pow(power, value * max);
        return resolution;
      }
    );
  };
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */


  View.prototype.getRotation = function () {
    return (
      /** @type {number} */
      this.get(_ViewProperty.default.ROTATION)
    );
  };
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number=} opt_power Power.
   * @return {function(number): number} Value for resolution function.
   */


  View.prototype.getValueForResolutionFunction = function (opt_power) {
    var logPower = Math.log(opt_power || 2);
    var maxResolution = this.getConstrainedResolution(this.maxResolution_);
    var minResolution = this.minResolution_;
    var max = Math.log(maxResolution / minResolution) / logPower;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function (resolution) {
        var value = Math.log(maxResolution / resolution) / logPower / max;
        return value;
      }
    );
  };
  /**
   * @return {State} View state.
   */


  View.prototype.getState = function () {
    var center =
    /** @type {import("./coordinate.js").Coordinate} */
    this.getCenterInternal();
    var projection = this.getProjection();
    var resolution =
    /** @type {number} */
    this.getResolution();
    var rotation = this.getRotation();
    return {
      center: center.slice(0),
      projection: projection !== undefined ? projection : null,
      resolution: resolution,
      rotation: rotation,
      zoom: this.getZoom()
    };
  };
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */


  View.prototype.getZoom = function () {
    var zoom;
    var resolution = this.getResolution();

    if (resolution !== undefined) {
      zoom = this.getZoomForResolution(resolution);
    }

    return zoom;
  };
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */


  View.prototype.getZoomForResolution = function (resolution) {
    var offset = this.minZoom_ || 0;
    var max, zoomFactor;

    if (this.resolutions_) {
      var nearest = (0, _array.linearFindNearest)(this.resolutions_, resolution, 1);
      offset = nearest;
      max = this.resolutions_[nearest];

      if (nearest == this.resolutions_.length - 1) {
        zoomFactor = 2;
      } else {
        zoomFactor = max / this.resolutions_[nearest + 1];
      }
    } else {
      max = this.maxResolution_;
      zoomFactor = this.zoomFactor_;
    }

    return offset + Math.log(max / resolution) / Math.log(zoomFactor);
  };
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */


  View.prototype.getResolutionForZoom = function (zoom) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1) {
        return 0;
      }

      var baseLevel = (0, _math.clamp)(Math.floor(zoom), 0, this.resolutions_.length - 2);
      var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
      return this.resolutions_[baseLevel] / Math.pow(zoomFactor, (0, _math.clamp)(zoom - baseLevel, 0, 1));
    } else {
      return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
    }
  };
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions=} opt_options Options.
   * @api
   */


  View.prototype.fit = function (geometryOrExtent, opt_options) {
    var options = (0, _obj.assign)({
      size: this.getViewportSize_()
    }, opt_options || {});
    /** @type {import("./geom/SimpleGeometry.js").default} */

    var geometry;
    (0, _asserts.assert)(Array.isArray(geometryOrExtent) || typeof
    /** @type {?} */
    geometryOrExtent.getSimplifiedGeometry === 'function', 24); // Invalid extent or geometry provided as `geometry`

    if (Array.isArray(geometryOrExtent)) {
      (0, _asserts.assert)(!(0, _extent.isEmpty)(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`

      var extent = (0, _proj.fromUserExtent)(geometryOrExtent, this.getProjection());
      geometry = (0, _Polygon.fromExtent)(extent);
    } else if (geometryOrExtent.getType() === _GeometryType.default.CIRCLE) {
      var extent = (0, _proj.fromUserExtent)(geometryOrExtent.getExtent(), this.getProjection());
      geometry = (0, _Polygon.fromExtent)(extent);
      geometry.rotate(this.getRotation(), (0, _extent.getCenter)(extent));
    } else {
      var userProjection = (0, _proj.getUserProjection)();

      if (userProjection) {
        geometry =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometryOrExtent.clone().transform(userProjection, this.getProjection());
      } else {
        geometry = geometryOrExtent;
      }
    }

    this.fitInternal(geometry, options);
  };
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions=} opt_options Options.
   */


  View.prototype.fitInternal = function (geometry, opt_options) {
    var options = opt_options || {};
    var size = options.size;

    if (!size) {
      size = this.getViewportSize_();
    }

    var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
    var nearest = options.nearest !== undefined ? options.nearest : false;
    var minResolution;

    if (options.minResolution !== undefined) {
      minResolution = options.minResolution;
    } else if (options.maxZoom !== undefined) {
      minResolution = this.getResolutionForZoom(options.maxZoom);
    } else {
      minResolution = 0;
    }

    var coords = geometry.getFlatCoordinates(); // calculate rotated extent

    var rotation = this.getRotation();
    var cosAngle = Math.cos(-rotation);
    var sinAngle = Math.sin(-rotation);
    var minRotX = +Infinity;
    var minRotY = +Infinity;
    var maxRotX = -Infinity;
    var maxRotY = -Infinity;
    var stride = geometry.getStride();

    for (var i = 0, ii = coords.length; i < ii; i += stride) {
      var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
      var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
      minRotX = Math.min(minRotX, rotX);
      minRotY = Math.min(minRotY, rotY);
      maxRotX = Math.max(maxRotX, rotX);
      maxRotY = Math.max(maxRotY, rotY);
    } // calculate resolution


    var resolution = this.getResolutionForExtentInternal([minRotX, minRotY, maxRotX, maxRotY], [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
    resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1); // calculate center

    sinAngle = -sinAngle; // go back to original rotation

    var centerRotX = (minRotX + maxRotX) / 2;
    var centerRotY = (minRotY + maxRotY) / 2;
    centerRotX += (padding[1] - padding[3]) / 2 * resolution;
    centerRotY += (padding[0] - padding[2]) / 2 * resolution;
    var centerX = centerRotX * cosAngle - centerRotY * sinAngle;
    var centerY = centerRotY * cosAngle + centerRotX * sinAngle;
    var center = [centerX, centerY];
    var callback = options.callback ? options.callback : _functions.VOID;

    if (options.duration !== undefined) {
      this.animateInternal({
        resolution: resolution,
        center: this.getConstrainedCenter(center, resolution),
        duration: options.duration,
        easing: options.easing
      }, callback);
    } else {
      this.targetResolution_ = resolution;
      this.targetCenter_ = center;
      this.applyTargetState_(false, true);
      animationCallback(callback, true);
    }
  };
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */


  View.prototype.centerOn = function (coordinate, size, position) {
    this.centerOnInternal((0, _proj.fromUserCoordinate)(coordinate, this.getProjection()), size, position);
  };
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */


  View.prototype.centerOnInternal = function (coordinate, size, position) {
    // calculate rotated position
    var rotation = this.getRotation();
    var cosAngle = Math.cos(-rotation);
    var sinAngle = Math.sin(-rotation);
    var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    var resolution = this.getResolution();
    rotX += (size[0] / 2 - position[0]) * resolution;
    rotY += (position[1] - size[1] / 2) * resolution; // go back to original angle

    sinAngle = -sinAngle; // go back to original rotation

    var centerX = rotX * cosAngle - rotY * sinAngle;
    var centerY = rotY * cosAngle + rotX * sinAngle;
    this.setCenterInternal([centerX, centerY]);
  };
  /**
   * @return {boolean} Is defined.
   */


  View.prototype.isDef = function () {
    return !!this.getCenterInternal() && this.getResolution() !== undefined;
  };
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */


  View.prototype.adjustCenter = function (deltaCoordinates) {
    var center = (0, _proj.toUserCoordinate)(this.targetCenter_, this.getProjection());
    this.setCenter([center[0] + deltaCoordinates[0], center[1] + deltaCoordinates[1]]);
  };
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */


  View.prototype.adjustCenterInternal = function (deltaCoordinates) {
    var center = this.targetCenter_;
    this.setCenterInternal([center[0] + deltaCoordinates[0], center[1] + deltaCoordinates[1]]);
  };
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
   * @api
   */


  View.prototype.adjustResolution = function (ratio, opt_anchor) {
    var anchor = opt_anchor && (0, _proj.fromUserCoordinate)(opt_anchor, this.getProjection());
    this.adjustResolutionInternal(ratio, anchor);
  };
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
   */


  View.prototype.adjustResolutionInternal = function (ratio, opt_anchor) {
    var isMoving = this.getAnimating() || this.getInteracting();
    var size = this.getViewportSize_(this.getRotation());
    var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);

    if (opt_anchor) {
      this.targetCenter_ = this.calculateCenterZoom(newResolution, opt_anchor);
    }

    this.targetResolution_ *= ratio;
    this.applyTargetState_();
  };
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
   * @api
   */


  View.prototype.adjustZoom = function (delta, opt_anchor) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), opt_anchor);
  };
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The rotation center.
   * @api
   */


  View.prototype.adjustRotation = function (delta, opt_anchor) {
    if (opt_anchor) {
      opt_anchor = (0, _proj.fromUserCoordinate)(opt_anchor, this.getProjection());
    }

    this.adjustRotationInternal(delta, opt_anchor);
  };
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The rotation center.
   */


  View.prototype.adjustRotationInternal = function (delta, opt_anchor) {
    var isMoving = this.getAnimating() || this.getInteracting();
    var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);

    if (opt_anchor) {
      this.targetCenter_ = this.calculateCenterRotate(newRotation, opt_anchor);
    }

    this.targetRotation_ += delta;
    this.applyTargetState_();
  };
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */


  View.prototype.setCenter = function (center) {
    this.setCenterInternal((0, _proj.fromUserCoordinate)(center, this.getProjection()));
  };
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */


  View.prototype.setCenterInternal = function (center) {
    this.targetCenter_ = center;
    this.applyTargetState_();
  };
  /**
   * @param {ViewHint} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */


  View.prototype.setHint = function (hint, delta) {
    this.hints_[hint] += delta;
    this.changed();
    return this.hints_[hint];
  };
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */


  View.prototype.setResolution = function (resolution) {
    this.targetResolution_ = resolution;
    this.applyTargetState_();
  };
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */


  View.prototype.setRotation = function (rotation) {
    this.targetRotation_ = rotation;
    this.applyTargetState_();
  };
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */


  View.prototype.setZoom = function (zoom) {
    this.setResolution(this.getResolutionForZoom(zoom));
  };
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean=} opt_doNotCancelAnims Do not cancel animations.
   * @param {boolean=} opt_forceMoving Apply constraints as if the view is moving.
   * @private
   */


  View.prototype.applyTargetState_ = function (opt_doNotCancelAnims, opt_forceMoving) {
    var isMoving = this.getAnimating() || this.getInteracting() || opt_forceMoving; // compute rotation

    var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
    var size = this.getViewportSize_(newRotation);
    var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
    var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving);

    if (this.get(_ViewProperty.default.ROTATION) !== newRotation) {
      this.set(_ViewProperty.default.ROTATION, newRotation);
    }

    if (this.get(_ViewProperty.default.RESOLUTION) !== newResolution) {
      this.set(_ViewProperty.default.RESOLUTION, newResolution);
    }

    if (!this.get(_ViewProperty.default.CENTER) || !(0, _coordinate.equals)(this.get(_ViewProperty.default.CENTER), newCenter)) {
      this.set(_ViewProperty.default.CENTER, newCenter);
    }

    if (this.getAnimating() && !opt_doNotCancelAnims) {
      this.cancelAnimations();
    }

    this.cancelAnchor_ = undefined;
  };
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number=} opt_duration The animation duration in ms.
   * @param {number=} opt_resolutionDirection Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
   */


  View.prototype.resolveConstraints = function (opt_duration, opt_resolutionDirection, opt_anchor) {
    var duration = opt_duration !== undefined ? opt_duration : 200;
    var direction = opt_resolutionDirection || 0;
    var newRotation = this.constraints_.rotation(this.targetRotation_);
    var size = this.getViewportSize_(newRotation);
    var newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
    var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size);

    if (duration === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = newResolution;
      this.targetRotation_ = newRotation;
      this.targetCenter_ = newCenter;
      this.applyTargetState_();
      return;
    }

    var anchor = opt_anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
    this.cancelAnchor_ = undefined;

    if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !(0, _coordinate.equals)(this.getCenterInternal(), newCenter)) {
      if (this.getAnimating()) {
        this.cancelAnimations();
      }

      this.animateInternal({
        rotation: newRotation,
        center: newCenter,
        resolution: newResolution,
        duration: duration,
        easing: _easing.easeOut,
        anchor: anchor
      });
    }
  };
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */


  View.prototype.beginInteraction = function () {
    this.resolveConstraints(0);
    this.setHint(_ViewHint.default.INTERACTING, 1);
  };
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number=} opt_duration Animation duration in ms.
   * @param {number=} opt_resolutionDirection Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
   * @api
   */


  View.prototype.endInteraction = function (opt_duration, opt_resolutionDirection, opt_anchor) {
    var anchor = opt_anchor && (0, _proj.fromUserCoordinate)(opt_anchor, this.getProjection());
    this.endInteractionInternal(opt_duration, opt_resolutionDirection, anchor);
  };
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number=} opt_duration Animation duration in ms.
   * @param {number=} opt_resolutionDirection Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
   */


  View.prototype.endInteractionInternal = function (opt_duration, opt_resolutionDirection, opt_anchor) {
    this.setHint(_ViewHint.default.INTERACTING, -1);
    this.resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor);
  };
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number=} opt_targetResolution Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */


  View.prototype.getConstrainedCenter = function (targetCenter, opt_targetResolution) {
    var size = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(targetCenter, opt_targetResolution || this.getResolution(), size);
  };
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number=} [opt_direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */


  View.prototype.getConstrainedZoom = function (targetZoom, opt_direction) {
    var targetRes = this.getResolutionForZoom(targetZoom);
    return this.getZoomForResolution(this.getConstrainedResolution(targetRes, opt_direction));
  };
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number=} [opt_direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */


  View.prototype.getConstrainedResolution = function (targetResolution, opt_direction) {
    var direction = opt_direction || 0;
    var size = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(targetResolution, direction, size);
  };

  return View;
}(_Object.default);
/**
 * @param {Function} callback Callback.
 * @param {*} returnValue Return value.
 */


function animationCallback(callback, returnValue) {
  setTimeout(function () {
    callback(returnValue);
  }, 0);
}
/**
 * @param {ViewOptions} options View options.
 * @return {import("./centerconstraint.js").Type} The constraint.
 */


function createCenterConstraint(options) {
  if (options.extent !== undefined) {
    var smooth = options.smoothExtentConstraint !== undefined ? options.smoothExtentConstraint : true;
    return (0, _centerconstraint.createExtent)(options.extent, options.constrainOnlyCenter, smooth);
  }

  var projection = (0, _proj.createProjection)(options.projection, 'EPSG:3857');

  if (options.multiWorld !== true && projection.isGlobal()) {
    var extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return (0, _centerconstraint.createExtent)(extent, false, false);
  }

  return _centerconstraint.none;
}
/**
 * @param {ViewOptions} options View options.
 * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
 *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
 */


function createResolutionConstraint(options) {
  var resolutionConstraint;
  var maxResolution;
  var minResolution; // TODO: move these to be ol constants
  // see https://github.com/openlayers/openlayers/issues/2076

  var defaultMaxZoom = 28;
  var defaultZoomFactor = 2;
  var minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;
  var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
  var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;
  var multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;
  var smooth = options.smoothResolutionConstraint !== undefined ? options.smoothResolutionConstraint : true;
  var showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;
  var projection = (0, _proj.createProjection)(options.projection, 'EPSG:3857');
  var projExtent = projection.getExtent();
  var constrainOnlyCenter = options.constrainOnlyCenter;
  var extent = options.extent;

  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }

  if (options.resolutions !== undefined) {
    var resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];

    if (options.constrainResolution) {
      resolutionConstraint = (0, _resolutionconstraint.createSnapToResolutions)(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
      resolutionConstraint = (0, _resolutionconstraint.createMinMaxResolution)(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
  } else {
    // calculate the default min and max resolution
    var size = !projExtent ? // use an extent that can fit the whole world if need be
    360 * _proj.METERS_PER_UNIT[_Units.default.DEGREES] / projection.getMetersPerUnit() : Math.max((0, _extent.getWidth)(projExtent), (0, _extent.getHeight)(projExtent));
    var defaultMaxResolution = size / _common.DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM); // user provided maxResolution takes precedence

    maxResolution = options.maxResolution;

    if (maxResolution !== undefined) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    } // user provided minResolution takes precedence


    minResolution = options.minResolution;

    if (minResolution === undefined) {
      if (options.maxZoom !== undefined) {
        if (options.maxResolution !== undefined) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    } // given discrete zoom levels, minResolution may be different than provided


    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);

    if (options.constrainResolution) {
      resolutionConstraint = (0, _resolutionconstraint.createSnapToPower)(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
      resolutionConstraint = (0, _resolutionconstraint.createMinMaxResolution)(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
  }

  return {
    constraint: resolutionConstraint,
    maxResolution: maxResolution,
    minResolution: minResolution,
    minZoom: minZoom,
    zoomFactor: zoomFactor
  };
}
/**
 * @param {ViewOptions} options View options.
 * @return {import("./rotationconstraint.js").Type} Rotation constraint.
 */


function createRotationConstraint(options) {
  var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;

  if (enableRotation) {
    var constrainRotation = options.constrainRotation;

    if (constrainRotation === undefined || constrainRotation === true) {
      return (0, _rotationconstraint.createSnapToZero)();
    } else if (constrainRotation === false) {
      return _rotationconstraint.none;
    } else if (typeof constrainRotation === 'number') {
      return (0, _rotationconstraint.createSnapToN)(constrainRotation);
    } else {
      return _rotationconstraint.none;
    }
  } else {
    return _rotationconstraint.disable;
  }
}
/**
 * Determine if an animation involves no view change.
 * @param {Animation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */


function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!(0, _coordinate.equals)(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }

  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }

  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }

  return true;
}

var _default = View;
exports.default = _default;
},{"./tilegrid/common.js":"node_modules/ol/tilegrid/common.js","./functions.js":"node_modules/ol/functions.js","./centerconstraint.js":"node_modules/ol/centerconstraint.js","./Object.js":"node_modules/ol/Object.js","./resolutionconstraint.js":"node_modules/ol/resolutionconstraint.js","./rotationconstraint.js":"node_modules/ol/rotationconstraint.js","./ViewHint.js":"node_modules/ol/ViewHint.js","./ViewProperty.js":"node_modules/ol/ViewProperty.js","./array.js":"node_modules/ol/array.js","./asserts.js":"node_modules/ol/asserts.js","./coordinate.js":"node_modules/ol/coordinate.js","./easing.js":"node_modules/ol/easing.js","./extent.js":"node_modules/ol/extent.js","./geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","./geom/Polygon.js":"node_modules/ol/geom/Polygon.js","./math.js":"node_modules/ol/math.js","./obj.js":"node_modules/ol/obj.js","./proj.js":"node_modules/ol/proj.js","./proj/Units.js":"node_modules/ol/proj/Units.js"}],"node_modules/ol/dom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCanvasContext2D = createCanvasContext2D;
exports.outerWidth = outerWidth;
exports.outerHeight = outerHeight;
exports.replaceNode = replaceNode;
exports.removeNode = removeNode;
exports.removeChildren = removeChildren;
exports.replaceChildren = replaceChildren;

var _has = require("./has.js");

/**
 * @module ol/dom
 */
//FIXME Move this function to the canvas module

/**
 * Create an html canvas element and returns its 2d context.
 * @param {number=} opt_width Canvas width.
 * @param {number=} opt_height Canvas height.
 * @param {Array<HTMLCanvasElement>=} opt_canvasPool Canvas pool to take existing canvas from.
 * @return {CanvasRenderingContext2D} The context.
 */
function createCanvasContext2D(opt_width, opt_height, opt_canvasPool) {
  var canvas = opt_canvasPool && opt_canvasPool.length ? opt_canvasPool.shift() : _has.WORKER_OFFSCREEN_CANVAS ? new OffscreenCanvas(opt_width || 300, opt_height || 300) : document.createElement('canvas');

  if (opt_width) {
    canvas.width = opt_width;
  }

  if (opt_height) {
    canvas.height = opt_height;
  } //FIXME Allow OffscreenCanvasRenderingContext2D as return type


  return (
    /** @type {CanvasRenderingContext2D} */
    canvas.getContext('2d')
  );
}
/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The width.
 */


function outerWidth(element) {
  var width = element.offsetWidth;
  var style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
  return width;
}
/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The height.
 */


function outerHeight(element) {
  var height = element.offsetHeight;
  var style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
  return height;
}
/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */


function replaceNode(newNode, oldNode) {
  var parent = oldNode.parentNode;

  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}
/**
 * @param {Node} node The node to remove.
 * @returns {Node} The node that was removed or null.
 */


function removeNode(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}
/**
 * @param {Node} node The node to remove the children from.
 */


function removeChildren(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
}
/**
 * Transform the children of a parent node so they match the
 * provided list of children.  This function aims to efficiently
 * remove, add, and reorder child nodes while maintaining a simple
 * implementation (it is not guaranteed to minimize DOM operations).
 * @param {Node} node The parent node whose children need reworking.
 * @param {Array<Node>} children The desired children.
 */


function replaceChildren(node, children) {
  var oldChildren = node.childNodes;

  for (var i = 0; true; ++i) {
    var oldChild = oldChildren[i];
    var newChild = children[i]; // check if our work is done

    if (!oldChild && !newChild) {
      break;
    } // check if children match


    if (oldChild === newChild) {
      continue;
    } // check if a new child needs to be added


    if (!oldChild) {
      node.appendChild(newChild);
      continue;
    } // check if an old child needs to be removed


    if (!newChild) {
      node.removeChild(oldChild);
      --i;
      continue;
    } // reorder


    node.insertBefore(newChild, oldChild);
  }
}
},{"./has.js":"node_modules/ol/has.js"}],"node_modules/ol/layer/Property.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/layer/Property
 */

/**
 * @enum {string}
 */
var _default = {
  OPACITY: 'opacity',
  VISIBLE: 'visible',
  EXTENT: 'extent',
  Z_INDEX: 'zIndex',
  MAX_RESOLUTION: 'maxResolution',
  MIN_RESOLUTION: 'minResolution',
  MAX_ZOOM: 'maxZoom',
  MIN_ZOOM: 'minZoom',
  SOURCE: 'source'
};
exports.default = _default;
},{}],"node_modules/ol/layer/Base.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("../util.js");

var _Object = _interopRequireDefault(require("../Object.js"));

var _Property = _interopRequireDefault(require("./Property.js"));

var _math = require("../math.js");

var _obj = require("../obj.js");

var _asserts = require("../asserts.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/Base
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:ol/layer/Base} and all its subclasses, any property set in
 * the options is set as a {@link module:ol/Object} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */
var BaseLayer =
/** @class */
function (_super) {
  __extends(BaseLayer, _super);
  /**
   * @param {Options} options Layer options.
   */


  function BaseLayer(options) {
    var _this = _super.call(this) || this;
    /**
     * @type {Object<string, *>}
     */


    var properties = (0, _obj.assign)({}, options);
    properties[_Property.default.OPACITY] = options.opacity !== undefined ? options.opacity : 1;
    (0, _asserts.assert)(typeof properties[_Property.default.OPACITY] === 'number', 64); // Layer opacity must be a number

    properties[_Property.default.VISIBLE] = options.visible !== undefined ? options.visible : true;
    properties[_Property.default.Z_INDEX] = options.zIndex;
    properties[_Property.default.MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;
    properties[_Property.default.MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;
    properties[_Property.default.MIN_ZOOM] = options.minZoom !== undefined ? options.minZoom : -Infinity;
    properties[_Property.default.MAX_ZOOM] = options.maxZoom !== undefined ? options.maxZoom : Infinity;
    /**
     * @type {string}
     * @private
     */

    _this.className_ = properties.className !== undefined ? options.className : 'ol-layer';
    delete properties.className;

    _this.setProperties(properties);
    /**
     * @type {import("./Layer.js").State}
     * @private
     */


    _this.state_ = null;
    return _this;
  }
  /**
   * @return {string} CSS class name.
   */


  BaseLayer.prototype.getClassName = function () {
    return this.className_;
  };
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean=} opt_managed Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */


  BaseLayer.prototype.getLayerState = function (opt_managed) {
    /** @type {import("./Layer.js").State} */
    var state = this.state_ ||
    /** @type {?} */
    {
      layer: this,
      managed: opt_managed === undefined ? true : opt_managed
    };
    var zIndex = this.getZIndex();
    state.opacity = (0, _math.clamp)(Math.round(this.getOpacity() * 100) / 100, 0, 1);
    state.sourceState = this.getSourceState();
    state.visible = this.getVisible();
    state.extent = this.getExtent();
    state.zIndex = zIndex !== undefined ? zIndex : state.managed === false ? Infinity : 0;
    state.maxResolution = this.getMaxResolution();
    state.minResolution = Math.max(this.getMinResolution(), 0);
    state.minZoom = this.getMinZoom();
    state.maxZoom = this.getMaxZoom();
    this.state_ = state;
    return state;
  };
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */


  BaseLayer.prototype.getLayersArray = function (opt_array) {
    return (0, _util.abstract)();
  };
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */


  BaseLayer.prototype.getLayerStatesArray = function (opt_states) {
    return (0, _util.abstract)();
  };
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */


  BaseLayer.prototype.getExtent = function () {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(_Property.default.EXTENT)
    );
  };
  /**
   * Return the maximum resolution of the layer.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getMaxResolution = function () {
    return (
      /** @type {number} */
      this.get(_Property.default.MAX_RESOLUTION)
    );
  };
  /**
   * Return the minimum resolution of the layer.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getMinResolution = function () {
    return (
      /** @type {number} */
      this.get(_Property.default.MIN_RESOLUTION)
    );
  };
  /**
   * Return the minimum zoom level of the layer.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getMinZoom = function () {
    return (
      /** @type {number} */
      this.get(_Property.default.MIN_ZOOM)
    );
  };
  /**
   * Return the maximum zoom level of the layer.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getMaxZoom = function () {
    return (
      /** @type {number} */
      this.get(_Property.default.MAX_ZOOM)
    );
  };
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getOpacity = function () {
    return (
      /** @type {number} */
      this.get(_Property.default.OPACITY)
    );
  };
  /**
   * @abstract
   * @return {import("../source/State.js").default} Source state.
   */


  BaseLayer.prototype.getSourceState = function () {
    return (0, _util.abstract)();
  };
  /**
   * Return the visibility of the layer (`true` or `false`).
   * @return {boolean} The visibility of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getVisible = function () {
    return (
      /** @type {boolean} */
      this.get(_Property.default.VISIBLE)
    );
  };
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. The default Z-index is 0.
   * @return {number} The Z-index of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getZIndex = function () {
    return (
      /** @type {number} */
      this.get(_Property.default.Z_INDEX)
    );
  };
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setExtent = function (extent) {
    this.set(_Property.default.EXTENT, extent);
  };
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setMaxResolution = function (maxResolution) {
    this.set(_Property.default.MAX_RESOLUTION, maxResolution);
  };
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setMinResolution = function (minResolution) {
    this.set(_Property.default.MIN_RESOLUTION, minResolution);
  };
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setMaxZoom = function (maxZoom) {
    this.set(_Property.default.MAX_ZOOM, maxZoom);
  };
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setMinZoom = function (minZoom) {
    this.set(_Property.default.MIN_ZOOM, minZoom);
  };
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setOpacity = function (opacity) {
    (0, _asserts.assert)(typeof opacity === 'number', 64); // Layer opacity must be a number

    this.set(_Property.default.OPACITY, opacity);
  };
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setVisible = function (visible) {
    this.set(_Property.default.VISIBLE, visible);
  };
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setZIndex = function (zindex) {
    this.set(_Property.default.Z_INDEX, zindex);
  };
  /**
   * @inheritDoc
   */


  BaseLayer.prototype.disposeInternal = function () {
    if (this.state_) {
      this.state_.layer = null;
      this.state_ = null;
    }

    _super.prototype.disposeInternal.call(this);
  };

  return BaseLayer;
}(_Object.default);

var _default = BaseLayer;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","../Object.js":"node_modules/ol/Object.js","./Property.js":"node_modules/ol/layer/Property.js","../math.js":"node_modules/ol/math.js","../obj.js":"node_modules/ol/obj.js","../asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/source/State.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/source/State
 */

/**
 * @enum {string}
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */
var _default = {
  UNDEFINED: 'undefined',
  LOADING: 'loading',
  READY: 'ready',
  ERROR: 'error'
};
exports.default = _default;
},{}],"node_modules/ol/layer/Group.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("../util.js");

var _Collection = _interopRequireDefault(require("../Collection.js"));

var _CollectionEventType = _interopRequireDefault(require("../CollectionEventType.js"));

var _Object = require("../Object.js");

var _ObjectEventType = _interopRequireDefault(require("../ObjectEventType.js"));

var _asserts = require("../asserts.js");

var _events = require("../events.js");

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _extent = require("../extent.js");

var _Base = _interopRequireDefault(require("./Base.js"));

var _obj = require("../obj.js");

var _State = _interopRequireDefault(require("../source/State.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/Group
 */


/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {Array<import("./Base.js").default>|import("../Collection.js").default<import("./Base.js").default>} [layers] Child layers.
 */

/**
 * @enum {string}
 * @private
 */
var Property = {
  LAYERS: 'layers'
};
/**
 * @classdesc
 * A {@link module:ol/Collection~Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @api
 */

var LayerGroup =
/** @class */
function (_super) {
  __extends(LayerGroup, _super);
  /**
   * @param {Options=} opt_options Layer options.
   */


  function LayerGroup(opt_options) {
    var _this = this;

    var options = opt_options || {};
    var baseOptions =
    /** @type {Options} */
    (0, _obj.assign)({}, options);
    delete baseOptions.layers;
    var layers = options.layers;
    _this = _super.call(this, baseOptions) || this;
    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */

    _this.layersListenerKeys_ = [];
    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */

    _this.listenerKeys_ = {};

    _this.addEventListener((0, _Object.getChangeEventType)(Property.LAYERS), _this.handleLayersChanged_);

    if (layers) {
      if (Array.isArray(layers)) {
        layers = new _Collection.default(layers.slice(), {
          unique: true
        });
      } else {
        (0, _asserts.assert)(typeof
        /** @type {?} */
        layers.getArray === 'function', 43); // Expected `layers` to be an array or a `Collection`
      }
    } else {
      layers = new _Collection.default(undefined, {
        unique: true
      });
    }

    _this.setLayers(layers);

    return _this;
  }
  /**
   * @private
   */


  LayerGroup.prototype.handleLayerChange_ = function () {
    this.changed();
  };
  /**
   * @private
   */


  LayerGroup.prototype.handleLayersChanged_ = function () {
    this.layersListenerKeys_.forEach(_events.unlistenByKey);
    this.layersListenerKeys_.length = 0;
    var layers = this.getLayers();
    this.layersListenerKeys_.push((0, _events.listen)(layers, _CollectionEventType.default.ADD, this.handleLayersAdd_, this), (0, _events.listen)(layers, _CollectionEventType.default.REMOVE, this.handleLayersRemove_, this));

    for (var id in this.listenerKeys_) {
      this.listenerKeys_[id].forEach(_events.unlistenByKey);
    }

    (0, _obj.clear)(this.listenerKeys_);
    var layersArray = layers.getArray();

    for (var i = 0, ii = layersArray.length; i < ii; i++) {
      var layer = layersArray[i];
      this.listenerKeys_[(0, _util.getUid)(layer)] = [(0, _events.listen)(layer, _ObjectEventType.default.PROPERTYCHANGE, this.handleLayerChange_, this), (0, _events.listen)(layer, _EventType.default.CHANGE, this.handleLayerChange_, this)];
    }

    this.changed();
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
   * @private
   */


  LayerGroup.prototype.handleLayersAdd_ = function (collectionEvent) {
    var layer =
    /** @type {import("./Base.js").default} */
    collectionEvent.element;
    this.listenerKeys_[(0, _util.getUid)(layer)] = [(0, _events.listen)(layer, _ObjectEventType.default.PROPERTYCHANGE, this.handleLayerChange_, this), (0, _events.listen)(layer, _EventType.default.CHANGE, this.handleLayerChange_, this)];
    this.changed();
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
   * @private
   */


  LayerGroup.prototype.handleLayersRemove_ = function (collectionEvent) {
    var layer =
    /** @type {import("./Base.js").default} */
    collectionEvent.element;
    var key = (0, _util.getUid)(layer);
    this.listenerKeys_[key].forEach(_events.unlistenByKey);
    delete this.listenerKeys_[key];
    this.changed();
  };
  /**
   * Returns the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!import("../Collection.js").default<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base layers} that are part of this group.
   * @observable
   * @api
   */


  LayerGroup.prototype.getLayers = function () {
    return (
      /** @type {!import("../Collection.js").default<import("./Base.js").default>} */
      this.get(Property.LAYERS)
    );
  };
  /**
   * Set the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!import("../Collection.js").default<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base layers} that are part of this group.
   * @observable
   * @api
   */


  LayerGroup.prototype.setLayers = function (layers) {
    this.set(Property.LAYERS, layers);
  };
  /**
   * @inheritDoc
   */


  LayerGroup.prototype.getLayersArray = function (opt_array) {
    var array = opt_array !== undefined ? opt_array : [];
    this.getLayers().forEach(function (layer) {
      layer.getLayersArray(array);
    });
    return array;
  };
  /**
   * @inheritDoc
   */


  LayerGroup.prototype.getLayerStatesArray = function (opt_states) {
    var states = opt_states !== undefined ? opt_states : [];
    var pos = states.length;
    this.getLayers().forEach(function (layer) {
      layer.getLayerStatesArray(states);
    });
    var ownLayerState = this.getLayerState();

    for (var i = pos, ii = states.length; i < ii; i++) {
      var layerState = states[i];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
      layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);

      if (ownLayerState.extent !== undefined) {
        if (layerState.extent !== undefined) {
          layerState.extent = (0, _extent.getIntersection)(layerState.extent, ownLayerState.extent);
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }
    }

    return states;
  };
  /**
   * @inheritDoc
   */


  LayerGroup.prototype.getSourceState = function () {
    return _State.default.READY;
  };

  return LayerGroup;
}(_Base.default);

var _default = LayerGroup;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","../Collection.js":"node_modules/ol/Collection.js","../CollectionEventType.js":"node_modules/ol/CollectionEventType.js","../Object.js":"node_modules/ol/Object.js","../ObjectEventType.js":"node_modules/ol/ObjectEventType.js","../asserts.js":"node_modules/ol/asserts.js","../events.js":"node_modules/ol/events.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../extent.js":"node_modules/ol/extent.js","./Base.js":"node_modules/ol/layer/Base.js","../obj.js":"node_modules/ol/obj.js","../source/State.js":"node_modules/ol/source/State.js"}],"node_modules/ol/size.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buffer = buffer;
exports.hasArea = hasArea;
exports.scale = scale;
exports.toSize = toSize;

/**
 * @module ol/size
 */

/**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array<number>} Size
 * @api
 */

/**
 * Returns a buffered size.
 * @param {Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {Size=} opt_size Optional reusable size array.
 * @return {Size} The buffered size.
 */
function buffer(size, num, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }

  opt_size[0] = size[0] + 2 * num;
  opt_size[1] = size[1] + 2 * num;
  return opt_size;
}
/**
 * Determines if a size has a positive area.
 * @param {Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */


function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}
/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {Size} size Size.
 * @param {number} ratio Ratio.
 * @param {Size=} opt_size Optional reusable size array.
 * @return {Size} The scaled size.
 */


function scale(size, ratio, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }

  opt_size[0] = size[0] * ratio + 0.5 | 0;
  opt_size[1] = size[1] * ratio + 0.5 | 0;
  return opt_size;
}
/**
 * Returns an `Size` array for the passed in number (meaning: square) or
 * `Size` array.
 * (meaning: non-square),
 * @param {number|Size} size Width and height.
 * @param {Size=} opt_size Optional reusable size array.
 * @return {Size} Size.
 * @api
 */


function toSize(size, opt_size) {
  if (Array.isArray(size)) {
    return size;
  } else {
    if (opt_size === undefined) {
      opt_size = [size, size];
    } else {
      opt_size[0] = size;
      opt_size[1] = size;
    }

    return opt_size;
  }
}
},{}],"node_modules/ol/PluggableMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Collection = _interopRequireDefault(require("./Collection.js"));

var _CollectionEventType = _interopRequireDefault(require("./CollectionEventType.js"));

var _MapBrowserEvent = _interopRequireDefault(require("./MapBrowserEvent.js"));

var _MapBrowserEventHandler = _interopRequireDefault(require("./MapBrowserEventHandler.js"));

var _MapBrowserEventType = _interopRequireDefault(require("./MapBrowserEventType.js"));

var _MapEvent = _interopRequireDefault(require("./MapEvent.js"));

var _MapEventType = _interopRequireDefault(require("./MapEventType.js"));

var _MapProperty = _interopRequireDefault(require("./MapProperty.js"));

var _EventType = _interopRequireDefault(require("./render/EventType.js"));

var _Object = _interopRequireWildcard(require("./Object.js"));

var _ObjectEventType = _interopRequireDefault(require("./ObjectEventType.js"));

var _TileQueue = _interopRequireWildcard(require("./TileQueue.js"));

var _View = _interopRequireDefault(require("./View.js"));

var _ViewHint = _interopRequireDefault(require("./ViewHint.js"));

var _asserts = require("./asserts.js");

var _dom = require("./dom.js");

var _events = require("./events.js");

var _EventType2 = _interopRequireDefault(require("./events/EventType.js"));

var _extent = require("./extent.js");

var _functions = require("./functions.js");

var _has = require("./has.js");

var _Group = _interopRequireDefault(require("./layer/Group.js"));

var _size = require("./size.js");

var _transform = require("./transform.js");

var _proj = require("./proj.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/PluggableMap
 */


/**
 * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
 * be used in applications.
 * @typedef {Object} FrameState
 * @property {number} pixelRatio The pixel ratio of the frame.
 * @property {number} time The time when rendering of the frame was requested.
 * @property {import("./View.js").State} viewState The state of the current view.
 * @property {boolean} animate
 * @property {import("./transform.js").Transform} coordinateToPixelTransform
 * @property {null|import("./extent.js").Extent} extent
 * @property {Array<DeclutterItems>} declutterItems
 * @property {number} index
 * @property {Array<import("./layer/Layer.js").State>} layerStatesArray
 * @property {number} layerIndex
 * @property {import("./transform.js").Transform} pixelToCoordinateTransform
 * @property {Array<PostRenderFunction>} postRenderFunctions
 * @property {import("./size.js").Size} size
 * @property {TileQueue} tileQueue
 * @property {!Object<string, Object<string, boolean>>} usedTiles
 * @property {Array<number>} viewHints
 * @property {!Object<string, Object<string, boolean>>} wantedTiles
 */

/**
 * @typedef {Object} DeclutterItems
 * @property {Array<*>} items Declutter items of an executor.
 * @property {number} opacity Layer opacity.
 */

/**
 * @typedef {function(PluggableMap, ?FrameState): any} PostRenderFunction
 */

/**
 * @typedef {Object} AtPixelOptions
 * @property {undefined|function(import("./layer/Layer.js").default): boolean} [layerFilter] Layer filter
 * function. The filter function will receive one argument, the
 * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.
 * Only layers which are visible and for which this function returns `true`
 * will be tested for features. By default, all visible layers will be tested.
 * @property {number} [hitTolerance=0] Hit-detection tolerance in pixels. Pixels
 * inside the radius around the given position will be checked for features.
 * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for for wrapped geometries inside the range of
 *   +/- 1 world width. Works only if a projection is used that can be wrapped.
 */

/**
 * @typedef {Object} MapOptionsInternal
 * @property {Collection<import("./control/Control.js").default>} [controls]
 * @property {Collection<import("./interaction/Interaction.js").default>} [interactions]
 * @property {HTMLElement|Document} keyboardEventTarget
 * @property {Collection<import("./Overlay.js").default>} overlays
 * @property {Object<string, *>} values
 */

/**
 * Object literal with config options for the map.
 * @typedef {Object} MapOptions
 * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
 * Controls initially added to the map. If not specified,
 * {@link module:ol/control~defaults} is used.
 * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
 * physical pixels and device-independent pixels (dips) on the device.
 * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
 * Interactions that are initially added to the map. If not specified,
 * {@link module:ol/interaction~defaults} is used.
 * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
 * listen to keyboard events on. This determines when the `KeyboardPan` and
 * `KeyboardZoom` interactions trigger. For example, if this option is set to
 * `document` the keyboard interactions will always trigger. If this option is
 * not specified, the element the library listens to keyboard events on is the
 * map target (i.e. the user-provided div for the map). If this is not
 * `document`, the target element needs to be focused for key events to be
 * emitted, requiring that the target element has a `tabindex` attribute.
 * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
 * Layers. If this is not defined, a map with no layers will be rendered. Note
 * that layers are rendered in the order supplied, so if you want, for example,
 * a vector layer to appear on top of a tile layer, it must come after the tile
 * layer.
 * @property {number} [maxTilesLoading=16] Maximum number tiles to load
 * simultaneously.
 * @property {number} [moveTolerance=1] The minimum distance in pixels the
 * cursor must move to be detected as a map move event instead of a click.
 * Increasing this value can make it easier to click on the map.
 * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
 * Overlays initially added to the map. By default, no overlays are added.
 * @property {HTMLElement|string} [target] The container for the map, either the
 * element itself or the `id` of the element. If not specified at construction
 * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
 * rendered.
 * @property {View} [view] The map's view.  No layer sources will be
 * fetched unless this is specified at construction time or through
 * {@link module:ol/Map~Map#setView}.
 */

/**
 * @fires import("./MapBrowserEvent.js").MapBrowserEvent
 * @fires import("./MapEvent.js").MapEvent
 * @fires import("./render/Event.js").default#precompose
 * @fires import("./render/Event.js").default#postcompose
 * @fires import("./render/Event.js").default#rendercomplete
 * @api
 */
var PluggableMap =
/** @class */
function (_super) {
  __extends(PluggableMap, _super);
  /**
   * @param {MapOptions} options Map options.
   */


  function PluggableMap(options) {
    var _this = _super.call(this) || this;

    var optionsInternal = createOptionsInternal(options);
    /** @private */

    _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);
    /**
     * @type {number}
     * @private
     */

    _this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;
    /**
     * @private
     * @type {number}
     */

    _this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : _has.DEVICE_PIXEL_RATIO;
    /**
     * @private
     * @type {*}
     */

    _this.postRenderTimeoutHandle_;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.animationDelayKey_;
    /**
     * @private
     */

    _this.animationDelay_ = function () {
      this.animationDelayKey_ = undefined;
      this.renderFrame_(Date.now());
    }.bind(_this);
    /**
     * @private
     * @type {import("./transform.js").Transform}
     */


    _this.coordinateToPixelTransform_ = (0, _transform.create)();
    /**
     * @private
     * @type {import("./transform.js").Transform}
     */

    _this.pixelToCoordinateTransform_ = (0, _transform.create)();
    /**
     * @private
     * @type {number}
     */

    _this.frameIndex_ = 0;
    /**
     * @private
     * @type {?FrameState}
     */

    _this.frameState_ = null;
    /**
     * The extent at the previous 'moveend' event.
     * @private
     * @type {import("./extent.js").Extent}
     */

    _this.previousExtent_ = null;
    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */

    _this.viewPropertyListenerKey_ = null;
    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */

    _this.viewChangeListenerKey_ = null;
    /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */

    _this.layerGroupPropertyListenerKeys_ = null;
    /**
     * @private
     * @type {!HTMLElement}
     */

    _this.viewport_ = document.createElement('div');
    _this.viewport_.className = 'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');
    _this.viewport_.style.position = 'relative';
    _this.viewport_.style.overflow = 'hidden';
    _this.viewport_.style.width = '100%';
    _this.viewport_.style.height = '100%';
    /**
     * @private
     * @type {!HTMLElement}
     */

    _this.overlayContainer_ = document.createElement('div');
    _this.overlayContainer_.style.position = 'absolute';
    _this.overlayContainer_.style.zIndex = '0';
    _this.overlayContainer_.style.width = '100%';
    _this.overlayContainer_.style.height = '100%';
    _this.overlayContainer_.className = 'ol-overlaycontainer';

    _this.viewport_.appendChild(_this.overlayContainer_);
    /**
     * @private
     * @type {!HTMLElement}
     */


    _this.overlayContainerStopEvent_ = document.createElement('div');
    _this.overlayContainerStopEvent_.style.position = 'absolute';
    _this.overlayContainerStopEvent_.style.zIndex = '0';
    _this.overlayContainerStopEvent_.style.width = '100%';
    _this.overlayContainerStopEvent_.style.height = '100%';
    _this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';

    _this.viewport_.appendChild(_this.overlayContainerStopEvent_);
    /**
     * @private
     * @type {MapBrowserEventHandler}
     */


    _this.mapBrowserEventHandler_ = new _MapBrowserEventHandler.default(_this, options.moveTolerance);

    var handleMapBrowserEvent = _this.handleMapBrowserEvent.bind(_this);

    for (var key in _MapBrowserEventType.default) {
      _this.mapBrowserEventHandler_.addEventListener(_MapBrowserEventType.default[key], handleMapBrowserEvent);
    }
    /**
     * @private
     * @type {HTMLElement|Document}
     */


    _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
    /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */

    _this.keyHandlerKeys_ = null;

    var handleBrowserEvent = _this.handleBrowserEvent.bind(_this);

    _this.viewport_.addEventListener(_EventType2.default.CONTEXTMENU, handleBrowserEvent, false);

    _this.viewport_.addEventListener(_EventType2.default.WHEEL, handleBrowserEvent, _has.PASSIVE_EVENT_LISTENERS ? {
      passive: false
    } : false);
    /**
     * @type {Collection<import("./control/Control.js").default>}
     * @protected
     */


    _this.controls = optionsInternal.controls || new _Collection.default();
    /**
     * @type {Collection<import("./interaction/Interaction.js").default>}
     * @protected
     */

    _this.interactions = optionsInternal.interactions || new _Collection.default();
    /**
     * @type {Collection<import("./Overlay.js").default>}
     * @private
     */

    _this.overlays_ = optionsInternal.overlays;
    /**
     * A lookup of overlays by id.
     * @private
     * @type {Object<string, import("./Overlay.js").default>}
     */

    _this.overlayIdIndex_ = {};
    /**
     * @type {import("./renderer/Map.js").default}
     * @private
     */

    _this.renderer_ = null;
    /**
     * @type {undefined|function(Event): void}
     * @private
     */

    _this.handleResize_;
    /**
     * @private
     * @type {!Array<PostRenderFunction>}
     */

    _this.postRenderFunctions_ = [];
    /**
     * @private
     * @type {TileQueue}
     */

    _this.tileQueue_ = new _TileQueue.default(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));

    _this.addEventListener((0, _Object.getChangeEventType)(_MapProperty.default.LAYERGROUP), _this.handleLayerGroupChanged_);

    _this.addEventListener((0, _Object.getChangeEventType)(_MapProperty.default.VIEW), _this.handleViewChanged_);

    _this.addEventListener((0, _Object.getChangeEventType)(_MapProperty.default.SIZE), _this.handleSizeChanged_);

    _this.addEventListener((0, _Object.getChangeEventType)(_MapProperty.default.TARGET), _this.handleTargetChanged_); // setProperties will trigger the rendering of the map if the map
    // is "defined" already.


    _this.setProperties(optionsInternal.values);

    _this.controls.forEach(
    /**
     * @param {import("./control/Control.js").default} control Control.
     * @this {PluggableMap}
     */
    function (control) {
      control.setMap(this);
    }.bind(_this));

    _this.controls.addEventListener(_CollectionEventType.default.ADD,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(this);
    }.bind(_this));

    _this.controls.addEventListener(_CollectionEventType.default.REMOVE,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(null);
    }.bind(_this));

    _this.interactions.forEach(
    /**
     * @param {import("./interaction/Interaction.js").default} interaction Interaction.
     * @this {PluggableMap}
     */
    function (interaction) {
      interaction.setMap(this);
    }.bind(_this));

    _this.interactions.addEventListener(_CollectionEventType.default.ADD,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(this);
    }.bind(_this));

    _this.interactions.addEventListener(_CollectionEventType.default.REMOVE,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(null);
    }.bind(_this));

    _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));

    _this.overlays_.addEventListener(_CollectionEventType.default.ADD,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      this.addOverlayInternal_(
      /** @type {import("./Overlay.js").default} */
      event.element);
    }.bind(_this));

    _this.overlays_.addEventListener(_CollectionEventType.default.REMOVE,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      var overlay =
      /** @type {import("./Overlay.js").default} */
      event.element;
      var id = overlay.getId();

      if (id !== undefined) {
        delete this.overlayIdIndex_[id.toString()];
      }

      event.element.setMap(null);
    }.bind(_this));

    return _this;
  }
  /**
   * @abstract
   * @return {import("./renderer/Map.js").default} The map renderer
   */


  PluggableMap.prototype.createRenderer = function () {
    throw new Error('Use a map type that has a createRenderer method');
  };
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */


  PluggableMap.prototype.addControl = function (control) {
    this.getControls().push(control);
  };
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteraction()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */


  PluggableMap.prototype.addInteraction = function (interaction) {
    this.getInteractions().push(interaction);
  };
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */


  PluggableMap.prototype.addLayer = function (layer) {
    var layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  };
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */


  PluggableMap.prototype.addOverlay = function (overlay) {
    this.getOverlays().push(overlay);
  };
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */


  PluggableMap.prototype.addOverlayInternal_ = function (overlay) {
    var id = overlay.getId();

    if (id !== undefined) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }

    overlay.setMap(this);
  };
  /**
   *
   * @inheritDoc
   */


  PluggableMap.prototype.disposeInternal = function () {
    this.mapBrowserEventHandler_.dispose();
    this.viewport_.removeEventListener(_EventType2.default.CONTEXTMENU, this.boundHandleBrowserEvent_);
    this.viewport_.removeEventListener(_EventType2.default.WHEEL, this.boundHandleBrowserEvent_);

    if (this.handleResize_ !== undefined) {
      removeEventListener(_EventType2.default.RESIZE, this.handleResize_, false);
      this.handleResize_ = undefined;
    }

    this.setTarget(null);

    _super.prototype.disposeInternal.call(this);
  };
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `opt_options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(this: S, import("./Feature.js").FeatureLike,
   *     import("./layer/Layer.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature feature} or
   *     {@link module:ol/render/Feature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions=} opt_options Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template S,T
   * @api
   */


  PluggableMap.prototype.forEachFeatureAtPixel = function (pixel, callback, opt_options) {
    if (!this.frameState_) {
      return;
    }

    var coordinate = this.getCoordinateFromPixelInternal(pixel);
    opt_options = opt_options !== undefined ? opt_options : {};
    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : _functions.TRUE;
    var checkWrapped = opt_options.checkWrapped !== false;
    return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
  };
  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions=} opt_options Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */


  PluggableMap.prototype.getFeaturesAtPixel = function (pixel, opt_options) {
    var features = [];
    this.forEachFeatureAtPixel(pixel, function (feature) {
      features.push(feature);
    }, opt_options);
    return features;
  };
  /**
   * Detect layers that have a color value at a pixel on the viewport, and
   * execute a callback with each matching layer. Layers included in the
   * detection can be configured through `opt_layerFilter`.
   *
   * Note: this may give false positives unless the map layers have had different `className`
   * properties assigned to them.
   *
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(this: S, import("./layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback
   *     Layer callback. This callback will receive two arguments: first is the
   *     {@link module:ol/layer/Layer layer}, second argument is an array representing
   *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
   *     that do not currently support this argument. To stop detection, callback
   *     functions can return a truthy value.
   * @param {AtPixelOptions=} opt_options Configuration options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template S,T
   * @api
   */


  PluggableMap.prototype.forEachLayerAtPixel = function (pixel, callback, opt_options) {
    if (!this.frameState_) {
      return;
    }

    var options = opt_options || {};
    var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance * this.frameState_.pixelRatio : 0;
    var layerFilter = options.layerFilter || _functions.TRUE;
    return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);
  };
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through `opt_layerFilter`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions=} opt_options Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */


  PluggableMap.prototype.hasFeatureAtPixel = function (pixel, opt_options) {
    if (!this.frameState_) {
      return false;
    }

    var coordinate = this.getCoordinateFromPixelInternal(pixel);
    opt_options = opt_options !== undefined ? opt_options : {};
    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : _functions.TRUE;
    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
    var checkWrapped = opt_options.checkWrapped !== false;
    return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
  };
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {Event} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */


  PluggableMap.prototype.getEventCoordinate = function (event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  };
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {Event} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */


  PluggableMap.prototype.getEventCoordinateInternal = function (event) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
  };
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {Event|TouchEvent} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */


  PluggableMap.prototype.getEventPixel = function (event) {
    var viewportPosition = this.viewport_.getBoundingClientRect();
    var eventPosition = 'changedTouches' in event ?
    /** @type {TouchEvent} */
    event.changedTouches[0] :
    /** @type {MouseEvent} */
    event;
    return [eventPosition.clientX - viewportPosition.left, eventPosition.clientY - viewportPosition.top];
  };
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */


  PluggableMap.prototype.getTarget = function () {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(_MapProperty.default.TARGET)
    );
  };
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */


  PluggableMap.prototype.getTargetElement = function () {
    var target = this.getTarget();

    if (target !== undefined) {
      return typeof target === 'string' ? document.getElementById(target) : target;
    } else {
      return null;
    }
  };
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */


  PluggableMap.prototype.getCoordinateFromPixel = function (pixel) {
    return (0, _proj.toUserCoordinate)(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
  };
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */


  PluggableMap.prototype.getCoordinateFromPixelInternal = function (pixel) {
    var frameState = this.frameState_;

    if (!frameState) {
      return null;
    } else {
      return (0, _transform.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
    }
  };
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */


  PluggableMap.prototype.getControls = function () {
    return this.controls;
  };
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */


  PluggableMap.prototype.getOverlays = function () {
    return this.overlays_;
  };
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default} Overlay.
   * @api
   */


  PluggableMap.prototype.getOverlayById = function (id) {
    var overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== undefined ? overlay : null;
  };
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */


  PluggableMap.prototype.getInteractions = function () {
    return this.interactions;
  };
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */


  PluggableMap.prototype.getLayerGroup = function () {
    return (
      /** @type {LayerGroup} */
      this.get(_MapProperty.default.LAYERGROUP)
    );
  };
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */


  PluggableMap.prototype.getLayers = function () {
    var layers = this.getLayerGroup().getLayers();
    return layers;
  };
  /**
   * @return {boolean} Layers have sources that are still loading.
   */


  PluggableMap.prototype.getLoading = function () {
    var layerStatesArray = this.getLayerGroup().getLayerStatesArray();

    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var layer = layerStatesArray[i].layer;
      var source =
      /** @type {import("./layer/Layer.js").default} */
      layer.getSource();

      if (source && source.loading) {
        return true;
      }
    }

    return false;
  };
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */


  PluggableMap.prototype.getPixelFromCoordinate = function (coordinate) {
    var viewCoordinate = (0, _proj.fromUserCoordinate)(coordinate, this.getView().getProjection());
    return this.getPixelFromCoordinateInternal(viewCoordinate);
  };
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */


  PluggableMap.prototype.getPixelFromCoordinateInternal = function (coordinate) {
    var frameState = this.frameState_;

    if (!frameState) {
      return null;
    } else {
      return (0, _transform.apply)(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
    }
  };
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default} Renderer
   */


  PluggableMap.prototype.getRenderer = function () {
    return this.renderer_;
  };
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */


  PluggableMap.prototype.getSize = function () {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(_MapProperty.default.SIZE)
    );
  };
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */


  PluggableMap.prototype.getView = function () {
    return (
      /** @type {View} */
      this.get(_MapProperty.default.VIEW)
    );
  };
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */


  PluggableMap.prototype.getViewport = function () {
    return this.viewport_;
  };
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */


  PluggableMap.prototype.getOverlayContainer = function () {
    return this.overlayContainer_;
  };
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */


  PluggableMap.prototype.getOverlayContainerStopEvent = function () {
    return this.overlayContainerStopEvent_;
  };
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */


  PluggableMap.prototype.getTilePriority = function (tile, tileSourceKey, tileCenter, tileResolution) {
    return (0, _TileQueue.getTilePriority)(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
  };
  /**
   * @param {Event} browserEvent Browser event.
   * @param {string=} opt_type Type.
   */


  PluggableMap.prototype.handleBrowserEvent = function (browserEvent, opt_type) {
    var type = opt_type || browserEvent.type;
    var mapBrowserEvent = new _MapBrowserEvent.default(type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  };
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */


  PluggableMap.prototype.handleMapBrowserEvent = function (mapBrowserEvent) {
    if (!this.frameState_) {
      // With no view defined, we cannot translate pixels into geographical
      // coordinates so interactions cannot be used.
      return;
    }

    var target =
    /** @type {Node} */
    mapBrowserEvent.originalEvent.target;

    if (!mapBrowserEvent.dragging) {
      if (this.overlayContainerStopEvent_.contains(target) || !(document.body.contains(target) || this.viewport_.getRootNode && this.viewport_.getRootNode().contains(target))) {
        // Abort if the event target is a child of the container that doesn't allow
        // event propagation or is no longer in the page. It's possible for the target to no longer
        // be in the page if it has been removed in an event listener, this might happen in a Control
        // that recreates it's content based on user interaction either manually or via a render
        // in something like https://reactjs.org/
        return;
      }
    }

    mapBrowserEvent.frameState = this.frameState_;
    var interactionsArray = this.getInteractions().getArray();

    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      for (var i = interactionsArray.length - 1; i >= 0; i--) {
        var interaction = interactionsArray[i];

        if (!interaction.getActive()) {
          continue;
        }

        var cont = interaction.handleEvent(mapBrowserEvent);

        if (!cont) {
          break;
        }
      }
    }
  };
  /**
   * @protected
   */


  PluggableMap.prototype.handlePostRender = function () {
    var frameState = this.frameState_; // Manage the tile queue
    // Image loads are expensive and a limited resource, so try to use them
    // efficiently:
    // * When the view is static we allow a large number of parallel tile loads
    //   to complete the frame as quickly as possible.
    // * When animating or interacting, image loads can cause janks, so we reduce
    //   the maximum number of loads per frame and limit the number of parallel
    //   tile loads to remain reactive to view changes and to reduce the chance of
    //   loading tiles that will quickly disappear from view.

    var tileQueue = this.tileQueue_;

    if (!tileQueue.isEmpty()) {
      var maxTotalLoading = this.maxTilesLoading_;
      var maxNewLoads = maxTotalLoading;

      if (frameState) {
        var hints = frameState.viewHints;

        if (hints[_ViewHint.default.ANIMATING] || hints[_ViewHint.default.INTERACTING]) {
          var lowOnFrameBudget = !_has.IMAGE_DECODE && Date.now() - frameState.time > 8;
          maxTotalLoading = lowOnFrameBudget ? 0 : 8;
          maxNewLoads = lowOnFrameBudget ? 0 : 2;
        }
      }

      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize(); // FIXME only call if view has changed

        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }

    if (frameState && this.hasListener(_EventType.default.RENDERCOMPLETE) && !frameState.animate && !this.tileQueue_.getTilesLoading() && !this.getLoading()) {
      this.renderer_.dispatchRenderEvent(_EventType.default.RENDERCOMPLETE, frameState);
    }

    var postRenderFunctions = this.postRenderFunctions_;

    for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
      postRenderFunctions[i](this, frameState);
    }

    postRenderFunctions.length = 0;
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleSizeChanged_ = function () {
    if (this.getView()) {
      this.getView().resolveConstraints(0);
    }

    this.render();
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleTargetChanged_ = function () {
    // target may be undefined, null, a string or an Element.
    // If it's a string we convert it to an Element before proceeding.
    // If it's not now an Element we remove the viewport from the DOM.
    // If it's an Element we append the viewport element to it.
    var targetElement;

    if (this.getTarget()) {
      targetElement = this.getTargetElement();
    }

    if (this.keyHandlerKeys_) {
      for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {
        (0, _events.unlistenByKey)(this.keyHandlerKeys_[i]);
      }

      this.keyHandlerKeys_ = null;
    }

    if (!targetElement) {
      if (this.renderer_) {
        clearTimeout(this.postRenderTimeoutHandle_);
        this.postRenderFunctions_.length = 0;
        this.renderer_.dispose();
        this.renderer_ = null;
      }

      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelayKey_ = undefined;
      }

      (0, _dom.removeNode)(this.viewport_);

      if (this.handleResize_ !== undefined) {
        removeEventListener(_EventType2.default.RESIZE, this.handleResize_, false);
        this.handleResize_ = undefined;
      }
    } else {
      targetElement.appendChild(this.viewport_);

      if (!this.renderer_) {
        this.renderer_ = this.createRenderer();
      }

      var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
      this.keyHandlerKeys_ = [(0, _events.listen)(keyboardEventTarget, _EventType2.default.KEYDOWN, this.handleBrowserEvent, this), (0, _events.listen)(keyboardEventTarget, _EventType2.default.KEYPRESS, this.handleBrowserEvent, this)];

      if (!this.handleResize_) {
        this.handleResize_ = this.updateSize.bind(this);
        window.addEventListener(_EventType2.default.RESIZE, this.handleResize_, false);
      }
    }

    this.updateSize(); // updateSize calls setSize, so no need to call this.render
    // ourselves here.
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleTileChange_ = function () {
    this.render();
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleViewPropertyChanged_ = function () {
    this.render();
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleViewChanged_ = function () {
    if (this.viewPropertyListenerKey_) {
      (0, _events.unlistenByKey)(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }

    if (this.viewChangeListenerKey_) {
      (0, _events.unlistenByKey)(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }

    var view = this.getView();

    if (view) {
      this.updateViewportSize_();
      this.viewPropertyListenerKey_ = (0, _events.listen)(view, _ObjectEventType.default.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
      this.viewChangeListenerKey_ = (0, _events.listen)(view, _EventType2.default.CHANGE, this.handleViewPropertyChanged_, this);
      view.resolveConstraints(0);
    }

    this.render();
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleLayerGroupChanged_ = function () {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(_events.unlistenByKey);
      this.layerGroupPropertyListenerKeys_ = null;
    }

    var layerGroup = this.getLayerGroup();

    if (layerGroup) {
      this.layerGroupPropertyListenerKeys_ = [(0, _events.listen)(layerGroup, _ObjectEventType.default.PROPERTYCHANGE, this.render, this), (0, _events.listen)(layerGroup, _EventType2.default.CHANGE, this.render, this)];
    }

    this.render();
  };
  /**
   * @return {boolean} Is rendered.
   */


  PluggableMap.prototype.isRendered = function () {
    return !!this.frameState_;
  };
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */


  PluggableMap.prototype.renderSync = function () {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }

    this.animationDelay_();
  };
  /**
   * Redraws all text after new fonts have loaded
   */


  PluggableMap.prototype.redrawText = function () {
    var layerStates = this.getLayerGroup().getLayerStatesArray();

    for (var i = 0, ii = layerStates.length; i < ii; ++i) {
      var layer = layerStates[i].layer;

      if (layer.hasRenderer()) {
        layer.getRenderer().handleFontsChanged();
      }
    }
  };
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */


  PluggableMap.prototype.render = function () {
    if (this.renderer_ && this.animationDelayKey_ === undefined) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  };
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */


  PluggableMap.prototype.removeControl = function (control) {
    return this.getControls().remove(control);
  };
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */


  PluggableMap.prototype.removeInteraction = function (interaction) {
    return this.getInteractions().remove(interaction);
  };
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */


  PluggableMap.prototype.removeLayer = function (layer) {
    var layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  };
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */


  PluggableMap.prototype.removeOverlay = function (overlay) {
    return this.getOverlays().remove(overlay);
  };
  /**
   * @param {number} time Time.
   * @private
   */


  PluggableMap.prototype.renderFrame_ = function (time) {
    var size = this.getSize();
    var view = this.getView();
    var previousFrameState = this.frameState_;
    /** @type {?FrameState} */

    var frameState = null;

    if (size !== undefined && (0, _size.hasArea)(size) && view && view.isDef()) {
      var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
      var viewState = view.getState();
      frameState = {
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutterItems: previousFrameState ? previousFrameState.declutterItems : [],
        extent: (0, _extent.getForViewAndSize)(viewState.center, viewState.resolution, viewState.rotation, size),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: size,
        tileQueue: this.tileQueue_,
        time: time,
        usedTiles: {},
        viewState: viewState,
        viewHints: viewHints,
        wantedTiles: {}
      };
    }

    this.frameState_ = frameState;
    this.renderer_.renderFrame(frameState);

    if (frameState) {
      if (frameState.animate) {
        this.render();
      }

      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);

      if (previousFrameState) {
        var moveStart = !this.previousExtent_ || !(0, _extent.isEmpty)(this.previousExtent_) && !(0, _extent.equals)(frameState.extent, this.previousExtent_);

        if (moveStart) {
          this.dispatchEvent(new _MapEvent.default(_MapEventType.default.MOVESTART, this, previousFrameState));
          this.previousExtent_ = (0, _extent.createOrUpdateEmpty)(this.previousExtent_);
        }
      }

      var idle = this.previousExtent_ && !frameState.viewHints[_ViewHint.default.ANIMATING] && !frameState.viewHints[_ViewHint.default.INTERACTING] && !(0, _extent.equals)(frameState.extent, this.previousExtent_);

      if (idle) {
        this.dispatchEvent(new _MapEvent.default(_MapEventType.default.MOVEEND, this, frameState));
        (0, _extent.clone)(frameState.extent, this.previousExtent_);
      }
    }

    this.dispatchEvent(new _MapEvent.default(_MapEventType.default.POSTRENDER, this, frameState));
    this.postRenderTimeoutHandle_ = setTimeout(this.handlePostRender.bind(this), 0);
  };
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */


  PluggableMap.prototype.setLayerGroup = function (layerGroup) {
    this.set(_MapProperty.default.LAYERGROUP, layerGroup);
  };
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */


  PluggableMap.prototype.setSize = function (size) {
    this.set(_MapProperty.default.SIZE, size);
  };
  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string|undefined} target The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */


  PluggableMap.prototype.setTarget = function (target) {
    this.set(_MapProperty.default.TARGET, target);
  };
  /**
   * Set the view for this map.
   * @param {View} view The view that controls this map.
   * @observable
   * @api
   */


  PluggableMap.prototype.setView = function (view) {
    this.set(_MapProperty.default.VIEW, view);
  };
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */


  PluggableMap.prototype.updateSize = function () {
    var targetElement = this.getTargetElement();

    if (!targetElement) {
      this.setSize(undefined);
    } else {
      var computedStyle = getComputedStyle(targetElement);
      this.setSize([targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']), targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth'])]);
    }

    this.updateViewportSize_();
  };
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @private
   */


  PluggableMap.prototype.updateViewportSize_ = function () {
    var view = this.getView();

    if (view) {
      var size = undefined;
      var computedStyle = getComputedStyle(this.viewport_);

      if (computedStyle.width && computedStyle.height) {
        size = [parseInt(computedStyle.width, 10), parseInt(computedStyle.height, 10)];
      }

      view.setViewportSize(size);
    }
  };

  return PluggableMap;
}(_Object.default);
/**
 * @param {MapOptions} options Map options.
 * @return {MapOptionsInternal} Internal map options.
 */


function createOptionsInternal(options) {
  /**
   * @type {HTMLElement|Document}
   */
  var keyboardEventTarget = null;

  if (options.keyboardEventTarget !== undefined) {
    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }
  /**
   * @type {Object<string, *>}
   */


  var values = {};
  var layerGroup = options.layers && typeof
  /** @type {?} */
  options.layers.getLayers === 'function' ?
  /** @type {LayerGroup} */
  options.layers : new _Group.default({
    layers:
    /** @type {Collection} */
    options.layers
  });
  values[_MapProperty.default.LAYERGROUP] = layerGroup;
  values[_MapProperty.default.TARGET] = options.target;
  values[_MapProperty.default.VIEW] = options.view !== undefined ? options.view : new _View.default();
  var controls;

  if (options.controls !== undefined) {
    if (Array.isArray(options.controls)) {
      controls = new _Collection.default(options.controls.slice());
    } else {
      (0, _asserts.assert)(typeof
      /** @type {?} */
      options.controls.getArray === 'function', 47); // Expected `controls` to be an array or an `import("./Collection.js").Collection`

      controls =
      /** @type {Collection} */
      options.controls;
    }
  }

  var interactions;

  if (options.interactions !== undefined) {
    if (Array.isArray(options.interactions)) {
      interactions = new _Collection.default(options.interactions.slice());
    } else {
      (0, _asserts.assert)(typeof
      /** @type {?} */
      options.interactions.getArray === 'function', 48); // Expected `interactions` to be an array or an `import("./Collection.js").Collection`

      interactions =
      /** @type {Collection} */
      options.interactions;
    }
  }

  var overlays;

  if (options.overlays !== undefined) {
    if (Array.isArray(options.overlays)) {
      overlays = new _Collection.default(options.overlays.slice());
    } else {
      (0, _asserts.assert)(typeof
      /** @type {?} */
      options.overlays.getArray === 'function', 49); // Expected `overlays` to be an array or an `import("./Collection.js").Collection`

      overlays = options.overlays;
    }
  } else {
    overlays = new _Collection.default();
  }

  return {
    controls: controls,
    interactions: interactions,
    keyboardEventTarget: keyboardEventTarget,
    overlays: overlays,
    values: values
  };
}

var _default = PluggableMap;
exports.default = _default;
},{"./Collection.js":"node_modules/ol/Collection.js","./CollectionEventType.js":"node_modules/ol/CollectionEventType.js","./MapBrowserEvent.js":"node_modules/ol/MapBrowserEvent.js","./MapBrowserEventHandler.js":"node_modules/ol/MapBrowserEventHandler.js","./MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","./MapEvent.js":"node_modules/ol/MapEvent.js","./MapEventType.js":"node_modules/ol/MapEventType.js","./MapProperty.js":"node_modules/ol/MapProperty.js","./render/EventType.js":"node_modules/ol/render/EventType.js","./Object.js":"node_modules/ol/Object.js","./ObjectEventType.js":"node_modules/ol/ObjectEventType.js","./TileQueue.js":"node_modules/ol/TileQueue.js","./View.js":"node_modules/ol/View.js","./ViewHint.js":"node_modules/ol/ViewHint.js","./asserts.js":"node_modules/ol/asserts.js","./dom.js":"node_modules/ol/dom.js","./events.js":"node_modules/ol/events.js","./events/EventType.js":"node_modules/ol/events/EventType.js","./extent.js":"node_modules/ol/extent.js","./functions.js":"node_modules/ol/functions.js","./has.js":"node_modules/ol/has.js","./layer/Group.js":"node_modules/ol/layer/Group.js","./size.js":"node_modules/ol/size.js","./transform.js":"node_modules/ol/transform.js","./proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/control/Control.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _functions = require("../functions.js");

var _MapEventType = _interopRequireDefault(require("../MapEventType.js"));

var _Object = _interopRequireDefault(require("../Object.js"));

var _dom = require("../dom.js");

var _events = require("../events.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/control/Control
 */


/**
 * @typedef {Object} Options
 * @property {HTMLElement} [element] The element is the control's
 * container element. This only needs to be specified if you're developing
 * a custom control.
 * @property {function(import("../MapEvent.js").default)} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want
 * the control to be rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * var myControl = new Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @api
 */
var Control =
/** @class */
function (_super) {
  __extends(Control, _super);
  /**
   * @param {Options} options Control options.
   */


  function Control(options) {
    var _this = _super.call(this) || this;
    /**
     * @protected
     * @type {HTMLElement}
     */


    _this.element = options.element ? options.element : null;
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.target_ = null;
    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */

    _this.map_ = null;
    /**
     * @protected
     * @type {!Array<import("../events.js").EventsKey>}
     */

    _this.listenerKeys = [];
    /**
     * @private
     * @type {function(import("../MapEvent.js").default): void}
     */

    _this.render_ = options.render ? options.render : _functions.VOID;

    if (options.target) {
      _this.setTarget(options.target);
    }

    return _this;
  }
  /**
   * @inheritDoc
   */


  Control.prototype.disposeInternal = function () {
    (0, _dom.removeNode)(this.element);

    _super.prototype.disposeInternal.call(this);
  };
  /**
   * Get the map associated with this control.
   * @return {import("../PluggableMap.js").default} Map.
   * @api
   */


  Control.prototype.getMap = function () {
    return this.map_;
  };
  /**
   * Remove the control from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   * @api
   */


  Control.prototype.setMap = function (map) {
    if (this.map_) {
      (0, _dom.removeNode)(this.element);
    }

    for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
      (0, _events.unlistenByKey)(this.listenerKeys[i]);
    }

    this.listenerKeys.length = 0;
    this.map_ = map;

    if (this.map_) {
      var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
      target.appendChild(this.element);

      if (this.render !== _functions.VOID) {
        this.listenerKeys.push((0, _events.listen)(map, _MapEventType.default.POSTRENDER, this.render, this));
      }

      map.render();
    }
  };
  /**
   * Update the projection. Rendering of the coordinates is done in
   * `handleMouseMove` and `handleMouseUp`.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */


  Control.prototype.render = function (mapEvent) {
    this.render_.call(this, mapEvent);
  };
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */


  Control.prototype.setTarget = function (target) {
    this.target_ = typeof target === 'string' ? document.getElementById(target) : target;
  };

  return Control;
}(_Object.default);

var _default = Control;
exports.default = _default;
},{"../functions.js":"node_modules/ol/functions.js","../MapEventType.js":"node_modules/ol/MapEventType.js","../Object.js":"node_modules/ol/Object.js","../dom.js":"node_modules/ol/dom.js","../events.js":"node_modules/ol/events.js"}],"node_modules/ol/css.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFontParameters = exports.CLASS_COLLAPSED = exports.CLASS_CONTROL = exports.CLASS_UNSUPPORTED = exports.CLASS_UNSELECTABLE = exports.CLASS_SELECTABLE = exports.CLASS_HIDDEN = void 0;

/**
 * @module ol/css
 */

/**
 * @typedef {Object} FontParameters
 * @property {string} style
 * @property {string} variant
 * @property {string} weight
 * @property {string} size
 * @property {string} lineHeight
 * @property {string} family
 * @property {Array<string>} families
 */

/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */
var CLASS_HIDDEN = 'ol-hidden';
/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */

exports.CLASS_HIDDEN = CLASS_HIDDEN;
var CLASS_SELECTABLE = 'ol-selectable';
/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */

exports.CLASS_SELECTABLE = CLASS_SELECTABLE;
var CLASS_UNSELECTABLE = 'ol-unselectable';
/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */

exports.CLASS_UNSELECTABLE = CLASS_UNSELECTABLE;
var CLASS_UNSUPPORTED = 'ol-unsupported';
/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */

exports.CLASS_UNSUPPORTED = CLASS_UNSUPPORTED;
var CLASS_CONTROL = 'ol-control';
/**
 * The CSS class that we'll give the DOM elements that are collapsed, i.e.
 * to those elements which usually can be expanded.
 *
 * @const
 * @type {string}
 */

exports.CLASS_CONTROL = CLASS_CONTROL;
var CLASS_COLLAPSED = 'ol-collapsed';
/**
 * From http://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
 * @type {RegExp}
 */

exports.CLASS_COLLAPSED = CLASS_COLLAPSED;
var fontRegEx = new RegExp(['^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)', '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)', '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)', '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?', '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))', '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))', '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$'].join(''), 'i');
var fontRegExMatchIndex = ['style', 'variant', 'weight', 'size', 'lineHeight', 'family'];
/**
 * Get the list of font families from a font spec.  Note that this doesn't work
 * for font families that have commas in them.
 * @param {string} fontSpec The CSS font property.
 * @return {FontParameters} The font parameters (or null if the input spec is invalid).
 */

var getFontParameters = function (fontSpec) {
  var match = fontSpec.match(fontRegEx);

  if (!match) {
    return null;
  }

  var style =
  /** @type {FontParameters} */
  {
    lineHeight: 'normal',
    size: '1.2em',
    style: 'normal',
    weight: 'normal',
    variant: 'normal'
  };

  for (var i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
    var value = match[i + 1];

    if (value !== undefined) {
      style[fontRegExMatchIndex[i]] = value;
    }
  }

  style.families = style.family.split(/,\s?/);
  return style;
};

exports.getFontParameters = getFontParameters;
},{}],"node_modules/ol/layer/Layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inView = inView;
exports.default = void 0;

var _events = require("../events.js");

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Object = require("../Object.js");

var _Base = _interopRequireDefault(require("./Base.js"));

var _Property = _interopRequireDefault(require("./Property.js"));

var _obj = require("../obj.js");

var _EventType2 = _interopRequireDefault(require("../render/EventType.js"));

var _State = _interopRequireDefault(require("../source/State.js"));

var _asserts = require("../asserts.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/Layer
 */


/**
 * @typedef {function(import("../PluggableMap.js").FrameState):HTMLElement} RenderFunction
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../source/Source.js").default} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:ol/layer/Layer#setSource layer.setSource(source)} after
 * construction.
 * @property {import("../PluggableMap.js").default} [map] Map.
 * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
 * HTML element. Will overwrite the default rendering for the layer.
 */

/**
 * @typedef {Object} State
 * @property {import("./Base.js").default} layer
 * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
 * @property {SourceState} sourceState
 * @property {boolean} visible
 * @property {boolean} managed
 * @property {import("../extent.js").Extent} [extent]
 * @property {number} zIndex
 * @property {number} maxResolution
 * @property {number} minResolution
 * @property {number} minZoom
 * @property {number} maxZoom
 */

/**
 * @classdesc
 * Base class from which all layer types are derived. This should only be instantiated
 * in the case where a custom layer is be added to the map with a custom `render` function.
 * Such a function can be specified in the `options` object, and is expected to return an HTML element.
 *
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with {@link module:ol/Map#addLayer}. Components
 * like {@link module:ol/interaction/Select~Select} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * {@link module:ol/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 *
 * Please note that for performance reasons several layers might get rendered to
 * the same HTML element, which will cause {@link module:ol/Map~Map#forEachLayerAtPixel} to
 * give false positives. To avoid this, apply different `className` properties to the
 * layers at creation time.
 *
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 *
 * @template {import("../source/Source.js").default} SourceType
 * @api
 */
var Layer =
/** @class */
function (_super) {
  __extends(Layer, _super);
  /**
   * @param {Options} options Layer options.
   */


  function Layer(options) {
    var _this = this;

    var baseOptions = (0, _obj.assign)({}, options);
    delete baseOptions.source;
    _this = _super.call(this, baseOptions) || this;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */

    _this.mapPrecomposeKey_ = null;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */

    _this.mapRenderKey_ = null;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */

    _this.sourceChangeKey_ = null;
    /**
     * @private
     * @type {import("../renderer/Layer.js").default}
     */

    _this.renderer_ = null; // Overwrite default render method with a custom one

    if (options.render) {
      _this.render = options.render;
    }

    if (options.map) {
      _this.setMap(options.map);
    }

    _this.addEventListener((0, _Object.getChangeEventType)(_Property.default.SOURCE), _this.handleSourcePropertyChange_);

    var source = options.source ?
    /** @type {SourceType} */
    options.source : null;

    _this.setSource(source);

    return _this;
  }
  /**
   * @inheritDoc
   */


  Layer.prototype.getLayersArray = function (opt_array) {
    var array = opt_array ? opt_array : [];
    array.push(this);
    return array;
  };
  /**
   * @inheritDoc
   */


  Layer.prototype.getLayerStatesArray = function (opt_states) {
    var states = opt_states ? opt_states : [];
    states.push(this.getLayerState());
    return states;
  };
  /**
   * Get the layer source.
   * @return {SourceType} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */


  Layer.prototype.getSource = function () {
    return (
      /** @type {SourceType} */
      this.get(_Property.default.SOURCE) || null
    );
  };
  /**
    * @inheritDoc
    */


  Layer.prototype.getSourceState = function () {
    var source = this.getSource();
    return !source ? _State.default.UNDEFINED : source.getState();
  };
  /**
   * @private
   */


  Layer.prototype.handleSourceChange_ = function () {
    this.changed();
  };
  /**
   * @private
   */


  Layer.prototype.handleSourcePropertyChange_ = function () {
    if (this.sourceChangeKey_) {
      (0, _events.unlistenByKey)(this.sourceChangeKey_);
      this.sourceChangeKey_ = null;
    }

    var source = this.getSource();

    if (source) {
      this.sourceChangeKey_ = (0, _events.listen)(source, _EventType.default.CHANGE, this.handleSourceChange_, this);
    }

    this.changed();
  };
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
   * an array of features.
   */


  Layer.prototype.getFeatures = function (pixel) {
    return this.renderer_.getFeatures(pixel);
  };
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement} The rendered element.
   */


  Layer.prototype.render = function (frameState, target) {
    var layerRenderer = this.getRenderer();

    if (layerRenderer.prepareFrame(frameState)) {
      return layerRenderer.renderFrame(frameState, target);
    }
  };
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection, and the callback in
   * {@link module:ol/Map#forEachLayerAtPixel} will receive `null` as layer. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map#addLayer} instead.
   * @param {import("../PluggableMap.js").default} map Map.
   * @api
   */


  Layer.prototype.setMap = function (map) {
    if (this.mapPrecomposeKey_) {
      (0, _events.unlistenByKey)(this.mapPrecomposeKey_);
      this.mapPrecomposeKey_ = null;
    }

    if (!map) {
      this.changed();
    }

    if (this.mapRenderKey_) {
      (0, _events.unlistenByKey)(this.mapRenderKey_);
      this.mapRenderKey_ = null;
    }

    if (map) {
      this.mapPrecomposeKey_ = (0, _events.listen)(map, _EventType2.default.PRECOMPOSE, function (evt) {
        var renderEvent =
        /** @type {import("../render/Event.js").default} */
        evt;
        var layerStatesArray = renderEvent.frameState.layerStatesArray;
        var layerState = this.getLayerState(false); // A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.

        (0, _asserts.assert)(!layerStatesArray.some(function (arrayLayerState) {
          return arrayLayerState.layer === layerState.layer;
        }), 67);
        layerStatesArray.push(layerState);
      }, this);
      this.mapRenderKey_ = (0, _events.listen)(this, _EventType.default.CHANGE, map.render, map);
      this.changed();
    }
  };
  /**
   * Set the layer source.
   * @param {SourceType} source The layer source.
   * @observable
   * @api
   */


  Layer.prototype.setSource = function (source) {
    this.set(_Property.default.SOURCE, source);
  };
  /**
   * Get the renderer for this layer.
   * @return {import("../renderer/Layer.js").default} The layer renderer.
   */


  Layer.prototype.getRenderer = function () {
    if (!this.renderer_) {
      this.renderer_ = this.createRenderer();
    }

    return this.renderer_;
  };
  /**
   * @return {boolean} The layer has a renderer.
   */


  Layer.prototype.hasRenderer = function () {
    return !!this.renderer_;
  };
  /**
   * Create a renderer for this layer.
   * @return {import("../renderer/Layer.js").default} A layer renderer.
   * @protected
   */


  Layer.prototype.createRenderer = function () {
    return null;
  };
  /**
   * @inheritDoc
   */


  Layer.prototype.disposeInternal = function () {
    this.setSource(null);

    _super.prototype.disposeInternal.call(this);
  };

  return Layer;
}(_Base.default);
/**
 * Return `true` if the layer is visible and if the provided view state
 * has resolution and zoom levels that are in range of the layer's min/max.
 * @param {State} layerState Layer state.
 * @param {import("../View.js").State} viewState View state.
 * @return {boolean} The layer is visible at the given view state.
 */


function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }

  var resolution = viewState.resolution;

  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }

  var zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}

var _default = Layer;
exports.default = _default;
},{"../events.js":"node_modules/ol/events.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../Object.js":"node_modules/ol/Object.js","./Base.js":"node_modules/ol/layer/Base.js","./Property.js":"node_modules/ol/layer/Property.js","../obj.js":"node_modules/ol/obj.js","../render/EventType.js":"node_modules/ol/render/EventType.js","../source/State.js":"node_modules/ol/source/State.js","../asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/control/Attribution.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.render = render;
exports.default = void 0;

var _array = require("../array.js");

var _Control = _interopRequireDefault(require("./Control.js"));

var _css = require("../css.js");

var _dom = require("../dom.js");

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Layer = require("../layer/Layer.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/control/Attribution
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-attribution'] CSS class name.
 * @property {HTMLElement|string} [target] Specify a target if you
 * want the control to be rendered outside of the map's
 * viewport.
 * @property {boolean} [collapsible] Specify if attributions can
 * be collapsed. If not specified, sources control this behavior with their
 * `attributionsCollapsible` setting.
 * @property {boolean} [collapsed=true] Specify if attributions should
 * be collapsed at startup.
 * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
 * @property {string} [label='i'] Text label to use for the
 * collapsed attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [collapseLabel='»'] Text label to use
 * for the expanded attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {function(import("../MapEvent.js").default)} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 */

/**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @api
 */
var Attribution =
/** @class */
function (_super) {
  __extends(Attribution, _super);
  /**
   * @param {Options=} opt_options Attribution options.
   */


  function Attribution(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render || render,
      target: options.target
    }) || this;
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.ulElement_ = document.createElement('ul');
    /**
     * @private
     * @type {boolean}
     */

    _this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;
    /**
     * @private
     * @type {boolean}
     */

    _this.overrideCollapsible_ = options.collapsible !== undefined;
    /**
     * @private
     * @type {boolean}
     */

    _this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;

    if (!_this.collapsible_) {
      _this.collapsed_ = false;
    }

    var className = options.className !== undefined ? options.className : 'ol-attribution';
    var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';
    var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00BB';

    if (typeof collapseLabel === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      _this.collapseLabel_ = document.createElement('span');
      _this.collapseLabel_.textContent = collapseLabel;
    } else {
      _this.collapseLabel_ = collapseLabel;
    }

    var label = options.label !== undefined ? options.label : 'i';

    if (typeof label === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      _this.label_ = document.createElement('span');
      _this.label_.textContent = label;
    } else {
      _this.label_ = label;
    }

    var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
    var button = document.createElement('button');
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(activeLabel);
    button.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_this), false);
    var cssClasses = className + ' ' + _css.CLASS_UNSELECTABLE + ' ' + _css.CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? ' ' + _css.CLASS_COLLAPSED : '') + (_this.collapsible_ ? '' : ' ol-uncollapsible');
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(_this.ulElement_);
    element.appendChild(button);
    /**
     * A list of currently rendered resolutions.
     * @type {Array<string>}
     * @private
     */

    _this.renderedAttributions_ = [];
    /**
     * @private
     * @type {boolean}
     */

    _this.renderedVisible_ = true;
    return _this;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */


  Attribution.prototype.collectSourceAttributions_ = function (frameState) {
    /**
     * Used to determine if an attribution already exists.
     * @type {!Object<string, boolean>}
     */
    var lookup = {};
    /**
     * A list of visible attributions.
     * @type {Array<string>}
     */

    var visibleAttributions = [];
    var layerStatesArray = frameState.layerStatesArray;

    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var layerState = layerStatesArray[i];

      if (!(0, _Layer.inView)(layerState, frameState.viewState)) {
        continue;
      }

      var source =
      /** @type {import("../layer/Layer.js").default} */
      layerState.layer.getSource();

      if (!source) {
        continue;
      }

      var attributionGetter = source.getAttributions();

      if (!attributionGetter) {
        continue;
      }

      var attributions = attributionGetter(frameState);

      if (!attributions) {
        continue;
      }

      if (!this.overrideCollapsible_ && source.getAttributionsCollapsible() === false) {
        this.setCollapsible(false);
      }

      if (Array.isArray(attributions)) {
        for (var j = 0, jj = attributions.length; j < jj; ++j) {
          if (!(attributions[j] in lookup)) {
            visibleAttributions.push(attributions[j]);
            lookup[attributions[j]] = true;
          }
        }
      } else {
        if (!(attributions in lookup)) {
          visibleAttributions.push(attributions);
          lookup[attributions] = true;
        }
      }
    }

    return visibleAttributions;
  };
  /**
   * @private
   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
   */


  Attribution.prototype.updateElement_ = function (frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = 'none';
        this.renderedVisible_ = false;
      }

      return;
    }

    var attributions = this.collectSourceAttributions_(frameState);
    var visible = attributions.length > 0;

    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? '' : 'none';
      this.renderedVisible_ = visible;
    }

    if ((0, _array.equals)(attributions, this.renderedAttributions_)) {
      return;
    }

    (0, _dom.removeChildren)(this.ulElement_); // append the attributions

    for (var i = 0, ii = attributions.length; i < ii; ++i) {
      var element = document.createElement('li');
      element.innerHTML = attributions[i];
      this.ulElement_.appendChild(element);
    }

    this.renderedAttributions_ = attributions;
  };
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */


  Attribution.prototype.handleClick_ = function (event) {
    event.preventDefault();
    this.handleToggle_();
  };
  /**
   * @private
   */


  Attribution.prototype.handleToggle_ = function () {
    this.element.classList.toggle(_css.CLASS_COLLAPSED);

    if (this.collapsed_) {
      (0, _dom.replaceNode)(this.collapseLabel_, this.label_);
    } else {
      (0, _dom.replaceNode)(this.label_, this.collapseLabel_);
    }

    this.collapsed_ = !this.collapsed_;
  };
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */


  Attribution.prototype.getCollapsible = function () {
    return this.collapsible_;
  };
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */


  Attribution.prototype.setCollapsible = function (collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }

    this.collapsible_ = collapsible;
    this.element.classList.toggle('ol-uncollapsible');

    if (!collapsible && this.collapsed_) {
      this.handleToggle_();
    }
  };
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */


  Attribution.prototype.setCollapsed = function (collapsed) {
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }

    this.handleToggle_();
  };
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */


  Attribution.prototype.getCollapsed = function () {
    return this.collapsed_;
  };

  return Attribution;
}(_Control.default);
/**
 * Update the attribution element.
 * @param {import("../MapEvent.js").default} mapEvent Map event.
 * @this {Attribution}
 */


function render(mapEvent) {
  this.updateElement_(mapEvent.frameState);
}

var _default = Attribution;
exports.default = _default;
},{"../array.js":"node_modules/ol/array.js","./Control.js":"node_modules/ol/control/Control.js","../css.js":"node_modules/ol/css.js","../dom.js":"node_modules/ol/dom.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../layer/Layer.js":"node_modules/ol/layer/Layer.js"}],"node_modules/ol/control/Rotate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.render = render;
exports.default = void 0;

var _Control = _interopRequireDefault(require("./Control.js"));

var _css = require("../css.js");

var _easing = require("../easing.js");

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/control/Rotate
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-rotate'] CSS class name.
 * @property {string|HTMLElement} [label='⇧'] Text label to use for the rotate button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
 * @property {function(import("../MapEvent.js").default)} [render] Function called when the control should
 * be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {function()} [resetNorth] Function called when the control is clicked.
 * This will override the default `resetNorth`.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @api
 */
var Rotate =
/** @class */
function (_super) {
  __extends(Rotate, _super);
  /**
   * @param {Options=} opt_options Rotate options.
   */


  function Rotate(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render || render,
      target: options.target
    }) || this;
    var className = options.className !== undefined ? options.className : 'ol-rotate';
    var label = options.label !== undefined ? options.label : '\u21E7';
    /**
     * @type {HTMLElement}
     * @private
     */

    _this.label_ = null;

    if (typeof label === 'string') {
      _this.label_ = document.createElement('span');
      _this.label_.className = 'ol-compass';
      _this.label_.textContent = label;
    } else {
      _this.label_ = label;

      _this.label_.classList.add('ol-compass');
    }

    var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';
    var button = document.createElement('button');
    button.className = className + '-reset';
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(_this.label_);
    button.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_this), false);
    var cssClasses = className + ' ' + _css.CLASS_UNSELECTABLE + ' ' + _css.CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(button);
    _this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;
    /**
     * @type {number}
     * @private
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    /**
     * @type {boolean}
     * @private
     */

    _this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.rotation_ = undefined;

    if (_this.autoHide_) {
      _this.element.classList.add(_css.CLASS_HIDDEN);
    }

    return _this;
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */


  Rotate.prototype.handleClick_ = function (event) {
    event.preventDefault();

    if (this.callResetNorth_ !== undefined) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  };
  /**
   * @private
   */


  Rotate.prototype.resetNorth_ = function () {
    var map = this.getMap();
    var view = map.getView();

    if (!view) {
      // the map does not have a view, so we can't act
      // upon it
      return;
    }

    var rotation = view.getRotation();

    if (rotation !== undefined) {
      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: _easing.easeOut
        });
      } else {
        view.setRotation(0);
      }
    }
  };

  return Rotate;
}(_Control.default);
/**
 * Update the rotate control element.
 * @param {import("../MapEvent.js").default} mapEvent Map event.
 * @this {Rotate}
 */


function render(mapEvent) {
  var frameState = mapEvent.frameState;

  if (!frameState) {
    return;
  }

  var rotation = frameState.viewState.rotation;

  if (rotation != this.rotation_) {
    var transform = 'rotate(' + rotation + 'rad)';

    if (this.autoHide_) {
      var contains = this.element.classList.contains(_css.CLASS_HIDDEN);

      if (!contains && rotation === 0) {
        this.element.classList.add(_css.CLASS_HIDDEN);
      } else if (contains && rotation !== 0) {
        this.element.classList.remove(_css.CLASS_HIDDEN);
      }
    }

    this.label_.style.transform = transform;
  }

  this.rotation_ = rotation;
}

var _default = Rotate;
exports.default = _default;
},{"./Control.js":"node_modules/ol/control/Control.js","../css.js":"node_modules/ol/css.js","../easing.js":"node_modules/ol/easing.js","../events/EventType.js":"node_modules/ol/events/EventType.js"}],"node_modules/ol/control/Zoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Control = _interopRequireDefault(require("./Control.js"));

var _css = require("../css.js");

var _easing = require("../easing.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/control/Zoom
 */


/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {string} [className='ol-zoom'] CSS class name.
 * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
 * button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [zoomOutLabel='-'] Text label to use for the zoom-out button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
 * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
 * @property {number} [delta=1] The zoom delta applied on each click.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @api
 */
var Zoom =
/** @class */
function (_super) {
  __extends(Zoom, _super);
  /**
   * @param {Options=} opt_options Zoom options.
   */


  function Zoom(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      target: options.target
    }) || this;
    var className = options.className !== undefined ? options.className : 'ol-zoom';
    var delta = options.delta !== undefined ? options.delta : 1;
    var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
    var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2212';
    var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
    var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : 'Zoom out';
    var inElement = document.createElement('button');
    inElement.className = className + '-in';
    inElement.setAttribute('type', 'button');
    inElement.title = zoomInTipLabel;
    inElement.appendChild(typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel);
    inElement.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_this, delta), false);
    var outElement = document.createElement('button');
    outElement.className = className + '-out';
    outElement.setAttribute('type', 'button');
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel);
    outElement.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_this, -delta), false);
    var cssClasses = className + ' ' + _css.CLASS_UNSELECTABLE + ' ' + _css.CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);
    /**
     * @type {number}
     * @private
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */


  Zoom.prototype.handleClick_ = function (delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  };
  /**
   * @param {number} delta Zoom delta.
   * @private
   */


  Zoom.prototype.zoomByDelta_ = function (delta) {
    var map = this.getMap();
    var view = map.getView();

    if (!view) {
      // the map does not have a view, so we can't act
      // upon it
      return;
    }

    var currentZoom = view.getZoom();

    if (currentZoom !== undefined) {
      var newZoom = view.getConstrainedZoom(currentZoom + delta);

      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }

        view.animate({
          zoom: newZoom,
          duration: this.duration_,
          easing: _easing.easeOut
        });
      } else {
        view.setZoom(newZoom);
      }
    }
  };

  return Zoom;
}(_Control.default);

var _default = Zoom;
exports.default = _default;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","./Control.js":"node_modules/ol/control/Control.js","../css.js":"node_modules/ol/css.js","../easing.js":"node_modules/ol/easing.js"}],"node_modules/ol/control/FullScreen.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Control = _interopRequireDefault(require("./Control.js"));

var _css = require("../css.js");

var _dom = require("../dom.js");

var _events = require("../events.js");

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/control/FullScreen
 */


var events = ['fullscreenchange', 'webkitfullscreenchange', 'MSFullscreenChange'];
/**
 * @enum {string}
 */

var FullScreenEventType = {
  /**
   * Triggered after the map entered fullscreen.
   * @event FullScreenEventType#enterfullscreen
   * @api
   */
  ENTERFULLSCREEN: 'enterfullscreen',

  /**
   * Triggered after the map leave fullscreen.
   * @event FullScreenEventType#leavefullscreen
   * @api
   */
  LEAVEFULLSCREEN: 'leavefullscreen'
};
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-full-screen'] CSS class name.
 * @property {string|Text} [label='\u2922'] Text label to use for the button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|Text} [labelActive='\u00d7'] Text label to use for the
 * button when full-screen is active.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Toggle full-screen'] Text label to use for the button tip.
 * @property {boolean} [keys=false] Full keyboard access.
 * @property {HTMLElement|string} [target] Specify a target if you want the
 * control to be rendered outside of the map's viewport.
 * @property {HTMLElement|string} [source] The element to be displayed
 * fullscreen. When not provided, the element containing the map viewport will
 * be displayed fullscreen.
 */

/**
 * @classdesc
 * Provides a button that when clicked fills up the full screen with the map.
 * The full screen source element is by default the element containing the map viewport unless
 * overridden by providing the `source` option. In which case, the dom
 * element introduced using this parameter will be displayed in full screen.
 *
 * When in full screen mode, a close button is shown to exit full screen mode.
 * The [Fullscreen API](http://www.w3.org/TR/fullscreen/) is used to
 * toggle the map in full screen mode.
 *
 * @fires FullScreenEventType#enterfullscreen
 * @fires FullScreenEventType#leavefullscreen
 * @api
 */

var FullScreen =
/** @class */
function (_super) {
  __extends(FullScreen, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function FullScreen(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      target: options.target
    }) || this;
    /**
     * @private
     * @type {string}
     */

    _this.cssClassName_ = options.className !== undefined ? options.className : 'ol-full-screen';
    var label = options.label !== undefined ? options.label : '\u2922';
    /**
     * @private
     * @type {Text}
     */

    _this.labelNode_ = typeof label === 'string' ? document.createTextNode(label) : label;
    var labelActive = options.labelActive !== undefined ? options.labelActive : '\u00d7';
    /**
     * @private
     * @type {Text}
     */

    _this.labelActiveNode_ = typeof labelActive === 'string' ? document.createTextNode(labelActive) : labelActive;
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.button_ = document.createElement('button');
    var tipLabel = options.tipLabel ? options.tipLabel : 'Toggle full-screen';

    _this.setClassName_(_this.button_, isFullScreen());

    _this.button_.setAttribute('type', 'button');

    _this.button_.title = tipLabel;

    _this.button_.appendChild(_this.labelNode_);

    _this.button_.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_this), false);

    var cssClasses = _this.cssClassName_ + ' ' + _css.CLASS_UNSELECTABLE + ' ' + _css.CLASS_CONTROL + ' ' + (!isFullScreenSupported() ? _css.CLASS_UNSUPPORTED : '');
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(_this.button_);
    /**
     * @private
     * @type {boolean}
     */

    _this.keys_ = options.keys !== undefined ? options.keys : false;
    /**
     * @private
     * @type {HTMLElement|string|undefined}
     */

    _this.source_ = options.source;
    return _this;
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */


  FullScreen.prototype.handleClick_ = function (event) {
    event.preventDefault();
    this.handleFullScreen_();
  };
  /**
   * @private
   */


  FullScreen.prototype.handleFullScreen_ = function () {
    if (!isFullScreenSupported()) {
      return;
    }

    var map = this.getMap();

    if (!map) {
      return;
    }

    if (isFullScreen()) {
      exitFullScreen();
    } else {
      var element = void 0;

      if (this.source_) {
        element = typeof this.source_ === 'string' ? document.getElementById(this.source_) : this.source_;
      } else {
        element = map.getTargetElement();
      }

      if (this.keys_) {
        requestFullScreenWithKeys(element);
      } else {
        requestFullScreen(element);
      }
    }
  };
  /**
   * @private
   */


  FullScreen.prototype.handleFullScreenChange_ = function () {
    var map = this.getMap();

    if (isFullScreen()) {
      this.setClassName_(this.button_, true);
      (0, _dom.replaceNode)(this.labelActiveNode_, this.labelNode_);
      this.dispatchEvent(FullScreenEventType.ENTERFULLSCREEN);
    } else {
      this.setClassName_(this.button_, false);
      (0, _dom.replaceNode)(this.labelNode_, this.labelActiveNode_);
      this.dispatchEvent(FullScreenEventType.LEAVEFULLSCREEN);
    }

    if (map) {
      map.updateSize();
    }
  };
  /**
   * @param {HTMLElement} element Target element
   * @param {boolean} fullscreen True if fullscreen class name should be active
   * @private
   */


  FullScreen.prototype.setClassName_ = function (element, fullscreen) {
    var activeClassName = this.cssClassName_ + '-true';
    var inactiveClassName = this.cssClassName_ + '-false';
    var nextClassName = fullscreen ? activeClassName : inactiveClassName;
    element.classList.remove(activeClassName);
    element.classList.remove(inactiveClassName);
    element.classList.add(nextClassName);
  };
  /**
   * @inheritDoc
   * @api
   */


  FullScreen.prototype.setMap = function (map) {
    _super.prototype.setMap.call(this, map);

    if (map) {
      for (var i = 0, ii = events.length; i < ii; ++i) {
        this.listenerKeys.push((0, _events.listen)(document, events[i], this.handleFullScreenChange_, this));
      }
    }
  };

  return FullScreen;
}(_Control.default);
/**
 * @return {boolean} Fullscreen is supported by the current platform.
 */


function isFullScreenSupported() {
  var body = document.body;
  return !!(body.webkitRequestFullscreen || body.msRequestFullscreen && document.msFullscreenEnabled || body.requestFullscreen && document.fullscreenEnabled);
}
/**
 * @return {boolean} Element is currently in fullscreen.
 */


function isFullScreen() {
  return !!(document.webkitIsFullScreen || document.msFullscreenElement || document.fullscreenElement);
}
/**
 * Request to fullscreen an element.
 * @param {HTMLElement} element Element to request fullscreen
 */


function requestFullScreen(element) {
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element.msRequestFullscreen) {
    element.msRequestFullscreen();
  } else if (element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen();
  }
}
/**
 * Request to fullscreen an element with keyboard input.
 * @param {HTMLElement} element Element to request fullscreen
 */


function requestFullScreenWithKeys(element) {
  if (element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen();
  } else {
    requestFullScreen(element);
  }
}
/**
 * Exit fullscreen.
 */


function exitFullScreen() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen();
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
  }
}

var _default = FullScreen;
exports.default = _default;
},{"./Control.js":"node_modules/ol/control/Control.js","../css.js":"node_modules/ol/css.js","../dom.js":"node_modules/ol/dom.js","../events.js":"node_modules/ol/events.js","../events/EventType.js":"node_modules/ol/events/EventType.js"}],"node_modules/ol/control/MousePosition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.render = render;
exports.default = void 0;

require("elm-pep");

var _events = require("../events.js");

var _EventType = _interopRequireDefault(require("../pointer/EventType.js"));

var _Object = require("../Object.js");

var _Control = _interopRequireDefault(require("./Control.js"));

var _proj = require("../proj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/control/MousePosition
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @type {string}
 */
var PROJECTION = 'projection';
/**
 * @type {string}
 */

var COORDINATE_FORMAT = 'coordinateFormat';
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-mouse-position'] CSS class name.
 * @property {import("../coordinate.js").CoordinateFormat} [coordinateFormat] Coordinate format.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {function(import("../MapEvent.js").default)} [render] Function called when the
 * control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want the
 * control to be rendered outside of the map's viewport.
 * @property {string} [undefinedHTML='&#160;'] Markup to show when coordinates are not
 * available (e.g. when the pointer leaves the map viewport).  By default, the last position
 * will be replaced with `'&#160;'` (`&nbsp;`) when the pointer leaves the viewport.  To
 * retain the last rendered position, set this option to something falsey (like an empty
 * string `''`).
 */

/**
 * @classdesc
 * A control to show the 2D coordinates of the mouse cursor. By default, these
 * are in the view projection, but can be in any supported projection.
 * By default the control is shown in the top right corner of the map, but this
 * can be changed by using the css selector `.ol-mouse-position`.
 *
 * On touch devices, which usually do not have a mouse cursor, the coordinates
 * of the currently touched position are shown.
 *
 * @api
 */

var MousePosition =
/** @class */
function (_super) {
  __extends(MousePosition, _super);
  /**
   * @param {Options=} opt_options Mouse position options.
   */


  function MousePosition(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var element = document.createElement('div');
    element.className = options.className !== undefined ? options.className : 'ol-mouse-position';
    _this = _super.call(this, {
      element: element,
      render: options.render || render,
      target: options.target
    }) || this;

    _this.addEventListener((0, _Object.getChangeEventType)(PROJECTION), _this.handleProjectionChanged_);

    if (options.coordinateFormat) {
      _this.setCoordinateFormat(options.coordinateFormat);
    }

    if (options.projection) {
      _this.setProjection(options.projection);
    }
    /**
     * @private
     * @type {string}
     */


    _this.undefinedHTML_ = options.undefinedHTML !== undefined ? options.undefinedHTML : '&#160;';
    /**
     * @private
     * @type {boolean}
     */

    _this.renderOnMouseOut_ = !!_this.undefinedHTML_;
    /**
     * @private
     * @type {string}
     */

    _this.renderedHTML_ = element.innerHTML;
    /**
     * @private
     * @type {?import("../proj/Projection.js").default}
     */

    _this.mapProjection_ = null;
    /**
     * @private
     * @type {?import("../proj.js").TransformFunction}
     */

    _this.transform_ = null;
    return _this;
  }
  /**
   * @private
   */


  MousePosition.prototype.handleProjectionChanged_ = function () {
    this.transform_ = null;
  };
  /**
   * Return the coordinate format type used to render the current position or
   * undefined.
   * @return {import("../coordinate.js").CoordinateFormat|undefined} The format to render the current
   *     position in.
   * @observable
   * @api
   */


  MousePosition.prototype.getCoordinateFormat = function () {
    return (
      /** @type {import("../coordinate.js").CoordinateFormat|undefined} */
      this.get(COORDINATE_FORMAT)
    );
  };
  /**
   * Return the projection that is used to report the mouse position.
   * @return {import("../proj/Projection.js").default|undefined} The projection to report mouse
   *     position in.
   * @observable
   * @api
   */


  MousePosition.prototype.getProjection = function () {
    return (
      /** @type {import("../proj/Projection.js").default|undefined} */
      this.get(PROJECTION)
    );
  };
  /**
   * @param {Event} event Browser event.
   * @protected
   */


  MousePosition.prototype.handleMouseMove = function (event) {
    var map = this.getMap();
    this.updateHTML_(map.getEventPixel(event));
  };
  /**
   * @param {Event} event Browser event.
   * @protected
   */


  MousePosition.prototype.handleMouseOut = function (event) {
    this.updateHTML_(null);
  };
  /**
   * @inheritDoc
   * @api
   */


  MousePosition.prototype.setMap = function (map) {
    _super.prototype.setMap.call(this, map);

    if (map) {
      var viewport = map.getViewport();
      this.listenerKeys.push((0, _events.listen)(viewport, _EventType.default.POINTERMOVE, this.handleMouseMove, this));

      if (this.renderOnMouseOut_) {
        this.listenerKeys.push((0, _events.listen)(viewport, _EventType.default.POINTEROUT, this.handleMouseOut, this));
      }
    }
  };
  /**
   * Set the coordinate format type used to render the current position.
   * @param {import("../coordinate.js").CoordinateFormat} format The format to render the current
   *     position in.
   * @observable
   * @api
   */


  MousePosition.prototype.setCoordinateFormat = function (format) {
    this.set(COORDINATE_FORMAT, format);
  };
  /**
   * Set the projection that is used to report the mouse position.
   * @param {import("../proj.js").ProjectionLike} projection The projection to report mouse
   *     position in.
   * @observable
   * @api
   */


  MousePosition.prototype.setProjection = function (projection) {
    this.set(PROJECTION, (0, _proj.get)(projection));
  };
  /**
   * @param {?import("../pixel.js").Pixel} pixel Pixel.
   * @private
   */


  MousePosition.prototype.updateHTML_ = function (pixel) {
    var html = this.undefinedHTML_;

    if (pixel && this.mapProjection_) {
      if (!this.transform_) {
        var projection = this.getProjection();

        if (projection) {
          this.transform_ = (0, _proj.getTransformFromProjections)(this.mapProjection_, projection);
        } else {
          this.transform_ = _proj.identityTransform;
        }
      }

      var map = this.getMap();
      var coordinate = map.getCoordinateFromPixelInternal(pixel);

      if (coordinate) {
        var userProjection = (0, _proj.getUserProjection)();

        if (userProjection) {
          this.transform_ = (0, _proj.getTransformFromProjections)(this.mapProjection_, userProjection);
        }

        this.transform_(coordinate, coordinate);
        var coordinateFormat = this.getCoordinateFormat();

        if (coordinateFormat) {
          html = coordinateFormat(coordinate);
        } else {
          html = coordinate.toString();
        }
      }
    }

    if (!this.renderedHTML_ || html !== this.renderedHTML_) {
      this.element.innerHTML = html;
      this.renderedHTML_ = html;
    }
  };

  return MousePosition;
}(_Control.default);
/**
 * Update the projection. Rendering of the coordinates is done in
 * `handleMouseMove` and `handleMouseUp`.
 * @param {import("../MapEvent.js").default} mapEvent Map event.
 * @this {MousePosition}
 */


function render(mapEvent) {
  var frameState = mapEvent.frameState;

  if (!frameState) {
    this.mapProjection_ = null;
  } else {
    if (this.mapProjection_ != frameState.viewState.projection) {
      this.mapProjection_ = frameState.viewState.projection;
      this.transform_ = null;
    }
  }
}

var _default = MousePosition;
exports.default = _default;
},{"elm-pep":"node_modules/elm-pep/dist/elm-pep.js","../events.js":"node_modules/ol/events.js","../pointer/EventType.js":"node_modules/ol/pointer/EventType.js","../Object.js":"node_modules/ol/Object.js","./Control.js":"node_modules/ol/control/Control.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/render/Event.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Event = _interopRequireDefault(require("../events/Event.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render/Event
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var RenderEvent =
/** @class */
function (_super) {
  __extends(RenderEvent, _super);
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform=} opt_inversePixelTransform Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../PluggableMap.js").FrameState=} opt_frameState Frame state.
   * @param {?CanvasRenderingContext2D=} opt_context Context.
   */


  function RenderEvent(type, opt_inversePixelTransform, opt_frameState, opt_context) {
    var _this = _super.call(this, type) || this;
    /**
     * Transform from CSS pixels (relative to the top-left corner of the map viewport)
     * to rendered pixels on this event's `context`.
     * @type {import("../transform.js").Transform|undefined}
     * @api
     */


    _this.inversePixelTransform = opt_inversePixelTransform;
    /**
     * An object representing the current render frame state.
     * @type {import("../PluggableMap.js").FrameState|undefined}
     * @api
     */

    _this.frameState = opt_frameState;
    /**
     * Canvas context. Not available when the event is dispatched by the map. Only available
     * when a Canvas renderer is used, null otherwise.
     * @type {CanvasRenderingContext2D|null|undefined}
     * @api
     */

    _this.context = opt_context;
    return _this;
  }

  return RenderEvent;
}(_Event.default);

var _default = RenderEvent;
exports.default = _default;
},{"../events/Event.js":"node_modules/ol/events/Event.js"}],"node_modules/ol/color.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.asString = asString;
exports.asArray = asArray;
exports.normalize = normalize;
exports.toString = toString;
exports.isStringColor = isStringColor;
exports.fromString = void 0;

var _asserts = require("./asserts.js");

var _math = require("./math.js");

/**
 * @module ol/color
 */

/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 * @typedef {Array<number>} Color
 * @api
 */

/**
 * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */
var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */

var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
/**
 * Return the color as an rgba string.
 * @param {Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */

function asString(color) {
  if (typeof color === 'string') {
    return color;
  } else {
    return toString(color);
  }
}
/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */


function fromNamed(color) {
  var el = document.createElement('div');
  el.style.color = color;

  if (el.style.color !== '') {
    document.body.appendChild(el);
    var rgb = getComputedStyle(el).color;
    document.body.removeChild(el);
    return rgb;
  } else {
    return '';
  }
}
/**
 * @param {string} s String.
 * @return {Color} Color.
 */


var fromString = function () {
  // We maintain a small cache of parsed strings.  To provide cheap LRU-like
  // semantics, whenever the cache grows too large we simply delete an
  // arbitrary 25% of the entries.

  /**
   * @const
   * @type {number}
   */
  var MAX_CACHE_SIZE = 1024;
  /**
   * @type {Object<string, Color>}
   */

  var cache = {};
  /**
   * @type {number}
   */

  var cacheSize = 0;
  return (
    /**
     * @param {string} s String.
     * @return {Color} Color.
     */
    function (s) {
      var color;

      if (cache.hasOwnProperty(s)) {
        color = cache[s];
      } else {
        if (cacheSize >= MAX_CACHE_SIZE) {
          var i = 0;

          for (var key in cache) {
            if ((i++ & 3) === 0) {
              delete cache[key];
              --cacheSize;
            }
          }
        }

        color = fromStringInternal_(s);
        cache[s] = color;
        ++cacheSize;
      }

      return color;
    }
  );
}();
/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {Color|string} color Color.
 * @return {Color} Color.
 * @api
 */


exports.fromString = fromString;

function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  } else {
    return fromString(color);
  }
}
/**
 * @param {string} s String.
 * @private
 * @return {Color} Color.
 */


function fromStringInternal_(s) {
  var r, g, b, a, color;

  if (NAMED_COLOR_RE_.exec(s)) {
    s = fromNamed(s);
  }

  if (HEX_COLOR_RE_.exec(s)) {
    // hex
    var n = s.length - 1; // number of hex digits

    var d = // number of digits per channel
    void 0; // number of digits per channel

    if (n <= 4) {
      d = 1;
    } else {
      d = 2;
    }

    var hasAlpha = n === 4 || n === 8;
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);

    if (hasAlpha) {
      a = parseInt(s.substr(1 + 3 * d, d), 16);
    } else {
      a = 255;
    }

    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;

      if (hasAlpha) {
        a = (a << 4) + a;
      }
    }

    color = [r, g, b, a / 255];
  } else if (s.indexOf('rgba(') == 0) {
    // rgba()
    color = s.slice(5, -1).split(',').map(Number);
    normalize(color);
  } else if (s.indexOf('rgb(') == 0) {
    // rgb()
    color = s.slice(4, -1).split(',').map(Number);
    color.push(1);
    normalize(color);
  } else {
    (0, _asserts.assert)(false, 14); // Invalid color
  }

  return color;
}
/**
 * TODO this function is only used in the test, we probably shouldn't export it
 * @param {Color} color Color.
 * @return {Color} Clamped color.
 */


function normalize(color) {
  color[0] = (0, _math.clamp)(color[0] + 0.5 | 0, 0, 255);
  color[1] = (0, _math.clamp)(color[1] + 0.5 | 0, 0, 255);
  color[2] = (0, _math.clamp)(color[2] + 0.5 | 0, 0, 255);
  color[3] = (0, _math.clamp)(color[3], 0, 1);
  return color;
}
/**
 * @param {Color} color Color.
 * @return {string} String.
 */


function toString(color) {
  var r = color[0];

  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }

  var g = color[1];

  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }

  var b = color[2];

  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }

  var a = color[3] === undefined ? 1 : color[3];
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}
/**
 * @param {string} s String.
 * @return {boolean} Whether the string is actually a valid color
 */


function isStringColor(s) {
  if (NAMED_COLOR_RE_.test(s)) {
    s = fromNamed(s);
  }

  return HEX_COLOR_RE_.test(s) || s.indexOf('rgba(') === 0 || s.indexOf('rgb(') === 0;
}
},{"./asserts.js":"node_modules/ol/asserts.js","./math.js":"node_modules/ol/math.js"}],"node_modules/ol/style/IconImageCache.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shared = exports.default = void 0;

var _color = require("../color.js");

/**
 * @module ol/style/IconImageCache
 */

/**
 * @classdesc
 * Singleton class. Available through {@link module:ol/style/IconImageCache~shared}.
 */
var IconImageCache =
/** @class */
function () {
  function IconImageCache() {
    /**
    * @type {!Object<string, import("./IconImage.js").default>}
    * @private
    */
    this.cache_ = {};
    /**
    * @type {number}
    * @private
    */

    this.cacheSize_ = 0;
    /**
    * @type {number}
    * @private
    */

    this.maxCacheSize_ = 32;
  }
  /**
  * FIXME empty description for jsdoc
  */


  IconImageCache.prototype.clear = function () {
    this.cache_ = {};
    this.cacheSize_ = 0;
  };
  /**
   * @return {boolean} Can expire cache.
   */


  IconImageCache.prototype.canExpireCache = function () {
    return this.cacheSize_ > this.maxCacheSize_;
  };
  /**
  * FIXME empty description for jsdoc
  */


  IconImageCache.prototype.expire = function () {
    if (this.canExpireCache()) {
      var i = 0;

      for (var key in this.cache_) {
        var iconImage = this.cache_[key];

        if ((i++ & 3) === 0 && !iconImage.hasListener()) {
          delete this.cache_[key];
          --this.cacheSize_;
        }
      }
    }
  };
  /**
  * @param {string} src Src.
  * @param {?string} crossOrigin Cross origin.
  * @param {import("../color.js").Color} color Color.
  * @return {import("./IconImage.js").default} Icon image.
  */


  IconImageCache.prototype.get = function (src, crossOrigin, color) {
    var key = getKey(src, crossOrigin, color);
    return key in this.cache_ ? this.cache_[key] : null;
  };
  /**
  * @param {string} src Src.
  * @param {?string} crossOrigin Cross origin.
  * @param {import("../color.js").Color} color Color.
  * @param {import("./IconImage.js").default} iconImage Icon image.
  */


  IconImageCache.prototype.set = function (src, crossOrigin, color, iconImage) {
    var key = getKey(src, crossOrigin, color);
    this.cache_[key] = iconImage;
    ++this.cacheSize_;
  };
  /**
  * Set the cache size of the icon cache. Default is `32`. Change this value when
  * your map uses more than 32 different icon images and you are not caching icon
  * styles on the application level.
  * @param {number} maxCacheSize Cache max size.
  * @api
  */


  IconImageCache.prototype.setSize = function (maxCacheSize) {
    this.maxCacheSize_ = maxCacheSize;
    this.expire();
  };

  return IconImageCache;
}();
/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../color.js").Color} color Color.
 * @return {string} Cache key.
 */


function getKey(src, crossOrigin, color) {
  var colorString = color ? (0, _color.asString)(color) : 'null';
  return crossOrigin + ':' + src + ':' + colorString;
}

var _default = IconImageCache;
/**
 * The {@link module:ol/style/IconImageCache~IconImageCache} for
 * {@link module:ol/style/Icon~Icon} images.
 * @api
 */

exports.default = _default;
var shared = new IconImageCache();
exports.shared = shared;
},{"../color.js":"node_modules/ol/color.js"}],"node_modules/ol/colorlike.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.asColorLike = asColorLike;

var _color = require("./color.js");

/**
 * @module ol/colorlike
 */

/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, pattern, or gradient. The origin for patterns and
 * gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */

/**
 * @param {import("./color.js").Color|ColorLike} color Color.
 * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
 * @api
 */
function asColorLike(color) {
  if (Array.isArray(color)) {
    return (0, _color.toString)(color);
  } else {
    return color;
  }
}
},{"./color.js":"node_modules/ol/color.js"}],"node_modules/ol/render/VectorContext.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/render/VectorContext
 */

/**
 * @classdesc
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @api
 */
var VectorContext =
/** @class */
function () {
  function VectorContext() {}
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   */


  VectorContext.prototype.drawCustom = function (geometry, feature, renderer) {};
  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */


  VectorContext.prototype.drawGeometry = function (geometry) {};
  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */


  VectorContext.prototype.setStyle = function (style) {};
  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   */


  VectorContext.prototype.drawCircle = function (circleGeometry, feature) {};
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   */


  VectorContext.prototype.drawFeature = function (feature, style) {};
  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   */


  VectorContext.prototype.drawGeometryCollection = function (geometryCollectionGeometry, feature) {};
  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawLineString = function (lineStringGeometry, feature) {};
  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {};
  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawMultiPoint = function (multiPointGeometry, feature) {};
  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {};
  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawPoint = function (pointGeometry, feature) {};
  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawPolygon = function (polygonGeometry, feature) {};
  /**
   * @param {import("../geom/Geometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawText = function (geometry, feature) {};
  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */


  VectorContext.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {};
  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("./canvas.js").DeclutterGroup=} opt_declutterGroup Declutter.
   */


  VectorContext.prototype.setImageStyle = function (imageStyle, opt_declutterGroup) {};
  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("./canvas.js").DeclutterGroups=} opt_declutterGroups Declutter.
   */


  VectorContext.prototype.setTextStyle = function (textStyle, opt_declutterGroups) {};

  return VectorContext;
}();

var _default = VectorContext;
exports.default = _default;
},{}],"node_modules/ol/render/canvas.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.measureTextWidth = measureTextWidth;
exports.measureAndCacheTextWidth = measureAndCacheTextWidth;
exports.measureTextWidths = measureTextWidths;
exports.rotateAtOffset = rotateAtOffset;
exports.drawImageOrLabel = drawImageOrLabel;
exports.createTransformString = createTransformString;
exports.measureTextHeight = exports.registerFont = exports.textHeights = exports.labelCache = exports.checkedFonts = exports.defaultLineWidth = exports.defaultPadding = exports.defaultTextBaseline = exports.defaultTextAlign = exports.defaultStrokeStyle = exports.defaultMiterLimit = exports.defaultLineJoin = exports.defaultLineDashOffset = exports.defaultLineDash = exports.defaultLineCap = exports.defaultFillStyle = exports.defaultFont = void 0;

var _css = require("../css.js");

var _dom = require("../dom.js");

var _obj = require("../obj.js");

var _Object = _interopRequireDefault(require("../Object.js"));

var _Target = _interopRequireDefault(require("../events/Target.js"));

var _has = require("../has.js");

var _transform = require("../transform.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render/canvas
 */

/**
 * @typedef {Object} FillState
 * @property {import("../colorlike.js").ColorLike} fillStyle
 */

/**
 * @typedef Label
 * @property {number} width
 * @property {number} height
 * @property {Array<string|number>} contextInstructions
 */

/**
 * @typedef {Object} FillStrokeState
 * @property {import("../colorlike.js").ColorLike} [currentFillStyle]
 * @property {import("../colorlike.js").ColorLike} [currentStrokeStyle]
 * @property {CanvasLineCap} [currentLineCap]
 * @property {Array<number>} currentLineDash
 * @property {number} [currentLineDashOffset]
 * @property {CanvasLineJoin} [currentLineJoin]
 * @property {number} [currentLineWidth]
 * @property {number} [currentMiterLimit]
 * @property {number} [lastStroke]
 * @property {import("../colorlike.js").ColorLike} [fillStyle]
 * @property {import("../colorlike.js").ColorLike} [strokeStyle]
 * @property {CanvasLineCap} [lineCap]
 * @property {Array<number>} lineDash
 * @property {number} [lineDashOffset]
 * @property {CanvasLineJoin} [lineJoin]
 * @property {number} [lineWidth]
 * @property {number} [miterLimit]
 */

/**
 * @typedef {Object} StrokeState
 * @property {CanvasLineCap} lineCap
 * @property {Array<number>} lineDash
 * @property {number} lineDashOffset
 * @property {CanvasLineJoin} lineJoin
 * @property {number} lineWidth
 * @property {number} miterLimit
 * @property {import("../colorlike.js").ColorLike} strokeStyle
 */

/**
 * @typedef {Object} TextState
 * @property {string} font
 * @property {string} [textAlign]
 * @property {string} textBaseline
 * @property {string} [placement]
 * @property {number} [maxAngle]
 * @property {boolean} [overflow]
 * @property {import("../style/Fill.js").default} [backgroundFill]
 * @property {import("../style/Stroke.js").default} [backgroundStroke]
 * @property {number} [scale]
 * @property {Array<number>} [padding]
 */

/**
 * Container for decluttered replay instructions that need to be rendered or
 * omitted together, i.e. when styles render both an image and text, or for the
 * characters that form text along lines. The basic elements of this array are
 * `[minX, minY, maxX, maxY, count]`, where the first four entries are the
 * rendered extent of the group in pixel space. `count` is the number of styles
 * in the group, i.e. 2 when an image and a text are grouped, or 1 otherwise.
 * In addition to these four elements, declutter instruction arrays (i.e. the
 * arguments to {@link module:ol/render/canvas~drawImage} are appended to the array.
 * @typedef {Array<*>} DeclutterGroup
 */

/**
 * Declutter groups for support of multi geometries.
 * @typedef {Array<DeclutterGroup>} DeclutterGroups
 */

/**
 * @const
 * @type {string}
 */
var defaultFont = '10px sans-serif';
/**
 * @const
 * @type {import("../colorlike.js").ColorLike}
 */

exports.defaultFont = defaultFont;
var defaultFillStyle = '#000';
/**
 * @const
 * @type {CanvasLineCap}
 */

exports.defaultFillStyle = defaultFillStyle;
var defaultLineCap = 'round';
/**
 * @const
 * @type {Array<number>}
 */

exports.defaultLineCap = defaultLineCap;
var defaultLineDash = [];
/**
 * @const
 * @type {number}
 */

exports.defaultLineDash = defaultLineDash;
var defaultLineDashOffset = 0;
/**
 * @const
 * @type {CanvasLineJoin}
 */

exports.defaultLineDashOffset = defaultLineDashOffset;
var defaultLineJoin = 'round';
/**
 * @const
 * @type {number}
 */

exports.defaultLineJoin = defaultLineJoin;
var defaultMiterLimit = 10;
/**
 * @const
 * @type {import("../colorlike.js").ColorLike}
 */

exports.defaultMiterLimit = defaultMiterLimit;
var defaultStrokeStyle = '#000';
/**
 * @const
 * @type {string}
 */

exports.defaultStrokeStyle = defaultStrokeStyle;
var defaultTextAlign = 'center';
/**
 * @const
 * @type {string}
 */

exports.defaultTextAlign = defaultTextAlign;
var defaultTextBaseline = 'middle';
/**
 * @const
 * @type {Array<number>}
 */

exports.defaultTextBaseline = defaultTextBaseline;
var defaultPadding = [0, 0, 0, 0];
/**
 * @const
 * @type {number}
 */

exports.defaultPadding = defaultPadding;
var defaultLineWidth = 1;
/**
 * @type {BaseObject}
 */

exports.defaultLineWidth = defaultLineWidth;
var checkedFonts = new _Object.default();
/**
 * The label cache for text rendering. To change the default cache size of 2048
 * entries, use {@link module:ol/structs/LRUCache#setSize}.
 * Deprecated - there is no label cache any more.
 * @type {?}
 * @api
 * @deprecated
 */

exports.checkedFonts = checkedFonts;
var labelCache = new _Target.default();
exports.labelCache = labelCache;

labelCache.setSize = function () {
  console.warn('labelCache is deprecated.'); //eslint-disable-line
};
/**
 * @type {CanvasRenderingContext2D}
 */


var measureContext = null;
/**
 * @type {string}
 */

var measureFont;
/**
 * @type {!Object<string, number>}
 */

var textHeights = {};
/**
 * Clears the label cache when a font becomes available.
 * @param {string} fontSpec CSS font spec.
 */

exports.textHeights = textHeights;

var registerFont = function () {
  var retries = 100;
  var size = '32px ';
  var referenceFonts = ['monospace', 'serif'];
  var len = referenceFonts.length;
  var text = 'wmytzilWMYTZIL@#/&?$%10\uF013';
  var interval, referenceWidth;
  /**
   * @param {string} fontStyle Css font-style
   * @param {string} fontWeight Css font-weight
   * @param {*} fontFamily Css font-family
   * @return {boolean} Font with style and weight is available
   */

  function isAvailable(fontStyle, fontWeight, fontFamily) {
    var available = true;

    for (var i = 0; i < len; ++i) {
      var referenceFont = referenceFonts[i];
      referenceWidth = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + referenceFont, text);

      if (fontFamily != referenceFont) {
        var width = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + fontFamily + ',' + referenceFont, text); // If width and referenceWidth are the same, then the fallback was used
        // instead of the font we wanted, so the font is not available.

        available = available && width != referenceWidth;
      }
    }

    if (available) {
      return true;
    }

    return false;
  }

  function check() {
    var done = true;
    var fonts = checkedFonts.getKeys();

    for (var i = 0, ii = fonts.length; i < ii; ++i) {
      var font = fonts[i];

      if (checkedFonts.get(font) < retries) {
        if (isAvailable.apply(this, font.split('\n'))) {
          (0, _obj.clear)(textHeights); // Make sure that loaded fonts are picked up by Safari

          measureContext = null;
          measureFont = undefined;
          checkedFonts.set(font, retries);
        } else {
          checkedFonts.set(font, checkedFonts.get(font) + 1, true);
          done = false;
        }
      }
    }

    if (done) {
      clearInterval(interval);
      interval = undefined;
    }
  }

  return function (fontSpec) {
    var font = (0, _css.getFontParameters)(fontSpec);

    if (!font) {
      return;
    }

    var families = font.families;

    for (var i = 0, ii = families.length; i < ii; ++i) {
      var family = families[i];
      var key = font.style + '\n' + font.weight + '\n' + family;

      if (checkedFonts.get(key) === undefined) {
        checkedFonts.set(key, retries, true);

        if (!isAvailable(font.style, font.weight, family)) {
          checkedFonts.set(key, 0, true);

          if (interval === undefined) {
            interval = setInterval(check, 32);
          }
        }
      }
    }
  };
}();
/**
 * @param {string} font Font to use for measuring.
 * @return {import("../size.js").Size} Measurement.
 */


exports.registerFont = registerFont;

var measureTextHeight = function () {
  /**
   * @type {HTMLDivElement}
   */
  var div;
  var heights = textHeights;
  return function (fontSpec) {
    var height = heights[fontSpec];

    if (height == undefined) {
      if (_has.WORKER_OFFSCREEN_CANVAS) {
        var font = (0, _css.getFontParameters)(fontSpec);
        var metrics = measureText(fontSpec, 'Žg');
        var lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
        textHeights[fontSpec] = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
      } else {
        if (!div) {
          div = document.createElement('div');
          div.innerHTML = 'M';
          div.style.margin = '0 !important';
          div.style.padding = '0 !important';
          div.style.position = 'absolute !important';
          div.style.left = '-99999px !important';
        }

        div.style.font = fontSpec;
        document.body.appendChild(div);
        height = div.offsetHeight;
        heights[fontSpec] = height;
        document.body.removeChild(div);
      }
    }

    return height;
  };
}();
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {TextMetrics} Text metrics.
 */


exports.measureTextHeight = measureTextHeight;

function measureText(font, text) {
  if (!measureContext) {
    measureContext = (0, _dom.createCanvasContext2D)(1, 1);
  }

  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }

  return measureContext.measureText(text);
}
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */


function measureTextWidth(font, text) {
  return measureText(font, text).width;
}
/**
 * Measure text width using a cache.
 * @param {string} font The font.
 * @param {string} text The text to measure.
 * @param {Object<string, number>} cache A lookup of cached widths by text.
 * @returns {number} The text width.
 */


function measureAndCacheTextWidth(font, text, cache) {
  if (text in cache) {
    return cache[text];
  }

  var width = measureTextWidth(font, text);
  cache[text] = width;
  return width;
}
/**
 * @param {string} font Font to use for measuring.
 * @param {Array<string>} lines Lines to measure.
 * @param {Array<number>} widths Array will be populated with the widths of
 * each line.
 * @return {number} Width of the whole text.
 */


function measureTextWidths(font, lines, widths) {
  var numLines = lines.length;
  var width = 0;

  for (var i = 0; i < numLines; ++i) {
    var currentWidth = measureTextWidth(font, lines[i]);
    width = Math.max(width, currentWidth);
    widths.push(currentWidth);
  }

  return width;
}
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */


function rotateAtOffset(context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
}
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {import("../transform.js").Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {Label|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} labelOrImage Label.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} scale Scale.
 */


function drawImageOrLabel(context, transform, opacity, labelOrImage, originX, originY, w, h, x, y, scale) {
  context.save();

  if (opacity !== 1) {
    context.globalAlpha *= opacity;
  }

  if (transform) {
    context.setTransform.apply(context, transform);
  }

  if (
  /** @type {*} */
  labelOrImage.contextInstructions) {
    // label
    context.translate(x, y);
    context.scale(scale, scale);
    executeLabelInstructions(
    /** @type {Label} */
    labelOrImage, context);
  } else {
    // image
    context.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    labelOrImage, originX, originY, w, h, x, y, w * scale, h * scale);
  }

  context.restore();
}
/**
 * @param {Label} label Label.
 * @param {CanvasRenderingContext2D} context Context.
 */


function executeLabelInstructions(label, context) {
  var contextInstructions = label.contextInstructions;

  for (var i = 0, ii = contextInstructions.length; i < ii; i += 2) {
    if (Array.isArray(contextInstructions[i + 1])) {
      context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
    } else {
      context[contextInstructions[i]] = contextInstructions[i + 1];
    }
  }
}
/**
 * @type {HTMLCanvasElement}
 * @private
 */


var createTransformStringCanvas = null;
/**
 * @param {import("../transform.js").Transform} transform Transform.
 * @return {string} CSS transform.
 */

function createTransformString(transform) {
  if (_has.WORKER_OFFSCREEN_CANVAS) {
    return (0, _transform.toString)(transform);
  } else {
    if (!createTransformStringCanvas) {
      createTransformStringCanvas = (0, _dom.createCanvasContext2D)(1, 1).canvas;
    }

    createTransformStringCanvas.style.transform = (0, _transform.toString)(transform);
    return createTransformStringCanvas.style.transform;
  }
}
},{"../css.js":"node_modules/ol/css.js","../dom.js":"node_modules/ol/dom.js","../obj.js":"node_modules/ol/obj.js","../Object.js":"node_modules/ol/Object.js","../events/Target.js":"node_modules/ol/events/Target.js","../has.js":"node_modules/ol/has.js","../transform.js":"node_modules/ol/transform.js"}],"node_modules/ol/render/canvas/Immediate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _array = require("../../array.js");

var _colorlike = require("../../colorlike.js");

var _extent = require("../../extent.js");

var _GeometryType = _interopRequireDefault(require("../../geom/GeometryType.js"));

var _SimpleGeometry = require("../../geom/SimpleGeometry.js");

var _transform = require("../../geom/flat/transform.js");

var _VectorContext = _interopRequireDefault(require("../VectorContext.js"));

var _canvas = require("../canvas.js");

var _transform2 = require("../../transform.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render/canvas/Immediate
 */
// FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol/geom/flat/transform~transform2D?
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @classdesc
 * A concrete subclass of {@link module:ol/render/VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 */
var CanvasImmediateRenderer =
/** @class */
function (_super) {
  __extends(CanvasImmediateRenderer, _super);
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number=} opt_squaredTolerance Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction=} opt_userTransform Transform from user to view projection.
   */


  function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation, opt_squaredTolerance, opt_userTransform) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */


    _this.context_ = context;
    /**
     * @private
     * @type {number}
     */

    _this.pixelRatio_ = pixelRatio;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    _this.extent_ = extent;
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    _this.transform_ = transform;
    /**
     * @private
     * @type {number}
     */

    _this.viewRotation_ = viewRotation;
    /**
     * @private
     * @type {number}
     */

    _this.squaredTolerance_ = opt_squaredTolerance;
    /**
     * @private
     * @type {import("../../proj.js").TransformFunction}
     */

    _this.userTransform_ = opt_userTransform;
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */

    _this.contextFillState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */

    _this.contextStrokeState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */

    _this.contextTextState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */

    _this.fillState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */

    _this.strokeState_ = null;
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */

    _this.image_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.imageAnchorX_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageAnchorY_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageHeight_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageOpacity_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageOriginX_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageOriginY_ = 0;
    /**
     * @private
     * @type {boolean}
     */

    _this.imageRotateWithView_ = false;
    /**
     * @private
     * @type {number}
     */

    _this.imageRotation_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageScale_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageWidth_ = 0;
    /**
     * @private
     * @type {string}
     */

    _this.text_ = '';
    /**
     * @private
     * @type {number}
     */

    _this.textOffsetX_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.textOffsetY_ = 0;
    /**
     * @private
     * @type {boolean}
     */

    _this.textRotateWithView_ = false;
    /**
     * @private
     * @type {number}
     */

    _this.textRotation_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.textScale_ = 0;
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */

    _this.textFillState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */

    _this.textStrokeState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */

    _this.textState_ = null;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.pixelCoordinates_ = [];
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    _this.tmpLocalTransform_ = (0, _transform2.create)();
    return _this;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */


  CanvasImmediateRenderer.prototype.drawImages_ = function (flatCoordinates, offset, end, stride) {
    if (!this.image_) {
      return;
    }

    var pixelCoordinates = (0, _transform.transform2D)(flatCoordinates, offset, end, 2, this.transform_, this.pixelCoordinates_);
    var context = this.context_;
    var localTransform = this.tmpLocalTransform_;
    var alpha = context.globalAlpha;

    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha * this.imageOpacity_;
    }

    var rotation = this.imageRotation_;

    if (this.imageRotateWithView_) {
      rotation += this.viewRotation_;
    }

    for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
      var x = pixelCoordinates[i] - this.imageAnchorX_;
      var y = pixelCoordinates[i + 1] - this.imageAnchorY_;

      if (rotation !== 0 || this.imageScale_ != 1) {
        var centerX = x + this.imageAnchorX_;
        var centerY = y + this.imageAnchorY_;
        (0, _transform2.compose)(localTransform, centerX, centerY, this.imageScale_, this.imageScale_, rotation, -centerX, -centerY);
        context.setTransform.apply(context, localTransform);
      }

      context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
    }

    if (rotation !== 0 || this.imageScale_ != 1) {
      context.setTransform(1, 0, 0, 1, 0, 0);
    }

    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha;
    }
  };
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */


  CanvasImmediateRenderer.prototype.drawText_ = function (flatCoordinates, offset, end, stride) {
    if (!this.textState_ || this.text_ === '') {
      return;
    }

    if (this.textFillState_) {
      this.setContextFillState_(this.textFillState_);
    }

    if (this.textStrokeState_) {
      this.setContextStrokeState_(this.textStrokeState_);
    }

    this.setContextTextState_(this.textState_);
    var pixelCoordinates = (0, _transform.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
    var context = this.context_;
    var rotation = this.textRotation_;

    if (this.textRotateWithView_) {
      rotation += this.viewRotation_;
    }

    for (; offset < end; offset += stride) {
      var x = pixelCoordinates[offset] + this.textOffsetX_;
      var y = pixelCoordinates[offset + 1] + this.textOffsetY_;

      if (rotation !== 0 || this.textScale_ != 1) {
        var localTransform = (0, _transform2.compose)(this.tmpLocalTransform_, x, y, this.textScale_, this.textScale_, rotation, -x, -y);
        context.setTransform.apply(context, localTransform);
      }

      if (this.textStrokeState_) {
        context.strokeText(this.text_, x, y);
      }

      if (this.textFillState_) {
        context.fillText(this.text_, x, y);
      }
    }

    if (rotation !== 0 || this.textScale_ != 1) {
      context.setTransform(1, 0, 0, 1, 0, 0);
    }
  };
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */


  CanvasImmediateRenderer.prototype.moveToLineTo_ = function (flatCoordinates, offset, end, stride, close) {
    var context = this.context_;
    var pixelCoordinates = (0, _transform.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
    context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
    var length = pixelCoordinates.length;

    if (close) {
      length -= 2;
    }

    for (var i = 2; i < length; i += 2) {
      context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
    }

    if (close) {
      context.closePath();
    }

    return end;
  };
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */


  CanvasImmediateRenderer.prototype.drawRings_ = function (flatCoordinates, offset, ends, stride) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
    }

    return offset;
  };
  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @override
   * @api
   */


  CanvasImmediateRenderer.prototype.drawCircle = function (geometry) {
    if (!(0, _extent.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }

    if (this.fillState_ || this.strokeState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }

      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }

      var pixelCoordinates = (0, _SimpleGeometry.transformGeom2D)(geometry, this.transform_, this.pixelCoordinates_);
      var dx = pixelCoordinates[2] - pixelCoordinates[0];
      var dy = pixelCoordinates[3] - pixelCoordinates[1];
      var radius = Math.sqrt(dx * dx + dy * dy);
      var context = this.context_;
      context.beginPath();
      context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);

      if (this.fillState_) {
        context.fill();
      }

      if (this.strokeState_) {
        context.stroke();
      }
    }

    if (this.text_ !== '') {
      this.drawText_(geometry.getCenter(), 0, 2, 2);
    }
  };
  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @override
   * @api
   */


  CanvasImmediateRenderer.prototype.setStyle = function (style) {
    this.setFillStrokeStyle(style.getFill(), style.getStroke());
    this.setImageStyle(style.getImage());
    this.setTextStyle(style.getText());
  };
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */


  CanvasImmediateRenderer.prototype.setTransform = function (transform) {
    this.transform_ = transform;
  };
  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate#setStyle} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @override
   * @api
   */


  CanvasImmediateRenderer.prototype.drawGeometry = function (geometry) {
    var type = geometry.getType();

    switch (type) {
      case _GeometryType.default.POINT:
        this.drawPoint(
        /** @type {import("../../geom/Point.js").default} */
        geometry);
        break;

      case _GeometryType.default.LINE_STRING:
        this.drawLineString(
        /** @type {import("../../geom/LineString.js").default} */
        geometry);
        break;

      case _GeometryType.default.POLYGON:
        this.drawPolygon(
        /** @type {import("../../geom/Polygon.js").default} */
        geometry);
        break;

      case _GeometryType.default.MULTI_POINT:
        this.drawMultiPoint(
        /** @type {import("../../geom/MultiPoint.js").default} */
        geometry);
        break;

      case _GeometryType.default.MULTI_LINE_STRING:
        this.drawMultiLineString(
        /** @type {import("../../geom/MultiLineString.js").default} */
        geometry);
        break;

      case _GeometryType.default.MULTI_POLYGON:
        this.drawMultiPolygon(
        /** @type {import("../../geom/MultiPolygon.js").default} */
        geometry);
        break;

      case _GeometryType.default.GEOMETRY_COLLECTION:
        this.drawGeometryCollection(
        /** @type {import("../../geom/GeometryCollection.js").default} */
        geometry);
        break;

      case _GeometryType.default.CIRCLE:
        this.drawCircle(
        /** @type {import("../../geom/Circle.js").default} */
        geometry);
        break;

      default:
    }
  };
  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @override
   * @api
   */


  CanvasImmediateRenderer.prototype.drawFeature = function (feature, style) {
    var geometry = style.getGeometryFunction()(feature);

    if (!geometry || !(0, _extent.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }

    this.setStyle(style);
    this.drawGeometry(geometry);
  };
  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   * @override
   */


  CanvasImmediateRenderer.prototype.drawGeometryCollection = function (geometry) {
    var geometries = geometry.getGeometriesArray();

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      this.drawGeometry(geometries[i]);
    }
  };
  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   * @override
   */


  CanvasImmediateRenderer.prototype.drawPoint = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/Point.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();

    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }

    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  };
  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   * @override
   */


  CanvasImmediateRenderer.prototype.drawMultiPoint = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/MultiPoint.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();

    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }

    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  };
  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   * @override
   */


  CanvasImmediateRenderer.prototype.drawLineString = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/LineString.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    if (!(0, _extent.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }

    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      var context = this.context_;
      var flatCoordinates = geometry.getFlatCoordinates();
      context.beginPath();
      this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
      context.stroke();
    }

    if (this.text_ !== '') {
      var flatMidpoint = geometry.getFlatMidpoint();
      this.drawText_(flatMidpoint, 0, 2, 2);
    }
  };
  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   * @override
   */


  CanvasImmediateRenderer.prototype.drawMultiLineString = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/MultiLineString.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    var geometryExtent = geometry.getExtent();

    if (!(0, _extent.intersects)(this.extent_, geometryExtent)) {
      return;
    }

    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      var context = this.context_;
      var flatCoordinates = geometry.getFlatCoordinates();
      var offset = 0;
      var ends =
      /** @type {Array<number>} */
      geometry.getEnds();
      var stride = geometry.getStride();
      context.beginPath();

      for (var i = 0, ii = ends.length; i < ii; ++i) {
        offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
      }

      context.stroke();
    }

    if (this.text_ !== '') {
      var flatMidpoints = geometry.getFlatMidpoints();
      this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
    }
  };
  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   * @override
   */


  CanvasImmediateRenderer.prototype.drawPolygon = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/Polygon.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    if (!(0, _extent.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }

    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }

      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }

      var context = this.context_;
      context.beginPath();
      this.drawRings_(geometry.getOrientedFlatCoordinates(), 0,
      /** @type {Array<number>} */
      geometry.getEnds(), geometry.getStride());

      if (this.fillState_) {
        context.fill();
      }

      if (this.strokeState_) {
        context.stroke();
      }
    }

    if (this.text_ !== '') {
      var flatInteriorPoint = geometry.getFlatInteriorPoint();
      this.drawText_(flatInteriorPoint, 0, 2, 2);
    }
  };
  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @override
   */


  CanvasImmediateRenderer.prototype.drawMultiPolygon = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/MultiPolygon.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    if (!(0, _extent.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }

    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }

      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }

      var context = this.context_;
      var flatCoordinates = geometry.getOrientedFlatCoordinates();
      var offset = 0;
      var endss = geometry.getEndss();
      var stride = geometry.getStride();
      context.beginPath();

      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        offset = this.drawRings_(flatCoordinates, offset, ends, stride);
      }

      if (this.fillState_) {
        context.fill();
      }

      if (this.strokeState_) {
        context.stroke();
      }
    }

    if (this.text_ !== '') {
      var flatInteriorPoints = geometry.getFlatInteriorPoints();
      this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
    }
  };
  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */


  CanvasImmediateRenderer.prototype.setContextFillState_ = function (fillState) {
    var context = this.context_;
    var contextFillState = this.contextFillState_;

    if (!contextFillState) {
      context.fillStyle = fillState.fillStyle;
      this.contextFillState_ = {
        fillStyle: fillState.fillStyle
      };
    } else {
      if (contextFillState.fillStyle != fillState.fillStyle) {
        contextFillState.fillStyle = fillState.fillStyle;
        context.fillStyle = fillState.fillStyle;
      }
    }
  };
  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */


  CanvasImmediateRenderer.prototype.setContextStrokeState_ = function (strokeState) {
    var context = this.context_;
    var contextStrokeState = this.contextStrokeState_;

    if (!contextStrokeState) {
      context.lineCap = strokeState.lineCap;

      if (context.setLineDash) {
        context.setLineDash(strokeState.lineDash);
        context.lineDashOffset = strokeState.lineDashOffset;
      }

      context.lineJoin = strokeState.lineJoin;
      context.lineWidth = strokeState.lineWidth;
      context.miterLimit = strokeState.miterLimit;
      context.strokeStyle = strokeState.strokeStyle;
      this.contextStrokeState_ = {
        lineCap: strokeState.lineCap,
        lineDash: strokeState.lineDash,
        lineDashOffset: strokeState.lineDashOffset,
        lineJoin: strokeState.lineJoin,
        lineWidth: strokeState.lineWidth,
        miterLimit: strokeState.miterLimit,
        strokeStyle: strokeState.strokeStyle
      };
    } else {
      if (contextStrokeState.lineCap != strokeState.lineCap) {
        contextStrokeState.lineCap = strokeState.lineCap;
        context.lineCap = strokeState.lineCap;
      }

      if (context.setLineDash) {
        if (!(0, _array.equals)(contextStrokeState.lineDash, strokeState.lineDash)) {
          context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
        }

        if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
          contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
          context.lineDashOffset = strokeState.lineDashOffset;
        }
      }

      if (contextStrokeState.lineJoin != strokeState.lineJoin) {
        contextStrokeState.lineJoin = strokeState.lineJoin;
        context.lineJoin = strokeState.lineJoin;
      }

      if (contextStrokeState.lineWidth != strokeState.lineWidth) {
        contextStrokeState.lineWidth = strokeState.lineWidth;
        context.lineWidth = strokeState.lineWidth;
      }

      if (contextStrokeState.miterLimit != strokeState.miterLimit) {
        contextStrokeState.miterLimit = strokeState.miterLimit;
        context.miterLimit = strokeState.miterLimit;
      }

      if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
        contextStrokeState.strokeStyle = strokeState.strokeStyle;
        context.strokeStyle = strokeState.strokeStyle;
      }
    }
  };
  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */


  CanvasImmediateRenderer.prototype.setContextTextState_ = function (textState) {
    var context = this.context_;
    var contextTextState = this.contextTextState_;
    var textAlign = textState.textAlign ? textState.textAlign : _canvas.defaultTextAlign;

    if (!contextTextState) {
      context.font = textState.font;
      context.textAlign =
      /** @type {CanvasTextAlign} */
      textAlign;
      context.textBaseline =
      /** @type {CanvasTextBaseline} */
      textState.textBaseline;
      this.contextTextState_ = {
        font: textState.font,
        textAlign: textAlign,
        textBaseline: textState.textBaseline
      };
    } else {
      if (contextTextState.font != textState.font) {
        contextTextState.font = textState.font;
        context.font = textState.font;
      }

      if (contextTextState.textAlign != textAlign) {
        contextTextState.textAlign =
        /** @type {CanvasTextAlign} */
        textAlign;
        context.textAlign =
        /** @type {CanvasTextAlign} */
        textAlign;
      }

      if (contextTextState.textBaseline != textState.textBaseline) {
        contextTextState.textBaseline =
        /** @type {CanvasTextBaseline} */
        textState.textBaseline;
        context.textBaseline =
        /** @type {CanvasTextBaseline} */
        textState.textBaseline;
      }
    }
  };
  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   * @override
   */


  CanvasImmediateRenderer.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
    if (!fillStyle) {
      this.fillState_ = null;
    } else {
      var fillStyleColor = fillStyle.getColor();
      this.fillState_ = {
        fillStyle: (0, _colorlike.asColorLike)(fillStyleColor ? fillStyleColor : _canvas.defaultFillStyle)
      };
    }

    if (!strokeStyle) {
      this.strokeState_ = null;
    } else {
      var strokeStyleColor = strokeStyle.getColor();
      var strokeStyleLineCap = strokeStyle.getLineCap();
      var strokeStyleLineDash = strokeStyle.getLineDash();
      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      var strokeStyleLineJoin = strokeStyle.getLineJoin();
      var strokeStyleWidth = strokeStyle.getWidth();
      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      this.strokeState_ = {
        lineCap: strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas.defaultLineCap,
        lineDash: strokeStyleLineDash ? strokeStyleLineDash : _canvas.defaultLineDash,
        lineDashOffset: strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvas.defaultLineDashOffset,
        lineJoin: strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvas.defaultLineJoin,
        lineWidth: this.pixelRatio_ * (strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas.defaultLineWidth),
        miterLimit: strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvas.defaultMiterLimit,
        strokeStyle: (0, _colorlike.asColorLike)(strokeStyleColor ? strokeStyleColor : _canvas.defaultStrokeStyle)
      };
    }
  };
  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @override
   */


  CanvasImmediateRenderer.prototype.setImageStyle = function (imageStyle) {
    if (!imageStyle) {
      this.image_ = null;
    } else {
      var imageAnchor = imageStyle.getAnchor(); // FIXME pixel ratio

      var imageImage = imageStyle.getImage(1);
      var imageOrigin = imageStyle.getOrigin();
      var imageSize = imageStyle.getSize();
      this.imageAnchorX_ = imageAnchor[0];
      this.imageAnchorY_ = imageAnchor[1];
      this.imageHeight_ = imageSize[1];
      this.image_ = imageImage;
      this.imageOpacity_ = imageStyle.getOpacity();
      this.imageOriginX_ = imageOrigin[0];
      this.imageOriginY_ = imageOrigin[1];
      this.imageRotateWithView_ = imageStyle.getRotateWithView();
      this.imageRotation_ = imageStyle.getRotation();
      this.imageScale_ = imageStyle.getScale() * this.pixelRatio_;
      this.imageWidth_ = imageSize[0];
    }
  };
  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @override
   */


  CanvasImmediateRenderer.prototype.setTextStyle = function (textStyle) {
    if (!textStyle) {
      this.text_ = '';
    } else {
      var textFillStyle = textStyle.getFill();

      if (!textFillStyle) {
        this.textFillState_ = null;
      } else {
        var textFillStyleColor = textFillStyle.getColor();
        this.textFillState_ = {
          fillStyle: (0, _colorlike.asColorLike)(textFillStyleColor ? textFillStyleColor : _canvas.defaultFillStyle)
        };
      }

      var textStrokeStyle = textStyle.getStroke();

      if (!textStrokeStyle) {
        this.textStrokeState_ = null;
      } else {
        var textStrokeStyleColor = textStrokeStyle.getColor();
        var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
        var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
        var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
        var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
        var textStrokeStyleWidth = textStrokeStyle.getWidth();
        var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : _canvas.defaultLineCap,
          lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : _canvas.defaultLineDash,
          lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : _canvas.defaultLineDashOffset,
          lineJoin: textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : _canvas.defaultLineJoin,
          lineWidth: textStrokeStyleWidth !== undefined ? textStrokeStyleWidth : _canvas.defaultLineWidth,
          miterLimit: textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : _canvas.defaultMiterLimit,
          strokeStyle: (0, _colorlike.asColorLike)(textStrokeStyleColor ? textStrokeStyleColor : _canvas.defaultStrokeStyle)
        };
      }

      var textFont = textStyle.getFont();
      var textOffsetX = textStyle.getOffsetX();
      var textOffsetY = textStyle.getOffsetY();
      var textRotateWithView = textStyle.getRotateWithView();
      var textRotation = textStyle.getRotation();
      var textScale = textStyle.getScale();
      var textText = textStyle.getText();
      var textTextAlign = textStyle.getTextAlign();
      var textTextBaseline = textStyle.getTextBaseline();
      this.textState_ = {
        font: textFont !== undefined ? textFont : _canvas.defaultFont,
        textAlign: textTextAlign !== undefined ? textTextAlign : _canvas.defaultTextAlign,
        textBaseline: textTextBaseline !== undefined ? textTextBaseline : _canvas.defaultTextBaseline
      };
      this.text_ = textText !== undefined ? textText : '';
      this.textOffsetX_ = textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
      this.textOffsetY_ = textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
      this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
      this.textRotation_ = textRotation !== undefined ? textRotation : 0;
      this.textScale_ = this.pixelRatio_ * (textScale !== undefined ? textScale : 1);
    }
  };

  return CanvasImmediateRenderer;
}(_VectorContext.default);

var _default = CanvasImmediateRenderer;
exports.default = _default;
},{"../../array.js":"node_modules/ol/array.js","../../colorlike.js":"node_modules/ol/colorlike.js","../../extent.js":"node_modules/ol/extent.js","../../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../../geom/SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","../../geom/flat/transform.js":"node_modules/ol/geom/flat/transform.js","../VectorContext.js":"node_modules/ol/render/VectorContext.js","../canvas.js":"node_modules/ol/render/canvas.js","../../transform.js":"node_modules/ol/transform.js"}],"node_modules/ol/ImageState.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/ImageState
 */

/**
 * @enum {number}
 */
var _default = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
exports.default = _default;
},{}],"node_modules/ol/render/canvas/BuilderType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/render/canvas/BuilderType
 */

/**
 * @enum {string}
 */
var _default = {
  CIRCLE: 'Circle',
  DEFAULT: 'Default',
  IMAGE: 'Image',
  LINE_STRING: 'LineString',
  POLYGON: 'Polygon',
  TEXT: 'Text'
};
exports.default = _default;
},{}],"node_modules/ol/renderer/vector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultOrder = defaultOrder;
exports.getSquaredTolerance = getSquaredTolerance;
exports.getTolerance = getTolerance;
exports.renderFeature = renderFeature;

var _util = require("../util.js");

var _ImageState = _interopRequireDefault(require("../ImageState.js"));

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _BuilderType = _interopRequireDefault(require("../render/canvas/BuilderType.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/renderer/vector
 */

/**
 * Tolerance for geometry simplification in device pixels.
 * @type {number}
 */
var SIMPLIFY_TOLERANCE = 0.5;
/**
 * @const
 * @type {Object<import("../geom/GeometryType.js").default,
 *                function(import("../render/canvas/BuilderGroup.js").default, import("../geom/Geometry.js").default,
 *                         import("../style/Style.js").default, Object): void>}
 */

var GEOMETRY_RENDERERS = {
  'Point': renderPointGeometry,
  'LineString': renderLineStringGeometry,
  'Polygon': renderPolygonGeometry,
  'MultiPoint': renderMultiPointGeometry,
  'MultiLineString': renderMultiLineStringGeometry,
  'MultiPolygon': renderMultiPolygonGeometry,
  'GeometryCollection': renderGeometryCollectionGeometry,
  'Circle': renderCircleGeometry
};
/**
 * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
 * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
 * @return {number} Order.
 */

function defaultOrder(feature1, feature2) {
  return parseInt((0, _util.getUid)(feature1), 10) - parseInt((0, _util.getUid)(feature2), 10);
}
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */


function getSquaredTolerance(resolution, pixelRatio) {
  var tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */


function getTolerance(resolution, pixelRatio) {
  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
 * @param {import("../geom/Circle.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 */


function renderCircleGeometry(builderGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (fillStyle || strokeStyle) {
    var circleReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.CIRCLE);
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.TEXT);
    textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(import("../events/Event.js").default): void} listener Listener function.
 * @param {import("../proj.js").TransformFunction} [opt_transform] Transform from user to view projection.
 * @return {boolean} `true` if style is loading.
 * @template T
 */


function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform) {
  var loading = false;
  var imageStyle = style.getImage();

  if (imageStyle) {
    var imageState = imageStyle.getImageState();

    if (imageState == _ImageState.default.LOADED || imageState == _ImageState.default.ERROR) {
      imageStyle.unlistenImageChange(listener);
    } else {
      if (imageState == _ImageState.default.IDLE) {
        imageStyle.load();
      }

      imageState = imageStyle.getImageState();
      imageStyle.listenImageChange(listener);
      loading = true;
    }
  }

  renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform);
  return loading;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
 */


function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform) {
  var geometry = style.getGeometryFunction()(feature);

  if (!geometry) {
    return;
  }

  var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);
  var renderer = style.getRenderer();

  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style, feature);
  } else {
    var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(replayGroup, simplifiedGeometry, style, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */


function renderGeometry(replayGroup, geometry, style, feature) {
  if (geometry.getType() == _GeometryType.default.GEOMETRY_COLLECTION) {
    var geometries =
    /** @type {import("../geom/GeometryCollection.js").default} */
    geometry.getGeometries();

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      renderGeometry(replayGroup, geometries[i], style, feature);
    }

    return;
  }

  var replay = replayGroup.getBuilder(style.getZIndex(), _BuilderType.default.DEFAULT);
  replay.drawCustom(
  /** @type {import("../geom/SimpleGeometry.js").default} */
  geometry, feature, style.getRenderer());
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 */


function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;

  for (i = 0, ii = geometries.length; i < ii; ++i) {
    var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
    geometryRenderer(replayGroup, geometries[i], style, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */


function renderLineStringGeometry(builderGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();

  if (strokeStyle) {
    var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.TEXT);
    textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */


function renderMultiLineStringGeometry(builderGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();

  if (strokeStyle) {
    var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.TEXT);
    textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 */


function renderMultiPolygonGeometry(builderGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (strokeStyle || fillStyle) {
    var polygonReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.TEXT);
    textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */


function renderPointGeometry(builderGroup, geometry, style, feature) {
  var imageStyle = style.getImage();

  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState.default.LOADED) {
      return;
    }

    var imageReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.IMAGE);
    imageReplay.setImageStyle(imageStyle, builderGroup.addDeclutter(false));
    imageReplay.drawPoint(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.TEXT);
    textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(!!imageStyle));
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */


function renderMultiPointGeometry(builderGroup, geometry, style, feature) {
  var imageStyle = style.getImage();

  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState.default.LOADED) {
      return;
    }

    var imageReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.IMAGE);
    imageReplay.setImageStyle(imageStyle, builderGroup.addDeclutter(false));
    imageReplay.drawMultiPoint(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.TEXT);
    textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(!!imageStyle));
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */


function renderPolygonGeometry(builderGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (fillStyle || strokeStyle) {
    var polygonReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.TEXT);
    textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}
},{"../util.js":"node_modules/ol/util.js","../ImageState.js":"node_modules/ol/ImageState.js","../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../render/canvas/BuilderType.js":"node_modules/ol/render/canvas/BuilderType.js"}],"node_modules/ol/render.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toContext = toContext;
exports.getVectorContext = getVectorContext;
exports.getRenderPixel = getRenderPixel;
exports.renderDeclutterItems = renderDeclutterItems;

var _has = require("./has.js");

var _transform = require("./transform.js");

var _Immediate = _interopRequireDefault(require("./render/canvas/Immediate.js"));

var _vector = require("./renderer/vector.js");

var _proj = require("./proj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render
 */

/**
 * @typedef {Object} State
 * @property {CanvasRenderingContext2D} context Canvas context that the layer is being rendered to.
 * @property {import("./Feature.js").FeatureLike} feature
 * @property {import("./geom/SimpleGeometry.js").default} geometry
 * @property {number} pixelRatio Pixel ratio used by the layer renderer.
 * @property {number} resolution Resolution that the render batch was created and optimized for.
 * This is not the view's resolution that is being rendered.
 * @property {number} rotation Rotation of the rendered layer in radians.
 */

/**
 * A function to be used when sorting features before rendering.
 * It takes two instances of {@link module:ol/Feature} or
 * {@link module:ol/render/Feature} and returns a `{number}`.
 *
 * @typedef {function(import("./Feature.js").FeatureLike, import("./Feature.js").FeatureLike):number} OrderFunction
 */

/**
 * @typedef {Object} ToContextOptions
 * @property {import("./size.js").Size} [size] Desired size of the canvas in css
 * pixels. When provided, both canvas and css size will be set according to the
 * `pixelRatio`. If not provided, the current canvas and css sizes will not be
 * altered.
 * @property {number} [pixelRatio=window.devicePixelRatio] Pixel ratio (canvas
 * pixel to css pixel ratio) for the canvas.
 */

/**
 * Binds a Canvas Immediate API to a canvas context, to allow drawing geometries
 * to the context's canvas.
 *
 * The units for geometry coordinates are css pixels relative to the top left
 * corner of the canvas element.
 * ```js
 * import {toContext} from 'ol/render';
 * import Fill from 'ol/style/Fill';
 * import Polygon from 'ol/geom/Polygon';
 *
 * var canvas = document.createElement('canvas');
 * var render = toContext(canvas.getContext('2d'),
 *     { size: [100, 100] });
 * render.setFillStrokeStyle(new Fill({ color: blue }));
 * render.drawPolygon(
 *     new Polygon([[[0, 0], [100, 100], [100, 0], [0, 0]]]));
 * ```
 *
 * @param {CanvasRenderingContext2D} context Canvas context.
 * @param {ToContextOptions=} opt_options Options.
 * @return {CanvasImmediateRenderer} Canvas Immediate.
 * @api
 */
function toContext(context, opt_options) {
  var canvas = context.canvas;
  var options = opt_options ? opt_options : {};
  var pixelRatio = options.pixelRatio || _has.DEVICE_PIXEL_RATIO;
  var size = options.size;

  if (size) {
    canvas.width = size[0] * pixelRatio;
    canvas.height = size[1] * pixelRatio;
    canvas.style.width = size[0] + 'px';
    canvas.style.height = size[1] + 'px';
  }

  var extent = [0, 0, canvas.width, canvas.height];
  var transform = (0, _transform.scale)((0, _transform.create)(), pixelRatio, pixelRatio);
  return new _Immediate.default(context, pixelRatio, extent, transform, 0);
}
/**
 * Gets a vector context for drawing to the event's canvas.
 * @param {import("./render/Event.js").default} event Render event.
 * @returns {CanvasImmediateRenderer} Vector context.
 * @api
 */


function getVectorContext(event) {
  var frameState = event.frameState;
  var transform = (0, _transform.multiply)(event.inversePixelTransform.slice(), frameState.coordinateToPixelTransform);
  var squaredTolerance = (0, _vector.getSquaredTolerance)(frameState.viewState.resolution, frameState.pixelRatio);
  var userTransform;
  var userProjection = (0, _proj.getUserProjection)();

  if (userProjection) {
    userTransform = (0, _proj.getTransformFromProjections)(userProjection, frameState.viewState.projection);
  }

  return new _Immediate.default(event.context, frameState.pixelRatio, frameState.extent, transform, frameState.viewState.rotation, squaredTolerance, userTransform);
}
/**
 * Gets the pixel of the event's canvas context from the map viewport's CSS pixel.
 * @param {import("./render/Event.js").default} event Render event.
 * @param {import("./pixel.js").Pixel} pixel CSS pixel relative to the top-left
 * corner of the map viewport.
 * @returns {import("./pixel.js").Pixel} Pixel on the event's canvas context.
 * @api
 */


function getRenderPixel(event, pixel) {
  var result = pixel.slice(0);
  (0, _transform.apply)(event.inversePixelTransform.slice(), result);
  return result;
}
/**
 * @param {import("./PluggableMap.js").FrameState} frameState Frame state.
 * @param {?} declutterTree Declutter tree.
 * @returns {?} Declutter tree.
 */


function renderDeclutterItems(frameState, declutterTree) {
  if (declutterTree) {
    declutterTree.clear();
  }

  var items = frameState.declutterItems;

  for (var z = items.length - 1; z >= 0; --z) {
    var item = items[z];
    var zIndexItems = item.items;

    for (var i = 0, ii = zIndexItems.length; i < ii; i += 3) {
      declutterTree = zIndexItems[i].renderDeclutter(zIndexItems[i + 1], zIndexItems[i + 2], item.opacity, declutterTree);
    }
  }

  items.length = 0;
  return declutterTree;
}
},{"./has.js":"node_modules/ol/has.js","./transform.js":"node_modules/ol/transform.js","./render/canvas/Immediate.js":"node_modules/ol/render/canvas/Immediate.js","./renderer/vector.js":"node_modules/ol/renderer/vector.js","./proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/renderer/Map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("../util.js");

var _Disposable = _interopRequireDefault(require("../Disposable.js"));

var _extent = require("../extent.js");

var _functions = require("../functions.js");

var _Layer = require("../layer/Layer.js");

var _IconImageCache = require("../style/IconImageCache.js");

var _transform = require("../transform.js");

var _render = require("../render.js");

var _coordinate = require("../coordinate.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/Map
 */


/**
 * @abstract
 */
var MapRenderer =
/** @class */
function (_super) {
  __extends(MapRenderer, _super);
  /**
   * @param {import("../PluggableMap.js").default} map Map.
   */


  function MapRenderer(map) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */


    _this.map_ = map;
    /**
     * @private
     */

    _this.declutterTree_ = null;
    return _this;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   */


  MapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {
    (0, _util.abstract)();
  };
  /**
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @protected
   */


  MapRenderer.prototype.calculateMatrices2D = function (frameState) {
    var viewState = frameState.viewState;
    var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
    (0, _transform.compose)(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
    (0, _transform.makeInverse)(pixelToCoordinateTransform, coordinateToPixelTransform);
  };
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: S, import("../Feature.js").FeatureLike,
   *     import("../layer/Layer.js").default): T} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */


  MapRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
    var result;
    var viewState = frameState.viewState;
    /**
     * @param {boolean} managed Managed layer.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../layer/Layer.js").default} layer Layer.
     * @return {?} Callback result.
     */

    function forEachFeatureAtCoordinate(managed, feature, layer) {
      return callback.call(thisArg, feature, managed ? layer : null);
    }

    var projection = viewState.projection;
    var translatedCoordinate = (0, _coordinate.wrapX)(coordinate.slice(), projection);
    var offsets = [[0, 0]];

    if (projection.canWrapX() && checkWrapped) {
      var projectionExtent = projection.getExtent();
      var worldWidth = (0, _extent.getWidth)(projectionExtent);
      offsets.push([-worldWidth, 0], [worldWidth, 0]);
    }

    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;
    var declutteredFeatures;

    if (this.declutterTree_) {
      declutteredFeatures = this.declutterTree_.all().map(function (entry) {
        return entry.value;
      });
    }

    var tmpCoord = [];

    for (var i = 0; i < offsets.length; i++) {
      for (var j = numLayers - 1; j >= 0; --j) {
        var layerState = layerStates[j];
        var layer =
        /** @type {import("../layer/Layer.js").default} */
        layerState.layer;

        if (layer.hasRenderer() && (0, _Layer.inView)(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
          var layerRenderer = layer.getRenderer();
          var source = layer.getSource();

          if (layerRenderer && source) {
            var coordinates = source.getWrapX() ? translatedCoordinate : coordinate;
            var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);
            tmpCoord[0] = coordinates[0] + offsets[i][0];
            tmpCoord[1] = coordinates[1] + offsets[i][1];
            result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, declutteredFeatures);
          }

          if (result) {
            return result;
          }
        }
      }
    }

    return undefined;
  };
  /**
   * @abstract
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(this: S, import("../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer
   *     callback.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */


  MapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {
    return (0, _util.abstract)();
  };
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */


  MapRenderer.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, _functions.TRUE, this, layerFilter, thisArg);
    return hasFeature !== undefined;
  };
  /**
   * @return {import("../PluggableMap.js").default} Map.
   */


  MapRenderer.prototype.getMap = function () {
    return this.map_;
  };
  /**
   * Render.
   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
   */


  MapRenderer.prototype.renderFrame = function (frameState) {
    this.declutterTree_ = (0, _render.renderDeclutterItems)(frameState, this.declutterTree_);
  };
  /**
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */


  MapRenderer.prototype.scheduleExpireIconCache = function (frameState) {
    if (_IconImageCache.shared.canExpireCache()) {
      frameState.postRenderFunctions.push(expireIconCache);
    }
  };

  return MapRenderer;
}(_Disposable.default);
/**
 * @param {import("../PluggableMap.js").default} map Map.
 * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
 */


function expireIconCache(map, frameState) {
  _IconImageCache.shared.expire();
}

var _default = MapRenderer;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","../Disposable.js":"node_modules/ol/Disposable.js","../extent.js":"node_modules/ol/extent.js","../functions.js":"node_modules/ol/functions.js","../layer/Layer.js":"node_modules/ol/layer/Layer.js","../style/IconImageCache.js":"node_modules/ol/style/IconImageCache.js","../transform.js":"node_modules/ol/transform.js","../render.js":"node_modules/ol/render.js","../coordinate.js":"node_modules/ol/coordinate.js"}],"node_modules/ol/renderer/Composite.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _css = require("../css.js");

var _Layer = require("../layer/Layer.js");

var _Event = _interopRequireDefault(require("../render/Event.js"));

var _EventType = _interopRequireDefault(require("../render/EventType.js"));

var _Map = _interopRequireDefault(require("./Map.js"));

var _State = _interopRequireDefault(require("../source/State.js"));

var _dom = require("../dom.js");

var _events = require("../events.js");

var _canvas = require("../render/canvas.js");

var _ObjectEventType = _interopRequireDefault(require("../ObjectEventType.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/Composite
 */


/**
 * @classdesc
 * Canvas map renderer.
 * @api
 */
var CompositeMapRenderer =
/** @class */
function (_super) {
  __extends(CompositeMapRenderer, _super);
  /**
   * @param {import("../PluggableMap.js").default} map Map.
   */


  function CompositeMapRenderer(map) {
    var _this = _super.call(this, map) || this;
    /**
     * @type {import("../events.js").EventsKey}
     */


    _this.fontChangeListenerKey_ = (0, _events.listen)(_canvas.checkedFonts, _ObjectEventType.default.PROPERTYCHANGE, map.redrawText.bind(map));
    /**
     * @private
     * @type {HTMLDivElement}
     */

    _this.element_ = document.createElement('div');
    var style = _this.element_.style;
    style.position = 'absolute';
    style.width = '100%';
    style.height = '100%';
    style.zIndex = '0';
    _this.element_.className = _css.CLASS_UNSELECTABLE + ' ol-layers';
    var container = map.getViewport();
    container.insertBefore(_this.element_, container.firstChild || null);
    /**
     * @private
     * @type {Array<HTMLElement>}
     */

    _this.children_ = [];
    /**
     * @private
     * @type {boolean}
     */

    _this.renderedVisible_ = true;
    return _this;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   */


  CompositeMapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {
    var map = this.getMap();

    if (map.hasListener(type)) {
      var event_1 = new _Event.default(type, undefined, frameState);
      map.dispatchEvent(event_1);
    }
  };

  CompositeMapRenderer.prototype.disposeInternal = function () {
    (0, _events.unlistenByKey)(this.fontChangeListenerKey_);
    this.element_.parentNode.removeChild(this.element_);

    _super.prototype.disposeInternal.call(this);
  };
  /**
   * @inheritDoc
   */


  CompositeMapRenderer.prototype.renderFrame = function (frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element_.style.display = 'none';
        this.renderedVisible_ = false;
      }

      return;
    }

    this.calculateMatrices2D(frameState);
    this.dispatchRenderEvent(_EventType.default.PRECOMPOSE, frameState);
    var layerStatesArray = frameState.layerStatesArray.sort(function (a, b) {
      return a.zIndex - b.zIndex;
    });
    var viewState = frameState.viewState;
    this.children_.length = 0;
    var previousElement = null;

    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var layerState = layerStatesArray[i];
      frameState.layerIndex = i;

      if (!(0, _Layer.inView)(layerState, viewState) || layerState.sourceState != _State.default.READY && layerState.sourceState != _State.default.UNDEFINED) {
        continue;
      }

      var layer = layerState.layer;
      var element = layer.render(frameState, previousElement);

      if (!element) {
        continue;
      }

      if (element !== previousElement) {
        this.children_.push(element);
        previousElement = element;
      }
    }

    _super.prototype.renderFrame.call(this, frameState);

    (0, _dom.replaceChildren)(this.element_, this.children_);
    this.dispatchRenderEvent(_EventType.default.POSTCOMPOSE, frameState);

    if (!this.renderedVisible_) {
      this.element_.style.display = '';
      this.renderedVisible_ = true;
    }

    this.scheduleExpireIconCache(frameState);
  };
  /**
   * @inheritDoc
   */


  CompositeMapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {
    var viewState = frameState.viewState;
    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;

    for (var i = numLayers - 1; i >= 0; --i) {
      var layerState = layerStates[i];
      var layer = layerState.layer;

      if (layer.hasRenderer() && (0, _Layer.inView)(layerState, viewState) && layerFilter(layer)) {
        var layerRenderer = layer.getRenderer();
        var data = layerRenderer.getDataAtPixel(pixel, frameState, hitTolerance);

        if (data) {
          var result = callback(layer, data);

          if (result) {
            return result;
          }
        }
      }
    }

    return undefined;
  };

  return CompositeMapRenderer;
}(_Map.default);

var _default = CompositeMapRenderer;
exports.default = _default;
},{"../css.js":"node_modules/ol/css.js","../layer/Layer.js":"node_modules/ol/layer/Layer.js","../render/Event.js":"node_modules/ol/render/Event.js","../render/EventType.js":"node_modules/ol/render/EventType.js","./Map.js":"node_modules/ol/renderer/Map.js","../source/State.js":"node_modules/ol/source/State.js","../dom.js":"node_modules/ol/dom.js","../events.js":"node_modules/ol/events.js","../render/canvas.js":"node_modules/ol/render/canvas.js","../ObjectEventType.js":"node_modules/ol/ObjectEventType.js"}],"node_modules/ol/OverlayPositioning.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/OverlayPositioning
 */

/**
 * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, `'top-right'`
 * @enum {string}
 */
var _default = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_CENTER: 'bottom-center',
  BOTTOM_RIGHT: 'bottom-right',
  CENTER_LEFT: 'center-left',
  CENTER_CENTER: 'center-center',
  CENTER_RIGHT: 'center-right',
  TOP_LEFT: 'top-left',
  TOP_CENTER: 'top-center',
  TOP_RIGHT: 'top-right'
};
exports.default = _default;
},{}],"node_modules/ol/Overlay.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MapEventType = _interopRequireDefault(require("./MapEventType.js"));

var _Object = _interopRequireWildcard(require("./Object.js"));

var _OverlayPositioning = _interopRequireDefault(require("./OverlayPositioning.js"));

var _css = require("./css.js");

var _dom = require("./dom.js");

var _events = require("./events.js");

var _extent = require("./extent.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/Overlay
 */


/**
 * @typedef {Object} Options
 * @property {number|string} [id] Set the overlay id. The overlay id can be used
 * with the {@link module:ol/Map~Map#getOverlayById} method.
 * @property {HTMLElement} [element] The overlay element.
 * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning
 * the overlay. The first element in the
 * array is the horizontal offset. A positive value shifts the overlay right.
 * The second element in the array is the vertical offset. A positive value
 * shifts the overlay down.
 * @property {import("./coordinate.js").Coordinate} [position] The overlay position
 * in map projection.
 * @property {OverlayPositioning} [positioning='top-left'] Defines how
 * the overlay is actually positioned with respect to its `position` property.
 * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, and `'top-right'`.
 * @property {boolean} [stopEvent=true] Whether event propagation to the map
 * viewport should be stopped. If `true` the overlay is placed in the same
 * container as that of the controls (CSS class name
 * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container
 * with CSS class name specified by the `className` property.
 * @property {boolean} [insertFirst=true] Whether the overlay is inserted first
 * in the overlay container, or appended. If the overlay is placed in the same
 * container as that of the controls (see the `stopEvent` option) you will
 * probably set `insertFirst` to `true` so the overlay is displayed below the
 * controls.
 * @property {PanIntoViewOptions|boolean} [autoPan=false] Pan the map when calling
 * `setPosition`, so that the overlay is entirely visible in the current viewport?
 * If `true` (deprecated), then `autoPanAnimation` and `autoPanMargin` will be
 * used to determine the panning parameters; if an object is supplied then other
 * parameters are ignored.
 * @property {PanOptions} [autoPanAnimation] The animation options used to pan
 * the overlay into view. This animation is only used when `autoPan` is enabled.
 * A `duration` and `easing` may be provided to customize the animation.
 * Deprecated and ignored if `autoPan` is supplied as an object.
 * @property {number} [autoPanMargin=20] The margin (in pixels) between the
 * overlay and the borders of the map when autopanning. Deprecated and ignored
 * if `autoPan` is supplied as an object.
 * @property {PanIntoViewOptions} [autoPanOptions] The options to use for the
 * autoPan. This is only used when `autoPan` is enabled and has preference over
 * the individual `autoPanMargin` and `autoPanOptions`.
 * @property {string} [className='ol-overlay-container ol-selectable'] CSS class
 * name.
 */

/**
 * @typedef {Object} PanOptions
 * @property {number} [duration=1000] The duration of the animation in
 * milliseconds.
 * @property {function(number):number} [easing] The easing function to use. Can
 * be one from {@link module:ol/easing} or a custom function.
 * Default is {@link module:ol/easing~inAndOut}.
 */

/**
 * @typedef {Object} PanIntoViewOptions
 * @property {PanOptions} [animation={}] The animation parameters for the pan
 * @property {number} [margin=20] The margin (in pixels) between the
 * overlay and the borders of the map when panning into view.
 */

/**
 * @enum {string}
 * @protected
 */
var Property = {
  ELEMENT: 'element',
  MAP: 'map',
  OFFSET: 'offset',
  POSITION: 'position',
  POSITIONING: 'positioning'
};
/**
 * @classdesc
 * An element to be displayed over the map and attached to a single map
 * location.  Like {@link module:ol/control/Control~Control}, Overlays are
 * visible widgets. Unlike Controls, they are not in a fixed position on the
 * screen, but are tied to a geographical coordinate, so panning the map will
 * move an Overlay but not a Control.
 *
 * Example:
 *
 *     import Overlay from 'ol/Overlay';
 *
 *     var popup = new Overlay({
 *       element: document.getElementById('popup')
 *     });
 *     popup.setPosition(coordinate);
 *     map.addOverlay(popup);
 *
 * @api
 */

var Overlay =
/** @class */
function (_super) {
  __extends(Overlay, _super);
  /**
   * @param {Options} options Overlay options.
   */


  function Overlay(options) {
    var _this = _super.call(this) || this;
    /**
     * @protected
     * @type {Options}
     */


    _this.options = options;
    /**
     * @protected
     * @type {number|string|undefined}
     */

    _this.id = options.id;
    /**
     * @protected
     * @type {boolean}
     */

    _this.insertFirst = options.insertFirst !== undefined ? options.insertFirst : true;
    /**
     * @protected
     * @type {boolean}
     */

    _this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;
    /**
     * @protected
     * @type {HTMLElement}
     */

    _this.element = document.createElement('div');
    _this.element.className = options.className !== undefined ? options.className : 'ol-overlay-container ' + _css.CLASS_SELECTABLE;
    _this.element.style.position = 'absolute';
    var autoPan = options.autoPan;

    if (autoPan && 'object' !== typeof autoPan) {
      autoPan = {
        animation: options.autoPanAnimation,
        margin: options.autoPanMargin
      };
    }
    /**
     * @protected
     * @type {PanIntoViewOptions|false}
     */


    _this.autoPan =
    /** @type {PanIntoViewOptions} */
    autoPan || false;
    /**
     * @protected
     * @type {{transform_: string,
     *         visible: boolean}}
     */

    _this.rendered = {
      transform_: '',
      visible: true
    };
    /**
     * @protected
     * @type {?import("./events.js").EventsKey}
     */

    _this.mapPostrenderListenerKey = null;

    _this.addEventListener((0, _Object.getChangeEventType)(Property.ELEMENT), _this.handleElementChanged);

    _this.addEventListener((0, _Object.getChangeEventType)(Property.MAP), _this.handleMapChanged);

    _this.addEventListener((0, _Object.getChangeEventType)(Property.OFFSET), _this.handleOffsetChanged);

    _this.addEventListener((0, _Object.getChangeEventType)(Property.POSITION), _this.handlePositionChanged);

    _this.addEventListener((0, _Object.getChangeEventType)(Property.POSITIONING), _this.handlePositioningChanged);

    if (options.element !== undefined) {
      _this.setElement(options.element);
    }

    _this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);

    _this.setPositioning(options.positioning !== undefined ?
    /** @type {OverlayPositioning} */
    options.positioning : _OverlayPositioning.default.TOP_LEFT);

    if (options.position !== undefined) {
      _this.setPosition(options.position);
    }

    return _this;
  }
  /**
   * Get the DOM element of this overlay.
   * @return {HTMLElement|undefined} The Element containing the overlay.
   * @observable
   * @api
   */


  Overlay.prototype.getElement = function () {
    return (
      /** @type {HTMLElement|undefined} */
      this.get(Property.ELEMENT)
    );
  };
  /**
   * Get the overlay identifier which is set on constructor.
   * @return {number|string|undefined} Id.
   * @api
   */


  Overlay.prototype.getId = function () {
    return this.id;
  };
  /**
   * Get the map associated with this overlay.
   * @return {import("./PluggableMap.js").default|undefined} The map that the
   * overlay is part of.
   * @observable
   * @api
   */


  Overlay.prototype.getMap = function () {
    return (
      /** @type {import("./PluggableMap.js").default|undefined} */
      this.get(Property.MAP)
    );
  };
  /**
   * Get the offset of this overlay.
   * @return {Array<number>} The offset.
   * @observable
   * @api
   */


  Overlay.prototype.getOffset = function () {
    return (
      /** @type {Array<number>} */
      this.get(Property.OFFSET)
    );
  };
  /**
   * Get the current position of this overlay.
   * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
   *     anchored at.
   * @observable
   * @api
   */


  Overlay.prototype.getPosition = function () {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Property.POSITION)
    );
  };
  /**
   * Get the current positioning of this overlay.
   * @return {OverlayPositioning} How the overlay is positioned
   *     relative to its point on the map.
   * @observable
   * @api
   */


  Overlay.prototype.getPositioning = function () {
    return (
      /** @type {OverlayPositioning} */
      this.get(Property.POSITIONING)
    );
  };
  /**
   * @protected
   */


  Overlay.prototype.handleElementChanged = function () {
    (0, _dom.removeChildren)(this.element);
    var element = this.getElement();

    if (element) {
      this.element.appendChild(element);
    }
  };
  /**
   * @protected
   */


  Overlay.prototype.handleMapChanged = function () {
    if (this.mapPostrenderListenerKey) {
      (0, _dom.removeNode)(this.element);
      (0, _events.unlistenByKey)(this.mapPostrenderListenerKey);
      this.mapPostrenderListenerKey = null;
    }

    var map = this.getMap();

    if (map) {
      this.mapPostrenderListenerKey = (0, _events.listen)(map, _MapEventType.default.POSTRENDER, this.render, this);
      this.updatePixelPosition();
      var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();

      if (this.insertFirst) {
        container.insertBefore(this.element, container.childNodes[0] || null);
      } else {
        container.appendChild(this.element);
      }

      this.performAutoPan();
    }
  };
  /**
   * @protected
   */


  Overlay.prototype.render = function () {
    this.updatePixelPosition();
  };
  /**
   * @protected
   */


  Overlay.prototype.handleOffsetChanged = function () {
    this.updatePixelPosition();
  };
  /**
   * @protected
   */


  Overlay.prototype.handlePositionChanged = function () {
    this.updatePixelPosition();
    this.performAutoPan();
  };
  /**
   * @protected
   */


  Overlay.prototype.handlePositioningChanged = function () {
    this.updatePixelPosition();
  };
  /**
   * Set the DOM element to be associated with this overlay.
   * @param {HTMLElement|undefined} element The Element containing the overlay.
   * @observable
   * @api
   */


  Overlay.prototype.setElement = function (element) {
    this.set(Property.ELEMENT, element);
  };
  /**
   * Set the map to be associated with this overlay.
   * @param {import("./PluggableMap.js").default|undefined} map The map that the
   * overlay is part of.
   * @observable
   * @api
   */


  Overlay.prototype.setMap = function (map) {
    this.set(Property.MAP, map);
  };
  /**
   * Set the offset for this overlay.
   * @param {Array<number>} offset Offset.
   * @observable
   * @api
   */


  Overlay.prototype.setOffset = function (offset) {
    this.set(Property.OFFSET, offset);
  };
  /**
   * Set the position for this overlay. If the position is `undefined` the
   * overlay is hidden.
   * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
   *     is anchored at.
   * @observable
   * @api
   */


  Overlay.prototype.setPosition = function (position) {
    this.set(Property.POSITION, position);
  };
  /**
   * Pan the map so that the overlay is entirely visisble in the current viewport
   * (if necessary) using the configured autoPan parameters
   * @protected
   */


  Overlay.prototype.performAutoPan = function () {
    if (this.autoPan) {
      this.panIntoView(this.autoPan);
    }
  };
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary).
   * @param {PanIntoViewOptions|undefined} panIntoViewOptions Options for the pan action
   * @api
   */


  Overlay.prototype.panIntoView = function (panIntoViewOptions) {
    var map = this.getMap();

    if (!map || !map.getTargetElement() || !this.get(Property.POSITION)) {
      return;
    }

    var mapRect = this.getRect(map.getTargetElement(), map.getSize());
    var element = this.getElement();
    var overlayRect = this.getRect(element, [(0, _dom.outerWidth)(element), (0, _dom.outerHeight)(element)]);
    var myMargin = panIntoViewOptions.margin === undefined ? 20 : panIntoViewOptions.margin;

    if (!(0, _extent.containsExtent)(mapRect, overlayRect)) {
      // the overlay is not completely inside the viewport, so pan the map
      var offsetLeft = overlayRect[0] - mapRect[0];
      var offsetRight = mapRect[2] - overlayRect[2];
      var offsetTop = overlayRect[1] - mapRect[1];
      var offsetBottom = mapRect[3] - overlayRect[3];
      var delta = [0, 0];

      if (offsetLeft < 0) {
        // move map to the left
        delta[0] = offsetLeft - myMargin;
      } else if (offsetRight < 0) {
        // move map to the right
        delta[0] = Math.abs(offsetRight) + myMargin;
      }

      if (offsetTop < 0) {
        // move map up
        delta[1] = offsetTop - myMargin;
      } else if (offsetBottom < 0) {
        // move map down
        delta[1] = Math.abs(offsetBottom) + myMargin;
      }

      if (delta[0] !== 0 || delta[1] !== 0) {
        var center =
        /** @type {import("./coordinate.js").Coordinate} */
        map.getView().getCenterInternal();
        var centerPx = map.getPixelFromCoordinateInternal(center);
        var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
        var panOptions = panIntoViewOptions.animation || {};
        map.getView().animateInternal({
          center: map.getCoordinateFromPixelInternal(newCenterPx),
          duration: panOptions.duration,
          easing: panOptions.easing
        });
      }
    }
  };
  /**
   * Get the extent of an element relative to the document
   * @param {HTMLElement} element The element.
   * @param {import("./size.js").Size} size The size of the element.
   * @return {import("./extent.js").Extent} The extent.
   * @protected
   */


  Overlay.prototype.getRect = function (element, size) {
    var box = element.getBoundingClientRect();
    var offsetX = box.left + window.pageXOffset;
    var offsetY = box.top + window.pageYOffset;
    return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
  };
  /**
   * Set the positioning for this overlay.
   * @param {OverlayPositioning} positioning how the overlay is
   *     positioned relative to its point on the map.
   * @observable
   * @api
   */


  Overlay.prototype.setPositioning = function (positioning) {
    this.set(Property.POSITIONING, positioning);
  };
  /**
   * Modify the visibility of the element.
   * @param {boolean} visible Element visibility.
   * @protected
   */


  Overlay.prototype.setVisible = function (visible) {
    if (this.rendered.visible !== visible) {
      this.element.style.display = visible ? '' : 'none';
      this.rendered.visible = visible;
    }
  };
  /**
   * Update pixel position.
   * @protected
   */


  Overlay.prototype.updatePixelPosition = function () {
    var map = this.getMap();
    var position = this.getPosition();

    if (!map || !map.isRendered() || !position) {
      this.setVisible(false);
      return;
    }

    var pixel = map.getPixelFromCoordinate(position);
    var mapSize = map.getSize();
    this.updateRenderedPosition(pixel, mapSize);
  };
  /**
   * @param {import("./pixel.js").Pixel} pixel The pixel location.
   * @param {import("./size.js").Size|undefined} mapSize The map size.
   * @protected
   */


  Overlay.prototype.updateRenderedPosition = function (pixel, mapSize) {
    var style = this.element.style;
    var offset = this.getOffset();
    var positioning = this.getPositioning();
    this.setVisible(true);
    var x = Math.round(pixel[0] + offset[0]) + 'px';
    var y = Math.round(pixel[1] + offset[1]) + 'px';
    var posX = '0%';
    var posY = '0%';

    if (positioning == _OverlayPositioning.default.BOTTOM_RIGHT || positioning == _OverlayPositioning.default.CENTER_RIGHT || positioning == _OverlayPositioning.default.TOP_RIGHT) {
      posX = '-100%';
    } else if (positioning == _OverlayPositioning.default.BOTTOM_CENTER || positioning == _OverlayPositioning.default.CENTER_CENTER || positioning == _OverlayPositioning.default.TOP_CENTER) {
      posX = '-50%';
    }

    if (positioning == _OverlayPositioning.default.BOTTOM_LEFT || positioning == _OverlayPositioning.default.BOTTOM_CENTER || positioning == _OverlayPositioning.default.BOTTOM_RIGHT) {
      posY = '-100%';
    } else if (positioning == _OverlayPositioning.default.CENTER_LEFT || positioning == _OverlayPositioning.default.CENTER_CENTER || positioning == _OverlayPositioning.default.CENTER_RIGHT) {
      posY = '-50%';
    }

    var transform = "translate(" + posX + ", " + posY + ") translate(" + x + ", " + y + ")";

    if (this.rendered.transform_ != transform) {
      this.rendered.transform_ = transform;
      style.transform = transform; // @ts-ignore IE9

      style.msTransform = transform;
    }
  };
  /**
   * returns the options this Overlay has been created with
   * @return {Options} overlay options
   */


  Overlay.prototype.getOptions = function () {
    return this.options;
  };

  return Overlay;
}(_Object.default);

var _default = Overlay;
exports.default = _default;
},{"./MapEventType.js":"node_modules/ol/MapEventType.js","./Object.js":"node_modules/ol/Object.js","./OverlayPositioning.js":"node_modules/ol/OverlayPositioning.js","./css.js":"node_modules/ol/css.js","./dom.js":"node_modules/ol/dom.js","./events.js":"node_modules/ol/events.js","./extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/control/OverviewMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.render = render;
exports.default = void 0;

var _PluggableMap = _interopRequireDefault(require("../PluggableMap.js"));

var _Composite = _interopRequireDefault(require("../renderer/Composite.js"));

var _MapEventType = _interopRequireDefault(require("../MapEventType.js"));

var _MapProperty = _interopRequireDefault(require("../MapProperty.js"));

var _Object = require("../Object.js");

var _ObjectEventType = _interopRequireDefault(require("../ObjectEventType.js"));

var _Overlay = _interopRequireDefault(require("../Overlay.js"));

var _OverlayPositioning = _interopRequireDefault(require("../OverlayPositioning.js"));

var _ViewProperty = _interopRequireDefault(require("../ViewProperty.js"));

var _Control = _interopRequireDefault(require("./Control.js"));

var _Polygon = require("../geom/Polygon.js");

var _css = require("../css.js");

var _dom = require("../dom.js");

var _events = require("../events.js");

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _extent = require("../extent.js");

var _View = _interopRequireDefault(require("../View.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/control/OverviewMap
 */


/**
 * Maximum width and/or height extent ratio that determines when the overview
 * map should be zoomed out.
 * @type {number}
 */
var MAX_RATIO = 0.75;
/**
 * Minimum width and/or height extent ratio that determines when the overview
 * map should be zoomed in.
 * @type {number}
 */

var MIN_RATIO = 0.1;

var ControlledMap =
/** @class */
function (_super) {
  __extends(ControlledMap, _super);

  function ControlledMap() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ControlledMap.prototype.createRenderer = function () {
    return new _Composite.default(this);
  };

  return ControlledMap;
}(_PluggableMap.default);
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-overviewmap'] CSS class name.
 * @property {boolean} [collapsed=true] Whether the control should start collapsed or not (expanded).
 * @property {string|HTMLElement} [collapseLabel='«'] Text label to use for the
 * expanded overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {boolean} [collapsible=true] Whether the control can be collapsed or not.
 * @property {string|HTMLElement} [label='»'] Text label to use for the collapsed
 * overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {Array<import("../layer/Layer.js").default>|import("../Collection.js").default<import("../layer/Layer.js").default>} [layers]
 * Layers for the overview map.
 * @property {function(import("../MapEvent.js").default)} [render] Function called when the control
 * should be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {boolean} [rotateWithView=false] Whether the control view should rotate with the main map view.
 * @property {HTMLElement|string} [target] Specify a target if you want the control
 * to be rendered outside of the map's viewport.
 * @property {string} [tipLabel='Overview map'] Text label to use for the button tip.
 * @property {View} [view] Custom view for the overview map (should use same projection as main map). If not provided,
 * a default view with the same projection as the main map will be used.
 */

/**
 * Create a new control with a map acting as an overview map for another
 * defined map.
 *
 * @api
 */


var OverviewMap =
/** @class */
function (_super) {
  __extends(OverviewMap, _super);
  /**
   * @param {Options=} opt_options OverviewMap options.
   */


  function OverviewMap(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render || render,
      target: options.target
    }) || this;
    /**
     * @private
     */

    _this.boundHandleRotationChanged_ = _this.handleRotationChanged_.bind(_this);
    /**
     * @type {boolean}
     * @private
     */

    _this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;
    /**
     * @private
     * @type {boolean}
     */

    _this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;

    if (!_this.collapsible_) {
      _this.collapsed_ = false;
    }
    /**
     * @private
     * @type {boolean}
     */


    _this.rotateWithView_ = options.rotateWithView !== undefined ? options.rotateWithView : false;
    /**
     * @private
     * @type {import("../extent.js").Extent|undefined}
     */

    _this.viewExtent_ = undefined;
    var className = options.className !== undefined ? options.className : 'ol-overviewmap';
    var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Overview map';
    var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00AB';

    if (typeof collapseLabel === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      _this.collapseLabel_ = document.createElement('span');
      _this.collapseLabel_.textContent = collapseLabel;
    } else {
      _this.collapseLabel_ = collapseLabel;
    }

    var label = options.label !== undefined ? options.label : '\u00BB';

    if (typeof label === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      _this.label_ = document.createElement('span');
      _this.label_.textContent = label;
    } else {
      _this.label_ = label;
    }

    var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
    var button = document.createElement('button');
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(activeLabel);
    button.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_this), false);
    /**
     * @type {HTMLElement}
     * @private
     */

    _this.ovmapDiv_ = document.createElement('div');
    _this.ovmapDiv_.className = 'ol-overviewmap-map';
    /**
     * Explicitly given view to be used instead of a view derived from the main map.
     * @type {View}
     * @private
     */

    _this.view_ = options.view;
    /**
     * @type {ControlledMap}
     * @private
     */

    _this.ovmap_ = new ControlledMap({
      view: options.view
    });
    var ovmap = _this.ovmap_;

    if (options.layers) {
      options.layers.forEach(function (layer) {
        ovmap.addLayer(layer);
      });
    }

    var box = document.createElement('div');
    box.className = 'ol-overviewmap-box';
    box.style.boxSizing = 'border-box';
    /**
     * @type {import("../Overlay.js").default}
     * @private
     */

    _this.boxOverlay_ = new _Overlay.default({
      position: [0, 0],
      positioning: _OverlayPositioning.default.CENTER_CENTER,
      element: box
    });

    _this.ovmap_.addOverlay(_this.boxOverlay_);

    var cssClasses = className + ' ' + _css.CLASS_UNSELECTABLE + ' ' + _css.CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? ' ' + _css.CLASS_COLLAPSED : '') + (_this.collapsible_ ? '' : ' ol-uncollapsible');
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(_this.ovmapDiv_);
    element.appendChild(button);
    /* Interactive map */

    var scope = _this;
    var overlay = _this.boxOverlay_;

    var overlayBox = _this.boxOverlay_.getElement();
    /* Functions definition */


    var computeDesiredMousePosition = function (mousePosition) {
      return {
        clientX: mousePosition.clientX,
        clientY: mousePosition.clientY
      };
    };

    var move = function (event) {
      var position =
      /** @type {?} */
      computeDesiredMousePosition(event);
      var coordinates = ovmap.getEventCoordinateInternal(
      /** @type {Event} */
      position);
      overlay.setPosition(coordinates);
    };

    var endMoving = function (event) {
      var coordinates = ovmap.getEventCoordinateInternal(event);
      scope.getMap().getView().setCenterInternal(coordinates);
      window.removeEventListener('mousemove', move);
      window.removeEventListener('mouseup', endMoving);
    };
    /* Binding */


    overlayBox.addEventListener('mousedown', function () {
      window.addEventListener('mousemove', move);
      window.addEventListener('mouseup', endMoving);
    });
    return _this;
  }
  /**
   * @inheritDoc
   * @api
   */


  OverviewMap.prototype.setMap = function (map) {
    var oldMap = this.getMap();

    if (map === oldMap) {
      return;
    }

    if (oldMap) {
      var oldView = oldMap.getView();

      if (oldView) {
        this.unbindView_(oldView);
      }

      this.ovmap_.setTarget(null);
    }

    _super.prototype.setMap.call(this, map);

    if (map) {
      this.ovmap_.setTarget(this.ovmapDiv_);
      this.listenerKeys.push((0, _events.listen)(map, _ObjectEventType.default.PROPERTYCHANGE, this.handleMapPropertyChange_, this));
      var view = map.getView();

      if (view) {
        this.bindView_(view);

        if (view.isDef()) {
          this.ovmap_.updateSize();
          this.resetExtent_();
        }
      }
    }
  };
  /**
   * Handle map property changes.  This only deals with changes to the map's view.
   * @param {import("../Object.js").ObjectEvent} event The propertychange event.
   * @private
   */


  OverviewMap.prototype.handleMapPropertyChange_ = function (event) {
    if (event.key === _MapProperty.default.VIEW) {
      var oldView =
      /** @type {import("../View.js").default} */
      event.oldValue;

      if (oldView) {
        this.unbindView_(oldView);
      }

      var newView = this.getMap().getView();
      this.bindView_(newView);
    }
  };
  /**
   * Register listeners for view property changes.
   * @param {import("../View.js").default} view The view.
   * @private
   */


  OverviewMap.prototype.bindView_ = function (view) {
    if (!this.view_) {
      // Unless an explicit view definition was given, derive default from whatever main map uses.
      var newView = new _View.default({
        projection: view.getProjection()
      });
      this.ovmap_.setView(newView);
    }

    view.addEventListener((0, _Object.getChangeEventType)(_ViewProperty.default.ROTATION), this.boundHandleRotationChanged_); // Sync once with the new view

    this.handleRotationChanged_();
  };
  /**
   * Unregister listeners for view property changes.
   * @param {import("../View.js").default} view The view.
   * @private
   */


  OverviewMap.prototype.unbindView_ = function (view) {
    view.removeEventListener((0, _Object.getChangeEventType)(_ViewProperty.default.ROTATION), this.boundHandleRotationChanged_);
  };
  /**
   * Handle rotation changes to the main map.
   * @private
   */


  OverviewMap.prototype.handleRotationChanged_ = function () {
    if (this.rotateWithView_) {
      this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
    }
  };
  /**
   * Reset the overview map extent if the box size (width or
   * height) is less than the size of the overview map size times minRatio
   * or is greater than the size of the overview size times maxRatio.
   *
   * If the map extent was not reset, the box size can fits in the defined
   * ratio sizes. This method then checks if is contained inside the overview
   * map current extent. If not, recenter the overview map to the current
   * main map center location.
   * @private
   */


  OverviewMap.prototype.validateExtent_ = function () {
    var map = this.getMap();
    var ovmap = this.ovmap_;

    if (!map.isRendered() || !ovmap.isRendered()) {
      return;
    }

    var mapSize =
    /** @type {import("../size.js").Size} */
    map.getSize();
    var view = map.getView();
    var extent = view.calculateExtentInternal(mapSize);

    if (this.viewExtent_ && (0, _extent.equals)(extent, this.viewExtent_)) {
      // repeats of the same extent may indicate constraint conflicts leading to an endless cycle
      return;
    }

    this.viewExtent_ = extent;
    var ovmapSize =
    /** @type {import("../size.js").Size} */
    ovmap.getSize();
    var ovview = ovmap.getView();
    var ovextent = ovview.calculateExtentInternal(ovmapSize);
    var topLeftPixel = ovmap.getPixelFromCoordinateInternal((0, _extent.getTopLeft)(extent));
    var bottomRightPixel = ovmap.getPixelFromCoordinateInternal((0, _extent.getBottomRight)(extent));
    var boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);
    var boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);
    var ovmapWidth = ovmapSize[0];
    var ovmapHeight = ovmapSize[1];

    if (boxWidth < ovmapWidth * MIN_RATIO || boxHeight < ovmapHeight * MIN_RATIO || boxWidth > ovmapWidth * MAX_RATIO || boxHeight > ovmapHeight * MAX_RATIO) {
      this.resetExtent_();
    } else if (!(0, _extent.containsExtent)(ovextent, extent)) {
      this.recenter_();
    }
  };
  /**
   * Reset the overview map extent to half calculated min and max ratio times
   * the extent of the main map.
   * @private
   */


  OverviewMap.prototype.resetExtent_ = function () {
    if (MAX_RATIO === 0 || MIN_RATIO === 0) {
      return;
    }

    var map = this.getMap();
    var ovmap = this.ovmap_;
    var mapSize =
    /** @type {import("../size.js").Size} */
    map.getSize();
    var view = map.getView();
    var extent = view.calculateExtentInternal(mapSize);
    var ovview = ovmap.getView(); // get how many times the current map overview could hold different
    // box sizes using the min and max ratio, pick the step in the middle used
    // to calculate the extent from the main map to set it to the overview map,

    var steps = Math.log(MAX_RATIO / MIN_RATIO) / Math.LN2;
    var ratio = 1 / (Math.pow(2, steps / 2) * MIN_RATIO);
    (0, _extent.scaleFromCenter)(extent, ratio);
    ovview.fitInternal((0, _Polygon.fromExtent)(extent));
  };
  /**
   * Set the center of the overview map to the map center without changing its
   * resolution.
   * @private
   */


  OverviewMap.prototype.recenter_ = function () {
    var map = this.getMap();
    var ovmap = this.ovmap_;
    var view = map.getView();
    var ovview = ovmap.getView();
    ovview.setCenterInternal(view.getCenterInternal());
  };
  /**
   * Update the box using the main map extent
   * @private
   */


  OverviewMap.prototype.updateBox_ = function () {
    var map = this.getMap();
    var ovmap = this.ovmap_;

    if (!map.isRendered() || !ovmap.isRendered()) {
      return;
    }

    var mapSize =
    /** @type {import("../size.js").Size} */
    map.getSize();
    var view = map.getView();
    var ovview = ovmap.getView();
    var rotation = this.rotateWithView_ ? 0 : -view.getRotation();
    var overlay = this.boxOverlay_;
    var box = this.boxOverlay_.getElement();
    var center = view.getCenterInternal();
    var resolution = view.getResolution();
    var ovresolution = ovview.getResolution();
    var width = mapSize[0] * resolution / ovresolution;
    var height = mapSize[1] * resolution / ovresolution; // set position using center coordinates

    overlay.setPosition(center); // set box size calculated from map extent size and overview map resolution

    if (box) {
      box.style.width = width + 'px';
      box.style.height = height + 'px';
      var transform = 'rotate(' + rotation + 'rad)';
      box.style.transform = transform;
    }
  };
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */


  OverviewMap.prototype.handleClick_ = function (event) {
    event.preventDefault();
    this.handleToggle_();
  };
  /**
   * @private
   */


  OverviewMap.prototype.handleToggle_ = function () {
    this.element.classList.toggle(_css.CLASS_COLLAPSED);

    if (this.collapsed_) {
      (0, _dom.replaceNode)(this.collapseLabel_, this.label_);
    } else {
      (0, _dom.replaceNode)(this.label_, this.collapseLabel_);
    }

    this.collapsed_ = !this.collapsed_; // manage overview map if it had not been rendered before and control
    // is expanded

    var ovmap = this.ovmap_;

    if (!this.collapsed_) {
      if (ovmap.isRendered()) {
        this.viewExtent_ = undefined;
        ovmap.render();
        return;
      }

      ovmap.updateSize();
      this.resetExtent_();
      (0, _events.listenOnce)(ovmap, _MapEventType.default.POSTRENDER, function (event) {
        this.updateBox_();
      }, this);
    }
  };
  /**
   * Return `true` if the overview map is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */


  OverviewMap.prototype.getCollapsible = function () {
    return this.collapsible_;
  };
  /**
   * Set whether the overview map should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */


  OverviewMap.prototype.setCollapsible = function (collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }

    this.collapsible_ = collapsible;
    this.element.classList.toggle('ol-uncollapsible');

    if (!collapsible && this.collapsed_) {
      this.handleToggle_();
    }
  };
  /**
   * Collapse or expand the overview map according to the passed parameter. Will
   * not do anything if the overview map isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */


  OverviewMap.prototype.setCollapsed = function (collapsed) {
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }

    this.handleToggle_();
  };
  /**
   * Determine if the overview map is collapsed.
   * @return {boolean} The overview map is collapsed.
   * @api
   */


  OverviewMap.prototype.getCollapsed = function () {
    return this.collapsed_;
  };
  /**
   * Return `true` if the overview map view can rotate, `false` otherwise.
   * @return {boolean} True if the control view can rotate.
   * @api
   */


  OverviewMap.prototype.getRotateWithView = function () {
    return this.rotateWithView_;
  };
  /**
   * Set whether the overview map view should rotate with the main map view.
   * @param {boolean} rotateWithView True if the control view should rotate.
   * @api
   */


  OverviewMap.prototype.setRotateWithView = function (rotateWithView) {
    if (this.rotateWithView_ === rotateWithView) {
      return;
    }

    this.rotateWithView_ = rotateWithView;

    if (this.getMap().getView().getRotation() !== 0) {
      if (this.rotateWithView_) {
        this.handleRotationChanged_();
      } else {
        this.ovmap_.getView().setRotation(0);
      }

      this.viewExtent_ = undefined;
      this.validateExtent_();
      this.updateBox_();
    }
  };
  /**
   * Return the overview map.
   * @return {import("../PluggableMap.js").default} Overview map.
   * @api
   */


  OverviewMap.prototype.getOverviewMap = function () {
    return this.ovmap_;
  };

  return OverviewMap;
}(_Control.default);
/**
 * Update the overview map element.
 * @param {import("../MapEvent.js").default} mapEvent Map event.
 * @this {OverviewMap}
 */


function render(mapEvent) {
  this.validateExtent_();
  this.updateBox_();
}

var _default = OverviewMap;
exports.default = _default;
},{"../PluggableMap.js":"node_modules/ol/PluggableMap.js","../renderer/Composite.js":"node_modules/ol/renderer/Composite.js","../MapEventType.js":"node_modules/ol/MapEventType.js","../MapProperty.js":"node_modules/ol/MapProperty.js","../Object.js":"node_modules/ol/Object.js","../ObjectEventType.js":"node_modules/ol/ObjectEventType.js","../Overlay.js":"node_modules/ol/Overlay.js","../OverlayPositioning.js":"node_modules/ol/OverlayPositioning.js","../ViewProperty.js":"node_modules/ol/ViewProperty.js","./Control.js":"node_modules/ol/control/Control.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js","../css.js":"node_modules/ol/css.js","../dom.js":"node_modules/ol/dom.js","../events.js":"node_modules/ol/events.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../extent.js":"node_modules/ol/extent.js","../View.js":"node_modules/ol/View.js"}],"node_modules/ol/control/ScaleLine.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.render = render;
exports.default = exports.Units = void 0;

var _Object = require("../Object.js");

var _asserts = require("../asserts.js");

var _Control = _interopRequireDefault(require("./Control.js"));

var _css = require("../css.js");

var _proj = require("../proj.js");

var _Units = _interopRequireDefault(require("../proj/Units.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/control/ScaleLine
 */


/**
 * @type {string}
 */
var UNITS_PROP = 'units';
/**
 * Units for the scale line. Supported values are `'degrees'`, `'imperial'`,
 * `'nautical'`, `'metric'`, `'us'`.
 * @enum {string}
 */

var Units = {
  DEGREES: 'degrees',
  IMPERIAL: 'imperial',
  NAUTICAL: 'nautical',
  METRIC: 'metric',
  US: 'us'
};
/**
 * @const
 * @type {Array<number>}
 */

exports.Units = Units;
var LEADING_DIGITS = [1, 2, 5];
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-scale-line'] CSS Class name.
 * @property {number} [minWidth=64] Minimum width in pixels.
 * @property {function(import("../MapEvent.js").default)} [render] Function called when the control
 * should be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {HTMLElement|string} [target] Specify a target if you want the control
 * to be rendered outside of the map's viewport.
 * @property {Units|string} [units='metric'] Units.
 * @property {boolean} [bar=false] Render scalebars instead of a line.
 * @property {number} [steps=4] Number of steps the scalebar should use. Use even numbers
 * for best results. Only applies when `bar` is `true`.
 * @property {boolean} [text=false] Render the text scale above of the scalebar. Only applies
 * when `bar` is `true`.
 */

/**
 * @classdesc
 * A control displaying rough y-axis distances, calculated for the center of the
 * viewport. For conformal projections (e.g. EPSG:3857, the default view
 * projection in OpenLayers), the scale is valid for all directions.
 * No scale line will be shown when the y-axis distance of a pixel at the
 * viewport center cannot be calculated in the view projection.
 * By default the scale line will show in the bottom left portion of the map,
 * but this can be changed by using the css selector `.ol-scale-line`.
 * When specifying `bar` as `true`, a scalebar will be rendered instead
 * of a scaleline.
 *
 * @api
 */

var ScaleLine =
/** @class */
function (_super) {
  __extends(ScaleLine, _super);
  /**
   * @param {Options=} opt_options Scale line options.
   */


  function ScaleLine(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var className = options.className !== undefined ? options.className : options.bar ? 'ol-scale-bar' : 'ol-scale-line';
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render || render,
      target: options.target
    }) || this;
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.innerElement_ = document.createElement('div');
    _this.innerElement_.className = className + '-inner';
    _this.element.className = className + ' ' + _css.CLASS_UNSELECTABLE;

    _this.element.appendChild(_this.innerElement_);
    /**
     * @private
     * @type {?import("../View.js").State}
     */


    _this.viewState_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.minWidth_ = options.minWidth !== undefined ? options.minWidth : 64;
    /**
     * @private
     * @type {boolean}
     */

    _this.renderedVisible_ = false;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.renderedWidth_ = undefined;
    /**
     * @private
     * @type {string}
     */

    _this.renderedHTML_ = '';

    _this.addEventListener((0, _Object.getChangeEventType)(UNITS_PROP), _this.handleUnitsChanged_);

    _this.setUnits(options.units || Units.METRIC);
    /**
     * @private
     * @type {boolean}
     */


    _this.scaleBar_ = options.bar || false;
    /**
     * @private
     * @type {number}
     */

    _this.scaleBarSteps_ = options.steps || 4;
    /**
     * @private
     * @type {boolean}
     */

    _this.scaleBarText_ = options.text || false;
    return _this;
  }
  /**
   * Return the units to use in the scale line.
   * @return {Units} The units
   * to use in the scale line.
   * @observable
   * @api
   */


  ScaleLine.prototype.getUnits = function () {
    return this.get(UNITS_PROP);
  };
  /**
   * @private
   */


  ScaleLine.prototype.handleUnitsChanged_ = function () {
    this.updateElement_();
  };
  /**
   * Set the units to use in the scale line.
   * @param {Units} units The units to use in the scale line.
   * @observable
   * @api
   */


  ScaleLine.prototype.setUnits = function (units) {
    this.set(UNITS_PROP, units);
  };
  /**
   * @private
   */


  ScaleLine.prototype.updateElement_ = function () {
    var viewState = this.viewState_;

    if (!viewState) {
      if (this.renderedVisible_) {
        this.element.style.display = 'none';
        this.renderedVisible_ = false;
      }

      return;
    }

    var center = viewState.center;
    var projection = viewState.projection;
    var units = this.getUnits();
    var pointResolutionUnits = units == Units.DEGREES ? _Units.default.DEGREES : _Units.default.METERS;
    var pointResolution = (0, _proj.getPointResolution)(projection, viewState.resolution, center, pointResolutionUnits);
    var nominalCount = this.minWidth_ * pointResolution;
    var suffix = '';

    if (units == Units.DEGREES) {
      var metersPerDegree = _proj.METERS_PER_UNIT[_Units.default.DEGREES];
      nominalCount *= metersPerDegree;

      if (nominalCount < metersPerDegree / 60) {
        suffix = '\u2033'; // seconds

        pointResolution *= 3600;
      } else if (nominalCount < metersPerDegree) {
        suffix = '\u2032'; // minutes

        pointResolution *= 60;
      } else {
        suffix = '\u00b0'; // degrees
      }
    } else if (units == Units.IMPERIAL) {
      if (nominalCount < 0.9144) {
        suffix = 'in';
        pointResolution /= 0.0254;
      } else if (nominalCount < 1609.344) {
        suffix = 'ft';
        pointResolution /= 0.3048;
      } else {
        suffix = 'mi';
        pointResolution /= 1609.344;
      }
    } else if (units == Units.NAUTICAL) {
      pointResolution /= 1852;
      suffix = 'nm';
    } else if (units == Units.METRIC) {
      if (nominalCount < 0.001) {
        suffix = 'μm';
        pointResolution *= 1000000;
      } else if (nominalCount < 1) {
        suffix = 'mm';
        pointResolution *= 1000;
      } else if (nominalCount < 1000) {
        suffix = 'm';
      } else {
        suffix = 'km';
        pointResolution /= 1000;
      }
    } else if (units == Units.US) {
      if (nominalCount < 0.9144) {
        suffix = 'in';
        pointResolution *= 39.37;
      } else if (nominalCount < 1609.344) {
        suffix = 'ft';
        pointResolution /= 0.30480061;
      } else {
        suffix = 'mi';
        pointResolution /= 1609.3472;
      }
    } else {
      (0, _asserts.assert)(false, 33); // Invalid units
    }

    var i = 3 * Math.floor(Math.log(this.minWidth_ * pointResolution) / Math.log(10));
    var count, width, decimalCount;

    while (true) {
      decimalCount = Math.floor(i / 3);
      var decimal = Math.pow(10, decimalCount);
      count = LEADING_DIGITS[(i % 3 + 3) % 3] * decimal;
      width = Math.round(count / pointResolution);

      if (isNaN(width)) {
        this.element.style.display = 'none';
        this.renderedVisible_ = false;
        return;
      } else if (width >= this.minWidth_) {
        break;
      }

      ++i;
    }

    var html;

    if (this.scaleBar_) {
      html = this.createScaleBar(width, count, suffix);
    } else {
      html = count.toFixed(decimalCount < 0 ? -decimalCount : 0) + ' ' + suffix;
    }

    if (this.renderedHTML_ != html) {
      this.innerElement_.innerHTML = html;
      this.renderedHTML_ = html;
    }

    if (this.renderedWidth_ != width) {
      this.innerElement_.style.width = width + 'px';
      this.renderedWidth_ = width;
    }

    if (!this.renderedVisible_) {
      this.element.style.display = '';
      this.renderedVisible_ = true;
    }
  };
  /**
   * @private
   * @param {number} width The current width of the scalebar.
   * @param {number} scale The current scale.
   * @param {string} suffix The suffix to append to the scale text.
   * @returns {string} The stringified HTML of the scalebar.
   */


  ScaleLine.prototype.createScaleBar = function (width, scale, suffix) {
    var mapScale = '1 : ' + Math.round(this.getScaleForResolution()).toLocaleString();
    var scaleSteps = [];
    var stepWidth = width / this.scaleBarSteps_;
    var backgroundColor = '#ffffff';

    for (var i = 0; i < this.scaleBarSteps_; i++) {
      if (i === 0) {
        // create the first marker at position 0
        scaleSteps.push(this.createMarker('absolute', i));
      }

      scaleSteps.push('<div>' + '<div ' + 'class="ol-scale-singlebar" ' + 'style=' + '"width: ' + stepWidth + 'px;' + 'background-color: ' + backgroundColor + ';"' + '>' + '</div>' + this.createMarker('relative', i) + (
      /*render text every second step, except when only 2 steps */
      i % 2 === 0 || this.scaleBarSteps_ === 2 ? this.createStepText(i, width, false, scale, suffix) : '') + '</div>');

      if (i === this.scaleBarSteps_ - 1) {
        {
          /*render text at the end */
        }
        scaleSteps.push(this.createStepText(i + 1, width, true, scale, suffix));
      } // switch colors of steps between black and white


      if (backgroundColor === '#ffffff') {
        backgroundColor = '#000000';
      } else {
        backgroundColor = '#ffffff';
      }
    }

    var scaleBarText;

    if (this.scaleBarText_) {
      scaleBarText = '<div ' + 'class="ol-scale-text" ' + 'style="width: ' + width + 'px;">' + mapScale + '</div>';
    } else {
      scaleBarText = '';
    }

    var container = '<div ' + 'style="display: flex;">' + scaleBarText + scaleSteps.join('') + '</div>';
    return container;
  };
  /**
   * Creates a marker at given position
   * @param {string} position - The position, absolute or relative
   * @param {number} i - The iterator
   * @returns {string} The stringified div containing the marker
   */


  ScaleLine.prototype.createMarker = function (position, i) {
    var top = position === 'absolute' ? 3 : -10;
    return '<div ' + 'class="ol-scale-step-marker" ' + 'style="position: ' + position + ';' + 'top: ' + top + 'px;"' + '></div>';
  };
  /**
   * Creates the label for a marker marker at given position
   * @param {number} i - The iterator
   * @param {number} width - The width the scalebar will currently use
   * @param {boolean} isLast - Flag indicating if we add the last step text
   * @param {number} scale - The current scale for the whole scalebar
   * @param {string} suffix - The suffix for the scale
   * @returns {string} The stringified div containing the step text
   */


  ScaleLine.prototype.createStepText = function (i, width, isLast, scale, suffix) {
    var length = i === 0 ? 0 : Math.round(scale / this.scaleBarSteps_ * i * 100) / 100;
    var lengthString = length + (i === 0 ? '' : ' ' + suffix);
    var margin = i === 0 ? -3 : width / this.scaleBarSteps_ * -1;
    var minWidth = i === 0 ? 0 : width / this.scaleBarSteps_ * 2;
    return '<div ' + 'class="ol-scale-step-text" ' + 'style="' + 'margin-left: ' + margin + 'px;' + 'text-align: ' + (i === 0 ? 'left' : 'center') + '; ' + 'min-width: ' + minWidth + 'px;' + 'left: ' + (isLast ? width + 'px' : 'unset') + ';"' + '>' + lengthString + '</div>';
  };
  /**
   * Returns the appropriate scale for the given resolution and units.
   * @return {number} The appropriate scale.
   */


  ScaleLine.prototype.getScaleForResolution = function () {
    var resolution = this.getMap().getView().getResolution();
    var dpi = 25.4 / 0.28;
    var mpu = this.viewState_.projection.getMetersPerUnit();
    var inchesPerMeter = 39.37;
    return parseFloat(resolution.toString()) * mpu * inchesPerMeter * dpi;
  };

  return ScaleLine;
}(_Control.default);
/**
 * Update the scale line element.
 * @param {import("../MapEvent.js").default} mapEvent Map event.
 * @this {ScaleLine}
 */


function render(mapEvent) {
  var frameState = mapEvent.frameState;

  if (!frameState) {
    this.viewState_ = null;
  } else {
    this.viewState_ = frameState.viewState;
  }

  this.updateElement_();
}

var _default = ScaleLine;
exports.default = _default;
},{"../Object.js":"node_modules/ol/Object.js","../asserts.js":"node_modules/ol/asserts.js","./Control.js":"node_modules/ol/control/Control.js","../css.js":"node_modules/ol/css.js","../proj.js":"node_modules/ol/proj.js","../proj/Units.js":"node_modules/ol/proj/Units.js"}],"node_modules/ol/control/ZoomSlider.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.render = render;
exports.default = void 0;

require("elm-pep");

var _Control = _interopRequireDefault(require("./Control.js"));

var _css = require("../css.js");

var _easing = require("../easing.js");

var _events = require("../events.js");

var _Event = require("../events/Event.js");

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _math = require("../math.js");

var _EventType2 = _interopRequireDefault(require("../pointer/EventType.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/control/ZoomSlider
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * The enum for available directions.
 *
 * @enum {number}
 */
var Direction = {
  VERTICAL: 0,
  HORIZONTAL: 1
};
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-zoomslider'] CSS class name.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {function(import("../MapEvent.js").default)} [render] Function called when the control
 * should be re-rendered. This is called in a `requestAnimationFrame` callback.
 */

/**
 * @classdesc
 * A slider type of control for zooming.
 *
 * Example:
 *
 *     map.addControl(new ZoomSlider());
 *
 * @api
 */

var ZoomSlider =
/** @class */
function (_super) {
  __extends(ZoomSlider, _super);
  /**
   * @param {Options=} opt_options Zoom slider options.
   */


  function ZoomSlider(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render || render
    }) || this;
    /**
      * @type {!Array.<import("../events.js").EventsKey>}
      * @private
      */

    _this.dragListenerKeys_ = [];
    /**
     * Will hold the current resolution of the view.
     *
     * @type {number|undefined}
     * @private
     */

    _this.currentResolution_ = undefined;
    /**
     * The direction of the slider. Will be determined from actual display of the
     * container and defaults to Direction.VERTICAL.
     *
     * @type {Direction}
     * @private
     */

    _this.direction_ = Direction.VERTICAL;
    /**
     * @type {boolean}
     * @private
     */

    _this.dragging_;
    /**
     * @type {number}
     * @private
     */

    _this.heightLimit_ = 0;
    /**
     * @type {number}
     * @private
     */

    _this.widthLimit_ = 0;
    /**
     * @type {number|undefined}
     * @private
     */

    _this.startX_;
    /**
     * @type {number|undefined}
     * @private
     */

    _this.startY_;
    /**
     * The calculated thumb size (border box plus margins).  Set when initSlider_
     * is called.
     * @type {import("../size.js").Size}
     * @private
     */

    _this.thumbSize_ = null;
    /**
     * Whether the slider is initialized.
     * @type {boolean}
     * @private
     */

    _this.sliderInitialized_ = false;
    /**
     * @type {number}
     * @private
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 200;
    var className = options.className !== undefined ? options.className : 'ol-zoomslider';
    var thumbElement = document.createElement('button');
    thumbElement.setAttribute('type', 'button');
    thumbElement.className = className + '-thumb ' + _css.CLASS_UNSELECTABLE;
    var containerElement = _this.element;
    containerElement.className = className + ' ' + _css.CLASS_UNSELECTABLE + ' ' + _css.CLASS_CONTROL;
    containerElement.appendChild(thumbElement);
    containerElement.addEventListener(_EventType2.default.POINTERDOWN, _this.handleDraggerStart_.bind(_this), false);
    containerElement.addEventListener(_EventType2.default.POINTERMOVE, _this.handleDraggerDrag_.bind(_this), false);
    containerElement.addEventListener(_EventType2.default.POINTERUP, _this.handleDraggerEnd_.bind(_this), false);
    containerElement.addEventListener(_EventType.default.CLICK, _this.handleContainerClick_.bind(_this), false);
    thumbElement.addEventListener(_EventType.default.CLICK, _Event.stopPropagation, false);
    return _this;
  }
  /**
   * @inheritDoc
   */


  ZoomSlider.prototype.setMap = function (map) {
    _super.prototype.setMap.call(this, map);

    if (map) {
      map.render();
    }
  };
  /**
   * Initializes the slider element. This will determine and set this controls
   * direction_ and also constrain the dragging of the thumb to always be within
   * the bounds of the container.
   *
   * @private
   */


  ZoomSlider.prototype.initSlider_ = function () {
    var container = this.element;
    var containerSize = {
      width: container.offsetWidth,
      height: container.offsetHeight
    };
    var thumb =
    /** @type {HTMLElement} */
    container.firstElementChild;
    var computedStyle = getComputedStyle(thumb);
    var thumbWidth = thumb.offsetWidth + parseFloat(computedStyle['marginRight']) + parseFloat(computedStyle['marginLeft']);
    var thumbHeight = thumb.offsetHeight + parseFloat(computedStyle['marginTop']) + parseFloat(computedStyle['marginBottom']);
    this.thumbSize_ = [thumbWidth, thumbHeight];

    if (containerSize.width > containerSize.height) {
      this.direction_ = Direction.HORIZONTAL;
      this.widthLimit_ = containerSize.width - thumbWidth;
    } else {
      this.direction_ = Direction.VERTICAL;
      this.heightLimit_ = containerSize.height - thumbHeight;
    }

    this.sliderInitialized_ = true;
  };
  /**
   * @param {PointerEvent} event The browser event to handle.
   * @private
   */


  ZoomSlider.prototype.handleContainerClick_ = function (event) {
    var view = this.getMap().getView();
    var relativePosition = this.getRelativePosition_(event.offsetX - this.thumbSize_[0] / 2, event.offsetY - this.thumbSize_[1] / 2);
    var resolution = this.getResolutionForPosition_(relativePosition);
    var zoom = view.getConstrainedZoom(view.getZoomForResolution(resolution));
    view.animateInternal({
      zoom: zoom,
      duration: this.duration_,
      easing: _easing.easeOut
    });
  };
  /**
   * Handle dragger start events.
   * @param {PointerEvent} event The drag event.
   * @private
   */


  ZoomSlider.prototype.handleDraggerStart_ = function (event) {
    if (!this.dragging_ && event.target === this.element.firstElementChild) {
      var element =
      /** @type {HTMLElement} */
      this.element.firstElementChild;
      this.getMap().getView().beginInteraction();
      this.startX_ = event.clientX - parseFloat(element.style.left);
      this.startY_ = event.clientY - parseFloat(element.style.top);
      this.dragging_ = true;

      if (this.dragListenerKeys_.length === 0) {
        var drag = this.handleDraggerDrag_;
        var end = this.handleDraggerEnd_;
        this.dragListenerKeys_.push((0, _events.listen)(document, _EventType2.default.POINTERMOVE, drag, this), (0, _events.listen)(document, _EventType2.default.POINTERUP, end, this));
      }
    }
  };
  /**
   * Handle dragger drag events.
   *
   * @param {PointerEvent} event The drag event.
   * @private
   */


  ZoomSlider.prototype.handleDraggerDrag_ = function (event) {
    if (this.dragging_) {
      var deltaX = event.clientX - this.startX_;
      var deltaY = event.clientY - this.startY_;
      var relativePosition = this.getRelativePosition_(deltaX, deltaY);
      this.currentResolution_ = this.getResolutionForPosition_(relativePosition);
      this.getMap().getView().setResolution(this.currentResolution_);
    }
  };
  /**
   * Handle dragger end events.
   * @param {PointerEvent} event The drag event.
   * @private
   */


  ZoomSlider.prototype.handleDraggerEnd_ = function (event) {
    if (this.dragging_) {
      var view = this.getMap().getView();
      view.endInteraction();
      this.dragging_ = false;
      this.startX_ = undefined;
      this.startY_ = undefined;
      this.dragListenerKeys_.forEach(_events.unlistenByKey);
      this.dragListenerKeys_.length = 0;
    }
  };
  /**
   * Positions the thumb inside its container according to the given resolution.
   *
   * @param {number} res The res.
   * @private
   */


  ZoomSlider.prototype.setThumbPosition_ = function (res) {
    var position = this.getPositionForResolution_(res);
    var thumb =
    /** @type {HTMLElement} */
    this.element.firstElementChild;

    if (this.direction_ == Direction.HORIZONTAL) {
      thumb.style.left = this.widthLimit_ * position + 'px';
    } else {
      thumb.style.top = this.heightLimit_ * position + 'px';
    }
  };
  /**
   * Calculates the relative position of the thumb given x and y offsets.  The
   * relative position scales from 0 to 1.  The x and y offsets are assumed to be
   * in pixel units within the dragger limits.
   *
   * @param {number} x Pixel position relative to the left of the slider.
   * @param {number} y Pixel position relative to the top of the slider.
   * @return {number} The relative position of the thumb.
   * @private
   */


  ZoomSlider.prototype.getRelativePosition_ = function (x, y) {
    var amount;

    if (this.direction_ === Direction.HORIZONTAL) {
      amount = x / this.widthLimit_;
    } else {
      amount = y / this.heightLimit_;
    }

    return (0, _math.clamp)(amount, 0, 1);
  };
  /**
   * Calculates the corresponding resolution of the thumb given its relative
   * position (where 0 is the minimum and 1 is the maximum).
   *
   * @param {number} position The relative position of the thumb.
   * @return {number} The corresponding resolution.
   * @private
   */


  ZoomSlider.prototype.getResolutionForPosition_ = function (position) {
    var fn = this.getMap().getView().getResolutionForValueFunction();
    return fn(1 - position);
  };
  /**
   * Determines the relative position of the slider for the given resolution.  A
   * relative position of 0 corresponds to the minimum view resolution.  A
   * relative position of 1 corresponds to the maximum view resolution.
   *
   * @param {number} res The resolution.
   * @return {number} The relative position value (between 0 and 1).
   * @private
   */


  ZoomSlider.prototype.getPositionForResolution_ = function (res) {
    var fn = this.getMap().getView().getValueForResolutionFunction();
    return (0, _math.clamp)(1 - fn(res), 0, 1);
  };

  return ZoomSlider;
}(_Control.default);
/**
 * Update the zoomslider element.
 * @param {import("../MapEvent.js").default} mapEvent Map event.
 * @this {ZoomSlider}
 */


function render(mapEvent) {
  if (!mapEvent.frameState) {
    return;
  }

  if (!this.sliderInitialized_) {
    this.initSlider_();
  }

  var res = mapEvent.frameState.viewState.resolution;
  this.currentResolution_ = res;
  this.setThumbPosition_(res);
}

var _default = ZoomSlider;
exports.default = _default;
},{"elm-pep":"node_modules/elm-pep/dist/elm-pep.js","./Control.js":"node_modules/ol/control/Control.js","../css.js":"node_modules/ol/css.js","../easing.js":"node_modules/ol/easing.js","../events.js":"node_modules/ol/events.js","../events/Event.js":"node_modules/ol/events/Event.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../math.js":"node_modules/ol/math.js","../pointer/EventType.js":"node_modules/ol/pointer/EventType.js"}],"node_modules/ol/control/ZoomToExtent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Polygon = require("../geom/Polygon.js");

var _Control = _interopRequireDefault(require("./Control.js"));

var _css = require("../css.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/control/ZoomToExtent
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-zoom-extent'] Class name.
 * @property {HTMLElement|string} [target] Specify a target if you want the control
 * to be rendered outside of the map's viewport.
 * @property {string|HTMLElement} [label='E'] Text label to use for the button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Fit to extent'] Text label to use for the button tip.
 * @property {import("../extent.js").Extent} [extent] The extent to zoom to. If undefined the validity
 * extent of the view projection is used.
 */

/**
 * @classdesc
 * A button control which, when pressed, changes the map view to a specific
 * extent. To style this control use the css selector `.ol-zoom-extent`.
 *
 * @api
 */
var ZoomToExtent =
/** @class */
function (_super) {
  __extends(ZoomToExtent, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function ZoomToExtent(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      target: options.target
    }) || this;
    /**
     * @type {?import("../extent.js").Extent}
     * @protected
     */

    _this.extent = options.extent ? options.extent : null;
    var className = options.className !== undefined ? options.className : 'ol-zoom-extent';
    var label = options.label !== undefined ? options.label : 'E';
    var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Fit to extent';
    var button = document.createElement('button');
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(typeof label === 'string' ? document.createTextNode(label) : label);
    button.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_this), false);
    var cssClasses = className + ' ' + _css.CLASS_UNSELECTABLE + ' ' + _css.CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(button);
    return _this;
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */


  ZoomToExtent.prototype.handleClick_ = function (event) {
    event.preventDefault();
    this.handleZoomToExtent();
  };
  /**
   * @protected
   */


  ZoomToExtent.prototype.handleZoomToExtent = function () {
    var map = this.getMap();
    var view = map.getView();
    var extent = !this.extent ? view.getProjection().getExtent() : this.extent;
    view.fitInternal((0, _Polygon.fromExtent)(extent));
  };

  return ZoomToExtent;
}(_Control.default);

var _default = ZoomToExtent;
exports.default = _default;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js","./Control.js":"node_modules/ol/control/Control.js","../css.js":"node_modules/ol/css.js"}],"node_modules/ol/control.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaults = defaults;
Object.defineProperty(exports, "Attribution", {
  enumerable: true,
  get: function () {
    return _Attribution.default;
  }
});
Object.defineProperty(exports, "Rotate", {
  enumerable: true,
  get: function () {
    return _Rotate.default;
  }
});
Object.defineProperty(exports, "Zoom", {
  enumerable: true,
  get: function () {
    return _Zoom.default;
  }
});
Object.defineProperty(exports, "Control", {
  enumerable: true,
  get: function () {
    return _Control.default;
  }
});
Object.defineProperty(exports, "FullScreen", {
  enumerable: true,
  get: function () {
    return _FullScreen.default;
  }
});
Object.defineProperty(exports, "MousePosition", {
  enumerable: true,
  get: function () {
    return _MousePosition.default;
  }
});
Object.defineProperty(exports, "OverviewMap", {
  enumerable: true,
  get: function () {
    return _OverviewMap.default;
  }
});
Object.defineProperty(exports, "ScaleLine", {
  enumerable: true,
  get: function () {
    return _ScaleLine.default;
  }
});
Object.defineProperty(exports, "ZoomSlider", {
  enumerable: true,
  get: function () {
    return _ZoomSlider.default;
  }
});
Object.defineProperty(exports, "ZoomToExtent", {
  enumerable: true,
  get: function () {
    return _ZoomToExtent.default;
  }
});

var _Collection = _interopRequireDefault(require("./Collection.js"));

var _Attribution = _interopRequireDefault(require("./control/Attribution.js"));

var _Rotate = _interopRequireDefault(require("./control/Rotate.js"));

var _Zoom = _interopRequireDefault(require("./control/Zoom.js"));

var _Control = _interopRequireDefault(require("./control/Control.js"));

var _FullScreen = _interopRequireDefault(require("./control/FullScreen.js"));

var _MousePosition = _interopRequireDefault(require("./control/MousePosition.js"));

var _OverviewMap = _interopRequireDefault(require("./control/OverviewMap.js"));

var _ScaleLine = _interopRequireDefault(require("./control/ScaleLine.js"));

var _ZoomSlider = _interopRequireDefault(require("./control/ZoomSlider.js"));

var _ZoomToExtent = _interopRequireDefault(require("./control/ZoomToExtent.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/control
 */

/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [attribution=true] Include
 * {@link module:ol/control/Attribution~Attribution}.
 * @property {import("./control/Attribution.js").Options} [attributionOptions]
 * Options for {@link module:ol/control/Attribution~Attribution}.
 * @property {boolean} [rotate=true] Include
 * {@link module:ol/control/Rotate~Rotate}.
 * @property {import("./control/Rotate.js").Options} [rotateOptions] Options
 * for {@link module:ol/control/Rotate~Rotate}.
 * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
 * @property {import("./control/Zoom.js").Options} [zoomOptions] Options for
 * {@link module:ol/control/Zoom~Zoom}.
 * @api
 */

/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link module:ol/control/Zoom~Zoom}
 * * {@link module:ol/control/Rotate~Rotate}
 * * {@link module:ol/control/Attribution~Attribution}
 *
 * @param {DefaultsOptions=} opt_options
 * Defaults options.
 * @return {Collection<import("./control/Control.js").default>}
 * Controls.
 * @api
 */
function defaults(opt_options) {
  var options = opt_options ? opt_options : {};
  var controls = new _Collection.default();
  var zoomControl = options.zoom !== undefined ? options.zoom : true;

  if (zoomControl) {
    controls.push(new _Zoom.default(options.zoomOptions));
  }

  var rotateControl = options.rotate !== undefined ? options.rotate : true;

  if (rotateControl) {
    controls.push(new _Rotate.default(options.rotateOptions));
  }

  var attributionControl = options.attribution !== undefined ? options.attribution : true;

  if (attributionControl) {
    controls.push(new _Attribution.default(options.attributionOptions));
  }

  return controls;
}
},{"./Collection.js":"node_modules/ol/Collection.js","./control/Attribution.js":"node_modules/ol/control/Attribution.js","./control/Rotate.js":"node_modules/ol/control/Rotate.js","./control/Zoom.js":"node_modules/ol/control/Zoom.js","./control/Control.js":"node_modules/ol/control/Control.js","./control/FullScreen.js":"node_modules/ol/control/FullScreen.js","./control/MousePosition.js":"node_modules/ol/control/MousePosition.js","./control/OverviewMap.js":"node_modules/ol/control/OverviewMap.js","./control/ScaleLine.js":"node_modules/ol/control/ScaleLine.js","./control/ZoomSlider.js":"node_modules/ol/control/ZoomSlider.js","./control/ZoomToExtent.js":"node_modules/ol/control/ZoomToExtent.js"}],"node_modules/ol/Kinetic.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/Kinetic
 */

/**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @api
 */
var Kinetic =
/** @class */
function () {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  function Kinetic(decay, minVelocity, delay) {
    /**
     * @private
     * @type {number}
     */
    this.decay_ = decay;
    /**
     * @private
     * @type {number}
     */

    this.minVelocity_ = minVelocity;
    /**
     * @private
     * @type {number}
     */

    this.delay_ = delay;
    /**
     * @private
     * @type {Array<number>}
     */

    this.points_ = [];
    /**
     * @private
     * @type {number}
     */

    this.angle_ = 0;
    /**
     * @private
     * @type {number}
     */

    this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */


  Kinetic.prototype.begin = function () {
    this.points_.length = 0;
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */


  Kinetic.prototype.update = function (x, y) {
    this.points_.push(x, y, Date.now());
  };
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */


  Kinetic.prototype.end = function () {
    if (this.points_.length < 6) {
      // at least 2 points are required (i.e. there must be at least 6 elements
      // in the array)
      return false;
    }

    var delay = Date.now() - this.delay_;
    var lastIndex = this.points_.length - 3;

    if (this.points_[lastIndex + 2] < delay) {
      // the last tracked point is too old, which means that the user stopped
      // panning before releasing the map
      return false;
    } // get the first point which still falls into the delay time


    var firstIndex = lastIndex - 3;

    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
      firstIndex -= 3;
    }

    var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2]; // we don't want a duration of 0 (divide by zero)
    // we also make sure the user panned for a duration of at least one frame
    // (1/60s) to compute sane displacement values

    if (duration < 1000 / 60) {
      return false;
    }

    var dx = this.points_[lastIndex] - this.points_[firstIndex];
    var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
    this.angle_ = Math.atan2(dy, dx);
    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
    return this.initialVelocity_ > this.minVelocity_;
  };
  /**
   * @return {number} Total distance travelled (pixels).
   */


  Kinetic.prototype.getDistance = function () {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  };
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */


  Kinetic.prototype.getAngle = function () {
    return this.angle_;
  };

  return Kinetic;
}();

var _default = Kinetic;
exports.default = _default;
},{}],"node_modules/ol/interaction/Property.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/interaction/Property
 */

/**
 * @enum {string}
 */
var _default = {
  ACTIVE: 'active'
};
exports.default = _default;
},{}],"node_modules/ol/interaction/Interaction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pan = pan;
exports.zoomByDelta = zoomByDelta;
exports.default = void 0;

var _Object = _interopRequireDefault(require("../Object.js"));

var _easing = require("../easing.js");

var _Property = _interopRequireDefault(require("./Property.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/Interaction
 */


/**
 * Object literal with config options for interactions.
 * @typedef {Object} InteractionOptions
 * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. If the function returns a falsy value, propagation of
 * the event to other interactions in the map's interactions chain will be
 * prevented (this includes functions with no explicit return). The interactions
 * are traversed in reverse order of the interactions collection of the map.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
 * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
 * by a keyboard event not a button element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * @api
 */
var Interaction =
/** @class */
function (_super) {
  __extends(Interaction, _super);
  /**
   * @param {InteractionOptions} options Options.
   */


  function Interaction(options) {
    var _this = _super.call(this) || this;

    if (options.handleEvent) {
      _this.handleEvent = options.handleEvent;
    }
    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */


    _this.map_ = null;

    _this.setActive(true);

    return _this;
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */


  Interaction.prototype.getActive = function () {
    return (
      /** @type {boolean} */
      this.get(_Property.default.ACTIVE)
    );
  };
  /**
   * Get the map associated with this interaction.
   * @return {import("../PluggableMap.js").default} Map.
   * @api
   */


  Interaction.prototype.getMap = function () {
    return this.map_;
  };
  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */


  Interaction.prototype.handleEvent = function (mapBrowserEvent) {
    return true;
  };
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */


  Interaction.prototype.setActive = function (active) {
    this.set(_Property.default.ACTIVE, active);
  };
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   */


  Interaction.prototype.setMap = function (map) {
    this.map_ = map;
  };

  return Interaction;
}(_Object.default);
/**
 * @param {import("../View.js").default} view View.
 * @param {import("../coordinate.js").Coordinate} delta Delta.
 * @param {number=} opt_duration Duration.
 */


function pan(view, delta, opt_duration) {
  var currentCenter = view.getCenterInternal();

  if (currentCenter) {
    var center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
    view.animateInternal({
      duration: opt_duration !== undefined ? opt_duration : 250,
      easing: _easing.linear,
      center: view.getConstrainedCenter(center)
    });
  }
}
/**
 * @param {import("../View.js").default} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate in the user projection.
 * @param {number=} opt_duration Duration.
 */


function zoomByDelta(view, delta, opt_anchor, opt_duration) {
  var currentZoom = view.getZoom();

  if (currentZoom === undefined) {
    return;
  }

  var newZoom = view.getConstrainedZoom(currentZoom + delta);
  var newResolution = view.getResolutionForZoom(newZoom);

  if (view.getAnimating()) {
    view.cancelAnimations();
  }

  view.animate({
    resolution: newResolution,
    anchor: opt_anchor,
    duration: opt_duration !== undefined ? opt_duration : 250,
    easing: _easing.easeOut
  });
}

var _default = Interaction;
exports.default = _default;
},{"../Object.js":"node_modules/ol/Object.js","../easing.js":"node_modules/ol/easing.js","./Property.js":"node_modules/ol/interaction/Property.js"}],"node_modules/ol/interaction/DoubleClickZoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MapBrowserEventType = _interopRequireDefault(require("../MapBrowserEventType.js"));

var _Interaction = _interopRequireWildcard(require("./Interaction.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/DoubleClickZoom
 */


/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [delta=1] The zoom delta applied on each double click.
 */

/**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 * @api
 */
var DoubleClickZoom =
/** @class */
function (_super) {
  __extends(DoubleClickZoom, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function DoubleClickZoom(opt_options) {
    var _this = _super.call(this, {
      handleEvent: handleEvent
    }) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @private
     * @type {number}
     */

    _this.delta_ = options.delta ? options.delta : 1;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }

  return DoubleClickZoom;
}(_Interaction.default);
/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a
 * doubleclick) and eventually zooms the map.
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {DoubleClickZoom}
 */


function handleEvent(mapBrowserEvent) {
  var stopEvent = false;

  if (mapBrowserEvent.type == _MapBrowserEventType.default.DBLCLICK) {
    var browserEvent =
    /** @type {MouseEvent} */
    mapBrowserEvent.originalEvent;
    var map = mapBrowserEvent.map;
    var anchor = mapBrowserEvent.coordinate;
    var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
    var view = map.getView();
    (0, _Interaction.zoomByDelta)(view, delta, anchor, this.duration_);
    mapBrowserEvent.preventDefault();
    stopEvent = true;
  }

  return !stopEvent;
}

var _default = DoubleClickZoom;
exports.default = _default;
},{"../MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","./Interaction.js":"node_modules/ol/interaction/Interaction.js"}],"node_modules/ol/events/condition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.primaryAction = exports.penOnly = exports.touchOnly = exports.mouseOnly = exports.targetNotEditable = exports.shiftKeyOnly = exports.platformModifierKeyOnly = exports.noModifierKeys = exports.doubleClick = exports.singleClick = exports.pointerMove = exports.never = exports.mouseActionButton = exports.click = exports.always = exports.focus = exports.altShiftKeysOnly = exports.altKeyOnly = void 0;

var _MapBrowserEventType = _interopRequireDefault(require("../MapBrowserEventType.js"));

var _asserts = require("../asserts.js");

var _functions = require("../functions.js");

var _has = require("../has.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/events/condition
 */

/**
 * A function that takes an {@link module:ol/MapBrowserEvent} and returns a
 * `{boolean}`. If the condition is met, true should be returned.
 *
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
 */

/**
 * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
 * additionally the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt key is pressed.
 * @api
 */
var altKeyOnly = function (mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
 * (e.g. when additionally the platform-modifier-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt and shift keys are pressed.
 * @api
 */


exports.altKeyOnly = altKeyOnly;

var altShiftKeysOnly = function (mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
/**
 * Return `true` if the map has the focus. This condition requires a map target
 * element with a `tabindex` attribute, e.g. `<div id="map" tabindex="1">`.
 *
 * @param {import("../MapBrowserEvent.js").default} event Map browser event.
 * @return {boolean} The map has the focus.
 * @api
 */


exports.altShiftKeysOnly = altShiftKeysOnly;

var focus = function (event) {
  return event.target.getTargetElement() === document.activeElement;
};
/**
 * Return always true.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True.
 * @api
 */


exports.focus = focus;
var always = _functions.TRUE;
/**
 * Return `true` if the event is a `click` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `click` event.
 * @api
 */

exports.always = always;

var click = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType.default.CLICK;
};
/**
 * Return `true` if the event has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} The result.
 */


exports.click = click;

var mouseActionButton = function (mapBrowserEvent) {
  var originalEvent =
  /** @type {MouseEvent} */
  mapBrowserEvent.originalEvent;
  return originalEvent.button == 0 && !(_has.WEBKIT && _has.MAC && originalEvent.ctrlKey);
};
/**
 * Return always false.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} False.
 * @api
 */


exports.mouseActionButton = mouseActionButton;
var never = _functions.FALSE;
/**
 * Return `true` if the browser event is a `pointermove` event, `false`
 * otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the browser event is a `pointermove` event.
 * @api
 */

exports.never = never;

var pointerMove = function (mapBrowserEvent) {
  return mapBrowserEvent.type == 'pointermove';
};
/**
 * Return `true` if the event is a map `singleclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `singleclick` event.
 * @api
 */


exports.pointerMove = pointerMove;

var singleClick = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType.default.SINGLECLICK;
};
/**
 * Return `true` if the event is a map `dblclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `dblclick` event.
 * @api
 */


exports.singleClick = singleClick;

var doubleClick = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType.default.DBLCLICK;
};
/**
 * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
 * pressed.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if there no modifier keys are pressed.
 * @api
 */


exports.doubleClick = doubleClick;

var noModifierKeys = function (mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
 * the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the platform modifier key is pressed.
 * @api
 */


exports.noModifierKeys = noModifierKeys;

var platformModifierKeyOnly = function (mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && (_has.MAC ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
 * additionally the alt-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the shift key is pressed.
 * @api
 */


exports.platformModifierKeyOnly = platformModifierKeyOnly;

var shiftKeyOnly = function (mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
/**
 * Return `true` if the target element is not editable, i.e. not a `<input>`-,
 * `<select>`- or `<textarea>`-element, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if the target element is not editable.
 * @api
 */


exports.shiftKeyOnly = shiftKeyOnly;

var targetNotEditable = function (mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  var tagName =
  /** @type {Element} */
  originalEvent.target.tagName;
  return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA';
};
/**
 * Return `true` if the event originates from a mouse device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a mouse device.
 * @api
 */


exports.targetNotEditable = targetNotEditable;

var mouseOnly = function (mapBrowserEvent) {
  var pointerEvent =
  /** @type {import("../MapBrowserPointerEvent").default} */
  mapBrowserEvent.pointerEvent;
  (0, _asserts.assert)(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
  // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType

  return pointerEvent.pointerType == 'mouse';
};
/**
 * Return `true` if the event originates from a touchable device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a touchable device.
 * @api
 */


exports.mouseOnly = mouseOnly;

var touchOnly = function (mapBrowserEvent) {
  var pointerEvt =
  /** @type {import("../MapBrowserPointerEvent").default} */
  mapBrowserEvent.pointerEvent;
  (0, _asserts.assert)(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event
  // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType

  return pointerEvt.pointerType === 'touch';
};
/**
 * Return `true` if the event originates from a digital pen.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a digital pen.
 * @api
 */


exports.touchOnly = touchOnly;

var penOnly = function (mapBrowserEvent) {
  var pointerEvt =
  /** @type {import("../MapBrowserPointerEvent").default} */
  mapBrowserEvent.pointerEvent;
  (0, _asserts.assert)(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event
  // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType

  return pointerEvt.pointerType === 'pen';
};
/**
 * Return `true` if the event originates from a primary pointer in
 * contact with the surface or if the left mouse button is pressed.
 * See http://www.w3.org/TR/pointerevents/#button-states.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a primary pointer.
 * @api
 */


exports.penOnly = penOnly;

var primaryAction = function (mapBrowserEvent) {
  var pointerEvent =
  /** @type {import("../MapBrowserPointerEvent").default} */
  mapBrowserEvent.pointerEvent;
  (0, _asserts.assert)(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event

  return pointerEvent.isPrimary && pointerEvent.button === 0;
};

exports.primaryAction = primaryAction;
},{"../MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","../asserts.js":"node_modules/ol/asserts.js","../functions.js":"node_modules/ol/functions.js","../has.js":"node_modules/ol/has.js"}],"node_modules/ol/interaction/Pointer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.centroid = centroid;
exports.default = void 0;

var _MapBrowserEventType = _interopRequireDefault(require("../MapBrowserEventType.js"));

var _Interaction = _interopRequireDefault(require("./Interaction.js"));

var _obj = require("../obj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/Pointer
 */


/**
 * @typedef {Object} Options
 * @property {function(import("../MapBrowserPointerEvent.js").default):boolean} [handleDownEvent]
 * Function handling "down" events. If the function returns `true` then a drag
 * sequence is started.
 * @property {function(import("../MapBrowserPointerEvent.js").default)} [handleDragEvent]
 * Function handling "drag" events. This function is called on "move" events
 * during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. The function may return `false` to prevent the
 * propagation of the event to other interactions in the map's interactions
 * chain.
 * @property {function(import("../MapBrowserPointerEvent.js").default)} [handleMoveEvent]
 * Function handling "move" events. This function is called on "move" events.
 * This functions is also called during a drag sequence, so during a drag
 * sequence both the `handleDragEvent` function and this function are called.
 * If `handleDownEvent` is defined and it returns true this function will not
 * be called during a drag sequence.
 * @property {function(import("../MapBrowserPointerEvent.js").default):boolean} [handleUpEvent]
 *  Function handling "up" events. If the function returns `false` then the
 * current drag sequence is stopped.
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */

/**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * @api
 */
var PointerInteraction =
/** @class */
function (_super) {
  __extends(PointerInteraction, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function PointerInteraction(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this,
    /** @type {import("./Interaction.js").InteractionOptions} */
    options) || this;

    if (options.handleDownEvent) {
      _this.handleDownEvent = options.handleDownEvent;
    }

    if (options.handleDragEvent) {
      _this.handleDragEvent = options.handleDragEvent;
    }

    if (options.handleMoveEvent) {
      _this.handleMoveEvent = options.handleMoveEvent;
    }

    if (options.handleUpEvent) {
      _this.handleUpEvent = options.handleUpEvent;
    }

    if (options.stopDown) {
      _this.stopDown = options.stopDown;
    }
    /**
     * @type {boolean}
     * @protected
     */


    _this.handlingDownUpSequence = false;
    /**
     * @type {!Object<string, PointerEvent>}
     * @private
     */

    _this.trackedPointers_ = {};
    /**
     * @type {Array<PointerEvent>}
     * @protected
     */

    _this.targetPointers = [];
    return _this;
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */


  PointerInteraction.prototype.getPointerCount = function () {
    return this.targetPointers.length;
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */


  PointerInteraction.prototype.handleDownEvent = function (mapBrowserEvent) {
    return false;
  };
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
   * @protected
   */


  PointerInteraction.prototype.handleDragEvent = function (mapBrowserEvent) {};
  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @override
   * @api
   */


  PointerInteraction.prototype.handleEvent = function (mapBrowserEvent) {
    if (!
    /** @type {import("../MapBrowserPointerEvent.js").default} */
    mapBrowserEvent.pointerEvent) {
      return true;
    }

    var stopEvent = false;
    this.updateTrackedPointers_(mapBrowserEvent);

    if (this.handlingDownUpSequence) {
      if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERDRAG) {
        this.handleDragEvent(mapBrowserEvent);
      } else if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERUP) {
        var handledUp = this.handleUpEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
      }
    } else {
      if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERDOWN) {
        var handled = this.handleDownEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handled;
        stopEvent = this.stopDown(handled);
      } else if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERMOVE) {
        this.handleMoveEvent(mapBrowserEvent);
      }
    }

    return !stopEvent;
  };
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
   * @protected
   */


  PointerInteraction.prototype.handleMoveEvent = function (mapBrowserEvent) {};
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */


  PointerInteraction.prototype.handleUpEvent = function (mapBrowserEvent) {
    return false;
  };
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */


  PointerInteraction.prototype.stopDown = function (handled) {
    return handled;
  };
  /**
   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
   * @private
   */


  PointerInteraction.prototype.updateTrackedPointers_ = function (mapBrowserEvent) {
    if (isPointerDraggingEvent(mapBrowserEvent)) {
      var event_1 = mapBrowserEvent.pointerEvent;
      var id = event_1.pointerId.toString();

      if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERUP) {
        delete this.trackedPointers_[id];
      } else if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERDOWN) {
        this.trackedPointers_[id] = event_1;
      } else if (id in this.trackedPointers_) {
        // update only when there was a pointerdown event for this pointer
        this.trackedPointers_[id] = event_1;
      }

      this.targetPointers = (0, _obj.getValues)(this.trackedPointers_);
    }
  };

  return PointerInteraction;
}(_Interaction.default);
/**
 * @param {Array<PointerEvent>} pointerEvents List of events.
 * @return {import("../pixel.js").Pixel} Centroid pixel.
 */


function centroid(pointerEvents) {
  var length = pointerEvents.length;
  var clientX = 0;
  var clientY = 0;

  for (var i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }

  return [clientX / length, clientY / length];
}
/**
 * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
 * @return {boolean} Whether the event is a pointerdown, pointerdrag
 *     or pointerup event.
 */


function isPointerDraggingEvent(mapBrowserEvent) {
  var type = mapBrowserEvent.type;
  return type === _MapBrowserEventType.default.POINTERDOWN || type === _MapBrowserEventType.default.POINTERDRAG || type === _MapBrowserEventType.default.POINTERUP;
}

var _default = PointerInteraction;
exports.default = _default;
},{"../MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","./Interaction.js":"node_modules/ol/interaction/Interaction.js","../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/interaction/DragPan.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _coordinate = require("../coordinate.js");

var _easing = require("../easing.js");

var _condition = require("../events/condition.js");

var _functions = require("../functions.js");

var _Pointer = _interopRequireWildcard(require("./Pointer.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/DragPan
 */


/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~noModifierKeys} and {@link module:ol/events/condition~primaryAction}.
 * In addition, if there is a `tabindex` attribute on the map element,
 * {@link module:ol/events/condition~focus} will also be applied.
 * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
 */

/**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 * @api
 */
var DragPan =
/** @class */
function (_super) {
  __extends(DragPan, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function DragPan(opt_options) {
    var _this = _super.call(this, {
      stopDown: _functions.FALSE
    }) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @private
     * @type {import("../Kinetic.js").default|undefined}
     */

    _this.kinetic_ = options.kinetic;
    /**
     * @type {import("../pixel.js").Pixel}
     */

    _this.lastCentroid = null;
    /**
     * @type {number}
     */

    _this.lastPointersCount_;
    /**
     * @type {boolean}
     */

    _this.panning_ = false;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : defaultCondition;
    /**
     * @private
     * @type {boolean}
     */

    _this.noKinetic_ = false;
    return _this;
  }
  /**
   * @private
   * @param {import("../MapBrowserEvent").default} mapBrowserEvent Event.
   * @return {boolean} Condition passes.
   */


  DragPan.prototype.conditionInternal_ = function (mapBrowserEvent) {
    var pass = true;

    if (mapBrowserEvent.map.getTargetElement().hasAttribute('tabindex')) {
      pass = (0, _condition.focus)(mapBrowserEvent);
    }

    return pass && this.condition_(mapBrowserEvent);
  };
  /**
   * @inheritDoc
   */


  DragPan.prototype.handleDragEvent = function (mapBrowserEvent) {
    if (!this.panning_) {
      this.panning_ = true;
      this.getMap().getView().beginInteraction();
    }

    var targetPointers = this.targetPointers;
    var centroid = (0, _Pointer.centroid)(targetPointers);

    if (targetPointers.length == this.lastPointersCount_) {
      if (this.kinetic_) {
        this.kinetic_.update(centroid[0], centroid[1]);
      }

      if (this.lastCentroid) {
        var delta = [this.lastCentroid[0] - centroid[0], centroid[1] - this.lastCentroid[1]];
        var map = mapBrowserEvent.map;
        var view = map.getView();
        (0, _coordinate.scale)(delta, view.getResolution());
        (0, _coordinate.rotate)(delta, view.getRotation());
        view.adjustCenterInternal(delta);
      }
    } else if (this.kinetic_) {
      // reset so we don't overestimate the kinetic energy after
      // after one finger down, tiny drag, second finger down
      this.kinetic_.begin();
    }

    this.lastCentroid = centroid;
    this.lastPointersCount_ = targetPointers.length;
    mapBrowserEvent.originalEvent.preventDefault();
  };
  /**
   * @inheritDoc
   */


  DragPan.prototype.handleUpEvent = function (mapBrowserEvent) {
    var map = mapBrowserEvent.map;
    var view = map.getView();

    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        var distance = this.kinetic_.getDistance();
        var angle = this.kinetic_.getAngle();
        var center = view.getCenterInternal();
        var centerpx = map.getPixelFromCoordinateInternal(center);
        var dest = map.getCoordinateFromPixelInternal([centerpx[0] - distance * Math.cos(angle), centerpx[1] - distance * Math.sin(angle)]);
        view.animateInternal({
          center: view.getConstrainedCenter(dest),
          duration: 500,
          easing: _easing.easeOut
        });
      }

      if (this.panning_) {
        this.panning_ = false;
        view.endInteraction();
      }

      return false;
    } else {
      if (this.kinetic_) {
        // reset so we don't overestimate the kinetic energy after
        // after one finger up, tiny drag, second finger up
        this.kinetic_.begin();
      }

      this.lastCentroid = null;
      return true;
    }
  };
  /**
   * @inheritDoc
   */


  DragPan.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (this.targetPointers.length > 0 && this.conditionInternal_(mapBrowserEvent)) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      this.lastCentroid = null; // stop any current animation

      if (view.getAnimating()) {
        view.cancelAnimations();
      }

      if (this.kinetic_) {
        this.kinetic_.begin();
      } // No kinetic as soon as more than one pointer on the screen is
      // detected. This is to prevent nasty pans after pinch.


      this.noKinetic_ = this.targetPointers.length > 1;
      return true;
    } else {
      return false;
    }
  };

  return DragPan;
}(_Pointer.default);
/**
 * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Browser event.
 * @return {boolean} Combined condition result.
 */


function defaultCondition(mapBrowserEvent) {
  return (0, _condition.noModifierKeys)(mapBrowserEvent) && (0, _condition.primaryAction)(mapBrowserEvent);
}

var _default = DragPan;
exports.default = _default;
},{"../coordinate.js":"node_modules/ol/coordinate.js","../easing.js":"node_modules/ol/easing.js","../events/condition.js":"node_modules/ol/events/condition.js","../functions.js":"node_modules/ol/functions.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js"}],"node_modules/ol/interaction/DragRotate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rotationconstraint = require("../rotationconstraint.js");

var _condition = require("../events/condition.js");

var _functions = require("../functions.js");

var _Pointer = _interopRequireDefault(require("./Pointer.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/DragRotate
 */


/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an
 * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~altShiftKeysOnly}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 */

/**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 * @api
 */
var DragRotate =
/** @class */
function (_super) {
  __extends(DragRotate, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function DragRotate(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      stopDown: _functions.FALSE
    }) || this;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _condition.altShiftKeysOnly;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastAngle_ = undefined;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }
  /**
   * @inheritDoc
   */


  DragRotate.prototype.handleDragEvent = function (mapBrowserEvent) {
    if (!(0, _condition.mouseOnly)(mapBrowserEvent)) {
      return;
    }

    var map = mapBrowserEvent.map;
    var view = map.getView();

    if (view.getConstraints().rotation === _rotationconstraint.disable) {
      return;
    }

    var size = map.getSize();
    var offset = mapBrowserEvent.pixel;
    var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);

    if (this.lastAngle_ !== undefined) {
      var delta = theta - this.lastAngle_;
      view.adjustRotationInternal(-delta);
    }

    this.lastAngle_ = theta;
  };
  /**
   * @inheritDoc
   */


  DragRotate.prototype.handleUpEvent = function (mapBrowserEvent) {
    if (!(0, _condition.mouseOnly)(mapBrowserEvent)) {
      return true;
    }

    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.endInteraction(this.duration_);
    return false;
  };
  /**
   * @inheritDoc
   */


  DragRotate.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (!(0, _condition.mouseOnly)(mapBrowserEvent)) {
      return false;
    }

    if ((0, _condition.mouseActionButton)(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
      var map = mapBrowserEvent.map;
      map.getView().beginInteraction();
      this.lastAngle_ = undefined;
      return true;
    } else {
      return false;
    }
  };

  return DragRotate;
}(_Pointer.default);

var _default = DragRotate;
exports.default = _default;
},{"../rotationconstraint.js":"node_modules/ol/rotationconstraint.js","../events/condition.js":"node_modules/ol/events/condition.js","../functions.js":"node_modules/ol/functions.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js"}],"node_modules/ol/render/Box.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Disposable = _interopRequireDefault(require("../Disposable.js"));

var _Polygon = _interopRequireDefault(require("../geom/Polygon.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render/Box
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var RenderBox =
/** @class */
function (_super) {
  __extends(RenderBox, _super);
  /**
   * @param {string} className CSS class name.
   */


  function RenderBox(className) {
    var _this = _super.call(this) || this;
    /**
     * @type {import("../geom/Polygon.js").default}
     * @private
     */


    _this.geometry_ = null;
    /**
     * @type {HTMLDivElement}
     * @private
     */

    _this.element_ = document.createElement('div');
    _this.element_.style.position = 'absolute';
    _this.element_.className = 'ol-box ' + className;
    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */

    _this.map_ = null;
    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */

    _this.startPixel_ = null;
    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */

    _this.endPixel_ = null;
    return _this;
  }
  /**
   * @inheritDoc
   */


  RenderBox.prototype.disposeInternal = function () {
    this.setMap(null);
  };
  /**
   * @private
   */


  RenderBox.prototype.render_ = function () {
    var startPixel = this.startPixel_;
    var endPixel = this.endPixel_;
    var px = 'px';
    var style = this.element_.style;
    style.left = Math.min(startPixel[0], endPixel[0]) + px;
    style.top = Math.min(startPixel[1], endPixel[1]) + px;
    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  };
  /**
   * @param {import("../PluggableMap.js").default} map Map.
   */


  RenderBox.prototype.setMap = function (map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      var style = this.element_.style;
      style.left = 'inherit';
      style.top = 'inherit';
      style.width = 'inherit';
      style.height = 'inherit';
    }

    this.map_ = map;

    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  };
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */


  RenderBox.prototype.setPixels = function (startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  };
  /**
   * Creates or updates the cached geometry.
   */


  RenderBox.prototype.createOrUpdateGeometry = function () {
    var startPixel = this.startPixel_;
    var endPixel = this.endPixel_;
    var pixels = [startPixel, [startPixel[0], endPixel[1]], endPixel, [endPixel[0], startPixel[1]]];
    var coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_); // close the polygon

    coordinates[4] = coordinates[0].slice();

    if (!this.geometry_) {
      this.geometry_ = new _Polygon.default([coordinates]);
    } else {
      this.geometry_.setCoordinates([coordinates]);
    }
  };
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */


  RenderBox.prototype.getGeometry = function () {
    return this.geometry_;
  };

  return RenderBox;
}(_Disposable.default);

var _default = RenderBox;
exports.default = _default;
},{"../Disposable.js":"node_modules/ol/Disposable.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js"}],"node_modules/ol/interaction/DragBox.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _condition = require("../events/condition.js");

var _functions = require("../functions.js");

var _Pointer = _interopRequireDefault(require("./Pointer.js"));

var _Box = _interopRequireDefault(require("../render/Box.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/DragBox
 */
// FIXME draw drag box


/**
 * A function that takes a {@link module:ol/MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
 * true should be returned.
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link ol/events/condition~mouseActionButton}.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
 * `boxEndCondition` function.
 * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
 * Default is `true` if the area of the box is bigger than the `minArea` option.
 * @property {function(this:DragBox, import("../MapBrowserEvent.js").default)} [onBoxEnd] Code to execute just
 * before `boxend` is fired.
 */

/**
 * @enum {string}
 */
var DragBoxEventType = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: 'boxstart',

  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: 'boxdrag',

  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: 'boxend'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
 * this type.
 */

var DragBoxEvent =
/** @class */
function (_super) {
  __extends(DragBoxEvent, _super);
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */


  function DragBoxEvent(type, coordinate, mapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */


    _this.coordinate = coordinate;
    /**
     * @const
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */

    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }

  return DragBoxEvent;
}(_Event.default);
/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link module:ol/interaction/DragZoom~DragZoom} and
 * {@link module:ol/interaction/DragRotateAndZoom}).
 *
 * @fires DragBoxEvent
 * @api
 */


var DragBox =
/** @class */
function (_super) {
  __extends(DragBox, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function DragBox(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @type {import("../render/Box.js").default}
     * @private
     */

    _this.box_ = new _Box.default(options.className || 'ol-dragbox');
    /**
     * @type {number}
     * @private
     */

    _this.minArea_ = options.minArea !== undefined ? options.minArea : 64;
    /**
     * Function to execute just before `onboxend` is fired
     * @type {function(this:DragBox, import("../MapBrowserEvent.js").default): void}
     * @private
     */

    _this.onBoxEnd_ = options.onBoxEnd ? options.onBoxEnd : _functions.VOID;
    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */

    _this.startPixel_ = null;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _condition.mouseActionButton;
    /**
     * @private
     * @type {EndCondition}
     */

    _this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : _this.defaultBoxEndCondition;
    return _this;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */


  DragBox.prototype.defaultBoxEndCondition = function (mapBrowserEvent, startPixel, endPixel) {
    var width = endPixel[0] - startPixel[0];
    var height = endPixel[1] - startPixel[1];
    return width * width + height * height >= this.minArea_;
  };
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */


  DragBox.prototype.getGeometry = function () {
    return this.box_.getGeometry();
  };
  /**
   * @inheritDoc
   */


  DragBox.prototype.handleDragEvent = function (mapBrowserEvent) {
    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
  };
  /**
   * @inheritDoc
   */


  DragBox.prototype.handleUpEvent = function (mapBrowserEvent) {
    this.box_.setMap(null);

    if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {
      this.onBoxEnd_(mapBrowserEvent);
      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXEND, mapBrowserEvent.coordinate, mapBrowserEvent));
    }

    return false;
  };
  /**
   * @inheritDoc
   */


  DragBox.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (this.condition_(mapBrowserEvent)) {
      this.startPixel_ = mapBrowserEvent.pixel;
      this.box_.setMap(mapBrowserEvent.map);
      this.box_.setPixels(this.startPixel_, this.startPixel_);
      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
      return true;
    } else {
      return false;
    }
  };

  return DragBox;
}(_Pointer.default);

var _default = DragBox;
exports.default = _default;
},{"../events/Event.js":"node_modules/ol/events/Event.js","../events/condition.js":"node_modules/ol/events/condition.js","../functions.js":"node_modules/ol/functions.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js","../render/Box.js":"node_modules/ol/render/Box.js"}],"node_modules/ol/interaction/DragZoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _easing = require("../easing.js");

var _condition = require("../events/condition.js");

var _extent = require("../extent.js");

var _DragBox = _interopRequireDefault(require("./DragBox.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/DragZoom
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragzoom'] CSS class name for styling the
 * box.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~shiftKeyOnly}.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {boolean} [out=false] Use interaction for zooming out.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
 * `boxEndCondition` function.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 * @api
 */
var DragZoom =
/** @class */
function (_super) {
  __extends(DragZoom, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function DragZoom(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var condition = options.condition ? options.condition : _condition.shiftKeyOnly;
    _this = _super.call(this, {
      condition: condition,
      className: options.className || 'ol-dragzoom',
      minArea: options.minArea,
      onBoxEnd: onBoxEnd
    }) || this;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 200;
    /**
     * @private
     * @type {boolean}
     */

    _this.out_ = options.out !== undefined ? options.out : false;
    return _this;
  }

  return DragZoom;
}(_DragBox.default);
/**
 * @this {DragZoom}
 */


function onBoxEnd() {
  var map = this.getMap();
  var view =
  /** @type {!import("../View.js").default} */
  map.getView();
  var size =
  /** @type {!import("../size.js").Size} */
  map.getSize();
  var extent = this.getGeometry().getExtent();

  if (this.out_) {
    var mapExtent = view.calculateExtentInternal(size);
    var boxPixelExtent = (0, _extent.createOrUpdateFromCoordinates)([map.getPixelFromCoordinateInternal((0, _extent.getBottomLeft)(extent)), map.getPixelFromCoordinateInternal((0, _extent.getTopRight)(extent))]);
    var factor = view.getResolutionForExtentInternal(boxPixelExtent, size);
    (0, _extent.scaleFromCenter)(mapExtent, 1 / factor);
    extent = mapExtent;
  }

  var resolution = view.getConstrainedResolution(view.getResolutionForExtentInternal(extent, size));
  var center = view.getConstrainedCenter((0, _extent.getCenter)(extent), resolution);
  view.animateInternal({
    resolution: resolution,
    center: center,
    duration: this.duration_,
    easing: _easing.easeOut
  });
}

var _default = DragZoom;
exports.default = _default;
},{"../easing.js":"node_modules/ol/easing.js","../events/condition.js":"node_modules/ol/events/condition.js","../extent.js":"node_modules/ol/extent.js","./DragBox.js":"node_modules/ol/interaction/DragBox.js"}],"node_modules/ol/events/KeyCode.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/events/KeyCode
 */

/**
 * @enum {number}
 * @const
 */
var _default = {
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
};
exports.default = _default;
},{}],"node_modules/ol/interaction/KeyboardPan.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _coordinate = require("../coordinate.js");

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _KeyCode = _interopRequireDefault(require("../events/KeyCode.js"));

var _condition = require("../events/condition.js");

var _Interaction = _interopRequireWildcard(require("./Interaction.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/KeyboardPan
 */


/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition~noModifierKeys} and
 * {@link module:ol/events/condition~targetNotEditable}.
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
 * press.
 */

/**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
 * @api
 */
var KeyboardPan =
/** @class */
function (_super) {
  __extends(KeyboardPan, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function KeyboardPan(opt_options) {
    var _this = _super.call(this, {
      handleEvent: handleEvent
    }) || this;

    var options = opt_options || {};
    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */

    _this.defaultCondition_ = function (mapBrowserEvent) {
      return (0, _condition.noModifierKeys)(mapBrowserEvent) && (0, _condition.targetNotEditable)(mapBrowserEvent);
    };
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */


    _this.condition_ = options.condition !== undefined ? options.condition : _this.defaultCondition_;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 100;
    /**
     * @private
     * @type {number}
     */

    _this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;
    return _this;
  }

  return KeyboardPan;
}(_Interaction.default);
/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides the direction to pan to (if an arrow key was
 * pressed).
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {KeyboardPan}
 */


function handleEvent(mapBrowserEvent) {
  var stopEvent = false;

  if (mapBrowserEvent.type == _EventType.default.KEYDOWN) {
    var keyEvent =
    /** @type {KeyboardEvent} */
    mapBrowserEvent.originalEvent;
    var keyCode = keyEvent.keyCode;

    if (this.condition_(mapBrowserEvent) && (keyCode == _KeyCode.default.DOWN || keyCode == _KeyCode.default.LEFT || keyCode == _KeyCode.default.RIGHT || keyCode == _KeyCode.default.UP)) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
      var deltaX = 0,
          deltaY = 0;

      if (keyCode == _KeyCode.default.DOWN) {
        deltaY = -mapUnitsDelta;
      } else if (keyCode == _KeyCode.default.LEFT) {
        deltaX = -mapUnitsDelta;
      } else if (keyCode == _KeyCode.default.RIGHT) {
        deltaX = mapUnitsDelta;
      } else {
        deltaY = mapUnitsDelta;
      }

      var delta = [deltaX, deltaY];
      (0, _coordinate.rotate)(delta, view.getRotation());
      (0, _Interaction.pan)(view, delta, this.duration_);
      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }

  return !stopEvent;
}

var _default = KeyboardPan;
exports.default = _default;
},{"../coordinate.js":"node_modules/ol/coordinate.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../events/KeyCode.js":"node_modules/ol/events/KeyCode.js","../events/condition.js":"node_modules/ol/events/condition.js","./Interaction.js":"node_modules/ol/interaction/Interaction.js"}],"node_modules/ol/interaction/KeyboardZoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _condition = require("../events/condition.js");

var _Interaction = _interopRequireWildcard(require("./Interaction.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/KeyboardZoom
 */


/**
 * @typedef {Object} Options
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition~targetNotEditable}.
 * @property {number} [delta=1] The zoom level delta on each key press.
 */

/**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
 * @api
 */
var KeyboardZoom =
/** @class */
function (_super) {
  __extends(KeyboardZoom, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function KeyboardZoom(opt_options) {
    var _this = _super.call(this, {
      handleEvent: handleEvent
    }) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _condition.targetNotEditable;
    /**
     * @private
     * @type {number}
     */

    _this.delta_ = options.delta ? options.delta : 1;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 100;
    return _this;
  }

  return KeyboardZoom;
}(_Interaction.default);
/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
 * key pressed was '+' or '-').
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {KeyboardZoom}
 */


function handleEvent(mapBrowserEvent) {
  var stopEvent = false;

  if (mapBrowserEvent.type == _EventType.default.KEYDOWN || mapBrowserEvent.type == _EventType.default.KEYPRESS) {
    var keyEvent =
    /** @type {KeyboardEvent} */
    mapBrowserEvent.originalEvent;
    var charCode = keyEvent.charCode;

    if (this.condition_(mapBrowserEvent) && (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
      var map = mapBrowserEvent.map;
      var delta = charCode == '+'.charCodeAt(0) ? this.delta_ : -this.delta_;
      var view = map.getView();
      (0, _Interaction.zoomByDelta)(view, delta, undefined, this.duration_);
      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }

  return !stopEvent;
}

var _default = KeyboardZoom;
exports.default = _default;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","../events/condition.js":"node_modules/ol/events/condition.js","./Interaction.js":"node_modules/ol/interaction/Interaction.js"}],"node_modules/ol/interaction/MouseWheelZoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Mode = void 0;

var _condition = require("../events/condition.js");

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _has = require("../has.js");

var _Interaction = _interopRequireWildcard(require("./Interaction.js"));

var _math = require("../math.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/MouseWheelZoom
 */


/**
 * @enum {string}
 */
var Mode = {
  TRACKPAD: 'trackpad',
  WHEEL: 'wheel'
};
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition~always}.
 * In addition, if there is a `tabindex` attribute on the map element,
 * {@link module:ol/events/condition~focus} will also be applied.
 * @property {number} [maxDelta=1] Maximum mouse wheel delta.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
 * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
 * location as the anchor. When set to `false`, zooming in and out will zoom to
 * the center of the screen instead of zooming on the mouse's location.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 * @api
 */

exports.Mode = Mode;

var MouseWheelZoom =
/** @class */
function (_super) {
  __extends(MouseWheelZoom, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function MouseWheelZoom(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this,
    /** @type {import("./Interaction.js").InteractionOptions} */
    options) || this;
    /**
     * @private
     * @type {number}
     */

    _this.totalDelta_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.lastDelta_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    /**
     * @private
     * @type {number}
     */

    _this.timeout_ = options.timeout !== undefined ? options.timeout : 80;
    /**
     * @private
     * @type {boolean}
     */

    _this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _condition.always;
    /**
     * @private
     * @type {?import("../coordinate.js").Coordinate}
     */

    _this.lastAnchor_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.startTime_ = undefined;
    /**
     * @private
     * @type {?}
     */

    _this.timeoutId_;
    /**
     * @private
     * @type {Mode|undefined}
     */

    _this.mode_ = undefined;
    /**
     * Trackpad events separated by this delay will be considered separate
     * interactions.
     * @type {number}
     */

    _this.trackpadEventGap_ = 400;
    /**
     * @type {?}
     */

    _this.trackpadTimeoutId_;
    /**
     * The number of delta values per zoom level
     * @private
     * @type {number}
     */

    _this.deltaPerZoom_ = 300;
    return _this;
  }
  /**
   * @private
   * @param {import("../MapBrowserEvent").default} mapBrowserEvent Event.
   * @return {boolean} Condition passes.
   */


  MouseWheelZoom.prototype.conditionInternal_ = function (mapBrowserEvent) {
    var pass = true;

    if (mapBrowserEvent.map.getTargetElement().hasAttribute('tabindex')) {
      pass = (0, _condition.focus)(mapBrowserEvent);
    }

    return pass && this.condition_(mapBrowserEvent);
  };
  /**
   * @private
   */


  MouseWheelZoom.prototype.endInteraction_ = function () {
    this.trackpadTimeoutId_ = undefined;
    var view = this.getMap().getView();
    view.endInteraction(undefined, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_);
  };
  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @override
   */


  MouseWheelZoom.prototype.handleEvent = function (mapBrowserEvent) {
    if (!this.conditionInternal_(mapBrowserEvent)) {
      return true;
    }

    var type = mapBrowserEvent.type;

    if (type !== _EventType.default.WHEEL) {
      return true;
    }

    mapBrowserEvent.preventDefault();
    var map = mapBrowserEvent.map;
    var wheelEvent =
    /** @type {WheelEvent} */
    mapBrowserEvent.originalEvent;

    if (this.useAnchor_) {
      this.lastAnchor_ = mapBrowserEvent.coordinate;
    } // Delta normalisation inspired by
    // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js


    var delta;

    if (mapBrowserEvent.type == _EventType.default.WHEEL) {
      delta = wheelEvent.deltaY;

      if (_has.FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
        delta /= _has.DEVICE_PIXEL_RATIO;
      }

      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta *= 40;
      }
    }

    if (delta === 0) {
      return false;
    } else {
      this.lastDelta_ = delta;
    }

    var now = Date.now();

    if (this.startTime_ === undefined) {
      this.startTime_ = now;
    }

    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
      this.mode_ = Math.abs(delta) < 4 ? Mode.TRACKPAD : Mode.WHEEL;
    }

    var view = map.getView();

    if (this.mode_ === Mode.TRACKPAD && !view.getConstrainResolution()) {
      if (this.trackpadTimeoutId_) {
        clearTimeout(this.trackpadTimeoutId_);
      } else {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }

        view.beginInteraction();
      }

      this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
      view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
      this.startTime_ = now;
      return false;
    }

    this.totalDelta_ += delta;
    var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
    return false;
  };
  /**
   * @private
   * @param {import("../PluggableMap.js").default} map Map.
   */


  MouseWheelZoom.prototype.handleWheelZoom_ = function (map) {
    var view = map.getView();

    if (view.getAnimating()) {
      view.cancelAnimations();
    }

    var delta = -(0, _math.clamp)(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;

    if (view.getConstrainResolution()) {
      // view has a zoom constraint, zoom by 1
      delta = delta ? delta > 0 ? 1 : -1 : 0;
    }

    (0, _Interaction.zoomByDelta)(view, delta, this.lastAnchor_, this.duration_);
    this.mode_ = undefined;
    this.totalDelta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = undefined;
    this.timeoutId_ = undefined;
  };
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */


  MouseWheelZoom.prototype.setMouseAnchor = function (useAnchor) {
    this.useAnchor_ = useAnchor;

    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  };

  return MouseWheelZoom;
}(_Interaction.default);

var _default = MouseWheelZoom;
exports.default = _default;
},{"../events/condition.js":"node_modules/ol/events/condition.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../has.js":"node_modules/ol/has.js","./Interaction.js":"node_modules/ol/interaction/Interaction.js","../math.js":"node_modules/ol/math.js"}],"node_modules/ol/interaction/PinchRotate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _functions = require("../functions.js");

var _Pointer = _interopRequireWildcard(require("./Pointer.js"));

var _rotationconstraint = require("../rotationconstraint.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/PinchRotate
 */


/**
 * @typedef {Object} Options
 * @property {number} [duration=250] The duration of the animation in
 * milliseconds.
 * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
 */

/**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 * @api
 */
var PinchRotate =
/** @class */
function (_super) {
  __extends(PinchRotate, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function PinchRotate(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var pointerOptions =
    /** @type {import("./Pointer.js").Options} */
    options;

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions.FALSE;
    }

    _this = _super.call(this, pointerOptions) || this;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */

    _this.anchor_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastAngle_ = undefined;
    /**
     * @private
     * @type {boolean}
     */

    _this.rotating_ = false;
    /**
     * @private
     * @type {number}
     */

    _this.rotationDelta_ = 0.0;
    /**
     * @private
     * @type {number}
     */

    _this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }
  /**
   * @inheritDoc
   */


  PinchRotate.prototype.handleDragEvent = function (mapBrowserEvent) {
    var rotationDelta = 0.0;
    var touch0 = this.targetPointers[0];
    var touch1 = this.targetPointers[1]; // angle between touches

    var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);

    if (this.lastAngle_ !== undefined) {
      var delta = angle - this.lastAngle_;
      this.rotationDelta_ += delta;

      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
        this.rotating_ = true;
      }

      rotationDelta = delta;
    }

    this.lastAngle_ = angle;
    var map = mapBrowserEvent.map;
    var view = map.getView();

    if (view.getConstraints().rotation === _rotationconstraint.disable) {
      return;
    } // rotate anchor point.
    // FIXME: should be the intersection point between the lines:
    //     touch0,touch1 and previousTouch0,previousTouch1


    var viewportPosition = map.getViewport().getBoundingClientRect();
    var centroid = (0, _Pointer.centroid)(this.targetPointers);
    centroid[0] -= viewportPosition.left;
    centroid[1] -= viewportPosition.top;
    this.anchor_ = map.getCoordinateFromPixelInternal(centroid); // rotate

    if (this.rotating_) {
      map.render();
      view.adjustRotationInternal(rotationDelta, this.anchor_);
    }
  };
  /**
   * @inheritDoc
   */


  PinchRotate.prototype.handleUpEvent = function (mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      view.endInteraction(this.duration_);
      return false;
    } else {
      return true;
    }
  };
  /**
   * @inheritDoc
   */


  PinchRotate.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      var map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastAngle_ = undefined;
      this.rotating_ = false;
      this.rotationDelta_ = 0.0;

      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }

      return true;
    } else {
      return false;
    }
  };

  return PinchRotate;
}(_Pointer.default);

var _default = PinchRotate;
exports.default = _default;
},{"../functions.js":"node_modules/ol/functions.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js","../rotationconstraint.js":"node_modules/ol/rotationconstraint.js"}],"node_modules/ol/interaction/PinchZoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _functions = require("../functions.js");

var _Pointer = _interopRequireWildcard(require("./Pointer.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/PinchZoom
 */


/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 * @api
 */
var PinchZoom =
/** @class */
function (_super) {
  __extends(PinchZoom, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function PinchZoom(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var pointerOptions =
    /** @type {import("./Pointer.js").Options} */
    options;

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions.FALSE;
    }

    _this = _super.call(this, pointerOptions) || this;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */

    _this.anchor_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 400;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastDistance_ = undefined;
    /**
     * @private
     * @type {number}
     */

    _this.lastScaleDelta_ = 1;
    return _this;
  }
  /**
   * @inheritDoc
   */


  PinchZoom.prototype.handleDragEvent = function (mapBrowserEvent) {
    var scaleDelta = 1.0;
    var touch0 = this.targetPointers[0];
    var touch1 = this.targetPointers[1];
    var dx = touch0.clientX - touch1.clientX;
    var dy = touch0.clientY - touch1.clientY; // distance between touches

    var distance = Math.sqrt(dx * dx + dy * dy);

    if (this.lastDistance_ !== undefined) {
      scaleDelta = this.lastDistance_ / distance;
    }

    this.lastDistance_ = distance;
    var map = mapBrowserEvent.map;
    var view = map.getView();

    if (scaleDelta != 1.0) {
      this.lastScaleDelta_ = scaleDelta;
    } // scale anchor point.


    var viewportPosition = map.getViewport().getBoundingClientRect();
    var centroid = (0, _Pointer.centroid)(this.targetPointers);
    centroid[0] -= viewportPosition.left;
    centroid[1] -= viewportPosition.top;
    this.anchor_ = map.getCoordinateFromPixelInternal(centroid); // scale, bypass the resolution constraint

    map.render();
    view.adjustResolutionInternal(scaleDelta, this.anchor_);
  };
  /**
   * @inheritDoc
   */


  PinchZoom.prototype.handleUpEvent = function (mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
      view.endInteraction(this.duration_, direction);
      return false;
    } else {
      return true;
    }
  };
  /**
   * @inheritDoc
   */


  PinchZoom.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      var map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = undefined;
      this.lastScaleDelta_ = 1;

      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }

      return true;
    } else {
      return false;
    }
  };

  return PinchZoom;
}(_Pointer.default);

var _default = PinchZoom;
exports.default = _default;
},{"../functions.js":"node_modules/ol/functions.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js"}],"node_modules/ol/interaction/DragAndDrop.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _functions = require("../functions.js");

var _events = require("../events.js");

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Interaction = _interopRequireDefault(require("./Interaction.js"));

var _proj = require("../proj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/interaction/DragAndDrop
 */
// FIXME should handle all geo-referenced data, not just vector data
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {Array<typeof import("../format/Feature.js").default>} [formatConstructors] Format constructors.
 * @property {import("../source/Vector.js").default} [source] Optional vector source where features will be added.  If a source is provided
 * all existing features will be removed and new features will be added when
 * they are dropped on the target.  If you want to add features to a vector
 * source without removing the existing features (append only), instead of
 * providing the source option listen for the "addfeatures" event.
 * @property {import("../proj.js").ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.
 * @property {HTMLElement} [target] The element that is used as the drop target, default is the viewport element.
 */

/**
 * @enum {string}
 */
var DragAndDropEventType = {
  /**
   * Triggered when features are added
   * @event DragAndDropEvent#addfeatures
   * @api
   */
  ADD_FEATURES: 'addfeatures'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances
 * of this type.
 */

var DragAndDropEvent =
/** @class */
function (_super) {
  __extends(DragAndDropEvent, _super);
  /**
   * @param {DragAndDropEventType} type Type.
   * @param {File} file File.
   * @param {Array<import("../Feature.js").default>=} opt_features Features.
   * @param {import("../proj/Projection.js").default=} opt_projection Projection.
   */


  function DragAndDropEvent(type, file, opt_features, opt_projection) {
    var _this = _super.call(this, type) || this;
    /**
     * The features parsed from dropped data.
     * @type {Array<import("../Feature.js").FeatureLike>|undefined}
     * @api
     */


    _this.features = opt_features;
    /**
     * The dropped file.
     * @type {File}
     * @api
     */

    _this.file = file;
    /**
     * The feature projection.
     * @type {import("../proj/Projection.js").default|undefined}
     * @api
     */

    _this.projection = opt_projection;
    return _this;
  }

  return DragAndDropEvent;
}(_Event.default);
/**
 * @classdesc
 * Handles input of vector data by drag and drop.
 * @api
 *
 * @fires DragAndDropEvent
 */


var DragAndDrop =
/** @class */
function (_super) {
  __extends(DragAndDrop, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function DragAndDrop(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      handleEvent: _functions.TRUE
    }) || this;
    /**
     * @private
     * @type {Array<typeof import("../format/Feature.js").default>}
     */

    _this.formatConstructors_ = options.formatConstructors ? options.formatConstructors : [];
    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */

    _this.projection_ = options.projection ? (0, _proj.get)(options.projection) : null;
    /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */

    _this.dropListenKeys_ = null;
    /**
     * @private
     * @type {import("../source/Vector.js").default}
     */

    _this.source_ = options.source || null;
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.target = options.target ? options.target : null;
    return _this;
  }
  /**
   * @param {File} file File.
   * @param {Event} event Load event.
   * @private
   */


  DragAndDrop.prototype.handleResult_ = function (file, event) {
    var result = event.target.result;
    var map = this.getMap();
    var projection = this.projection_;

    if (!projection) {
      var view = map.getView();
      projection = view.getProjection();
    }

    var formatConstructors = this.formatConstructors_;
    var features = [];

    for (var i = 0, ii = formatConstructors.length; i < ii; ++i) {
      var format = new formatConstructors[i]();
      features = this.tryReadFeatures_(format, result, {
        featureProjection: projection
      });

      if (features && features.length > 0) {
        break;
      }
    }

    if (this.source_) {
      this.source_.clear();
      this.source_.addFeatures(features);
    }

    this.dispatchEvent(new DragAndDropEvent(DragAndDropEventType.ADD_FEATURES, file, features, projection));
  };
  /**
   * @private
   */


  DragAndDrop.prototype.registerListeners_ = function () {
    var map = this.getMap();

    if (map) {
      var dropArea = this.target ? this.target : map.getViewport();
      this.dropListenKeys_ = [(0, _events.listen)(dropArea, _EventType.default.DROP, handleDrop, this), (0, _events.listen)(dropArea, _EventType.default.DRAGENTER, handleStop, this), (0, _events.listen)(dropArea, _EventType.default.DRAGOVER, handleStop, this), (0, _events.listen)(dropArea, _EventType.default.DROP, handleStop, this)];
    }
  };
  /**
   * @inheritDoc
   */


  DragAndDrop.prototype.setActive = function (active) {
    if (!this.getActive() && active) {
      this.registerListeners_();
    }

    if (this.getActive() && !active) {
      this.unregisterListeners_();
    }

    _super.prototype.setActive.call(this, active);
  };
  /**
   * @inheritDoc
   */


  DragAndDrop.prototype.setMap = function (map) {
    this.unregisterListeners_();

    _super.prototype.setMap.call(this, map);

    if (this.getActive()) {
      this.registerListeners_();
    }
  };
  /**
   * @param {import("../format/Feature.js").default} format Format.
   * @param {string} text Text.
   * @param {import("../format/Feature.js").ReadOptions} options Read options.
   * @private
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   */


  DragAndDrop.prototype.tryReadFeatures_ = function (format, text, options) {
    try {
      return format.readFeatures(text, options);
    } catch (e) {
      return null;
    }
  };
  /**
   * @private
   */


  DragAndDrop.prototype.unregisterListeners_ = function () {
    if (this.dropListenKeys_) {
      this.dropListenKeys_.forEach(_events.unlistenByKey);
      this.dropListenKeys_ = null;
    }
  };

  return DragAndDrop;
}(_Interaction.default);
/**
 * @param {DragEvent} event Event.
 * @this {DragAndDrop}
 */


function handleDrop(event) {
  var files = event.dataTransfer.files;

  for (var i = 0, ii = files.length; i < ii; ++i) {
    var file = files.item(i);
    var reader = new FileReader();
    reader.addEventListener(_EventType.default.LOAD, this.handleResult_.bind(this, file));
    reader.readAsText(file);
  }
}
/**
 * @param {DragEvent} event Event.
 */


function handleStop(event) {
  event.stopPropagation();
  event.preventDefault();
  event.dataTransfer.dropEffect = 'copy';
}

var _default = DragAndDrop;
exports.default = _default;
},{"../functions.js":"node_modules/ol/functions.js","../events.js":"node_modules/ol/events.js","../events/Event.js":"node_modules/ol/events/Event.js","../events/EventType.js":"node_modules/ol/events/EventType.js","./Interaction.js":"node_modules/ol/interaction/Interaction.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/interaction/DragRotateAndZoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _condition = require("../events/condition.js");

var _Pointer = _interopRequireDefault(require("./Pointer.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/DragRotateAndZoom
 */


/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~shiftKeyOnly}.
 * @property {number} [duration=400] Animation duration in milliseconds.
 */

/**
 * @classdesc
 * Allows the user to zoom and rotate the map by clicking and dragging
 * on the map.  By default, this interaction is limited to when the shift
 * key is held down.
 *
 * This interaction is only supported for mouse devices.
 *
 * And this interaction is not included in the default interactions.
 * @api
 */
var DragRotateAndZoom =
/** @class */
function (_super) {
  __extends(DragRotateAndZoom, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function DragRotateAndZoom(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this,
    /** @type {import("./Pointer.js").Options} */
    options) || this;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _condition.shiftKeyOnly;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastAngle_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastMagnitude_ = undefined;
    /**
     * @private
     * @type {number}
     */

    _this.lastScaleDelta_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 400;
    return _this;
  }
  /**
   * @inheritDoc
   */


  DragRotateAndZoom.prototype.handleDragEvent = function (mapBrowserEvent) {
    if (!(0, _condition.mouseOnly)(mapBrowserEvent)) {
      return;
    }

    var map = mapBrowserEvent.map;
    var size = map.getSize();
    var offset = mapBrowserEvent.pixel;
    var deltaX = offset[0] - size[0] / 2;
    var deltaY = size[1] / 2 - offset[1];
    var theta = Math.atan2(deltaY, deltaX);
    var magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    var view = map.getView();

    if (this.lastAngle_ !== undefined) {
      var angleDelta = this.lastAngle_ - theta;
      view.adjustRotationInternal(angleDelta);
    }

    this.lastAngle_ = theta;

    if (this.lastMagnitude_ !== undefined) {
      view.adjustResolutionInternal(this.lastMagnitude_ / magnitude);
    }

    if (this.lastMagnitude_ !== undefined) {
      this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;
    }

    this.lastMagnitude_ = magnitude;
  };
  /**
   * @inheritDoc
   */


  DragRotateAndZoom.prototype.handleUpEvent = function (mapBrowserEvent) {
    if (!(0, _condition.mouseOnly)(mapBrowserEvent)) {
      return true;
    }

    var map = mapBrowserEvent.map;
    var view = map.getView();
    var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
    view.endInteraction(this.duration_, direction);
    this.lastScaleDelta_ = 0;
    return false;
  };
  /**
   * @inheritDoc
   */


  DragRotateAndZoom.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (!(0, _condition.mouseOnly)(mapBrowserEvent)) {
      return false;
    }

    if (this.condition_(mapBrowserEvent)) {
      mapBrowserEvent.map.getView().beginInteraction();
      this.lastAngle_ = undefined;
      this.lastMagnitude_ = undefined;
      return true;
    } else {
      return false;
    }
  };

  return DragRotateAndZoom;
}(_Pointer.default);

var _default = DragRotateAndZoom;
exports.default = _default;
},{"../events/condition.js":"node_modules/ol/events/condition.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js"}],"node_modules/ol/geom/Circle.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extent = require("../extent.js");

var _GeometryType = _interopRequireDefault(require("./GeometryType.js"));

var _SimpleGeometry = _interopRequireDefault(require("./SimpleGeometry.js"));

var _deflate = require("./flat/deflate.js");

var _transform = require("./flat/transform.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/Circle
 */


/**
 * @classdesc
 * Circle geometry.
 *
 * @api
 */
var Circle =
/** @class */
function (_super) {
  __extends(Circle, _super);
  /**
   * @param {!import("../coordinate.js").Coordinate} center Center.
   *     For internal use, flat coordinates in combination with `opt_layout` and no
   *     `opt_radius` are also accepted.
   * @param {number=} opt_radius Radius.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   */


  function Circle(center, opt_radius, opt_layout) {
    var _this = _super.call(this) || this;

    if (opt_layout !== undefined && opt_radius === undefined) {
      _this.setFlatCoordinates(opt_layout, center);
    } else {
      var radius = opt_radius ? opt_radius : 0;

      _this.setCenterAndRadius(center, radius, opt_layout);
    }

    return _this;
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @override
   * @api
   */


  Circle.prototype.clone = function () {
    return new Circle(this.flatCoordinates.slice(), undefined, this.layout);
  };
  /**
   * @inheritDoc
   */


  Circle.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    var flatCoordinates = this.flatCoordinates;
    var dx = x - flatCoordinates[0];
    var dy = y - flatCoordinates[1];
    var squaredDistance = dx * dx + dy * dy;

    if (squaredDistance < minSquaredDistance) {
      if (squaredDistance === 0) {
        for (var i = 0; i < this.stride; ++i) {
          closestPoint[i] = flatCoordinates[i];
        }
      } else {
        var delta = this.getRadius() / Math.sqrt(squaredDistance);
        closestPoint[0] = flatCoordinates[0] + delta * dx;
        closestPoint[1] = flatCoordinates[1] + delta * dy;

        for (var i = 2; i < this.stride; ++i) {
          closestPoint[i] = flatCoordinates[i];
        }
      }

      closestPoint.length = this.stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  };
  /**
   * @inheritDoc
   */


  Circle.prototype.containsXY = function (x, y) {
    var flatCoordinates = this.flatCoordinates;
    var dx = x - flatCoordinates[0];
    var dy = y - flatCoordinates[1];
    return dx * dx + dy * dy <= this.getRadiusSquared_();
  };
  /**
   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @return {import("../coordinate.js").Coordinate} Center.
   * @api
   */


  Circle.prototype.getCenter = function () {
    return this.flatCoordinates.slice(0, this.stride);
  };
  /**
   * @inheritDoc
   */


  Circle.prototype.computeExtent = function (extent) {
    var flatCoordinates = this.flatCoordinates;
    var radius = flatCoordinates[this.stride] - flatCoordinates[0];
    return (0, _extent.createOrUpdate)(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);
  };
  /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */


  Circle.prototype.getRadius = function () {
    return Math.sqrt(this.getRadiusSquared_());
  };
  /**
   * @private
   * @return {number} Radius squared.
   */


  Circle.prototype.getRadiusSquared_ = function () {
    var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
    var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return dx * dx + dy * dy;
  };
  /**
   * @inheritDoc
   * @api
   */


  Circle.prototype.getType = function () {
    return _GeometryType.default.CIRCLE;
  };
  /**
   * @inheritDoc
   * @api
   */


  Circle.prototype.intersectsExtent = function (extent) {
    var circleExtent = this.getExtent();

    if ((0, _extent.intersects)(extent, circleExtent)) {
      var center = this.getCenter();

      if (extent[0] <= center[0] && extent[2] >= center[0]) {
        return true;
      }

      if (extent[1] <= center[1] && extent[3] >= center[1]) {
        return true;
      }

      return (0, _extent.forEachCorner)(extent, this.intersectsCoordinate.bind(this));
    }

    return false;
  };
  /**
   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @api
   */


  Circle.prototype.setCenter = function (center) {
    var stride = this.stride;
    var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
    var flatCoordinates = center.slice();
    flatCoordinates[stride] = flatCoordinates[0] + radius;

    for (var i = 1; i < stride; ++i) {
      flatCoordinates[stride + i] = center[i];
    }

    this.setFlatCoordinates(this.layout, flatCoordinates);
    this.changed();
  };
  /**
   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!import("../coordinate.js").Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   * @api
   */


  Circle.prototype.setCenterAndRadius = function (center, radius, opt_layout) {
    this.setLayout(opt_layout, center, 0);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    /** @type {Array<number>} */


    var flatCoordinates = this.flatCoordinates;
    var offset = (0, _deflate.deflateCoordinate)(flatCoordinates, 0, center, this.stride);
    flatCoordinates[offset++] = flatCoordinates[0] + radius;

    for (var i = 1, ii = this.stride; i < ii; ++i) {
      flatCoordinates[offset++] = flatCoordinates[i];
    }

    flatCoordinates.length = offset;
    this.changed();
  };
  /**
   * @inheritDoc
   */


  Circle.prototype.getCoordinates = function () {
    return null;
  };
  /**
   * @inheritDoc
   */


  Circle.prototype.setCoordinates = function (coordinates, opt_layout) {};
  /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */


  Circle.prototype.setRadius = function (radius) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
    this.changed();
  };
  /**
   * @inheritDoc
   * @api
   */


  Circle.prototype.rotate = function (angle, anchor) {
    var center = this.getCenter();
    var stride = this.getStride();
    this.setCenter((0, _transform.rotate)(center, 0, center.length, stride, angle, anchor, center));
    this.changed();
  };
  /**
   * @inheritDoc
   * @api
   */


  Circle.prototype.translate = function (deltaX, deltaY) {
    var center = this.getCenter();
    var stride = this.getStride();
    this.setCenter((0, _transform.translate)(center, 0, center.length, stride, deltaX, deltaY, center));
    this.changed();
  };

  return Circle;
}(_SimpleGeometry.default);
/**
 * Transform each coordinate of the circle from one coordinate reference system
 * to another. The geometry is modified in place.
 * If you do not want the geometry modified in place, first clone() it and
 * then use this function on the clone.
 *
 * Internally a circle is currently represented by two points: the center of
 * the circle `[cx, cy]`, and the point to the right of the circle
 * `[cx + r, cy]`. This `transform` function just transforms these two points.
 * So the resulting geometry is also a circle, and that circle does not
 * correspond to the shape that would be obtained by transforming every point
 * of the original circle.
 *
 * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @return {Circle} This geometry.  Note that original geometry is
 *     modified in place.
 * @function
 * @api
 */


Circle.prototype.transform;
var _default = Circle;
exports.default = _default;
},{"../extent.js":"node_modules/ol/extent.js","./GeometryType.js":"node_modules/ol/geom/GeometryType.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","./flat/transform.js":"node_modules/ol/geom/flat/transform.js"}],"node_modules/ol/style/Image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("../util.js");

/**
 * @module ol/style/Image
 */

/**
 * @typedef {Object} Options
 * @property {number} opacity
 * @property {boolean} rotateWithView
 * @property {number} rotation
 * @property {number} scale
 * @property {Array<number>} displacement
 */

/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
 * {@link module:ol/style/RegularShape~RegularShape}.
 * @abstract
 * @api
 */
var ImageStyle =
/** @class */
function () {
  /**
   * @param {Options} options Options.
   */
  function ImageStyle(options) {
    /**
     * @private
     * @type {number}
     */
    this.opacity_ = options.opacity;
    /**
     * @private
     * @type {boolean}
     */

    this.rotateWithView_ = options.rotateWithView;
    /**
     * @private
     * @type {number}
     */

    this.rotation_ = options.rotation;
    /**
     * @private
     * @type {number}
     */

    this.scale_ = options.scale;
    /**
     * @private
     * @type {Array<number>}
     */

    this.displacement_ = options.displacement;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */


  ImageStyle.prototype.clone = function () {
    return new ImageStyle({
      opacity: this.getOpacity(),
      scale: this.getScale(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice()
    });
  };
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */


  ImageStyle.prototype.getOpacity = function () {
    return this.opacity_;
  };
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */


  ImageStyle.prototype.getRotateWithView = function () {
    return this.rotateWithView_;
  };
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */


  ImageStyle.prototype.getRotation = function () {
    return this.rotation_;
  };
  /**
   * Get the symbolizer scale.
   * @return {number} Scale.
   * @api
   */


  ImageStyle.prototype.getScale = function () {
    return this.scale_;
  };
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */


  ImageStyle.prototype.getDisplacement = function () {
    return this.displacement_;
  };
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */


  ImageStyle.prototype.getAnchor = function () {
    return (0, _util.abstract)();
  };
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */


  ImageStyle.prototype.getImage = function (pixelRatio) {
    return (0, _util.abstract)();
  };
  /**
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */


  ImageStyle.prototype.getHitDetectionImage = function (pixelRatio) {
    return (0, _util.abstract)();
  };
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */


  ImageStyle.prototype.getImageState = function () {
    return (0, _util.abstract)();
  };
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */


  ImageStyle.prototype.getImageSize = function () {
    return (0, _util.abstract)();
  };
  /**
   * @abstract
   * @return {import("../size.js").Size} Size of the hit-detection image.
   */


  ImageStyle.prototype.getHitDetectionImageSize = function () {
    return (0, _util.abstract)();
  };
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */


  ImageStyle.prototype.getOrigin = function () {
    return (0, _util.abstract)();
  };
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */


  ImageStyle.prototype.getSize = function () {
    return (0, _util.abstract)();
  };
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */


  ImageStyle.prototype.setOpacity = function (opacity) {
    this.opacity_ = opacity;
  };
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */


  ImageStyle.prototype.setRotateWithView = function (rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  };
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */


  ImageStyle.prototype.setRotation = function (rotation) {
    this.rotation_ = rotation;
  };
  /**
   * Set the scale.
   *
   * @param {number} scale Scale.
   * @api
   */


  ImageStyle.prototype.setScale = function (scale) {
    this.scale_ = scale;
  };
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @template T
   */


  ImageStyle.prototype.listenImageChange = function (listener) {
    (0, _util.abstract)();
  };
  /**
   * Load not yet loaded URI.
   * @abstract
   */


  ImageStyle.prototype.load = function () {
    (0, _util.abstract)();
  };
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @template T
   */


  ImageStyle.prototype.unlistenImageChange = function (listener) {
    (0, _util.abstract)();
  };

  return ImageStyle;
}();

var _default = ImageStyle;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js"}],"node_modules/ol/style/RegularShape.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _color = require("../color.js");

var _colorlike = require("../colorlike.js");

var _dom = require("../dom.js");

var _ImageState = _interopRequireDefault(require("../ImageState.js"));

var _canvas = require("../render/canvas.js");

var _Image = _interopRequireDefault(require("./Image.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/style/RegularShape
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * Specify radius for regular polygons, or radius1 and radius2 for stars.
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} [radius] Radius of a regular polygon.
 * @property {number} [radius1] Outer radius of a star.
 * @property {number} [radius2] Inner radius of a star.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
 * @property {Array<number>} [displacement=[0,0]] Displacement of the shape
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 */

/**
 * @typedef {Object} RenderOptions
 * @property {import("../colorlike.js").ColorLike} [strokeStyle]
 * @property {number} strokeWidth
 * @property {number} size
 * @property {CanvasLineCap} lineCap
 * @property {Array<number>} lineDash
 * @property {number} lineDashOffset
 * @property {CanvasLineJoin} lineJoin
 * @property {number} miterLimit
 */

/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 * @api
 */
var RegularShape =
/** @class */
function (_super) {
  __extends(RegularShape, _super);
  /**
   * @param {Options} options Options.
   */


  function RegularShape(options) {
    var _this = this;
    /**
     * @type {boolean}
     */


    var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
    _this = _super.call(this, {
      opacity: 1,
      rotateWithView: rotateWithView,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      scale: 1,
      displacement: options.displacement !== undefined ? options.displacement : [0, 0]
    }) || this;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.canvas_ = null;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.hitDetectionCanvas_ = null;
    /**
     * @private
     * @type {import("./Fill.js").default}
     */

    _this.fill_ = options.fill !== undefined ? options.fill : null;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.origin_ = [0, 0];
    /**
     * @private
     * @type {number}
     */

    _this.points_ = options.points;
    /**
     * @protected
     * @type {number}
     */

    _this.radius_ = options.radius !== undefined ? options.radius : options.radius1;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.radius2_ = options.radius2;
    /**
     * @private
     * @type {number}
     */

    _this.angle_ = options.angle !== undefined ? options.angle : 0;
    /**
     * @private
     * @type {import("./Stroke.js").default}
     */

    _this.stroke_ = options.stroke !== undefined ? options.stroke : null;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.anchor_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.size_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.imageSize_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.hitDetectionImageSize_ = null;

    _this.render();

    return _this;
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */


  RegularShape.prototype.clone = function () {
    var style = new RegularShape({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice()
    });
    style.setOpacity(this.getOpacity());
    style.setScale(this.getScale());
    return style;
  };
  /**
   * @inheritDoc
   * @api
   */


  RegularShape.prototype.getAnchor = function () {
    return this.anchor_;
  };
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */


  RegularShape.prototype.getAngle = function () {
    return this.angle_;
  };
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */


  RegularShape.prototype.getFill = function () {
    return this.fill_;
  };
  /**
   * @inheritDoc
   */


  RegularShape.prototype.getHitDetectionImage = function (pixelRatio) {
    return this.hitDetectionCanvas_;
  };
  /**
   * @inheritDoc
   * @api
   */


  RegularShape.prototype.getImage = function (pixelRatio) {
    return this.canvas_;
  };
  /**
   * @inheritDoc
   */


  RegularShape.prototype.getImageSize = function () {
    return this.imageSize_;
  };
  /**
   * @inheritDoc
   */


  RegularShape.prototype.getHitDetectionImageSize = function () {
    return this.hitDetectionImageSize_;
  };
  /**
   * @inheritDoc
   */


  RegularShape.prototype.getImageState = function () {
    return _ImageState.default.LOADED;
  };
  /**
   * @inheritDoc
   * @api
   */


  RegularShape.prototype.getOrigin = function () {
    return this.origin_;
  };
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */


  RegularShape.prototype.getPoints = function () {
    return this.points_;
  };
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */


  RegularShape.prototype.getRadius = function () {
    return this.radius_;
  };
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */


  RegularShape.prototype.getRadius2 = function () {
    return this.radius2_;
  };
  /**
   * @inheritDoc
   * @api
   */


  RegularShape.prototype.getSize = function () {
    return this.size_;
  };
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */


  RegularShape.prototype.getStroke = function () {
    return this.stroke_;
  };
  /**
   * @inheritDoc
   */


  RegularShape.prototype.listenImageChange = function (listener) {};
  /**
   * @inheritDoc
   */


  RegularShape.prototype.load = function () {};
  /**
   * @inheritDoc
   */


  RegularShape.prototype.unlistenImageChange = function (listener) {};
  /**
   * @protected
   */


  RegularShape.prototype.render = function () {
    var lineCap = _canvas.defaultLineCap;
    var lineJoin = _canvas.defaultLineJoin;
    var miterLimit = 0;
    var lineDash = null;
    var lineDashOffset = 0;
    var strokeStyle;
    var strokeWidth = 0;

    if (this.stroke_) {
      strokeStyle = this.stroke_.getColor();

      if (strokeStyle === null) {
        strokeStyle = _canvas.defaultStrokeStyle;
      }

      strokeStyle = (0, _colorlike.asColorLike)(strokeStyle);
      strokeWidth = this.stroke_.getWidth();

      if (strokeWidth === undefined) {
        strokeWidth = _canvas.defaultLineWidth;
      }

      lineDash = this.stroke_.getLineDash();
      lineDashOffset = this.stroke_.getLineDashOffset();
      lineJoin = this.stroke_.getLineJoin();

      if (lineJoin === undefined) {
        lineJoin = _canvas.defaultLineJoin;
      }

      lineCap = this.stroke_.getLineCap();

      if (lineCap === undefined) {
        lineCap = _canvas.defaultLineCap;
      }

      miterLimit = this.stroke_.getMiterLimit();

      if (miterLimit === undefined) {
        miterLimit = _canvas.defaultMiterLimit;
      }
    }

    var size = 2 * (this.radius_ + strokeWidth) + 1;
    var renderOptions = {
      strokeStyle: strokeStyle,
      strokeWidth: strokeWidth,
      size: size,
      lineCap: lineCap,
      lineDash: lineDash,
      lineDashOffset: lineDashOffset,
      lineJoin: lineJoin,
      miterLimit: miterLimit
    };
    var context = (0, _dom.createCanvasContext2D)(size, size);
    this.canvas_ = context.canvas; // canvas.width and height are rounded to the closest integer

    size = this.canvas_.width;
    var imageSize = size;
    var displacement = this.getDisplacement();
    this.draw_(renderOptions, context, 0, 0);
    this.createHitDetectionCanvas_(renderOptions);
    this.anchor_ = [size / 2 - displacement[0], size / 2 + displacement[1]];
    this.size_ = [size, size];
    this.imageSize_ = [imageSize, imageSize];
  };
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} x The origin for the symbol (x).
   * @param {number} y The origin for the symbol (y).
   */


  RegularShape.prototype.draw_ = function (renderOptions, context, x, y) {
    var i, angle0, radiusC; // reset transform

    context.setTransform(1, 0, 0, 1, 0, 0); // then move to (x, y)

    context.translate(x, y);
    context.beginPath();
    var points = this.points_;

    if (points === Infinity) {
      context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
    } else {
      var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;

      if (radius2 !== this.radius_) {
        points = 2 * points;
      }

      for (i = 0; i <= points; i++) {
        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
        radiusC = i % 2 === 0 ? this.radius_ : radius2;
        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
      }
    }

    if (this.fill_) {
      var color = this.fill_.getColor();

      if (color === null) {
        color = _canvas.defaultFillStyle;
      }

      context.fillStyle = (0, _colorlike.asColorLike)(color);
      context.fill();
    }

    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;

      if (context.setLineDash && renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }

      context.lineCap = renderOptions.lineCap;
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }

    context.closePath();
  };
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   */


  RegularShape.prototype.createHitDetectionCanvas_ = function (renderOptions) {
    this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];
    this.hitDetectionCanvas_ = this.canvas_;

    if (this.fill_) {
      var color = this.fill_.getColor(); // determine if fill is transparent (or pattern or gradient)

      var opacity = 0;

      if (typeof color === 'string') {
        color = (0, _color.asArray)(color);
      }

      if (color === null) {
        opacity = 1;
      } else if (Array.isArray(color)) {
        opacity = color.length === 4 ? color[3] : 1;
      }

      if (opacity === 0) {
        // if a transparent fill style is set, create an extra hit-detection image
        // with a default fill style
        var context = (0, _dom.createCanvasContext2D)(renderOptions.size, renderOptions.size);
        this.hitDetectionCanvas_ = context.canvas;
        this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);
      }
    }
  };
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   * @param {number} x The origin for the symbol (x).
   * @param {number} y The origin for the symbol (y).
   */


  RegularShape.prototype.drawHitDetectionCanvas_ = function (renderOptions, context, x, y) {
    // reset transform
    context.setTransform(1, 0, 0, 1, 0, 0); // then move to (x, y)

    context.translate(x, y);
    context.beginPath();
    var points = this.points_;

    if (points === Infinity) {
      context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
    } else {
      var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;

      if (radius2 !== this.radius_) {
        points = 2 * points;
      }

      var i = void 0,
          radiusC = void 0,
          angle0 = void 0;

      for (i = 0; i <= points; i++) {
        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
        radiusC = i % 2 === 0 ? this.radius_ : radius2;
        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
      }
    }

    context.fillStyle = _canvas.defaultFillStyle;
    context.fill();

    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;

      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }

      context.stroke();
    }

    context.closePath();
  };

  return RegularShape;
}(_Image.default);

var _default = RegularShape;
exports.default = _default;
},{"../color.js":"node_modules/ol/color.js","../colorlike.js":"node_modules/ol/colorlike.js","../dom.js":"node_modules/ol/dom.js","../ImageState.js":"node_modules/ol/ImageState.js","../render/canvas.js":"node_modules/ol/render/canvas.js","./Image.js":"node_modules/ol/style/Image.js"}],"node_modules/ol/style/Circle.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _RegularShape = _interopRequireDefault(require("./RegularShape.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/style/Circle
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {Array<number>} [displacement=[0,0]] displacement
 */

/**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */
var CircleStyle =
/** @class */
function (_super) {
  __extends(CircleStyle, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function CircleStyle(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      stroke: options.stroke,
      displacement: options.displacement !== undefined ? options.displacement : [0, 0]
    }) || this;
    return _this;
  }
  /**
  * Clones the style.
  * @return {CircleStyle} The cloned style.
  * @override
  * @api
  */


  CircleStyle.prototype.clone = function () {
    var style = new CircleStyle({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      radius: this.getRadius(),
      displacement: this.getDisplacement().slice()
    });
    style.setOpacity(this.getOpacity());
    style.setScale(this.getScale());
    return style;
  };
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */


  CircleStyle.prototype.setRadius = function (radius) {
    this.radius_ = radius;
    this.render();
  };

  return CircleStyle;
}(_RegularShape.default);

var _default = CircleStyle;
exports.default = _default;
},{"./RegularShape.js":"node_modules/ol/style/RegularShape.js"}],"node_modules/ol/style/Fill.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/style/Fill
 */

/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color=null] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 */

/**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */
var Fill =
/** @class */
function () {
  /**
   * @param {Options=} opt_options Options.
   */
  function Fill(opt_options) {
    var options = opt_options || {};
    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
     */

    this.color_ = options.color !== undefined ? options.color : null;
  }
  /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */


  Fill.prototype.clone = function () {
    var color = this.getColor();
    return new Fill({
      color: Array.isArray(color) ? color.slice() : color || undefined
    });
  };
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */


  Fill.prototype.getColor = function () {
    return this.color_;
  };
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */


  Fill.prototype.setColor = function (color) {
    this.color_ = color;
  };

  return Fill;
}();

var _default = Fill;
exports.default = _default;
},{}],"node_modules/ol/style/Stroke.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/style/Stroke
 */

/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
 * Please note that Internet Explorer 10 and lower do not support the `setLineDash` method on
 * the `CanvasRenderingContext2D` and therefore this option will have no visual effect in these browsers.
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */

/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */
var Stroke =
/** @class */
function () {
  /**
   * @param {Options=} opt_options Options.
   */
  function Stroke(opt_options) {
    var options = opt_options || {};
    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
     */

    this.color_ = options.color !== undefined ? options.color : null;
    /**
     * @private
     * @type {CanvasLineCap|undefined}
     */

    this.lineCap_ = options.lineCap;
    /**
     * @private
     * @type {Array<number>}
     */

    this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;
    /**
     * @private
     * @type {number|undefined}
     */

    this.lineDashOffset_ = options.lineDashOffset;
    /**
     * @private
     * @type {CanvasLineJoin|undefined}
     */

    this.lineJoin_ = options.lineJoin;
    /**
     * @private
     * @type {number|undefined}
     */

    this.miterLimit_ = options.miterLimit;
    /**
     * @private
     * @type {number|undefined}
     */

    this.width_ = options.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */


  Stroke.prototype.clone = function () {
    var color = this.getColor();
    return new Stroke({
      color: Array.isArray(color) ? color.slice() : color || undefined,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  };
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */


  Stroke.prototype.getColor = function () {
    return this.color_;
  };
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */


  Stroke.prototype.getLineCap = function () {
    return this.lineCap_;
  };
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>} Line dash.
   * @api
   */


  Stroke.prototype.getLineDash = function () {
    return this.lineDash_;
  };
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */


  Stroke.prototype.getLineDashOffset = function () {
    return this.lineDashOffset_;
  };
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */


  Stroke.prototype.getLineJoin = function () {
    return this.lineJoin_;
  };
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */


  Stroke.prototype.getMiterLimit = function () {
    return this.miterLimit_;
  };
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */


  Stroke.prototype.getWidth = function () {
    return this.width_;
  };
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */


  Stroke.prototype.setColor = function (color) {
    this.color_ = color;
  };
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */


  Stroke.prototype.setLineCap = function (lineCap) {
    this.lineCap_ = lineCap;
  };
  /**
   * Set the line dash.
   *
   * Please note that Internet Explorer 10 and lower [do not support][mdn] the
   * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
   * property will have no visual effect in these browsers.
   *
   * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
   *
   * @param {Array<number>} lineDash Line dash.
   * @api
   */


  Stroke.prototype.setLineDash = function (lineDash) {
    this.lineDash_ = lineDash;
  };
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */


  Stroke.prototype.setLineDashOffset = function (lineDashOffset) {
    this.lineDashOffset_ = lineDashOffset;
  };
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */


  Stroke.prototype.setLineJoin = function (lineJoin) {
    this.lineJoin_ = lineJoin;
  };
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */


  Stroke.prototype.setMiterLimit = function (miterLimit) {
    this.miterLimit_ = miterLimit;
  };
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */


  Stroke.prototype.setWidth = function (width) {
    this.width_ = width;
  };

  return Stroke;
}();

var _default = Stroke;
exports.default = _default;
},{}],"node_modules/ol/style/Style.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toFunction = toFunction;
exports.createDefaultStyle = createDefaultStyle;
exports.createEditingStyle = createEditingStyle;
exports.default = void 0;

var _asserts = require("../asserts.js");

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _Circle = _interopRequireDefault(require("./Circle.js"));

var _Fill = _interopRequireDefault(require("./Fill.js"));

var _Stroke = _interopRequireDefault(require("./Stroke.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/style/Style
 */

/**
 * A function that takes an {@link module:ol/Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:ol/style/Style} or an array of them. This way e.g. a
 * vector layer can be styled. If the function returns `undefined`, the
 * feature will not be rendered.
 *
 * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
 */

/**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 * @typedef {Style|Array<Style>|StyleFunction} StyleLike
 */

/**
 * A function that takes an {@link module:ol/Feature} as argument and returns an
 * {@link module:ol/geom/Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function(import("../Feature.js").FeatureLike):
 *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
 */

/**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:ol/render~State} of the layer renderer.
 *
 * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>),import("../render.js").State): void}
 * RenderFunction
 */

/**
 * @typedef {Object} Options
 * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {import("./Image.js").default} [image] Image style.
 * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Text.js").default} [text] Text style.
 * @property {number} [zIndex] Z index.
 */

/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * ## Feature styles
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Fill, Stroke, Circle, Style} from 'ol/style';
 *
 *  var fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)'
 *  });
 *  var stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25
 *  });
 *  var styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5
 *      }),
 *      fill: fill,
 *      stroke: stroke
 *    })
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import {Fill, Stroke, Circle, Style} from 'ol/style';
 *  import GeometryType from 'ol/geom/GeometryType';
 *
 *  var white = [255, 255, 255, 1];
 *  var blue = [0, 153, 255, 1];
 *  var width = 3;
 *  styles[GeometryType.POLYGON] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5]
 *      })
 *    })
 *  ];
 *  styles[GeometryType.MULTI_POLYGON] =
 *      styles[GeometryType.POLYGON];
 *  styles[GeometryType.LINE_STRING] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2
 *      })
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width
 *      })
 *    })
 *  ];
 *  styles[GeometryType.MULTI_LINE_STRING] =
 *      styles[GeometryType.LINE_STRING];
 *  styles[GeometryType.POINT] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2
 *        })
 *      }),
 *      zIndex: Infinity
 *    })
 *  ];
 *  styles[GeometryType.MULTI_POINT] =
 *      styles[GeometryType.POINT];
 *  styles[GeometryType.GEOMETRY_COLLECTION] =
 *      styles[GeometryType.POLYGON].concat(
 *          styles[GeometryType.LINE_STRING],
 *          styles[GeometryType.POINT]
 *      );
 * ```
 *
 * @api
 */
var Style =
/** @class */
function () {
  /**
   * @param {Options=} opt_options Style options.
   */
  function Style(opt_options) {
    var options = opt_options || {};
    /**
     * @private
     * @type {string|import("../geom/Geometry.js").default|GeometryFunction}
     */

    this.geometry_ = null;
    /**
     * @private
     * @type {!GeometryFunction}
     */

    this.geometryFunction_ = defaultGeometryFunction;

    if (options.geometry !== undefined) {
      this.setGeometry(options.geometry);
    }
    /**
     * @private
     * @type {import("./Fill.js").default}
     */


    this.fill_ = options.fill !== undefined ? options.fill : null;
    /**
       * @private
       * @type {import("./Image.js").default}
       */

    this.image_ = options.image !== undefined ? options.image : null;
    /**
     * @private
     * @type {RenderFunction|null}
     */

    this.renderer_ = options.renderer !== undefined ? options.renderer : null;
    /**
     * @private
     * @type {import("./Stroke.js").default}
     */

    this.stroke_ = options.stroke !== undefined ? options.stroke : null;
    /**
     * @private
     * @type {import("./Text.js").default}
     */

    this.text_ = options.text !== undefined ? options.text : null;
    /**
     * @private
     * @type {number|undefined}
     */

    this.zIndex_ = options.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */


  Style.prototype.clone = function () {
    var geometry = this.getGeometry();

    if (geometry && typeof geometry === 'object') {
      geometry =
      /** @type {import("../geom/Geometry.js").default} */
      geometry.clone();
    }

    return new Style({
      geometry: geometry,
      fill: this.getFill() ? this.getFill().clone() : undefined,
      image: this.getImage() ? this.getImage().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      text: this.getText() ? this.getText().clone() : undefined,
      zIndex: this.getZIndex()
    });
  };
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */


  Style.prototype.getRenderer = function () {
    return this.renderer_;
  };
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */


  Style.prototype.setRenderer = function (renderer) {
    this.renderer_ = renderer;
  };
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */


  Style.prototype.getGeometry = function () {
    return this.geometry_;
  };
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */


  Style.prototype.getGeometryFunction = function () {
    return this.geometryFunction_;
  };
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */


  Style.prototype.getFill = function () {
    return this.fill_;
  };
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */


  Style.prototype.setFill = function (fill) {
    this.fill_ = fill;
  };
  /**
   * Get the image style.
   * @return {import("./Image.js").default} Image style.
   * @api
   */


  Style.prototype.getImage = function () {
    return this.image_;
  };
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */


  Style.prototype.setImage = function (image) {
    this.image_ = image;
  };
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */


  Style.prototype.getStroke = function () {
    return this.stroke_;
  };
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */


  Style.prototype.setStroke = function (stroke) {
    this.stroke_ = stroke;
  };
  /**
   * Get the text style.
   * @return {import("./Text.js").default} Text style.
   * @api
   */


  Style.prototype.getText = function () {
    return this.text_;
  };
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */


  Style.prototype.setText = function (text) {
    this.text_ = text;
  };
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */


  Style.prototype.getZIndex = function () {
    return this.zIndex_;
  };
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */


  Style.prototype.setGeometry = function (geometry) {
    if (typeof geometry === 'function') {
      this.geometryFunction_ = geometry;
    } else if (typeof geometry === 'string') {
      this.geometryFunction_ = function (feature) {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          feature.get(geometry)
        );
      };
    } else if (!geometry) {
      this.geometryFunction_ = defaultGeometryFunction;
    } else if (geometry !== undefined) {
      this.geometryFunction_ = function () {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          geometry
        );
      };
    }

    this.geometry_ = geometry;
  };
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */


  Style.prototype.setZIndex = function (zIndex) {
    this.zIndex_ = zIndex;
  };

  return Style;
}();
/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of Style or single style objects wrapped in a
 * new style function.
 * @param {StyleFunction|Array<Style>|Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {StyleFunction} A style function.
 */


function toFunction(obj) {
  var styleFunction;

  if (typeof obj === 'function') {
    styleFunction = obj;
  } else {
    /**
     * @type {Array<Style>}
     */
    var styles_1;

    if (Array.isArray(obj)) {
      styles_1 = obj;
    } else {
      (0, _asserts.assert)(typeof
      /** @type {?} */
      obj.getZIndex === 'function', 41); // Expected an `Style` or an array of `Style`

      var style =
      /** @type {Style} */
      obj;
      styles_1 = [style];
    }

    styleFunction = function () {
      return styles_1;
    };
  }

  return styleFunction;
}
/**
 * @type {Array<Style>}
 */


var defaultStyles = null;
/**
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array<Style>} Style.
 */

function createDefaultStyle(feature, resolution) {
  // We don't use an immediately-invoked function
  // and a closure so we don't get an error at script evaluation time in
  // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
  // canvas.getContext('2d') at construction time, which will cause an.error
  // in such browsers.)
  if (!defaultStyles) {
    var fill = new _Fill.default({
      color: 'rgba(255,255,255,0.4)'
    });
    var stroke = new _Stroke.default({
      color: '#3399CC',
      width: 1.25
    });
    defaultStyles = [new Style({
      image: new _Circle.default({
        fill: fill,
        stroke: stroke,
        radius: 5
      }),
      fill: fill,
      stroke: stroke
    })];
  }

  return defaultStyles;
}
/**
 * Default styles for editing features.
 * @return {Object<import("../geom/GeometryType.js").default, Array<Style>>} Styles
 */


function createEditingStyle() {
  /** @type {Object<import("../geom/GeometryType.js").default, Array<Style>>} */
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles[_GeometryType.default.POLYGON] = [new Style({
    fill: new _Fill.default({
      color: [255, 255, 255, 0.5]
    })
  })];
  styles[_GeometryType.default.MULTI_POLYGON] = styles[_GeometryType.default.POLYGON];
  styles[_GeometryType.default.LINE_STRING] = [new Style({
    stroke: new _Stroke.default({
      color: white,
      width: width + 2
    })
  }), new Style({
    stroke: new _Stroke.default({
      color: blue,
      width: width
    })
  })];
  styles[_GeometryType.default.MULTI_LINE_STRING] = styles[_GeometryType.default.LINE_STRING];
  styles[_GeometryType.default.CIRCLE] = styles[_GeometryType.default.POLYGON].concat(styles[_GeometryType.default.LINE_STRING]);
  styles[_GeometryType.default.POINT] = [new Style({
    image: new _Circle.default({
      radius: width * 2,
      fill: new _Fill.default({
        color: blue
      }),
      stroke: new _Stroke.default({
        color: white,
        width: width / 2
      })
    }),
    zIndex: Infinity
  })];
  styles[_GeometryType.default.MULTI_POINT] = styles[_GeometryType.default.POINT];
  styles[_GeometryType.default.GEOMETRY_COLLECTION] = styles[_GeometryType.default.POLYGON].concat(styles[_GeometryType.default.LINE_STRING], styles[_GeometryType.default.POINT]);
  return styles;
}
/**
 * Function that is called with a feature and returns its default geometry.
 * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
 * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
 */


function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}

var _default = Style;
exports.default = _default;
},{"../asserts.js":"node_modules/ol/asserts.js","../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","./Circle.js":"node_modules/ol/style/Circle.js","./Fill.js":"node_modules/ol/style/Fill.js","./Stroke.js":"node_modules/ol/style/Stroke.js"}],"node_modules/ol/layer/BaseVector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Layer = _interopRequireDefault(require("./Layer.js"));

var _obj = require("../obj.js");

var _Style = require("../style/Style.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/BaseVector
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {import("../source/Vector.js").default} [source] Source.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 * @property {import("../style/Style.js").StyleLike} [style] Layer style. See
 * {@link module:ol/style} for default style which will be used if this is not defined.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
 * be recreated during animations. This means that no vectors will be shown clipped, but the
 * setting will have a performance impact for large amounts of vector data. When set to `false`,
 * batches will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
 * be recreated during interactions. See also `updateWhileAnimating`.
 */

/**
 * @enum {string}
 * @private
 */
var Property = {
  RENDER_ORDER: 'renderOrder'
};
/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @extends {Layer<VectorSourceType>}
 * @api
 */

var BaseVectorLayer =
/** @class */
function (_super) {
  __extends(BaseVectorLayer, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function BaseVectorLayer(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var baseOptions = (0, _obj.assign)({}, options);
    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    _this = _super.call(this, baseOptions) || this;
    /**
     * @private
     * @type {boolean}
     */

    _this.declutter_ = options.declutter !== undefined ? options.declutter : false;
    /**
     * @type {number}
     * @private
     */

    _this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;
    /**
     * User provided style.
     * @type {import("../style/Style.js").StyleLike}
     * @private
     */

    _this.style_ = null;
    /**
     * Style function for use within the library.
     * @type {import("../style/Style.js").StyleFunction|undefined}
     * @private
     */

    _this.styleFunction_ = undefined;

    _this.setStyle(options.style);
    /**
     * @type {boolean}
     * @private
     */


    _this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;
    /**
     * @type {boolean}
     * @private
     */

    _this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;
    return _this;
  }
  /**
   * @return {boolean} Declutter.
   */


  BaseVectorLayer.prototype.getDeclutter = function () {
    return this.declutter_;
  };
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in {@link import("../PluggableMap.js").default#getFeaturesAtPixel}: Text
   * is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
   * @api
   */


  BaseVectorLayer.prototype.getFeatures = function (pixel) {
    return _super.prototype.getFeatures.call(this, pixel);
  };
  /**
   * @return {number|undefined} Render buffer.
   */


  BaseVectorLayer.prototype.getRenderBuffer = function () {
    return this.renderBuffer_;
  };
  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */


  BaseVectorLayer.prototype.getRenderOrder = function () {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(Property.RENDER_ORDER)
    );
  };
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike}
   *     Layer style.
   * @api
   */


  BaseVectorLayer.prototype.getStyle = function () {
    return this.style_;
  };
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */


  BaseVectorLayer.prototype.getStyleFunction = function () {
    return this.styleFunction_;
  };
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */


  BaseVectorLayer.prototype.getUpdateWhileAnimating = function () {
    return this.updateWhileAnimating_;
  };
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */


  BaseVectorLayer.prototype.getUpdateWhileInteracting = function () {
    return this.updateWhileInteracting_;
  };
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */


  BaseVectorLayer.prototype.setRenderOrder = function (renderOrder) {
    this.set(Property.RENDER_ORDER, renderOrder);
  };
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If it is `undefined` the default style is used. If
   * it is `null` the layer has no style (a `null` style), so only features
   * that have their own styles will be rendered in the layer. See
   * {@link module:ol/style} for information on the default style.
   * @param {import("../style/Style.js").default|Array<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction|null|undefined} style Layer style.
   * @api
   */


  BaseVectorLayer.prototype.setStyle = function (style) {
    this.style_ = style !== undefined ? style : _Style.createDefaultStyle;
    this.styleFunction_ = style === null ? undefined : (0, _Style.toFunction)(this.style_);
    this.changed();
  };

  return BaseVectorLayer;
}(_Layer.default);

var _default = BaseVectorLayer;
exports.default = _default;
},{"./Layer.js":"node_modules/ol/layer/Layer.js","../obj.js":"node_modules/ol/obj.js","../style/Style.js":"node_modules/ol/style/Style.js"}],"node_modules/ol/render/canvas/Instruction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.closePathInstruction = exports.beginPathInstruction = exports.strokeInstruction = exports.fillInstruction = void 0;

/**
 * @module ol/render/canvas/Instruction
 */

/**
 * @enum {number}
 */
var Instruction = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
};
/**
 * @type {Array<Instruction>}
 */

var fillInstruction = [Instruction.FILL];
/**
 * @type {Array<Instruction>}
 */

exports.fillInstruction = fillInstruction;
var strokeInstruction = [Instruction.STROKE];
/**
 * @type {Array<Instruction>}
 */

exports.strokeInstruction = strokeInstruction;
var beginPathInstruction = [Instruction.BEGIN_PATH];
/**
 * @type {Array<Instruction>}
 */

exports.beginPathInstruction = beginPathInstruction;
var closePathInstruction = [Instruction.CLOSE_PATH];
exports.closePathInstruction = closePathInstruction;
var _default = Instruction;
exports.default = _default;
},{}],"node_modules/ol/render/canvas/Builder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _array = require("../../array.js");

var _colorlike = require("../../colorlike.js");

var _extent = require("../../extent.js");

var _Relationship = _interopRequireDefault(require("../../extent/Relationship.js"));

var _GeometryType = _interopRequireDefault(require("../../geom/GeometryType.js"));

var _inflate = require("../../geom/flat/inflate.js");

var _VectorContext = _interopRequireDefault(require("../VectorContext.js"));

var _canvas = require("../canvas.js");

var _Instruction = _interopRequireDefault(require("./Instruction.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/render/canvas/Builder
 */


/**
 * @typedef {Object} SerializableInstructions
 * @property {Array<*>} instructions The rendering instructions.
 * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.
 * @property {Array<number>} coordinates The array of all coordinates.
 * @property {!Object<string, import("../canvas.js").TextState>} [textStates] The text states (decluttering).
 * @property {!Object<string, import("../canvas.js").FillState>} [fillStates] The fill states (decluttering).
 * @property {!Object<string, import("../canvas.js").StrokeState>} [strokeStates] The stroke states (decluttering).
 */
var CanvasBuilder =
/** @class */
function (_super) {
  __extends(CanvasBuilder, _super);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */


  function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    var _this = _super.call(this) || this;
    /**
     * @protected
     * @type {number}
     */


    _this.tolerance = tolerance;
    /**
     * @protected
     * @const
     * @type {import("../../extent.js").Extent}
     */

    _this.maxExtent = maxExtent;
    /**
     * @protected
     * @type {number}
     */

    _this.pixelRatio = pixelRatio;
    /**
     * @protected
     * @type {number}
     */

    _this.maxLineWidth = 0;
    /**
     * @protected
     * @const
     * @type {number}
     */

    _this.resolution = resolution;
    /**
     * @private
     * @type {Array<*>}
     */

    _this.beginGeometryInstruction1_ = null;
    /**
     * @private
     * @type {Array<*>}
     */

    _this.beginGeometryInstruction2_ = null;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    _this.bufferedMaxExtent_ = null;
    /**
     * @protected
     * @type {Array<*>}
     */

    _this.instructions = [];
    /**
     * @protected
     * @type {Array<number>}
     */

    _this.coordinates = [];
    /**
     * @private
     * @type {import("../../coordinate.js").Coordinate}
     */

    _this.tmpCoordinate_ = [];
    /**
     * @protected
     * @type {Array<*>}
     */

    _this.hitDetectionInstructions = [];
    /**
     * @protected
     * @type {import("../canvas.js").FillStrokeState}
     */

    _this.state =
    /** @type {import("../canvas.js").FillStrokeState} */
    {};
    return _this;
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */


  CanvasBuilder.prototype.applyPixelRatio = function (dashArray) {
    var pixelRatio = this.pixelRatio;
    return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {
      return dash * pixelRatio;
    });
  };
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */


  CanvasBuilder.prototype.appendFlatCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {
    var myEnd = this.coordinates.length;
    var extent = this.getBufferedMaxExtent();

    if (skipFirst) {
      offset += stride;
    }

    var lastXCoord = flatCoordinates[offset];
    var lastYCoord = flatCoordinates[offset + 1];
    var nextCoord = this.tmpCoordinate_;
    var skipped = true;
    var i, lastRel, nextRel;

    for (i = offset + stride; i < end; i += stride) {
      nextCoord[0] = flatCoordinates[i];
      nextCoord[1] = flatCoordinates[i + 1];
      nextRel = (0, _extent.coordinateRelationship)(extent, nextCoord);

      if (nextRel !== lastRel) {
        if (skipped) {
          this.coordinates[myEnd++] = lastXCoord;
          this.coordinates[myEnd++] = lastYCoord;
        }

        this.coordinates[myEnd++] = nextCoord[0];
        this.coordinates[myEnd++] = nextCoord[1];
        skipped = false;
      } else if (nextRel === _Relationship.default.INTERSECTING) {
        this.coordinates[myEnd++] = nextCoord[0];
        this.coordinates[myEnd++] = nextCoord[1];
        skipped = false;
      } else {
        skipped = true;
      }

      lastXCoord = nextCoord[0];
      lastYCoord = nextCoord[1];
      lastRel = nextRel;
    } // Last coordinate equals first or only one point to append:


    if (closed && skipped || i === offset + stride) {
      this.coordinates[myEnd++] = lastXCoord;
      this.coordinates[myEnd++] = lastYCoord;
    }

    return myEnd;
  };
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */


  CanvasBuilder.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, builderEnds) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var builderEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
      builderEnds.push(builderEnd);
      offset = end;
    }

    return offset;
  };
  /**
   * @inheritDoc.
   */


  CanvasBuilder.prototype.drawCustom = function (geometry, feature, renderer) {
    this.beginGeometry(geometry, feature);
    var type = geometry.getType();
    var stride = geometry.getStride();
    var builderBegin = this.coordinates.length;
    var flatCoordinates, builderEnd, builderEnds, builderEndss;
    var offset;

    if (type == _GeometryType.default.MULTI_POLYGON) {
      geometry =
      /** @type {import("../../geom/MultiPolygon.js").default} */
      geometry;
      flatCoordinates = geometry.getOrientedFlatCoordinates();
      builderEndss = [];
      var endss = geometry.getEndss();
      offset = 0;

      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var myEnds = [];
        offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
        builderEndss.push(myEnds);
      }

      this.instructions.push([_Instruction.default.CUSTOM, builderBegin, builderEndss, geometry, renderer, _inflate.inflateMultiCoordinatesArray]);
    } else if (type == _GeometryType.default.POLYGON || type == _GeometryType.default.MULTI_LINE_STRING) {
      builderEnds = [];
      flatCoordinates = type == _GeometryType.default.POLYGON ?
      /** @type {import("../../geom/Polygon.js").default} */
      geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
      offset = this.drawCustomCoordinates_(flatCoordinates, 0,
      /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
      geometry.getEnds(), stride, builderEnds);
      this.instructions.push([_Instruction.default.CUSTOM, builderBegin, builderEnds, geometry, renderer, _inflate.inflateCoordinatesArray]);
    } else if (type == _GeometryType.default.LINE_STRING || type == _GeometryType.default.MULTI_POINT) {
      flatCoordinates = geometry.getFlatCoordinates();
      builderEnd = this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
      this.instructions.push([_Instruction.default.CUSTOM, builderBegin, builderEnd, geometry, renderer, _inflate.inflateCoordinates]);
    } else if (type == _GeometryType.default.POINT) {
      flatCoordinates = geometry.getFlatCoordinates();
      this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
      builderEnd = this.coordinates.length;
      this.instructions.push([_Instruction.default.CUSTOM, builderBegin, builderEnd, geometry, renderer]);
    }

    this.endGeometry(feature);
  };
  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasBuilder.prototype.beginGeometry = function (geometry, feature) {
    var extent = geometry.getExtent();
    this.beginGeometryInstruction1_ = [_Instruction.default.BEGIN_GEOMETRY, feature, 0, extent];
    this.instructions.push(this.beginGeometryInstruction1_);
    this.beginGeometryInstruction2_ = [_Instruction.default.BEGIN_GEOMETRY, feature, 0, extent];
    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  };
  /**
   * @return {SerializableInstructions} the serializable instructions.
   */


  CanvasBuilder.prototype.finish = function () {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  };
  /**
   * Reverse the hit detection instructions.
   */


  CanvasBuilder.prototype.reverseHitDetectionInstructions = function () {
    var hitDetectionInstructions = this.hitDetectionInstructions; // step 1 - reverse array

    hitDetectionInstructions.reverse(); // step 2 - reverse instructions within geometry blocks

    var i;
    var n = hitDetectionInstructions.length;
    var instruction;
    var type;
    var begin = -1;

    for (i = 0; i < n; ++i) {
      instruction = hitDetectionInstructions[i];
      type =
      /** @type {CanvasInstruction} */
      instruction[0];

      if (type == _Instruction.default.END_GEOMETRY) {
        begin = i;
      } else if (type == _Instruction.default.BEGIN_GEOMETRY) {
        instruction[2] = i;
        (0, _array.reverseSubArray)(this.hitDetectionInstructions, begin, i);
        begin = -1;
      }
    }
  };
  /**
   * @inheritDoc
   */


  CanvasBuilder.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
    var state = this.state;

    if (fillStyle) {
      var fillStyleColor = fillStyle.getColor();
      state.fillStyle = (0, _colorlike.asColorLike)(fillStyleColor ? fillStyleColor : _canvas.defaultFillStyle);
    } else {
      state.fillStyle = undefined;
    }

    if (strokeStyle) {
      var strokeStyleColor = strokeStyle.getColor();
      state.strokeStyle = (0, _colorlike.asColorLike)(strokeStyleColor ? strokeStyleColor : _canvas.defaultStrokeStyle);
      var strokeStyleLineCap = strokeStyle.getLineCap();
      state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas.defaultLineCap;
      var strokeStyleLineDash = strokeStyle.getLineDash();
      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : _canvas.defaultLineDash;
      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvas.defaultLineDashOffset;
      var strokeStyleLineJoin = strokeStyle.getLineJoin();
      state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvas.defaultLineJoin;
      var strokeStyleWidth = strokeStyle.getWidth();
      state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas.defaultLineWidth;
      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvas.defaultMiterLimit;

      if (state.lineWidth > this.maxLineWidth) {
        this.maxLineWidth = state.lineWidth; // invalidate the buffered max extent cache

        this.bufferedMaxExtent_ = null;
      }
    } else {
      state.strokeStyle = undefined;
      state.lineCap = undefined;
      state.lineDash = null;
      state.lineDashOffset = undefined;
      state.lineJoin = undefined;
      state.lineWidth = undefined;
      state.miterLimit = undefined;
    }
  };
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */


  CanvasBuilder.prototype.createFill = function (state) {
    var fillStyle = state.fillStyle;
    /** @type {Array<*>} */

    var fillInstruction = [_Instruction.default.SET_FILL_STYLE, fillStyle];

    if (typeof fillStyle !== 'string') {
      // Fill is a pattern or gradient - align it!
      fillInstruction.push(true);
    }

    return fillInstruction;
  };
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */


  CanvasBuilder.prototype.applyStroke = function (state) {
    this.instructions.push(this.createStroke(state));
  };
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */


  CanvasBuilder.prototype.createStroke = function (state) {
    return [_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];
  };
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */


  CanvasBuilder.prototype.updateFillStyle = function (state, createFill) {
    var fillStyle = state.fillStyle;

    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
      if (fillStyle !== undefined) {
        this.instructions.push(createFill.call(this, state));
      }

      state.currentFillStyle = fillStyle;
    }
  };
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */


  CanvasBuilder.prototype.updateStrokeStyle = function (state, applyStroke) {
    var strokeStyle = state.strokeStyle;
    var lineCap = state.lineCap;
    var lineDash = state.lineDash;
    var lineDashOffset = state.lineDashOffset;
    var lineJoin = state.lineJoin;
    var lineWidth = state.lineWidth;
    var miterLimit = state.miterLimit;

    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !(0, _array.equals)(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
      if (strokeStyle !== undefined) {
        applyStroke.call(this, state);
      }

      state.currentStrokeStyle = strokeStyle;
      state.currentLineCap = lineCap;
      state.currentLineDash = lineDash;
      state.currentLineDashOffset = lineDashOffset;
      state.currentLineJoin = lineJoin;
      state.currentLineWidth = lineWidth;
      state.currentMiterLimit = miterLimit;
    }
  };
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasBuilder.prototype.endGeometry = function (feature) {
    this.beginGeometryInstruction1_[2] = this.instructions.length;
    this.beginGeometryInstruction1_ = null;
    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
    this.beginGeometryInstruction2_ = null;
    var endGeometryInstruction = [_Instruction.default.END_GEOMETRY, feature];
    this.instructions.push(endGeometryInstruction);
    this.hitDetectionInstructions.push(endGeometryInstruction);
  };
  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */


  CanvasBuilder.prototype.getBufferedMaxExtent = function () {
    if (!this.bufferedMaxExtent_) {
      this.bufferedMaxExtent_ = (0, _extent.clone)(this.maxExtent);

      if (this.maxLineWidth > 0) {
        var width = this.resolution * (this.maxLineWidth + 1) / 2;
        (0, _extent.buffer)(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
      }
    }

    return this.bufferedMaxExtent_;
  };

  return CanvasBuilder;
}(_VectorContext.default);

var _default = CanvasBuilder;
exports.default = _default;
},{"../../array.js":"node_modules/ol/array.js","../../colorlike.js":"node_modules/ol/colorlike.js","../../extent.js":"node_modules/ol/extent.js","../../extent/Relationship.js":"node_modules/ol/extent/Relationship.js","../../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../../geom/flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","../VectorContext.js":"node_modules/ol/render/VectorContext.js","../canvas.js":"node_modules/ol/render/canvas.js","./Instruction.js":"node_modules/ol/render/canvas/Instruction.js"}],"node_modules/ol/render/canvas/ImageBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Instruction = _interopRequireDefault(require("./Instruction.js"));

var _Builder = _interopRequireDefault(require("./Builder.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/render/canvas/ImageBuilder
 */


var CanvasImageBuilder =
/** @class */
function (_super) {
  __extends(CanvasImageBuilder, _super);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */


  function CanvasImageBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
    /**
     * @private
     * @type {import("../canvas.js").DeclutterGroups}
     */


    _this.declutterGroups_ = null;
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */

    _this.hitDetectionImage_ = null;
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */

    _this.image_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.anchorX_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.anchorY_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.height_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.opacity_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.originX_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.originY_ = undefined;
    /**
     * @private
     * @type {boolean|undefined}
     */

    _this.rotateWithView_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.rotation_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.scale_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.width_ = undefined;
    return _this;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} My end.
   */


  CanvasImageBuilder.prototype.drawCoordinates_ = function (flatCoordinates, offset, end, stride) {
    return this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
  };
  /**
   * @inheritDoc
   */


  CanvasImageBuilder.prototype.drawPoint = function (pointGeometry, feature) {
    if (!this.image_) {
      return;
    }

    this.beginGeometry(pointGeometry, feature);
    var flatCoordinates = pointGeometry.getFlatCoordinates();
    var stride = pointGeometry.getStride();
    var myBegin = this.coordinates.length;
    var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
    this.instructions.push([_Instruction.default.DRAW_IMAGE, myBegin, myEnd, this.image_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
    this.anchorX_, this.anchorY_, this.declutterGroups_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.width_]);
    this.hitDetectionInstructions.push([_Instruction.default.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
    this.anchorX_, this.anchorY_, this.declutterGroups_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_]);
    this.endGeometry(feature);
  };
  /**
   * @inheritDoc
   */


  CanvasImageBuilder.prototype.drawMultiPoint = function (multiPointGeometry, feature) {
    if (!this.image_) {
      return;
    }

    this.beginGeometry(multiPointGeometry, feature);
    var flatCoordinates = multiPointGeometry.getFlatCoordinates();
    var stride = multiPointGeometry.getStride();
    var myBegin = this.coordinates.length;
    var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
    this.instructions.push([_Instruction.default.DRAW_IMAGE, myBegin, myEnd, this.image_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
    this.anchorX_, this.anchorY_, this.declutterGroups_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.width_]);
    this.hitDetectionInstructions.push([_Instruction.default.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
    this.anchorX_, this.anchorY_, this.declutterGroups_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_]);
    this.endGeometry(feature);
  };
  /**
   * @inheritDoc
   */


  CanvasImageBuilder.prototype.finish = function () {
    this.reverseHitDetectionInstructions(); // FIXME this doesn't really protect us against further calls to draw*Geometry

    this.anchorX_ = undefined;
    this.anchorY_ = undefined;
    this.hitDetectionImage_ = null;
    this.image_ = null;
    this.height_ = undefined;
    this.scale_ = undefined;
    this.opacity_ = undefined;
    this.originX_ = undefined;
    this.originY_ = undefined;
    this.rotateWithView_ = undefined;
    this.rotation_ = undefined;
    this.width_ = undefined;
    return _super.prototype.finish.call(this);
  };
  /**
   * @inheritDoc
   */


  CanvasImageBuilder.prototype.setImageStyle = function (imageStyle, declutterGroups) {
    var anchor = imageStyle.getAnchor();
    var size = imageStyle.getSize();
    var hitDetectionImage = imageStyle.getHitDetectionImage(1);
    var image = imageStyle.getImage(1);
    var origin = imageStyle.getOrigin();
    this.anchorX_ = anchor[0];
    this.anchorY_ = anchor[1];
    this.declutterGroups_ =
    /** @type {import("../canvas.js").DeclutterGroups} */
    declutterGroups;
    this.hitDetectionImage_ = hitDetectionImage;
    this.image_ = image;
    this.height_ = size[1];
    this.opacity_ = imageStyle.getOpacity();
    this.originX_ = origin[0];
    this.originY_ = origin[1];
    this.rotateWithView_ = imageStyle.getRotateWithView();
    this.rotation_ = imageStyle.getRotation();
    this.scale_ = imageStyle.getScale();
    this.width_ = size[0];
  };

  return CanvasImageBuilder;
}(_Builder.default);

var _default = CanvasImageBuilder;
exports.default = _default;
},{"./Instruction.js":"node_modules/ol/render/canvas/Instruction.js","./Builder.js":"node_modules/ol/render/canvas/Builder.js"}],"node_modules/ol/render/canvas/LineStringBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Instruction = _interopRequireWildcard(require("./Instruction.js"));

var _Builder = _interopRequireDefault(require("./Builder.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/render/canvas/LineStringBuilder
 */


var CanvasLineStringBuilder =
/** @class */
function (_super) {
  __extends(CanvasLineStringBuilder, _super);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */


  function CanvasLineStringBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */


  CanvasLineStringBuilder.prototype.drawFlatCoordinates_ = function (flatCoordinates, offset, end, stride) {
    var myBegin = this.coordinates.length;
    var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
    var moveToLineToInstruction = [_Instruction.default.MOVE_TO_LINE_TO, myBegin, myEnd];
    this.instructions.push(moveToLineToInstruction);
    this.hitDetectionInstructions.push(moveToLineToInstruction);
    return end;
  };
  /**
   * @inheritDoc
   */


  CanvasLineStringBuilder.prototype.drawLineString = function (lineStringGeometry, feature) {
    var state = this.state;
    var strokeStyle = state.strokeStyle;
    var lineWidth = state.lineWidth;

    if (strokeStyle === undefined || lineWidth === undefined) {
      return;
    }

    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(lineStringGeometry, feature);
    this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], _Instruction.beginPathInstruction);
    var flatCoordinates = lineStringGeometry.getFlatCoordinates();
    var stride = lineStringGeometry.getStride();
    this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
    this.hitDetectionInstructions.push(_Instruction.strokeInstruction);
    this.endGeometry(feature);
  };
  /**
   * @inheritDoc
   */


  CanvasLineStringBuilder.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {
    var state = this.state;
    var strokeStyle = state.strokeStyle;
    var lineWidth = state.lineWidth;

    if (strokeStyle === undefined || lineWidth === undefined) {
      return;
    }

    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(multiLineStringGeometry, feature);
    this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], _Instruction.beginPathInstruction);
    var ends = multiLineStringGeometry.getEnds();
    var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
    var stride = multiLineStringGeometry.getStride();
    var offset = 0;

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.drawFlatCoordinates_(flatCoordinates, offset, ends[i], stride);
    }

    this.hitDetectionInstructions.push(_Instruction.strokeInstruction);
    this.endGeometry(feature);
  };
  /**
   * @inheritDoc
   */


  CanvasLineStringBuilder.prototype.finish = function () {
    var state = this.state;

    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
      this.instructions.push(_Instruction.strokeInstruction);
    }

    this.reverseHitDetectionInstructions();
    this.state = null;
    return _super.prototype.finish.call(this);
  };
  /**
   * @inheritDoc.
   */


  CanvasLineStringBuilder.prototype.applyStroke = function (state) {
    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
      this.instructions.push(_Instruction.strokeInstruction);
      state.lastStroke = this.coordinates.length;
    }

    state.lastStroke = 0;

    _super.prototype.applyStroke.call(this, state);

    this.instructions.push(_Instruction.beginPathInstruction);
  };

  return CanvasLineStringBuilder;
}(_Builder.default);

var _default = CanvasLineStringBuilder;
exports.default = _default;
},{"./Instruction.js":"node_modules/ol/render/canvas/Instruction.js","./Builder.js":"node_modules/ol/render/canvas/Builder.js"}],"node_modules/ol/render/canvas/PolygonBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _simplify = require("../../geom/flat/simplify.js");

var _canvas = require("../canvas.js");

var _Instruction = _interopRequireWildcard(require("./Instruction.js"));

var _Builder = _interopRequireDefault(require("./Builder.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/render/canvas/PolygonBuilder
 */


var CanvasPolygonBuilder =
/** @class */
function (_super) {
  __extends(CanvasPolygonBuilder, _super);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */


  function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */


  CanvasPolygonBuilder.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {
    var state = this.state;
    var fill = state.fillStyle !== undefined;
    var stroke = state.strokeStyle !== undefined;
    var numEnds = ends.length;
    this.instructions.push(_Instruction.beginPathInstruction);
    this.hitDetectionInstructions.push(_Instruction.beginPathInstruction);

    for (var i = 0; i < numEnds; ++i) {
      var end = ends[i];
      var myBegin = this.coordinates.length;
      var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
      var moveToLineToInstruction = [_Instruction.default.MOVE_TO_LINE_TO, myBegin, myEnd];
      this.instructions.push(moveToLineToInstruction);
      this.hitDetectionInstructions.push(moveToLineToInstruction);

      if (stroke) {
        // Performance optimization: only call closePath() when we have a stroke.
        // Otherwise the ring is closed already (see appendFlatCoordinates above).
        this.instructions.push(_Instruction.closePathInstruction);
        this.hitDetectionInstructions.push(_Instruction.closePathInstruction);
      }

      offset = end;
    }

    if (fill) {
      this.instructions.push(_Instruction.fillInstruction);
      this.hitDetectionInstructions.push(_Instruction.fillInstruction);
    }

    if (stroke) {
      this.instructions.push(_Instruction.strokeInstruction);
      this.hitDetectionInstructions.push(_Instruction.strokeInstruction);
    }

    return offset;
  };
  /**
   * @inheritDoc
   */


  CanvasPolygonBuilder.prototype.drawCircle = function (circleGeometry, feature) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;

    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }

    this.setFillStrokeStyles_();
    this.beginGeometry(circleGeometry, feature);

    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction.default.SET_FILL_STYLE, _canvas.defaultFillStyle]);
    }

    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
    }

    var flatCoordinates = circleGeometry.getFlatCoordinates();
    var stride = circleGeometry.getStride();
    var myBegin = this.coordinates.length;
    this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
    var circleInstruction = [_Instruction.default.CIRCLE, myBegin];
    this.instructions.push(_Instruction.beginPathInstruction, circleInstruction);
    this.hitDetectionInstructions.push(_Instruction.beginPathInstruction, circleInstruction);

    if (state.fillStyle !== undefined) {
      this.instructions.push(_Instruction.fillInstruction);
      this.hitDetectionInstructions.push(_Instruction.fillInstruction);
    }

    if (state.strokeStyle !== undefined) {
      this.instructions.push(_Instruction.strokeInstruction);
      this.hitDetectionInstructions.push(_Instruction.strokeInstruction);
    }

    this.endGeometry(feature);
  };
  /**
   * @inheritDoc
   */


  CanvasPolygonBuilder.prototype.drawPolygon = function (polygonGeometry, feature) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;

    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }

    this.setFillStrokeStyles_();
    this.beginGeometry(polygonGeometry, feature);

    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction.default.SET_FILL_STYLE, _canvas.defaultFillStyle]);
    }

    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
    }

    var ends = polygonGeometry.getEnds();
    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
    var stride = polygonGeometry.getStride();
    this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);
    this.endGeometry(feature);
  };
  /**
   * @inheritDoc
   */


  CanvasPolygonBuilder.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;

    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }

    this.setFillStrokeStyles_();
    this.beginGeometry(multiPolygonGeometry, feature);

    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction.default.SET_FILL_STYLE, _canvas.defaultFillStyle]);
    }

    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
    }

    var endss = multiPolygonGeometry.getEndss();
    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
    var stride = multiPolygonGeometry.getStride();
    var offset = 0;

    for (var i = 0, ii = endss.length; i < ii; ++i) {
      offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
    }

    this.endGeometry(feature);
  };
  /**
   * @inheritDoc
   */


  CanvasPolygonBuilder.prototype.finish = function () {
    this.reverseHitDetectionInstructions();
    this.state = null; // We want to preserve topology when drawing polygons.  Polygons are
    // simplified using quantization and point elimination. However, we might
    // have received a mix of quantized and non-quantized geometries, so ensure
    // that all are quantized by quantizing all coordinates in the batch.

    var tolerance = this.tolerance;

    if (tolerance !== 0) {
      var coordinates = this.coordinates;

      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = (0, _simplify.snap)(coordinates[i], tolerance);
      }
    }

    return _super.prototype.finish.call(this);
  };
  /**
   * @private
   */


  CanvasPolygonBuilder.prototype.setFillStrokeStyles_ = function () {
    var state = this.state;
    var fillStyle = state.fillStyle;

    if (fillStyle !== undefined) {
      this.updateFillStyle(state, this.createFill);
    }

    if (state.strokeStyle !== undefined) {
      this.updateStrokeStyle(state, this.applyStroke);
    }
  };

  return CanvasPolygonBuilder;
}(_Builder.default);

var _default = CanvasPolygonBuilder;
exports.default = _default;
},{"../../geom/flat/simplify.js":"node_modules/ol/geom/flat/simplify.js","../canvas.js":"node_modules/ol/render/canvas.js","./Instruction.js":"node_modules/ol/render/canvas/Instruction.js","./Builder.js":"node_modules/ol/render/canvas/Builder.js"}],"node_modules/ol/geom/flat/straightchunk.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.matchingChunk = matchingChunk;

/**
 * @module ol/geom/flat/straightchunk
 */

/**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
  var chunkStart = offset;
  var chunkEnd = offset;
  var chunkM = 0;
  var m = 0;
  var start = offset;
  var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;

  for (i = offset; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];

    if (x1 !== undefined) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);

      if (x12 !== undefined) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));

        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }

          m = 0;
          start = i - stride;
        }
      }

      m12 = m23;
      x12 = x23;
      y12 = y23;
    }

    x1 = x2;
    y1 = y2;
  }

  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
}
},{}],"node_modules/ol/style/TextPlacement.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/style/TextPlacement
 */

/**
 * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
 * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
 * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
 * @enum {string}
 */
var _default = {
  POINT: 'point',
  LINE: 'line'
};
exports.default = _default;
},{}],"node_modules/ol/render/canvas/TextBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TEXT_ALIGN = void 0;

var _util = require("../../util.js");

var _colorlike = require("../../colorlike.js");

var _extent = require("../../extent.js");

var _straightchunk = require("../../geom/flat/straightchunk.js");

var _GeometryType = _interopRequireDefault(require("../../geom/GeometryType.js"));

var _canvas = require("../canvas.js");

var _Instruction = _interopRequireDefault(require("./Instruction.js"));

var _Builder = _interopRequireDefault(require("./Builder.js"));

var _TextPlacement = _interopRequireDefault(require("../../style/TextPlacement.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/render/canvas/TextBuilder
 */


/**
 * @const
 * @enum {number}
 */
var TEXT_ALIGN = {
  'left': 0,
  'end': 0,
  'center': 0.5,
  'right': 1,
  'start': 1,
  'top': 0,
  'middle': 0.5,
  'hanging': 0.2,
  'alphabetic': 0.8,
  'ideographic': 0.8,
  'bottom': 1
};
exports.TEXT_ALIGN = TEXT_ALIGN;

var CanvasTextBuilder =
/** @class */
function (_super) {
  __extends(CanvasTextBuilder, _super);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */


  function CanvasTextBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
    /**
     * @private
     * @type {import("../canvas.js").DeclutterGroups}
     */


    _this.declutterGroups_;
    /**
     * @private
     * @type {Array<HTMLCanvasElement>}
     */

    _this.labels_ = null;
    /**
     * @private
     * @type {string}
     */

    _this.text_ = '';
    /**
     * @private
     * @type {number}
     */

    _this.textOffsetX_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.textOffsetY_ = 0;
    /**
     * @private
     * @type {boolean|undefined}
     */

    _this.textRotateWithView_ = undefined;
    /**
     * @private
     * @type {number}
     */

    _this.textRotation_ = 0;
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */

    _this.textFillState_ = null;
    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */

    _this.fillStates = {};
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */

    _this.textStrokeState_ = null;
    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */

    _this.strokeStates = {};
    /**
     * @private
     * @type {import("../canvas.js").TextState}
     */

    _this.textState_ =
    /** @type {import("../canvas.js").TextState} */
    {};
    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */

    _this.textStates = {};
    /**
     * @private
     * @type {string}
     */

    _this.textKey_ = '';
    /**
     * @private
     * @type {string}
     */

    _this.fillKey_ = '';
    /**
     * @private
     * @type {string}
     */

    _this.strokeKey_ = '';
    return _this;
  }
  /**
   * @inheritDoc
   */


  CanvasTextBuilder.prototype.finish = function () {
    var instructions = _super.prototype.finish.call(this);

    instructions.textStates = this.textStates;
    instructions.fillStates = this.fillStates;
    instructions.strokeStates = this.strokeStates;
    return instructions;
  };
  /**
   * @inheritDoc
   */


  CanvasTextBuilder.prototype.drawText = function (geometry, feature) {
    var fillState = this.textFillState_;
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;

    if (this.text_ === '' || !textState || !fillState && !strokeState) {
      return;
    }

    var begin = this.coordinates.length;
    var geometryType = geometry.getType();
    var flatCoordinates = null;
    var end = 2;
    var stride = 2;
    var i, ii;

    if (textState.placement === _TextPlacement.default.LINE) {
      if (!(0, _extent.intersects)(this.getBufferedMaxExtent(), geometry.getExtent())) {
        return;
      }

      var ends = void 0;
      flatCoordinates = geometry.getFlatCoordinates();
      stride = geometry.getStride();

      if (geometryType == _GeometryType.default.LINE_STRING) {
        ends = [flatCoordinates.length];
      } else if (geometryType == _GeometryType.default.MULTI_LINE_STRING) {
        ends = geometry.getEnds();
      } else if (geometryType == _GeometryType.default.POLYGON) {
        ends = geometry.getEnds().slice(0, 1);
      } else if (geometryType == _GeometryType.default.MULTI_POLYGON) {
        var endss = geometry.getEndss();
        ends = [];

        for (i = 0, ii = endss.length; i < ii; ++i) {
          ends.push(endss[i][0]);
        }
      }

      this.beginGeometry(geometry, feature);
      var textAlign = textState.textAlign;
      var flatOffset = 0;
      var flatEnd = void 0;

      for (var o = 0, oo = ends.length; o < oo; ++o) {
        if (textAlign == undefined) {
          var range = (0, _straightchunk.matchingChunk)(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
          flatOffset = range[0];
          flatEnd = range[1];
        } else {
          flatEnd = ends[o];
        }

        for (i = flatOffset; i < flatEnd; i += stride) {
          this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
        }

        end = this.coordinates.length;
        flatOffset = ends[o];
        var declutterGroup = this.declutterGroups_ ? o === 0 ? this.declutterGroups_[0] : [].concat(this.declutterGroups_[0]) : null;
        this.drawChars_(begin, end, declutterGroup);
        begin = end;
      }

      this.endGeometry(feature);
    } else {
      var geometryWidths = null;

      if (!textState.overflow) {
        geometryWidths = [];
      }

      switch (geometryType) {
        case _GeometryType.default.POINT:
        case _GeometryType.default.MULTI_POINT:
          flatCoordinates = geometry.getFlatCoordinates();
          end = flatCoordinates.length;
          break;

        case _GeometryType.default.LINE_STRING:
          flatCoordinates =
          /** @type {import("../../geom/LineString.js").default} */
          geometry.getFlatMidpoint();
          break;

        case _GeometryType.default.CIRCLE:
          flatCoordinates =
          /** @type {import("../../geom/Circle.js").default} */
          geometry.getCenter();
          break;

        case _GeometryType.default.MULTI_LINE_STRING:
          flatCoordinates =
          /** @type {import("../../geom/MultiLineString.js").default} */
          geometry.getFlatMidpoints();
          end = flatCoordinates.length;
          break;

        case _GeometryType.default.POLYGON:
          flatCoordinates =
          /** @type {import("../../geom/Polygon.js").default} */
          geometry.getFlatInteriorPoint();

          if (!textState.overflow) {
            geometryWidths.push(flatCoordinates[2] / this.resolution);
          }

          stride = 3;
          break;

        case _GeometryType.default.MULTI_POLYGON:
          var interiorPoints =
          /** @type {import("../../geom/MultiPolygon.js").default} */
          geometry.getFlatInteriorPoints();
          flatCoordinates = [];

          for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {
            if (!textState.overflow) {
              geometryWidths.push(interiorPoints[i + 2] / this.resolution);
            }

            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
          }

          end = flatCoordinates.length;

          if (end == 0) {
            return;
          }

          break;

        default:
      }

      end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);
      this.saveTextStates_();

      if (textState.backgroundFill || textState.backgroundStroke) {
        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);

        if (textState.backgroundFill) {
          this.updateFillStyle(this.state, this.createFill);
          this.hitDetectionInstructions.push(this.createFill(this.state));
        }

        if (textState.backgroundStroke) {
          this.updateStrokeStyle(this.state, this.applyStroke);
          this.hitDetectionInstructions.push(this.createStroke(this.state));
        }
      }

      this.beginGeometry(geometry, feature); // The image is unknown at this stage so we pass null; it will be computed at render time.
      // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at
      // render time.

      var pixelRatio_1 = this.pixelRatio;
      this.instructions.push([_Instruction.default.DRAW_IMAGE, begin, end, null, NaN, NaN, this.declutterGroups_, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1, NaN, textState.padding == _canvas.defaultPadding ? _canvas.defaultPadding : textState.padding.map(function (p) {
        return p * pixelRatio_1;
      }), !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);
      this.hitDetectionInstructions.push([_Instruction.default.DRAW_IMAGE, begin, end, null, NaN, NaN, this.declutterGroups_, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1 / this.pixelRatio, NaN, textState.padding, !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);
      this.endGeometry(feature);
    }
  };
  /**
   * @private
   */


  CanvasTextBuilder.prototype.saveTextStates_ = function () {
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;
    var fillState = this.textFillState_;
    var strokeKey = this.strokeKey_;

    if (strokeState) {
      if (!(strokeKey in this.strokeStates)) {
        this.strokeStates[strokeKey] = {
          strokeStyle: strokeState.strokeStyle,
          lineCap: strokeState.lineCap,
          lineDashOffset: strokeState.lineDashOffset,
          lineWidth: strokeState.lineWidth,
          lineJoin: strokeState.lineJoin,
          miterLimit: strokeState.miterLimit,
          lineDash: strokeState.lineDash
        };
      }
    }

    var textKey = this.textKey_;

    if (!(textKey in this.textStates)) {
      this.textStates[textKey] = {
        font: textState.font,
        textAlign: textState.textAlign || _canvas.defaultTextAlign,
        textBaseline: textState.textBaseline || _canvas.defaultTextBaseline,
        scale: textState.scale
      };
    }

    var fillKey = this.fillKey_;

    if (fillState) {
      if (!(fillKey in this.fillStates)) {
        this.fillStates[fillKey] = {
          fillStyle: fillState.fillStyle
        };
      }
    }
  };
  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
   */


  CanvasTextBuilder.prototype.drawChars_ = function (begin, end, declutterGroup) {
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;
    var strokeKey = this.strokeKey_;
    var textKey = this.textKey_;
    var fillKey = this.fillKey_;
    this.saveTextStates_();
    var pixelRatio = this.pixelRatio;
    var baseline = TEXT_ALIGN[textState.textBaseline];
    var offsetY = this.textOffsetY_ * pixelRatio;
    var text = this.text_;
    var textScale = textState.scale;
    var strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;
    this.instructions.push([_Instruction.default.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, pixelRatio, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1]);
    this.hitDetectionInstructions.push([_Instruction.default.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, 1, offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio]);
  };
  /**
   * @inheritDoc
   */


  CanvasTextBuilder.prototype.setTextStyle = function (textStyle, declutterGroups) {
    var textState, fillState, strokeState;

    if (!textStyle) {
      this.text_ = '';
    } else {
      this.declutterGroups_ =
      /** @type {import("../canvas.js").DeclutterGroups} */
      declutterGroups;
      var textFillStyle = textStyle.getFill();

      if (!textFillStyle) {
        fillState = null;
        this.textFillState_ = fillState;
      } else {
        fillState = this.textFillState_;

        if (!fillState) {
          fillState =
          /** @type {import("../canvas.js").FillState} */
          {};
          this.textFillState_ = fillState;
        }

        fillState.fillStyle = (0, _colorlike.asColorLike)(textFillStyle.getColor() || _canvas.defaultFillStyle);
      }

      var textStrokeStyle = textStyle.getStroke();

      if (!textStrokeStyle) {
        strokeState = null;
        this.textStrokeState_ = strokeState;
      } else {
        strokeState = this.textStrokeState_;

        if (!strokeState) {
          strokeState =
          /** @type {import("../canvas.js").StrokeState} */
          {};
          this.textStrokeState_ = strokeState;
        }

        var lineDash = textStrokeStyle.getLineDash();
        var lineDashOffset = textStrokeStyle.getLineDashOffset();
        var lineWidth = textStrokeStyle.getWidth();
        var miterLimit = textStrokeStyle.getMiterLimit();
        strokeState.lineCap = textStrokeStyle.getLineCap() || _canvas.defaultLineCap;
        strokeState.lineDash = lineDash ? lineDash.slice() : _canvas.defaultLineDash;
        strokeState.lineDashOffset = lineDashOffset === undefined ? _canvas.defaultLineDashOffset : lineDashOffset;
        strokeState.lineJoin = textStrokeStyle.getLineJoin() || _canvas.defaultLineJoin;
        strokeState.lineWidth = lineWidth === undefined ? _canvas.defaultLineWidth : lineWidth;
        strokeState.miterLimit = miterLimit === undefined ? _canvas.defaultMiterLimit : miterLimit;
        strokeState.strokeStyle = (0, _colorlike.asColorLike)(textStrokeStyle.getColor() || _canvas.defaultStrokeStyle);
      }

      textState = this.textState_;

      var font = textStyle.getFont() || _canvas.defaultFont;

      (0, _canvas.registerFont)(font);
      var textScale = textStyle.getScale();
      textState.overflow = textStyle.getOverflow();
      textState.font = font;
      textState.maxAngle = textStyle.getMaxAngle();
      textState.placement = textStyle.getPlacement();
      textState.textAlign = textStyle.getTextAlign();
      textState.textBaseline = textStyle.getTextBaseline() || _canvas.defaultTextBaseline;
      textState.backgroundFill = textStyle.getBackgroundFill();
      textState.backgroundStroke = textStyle.getBackgroundStroke();
      textState.padding = textStyle.getPadding() || _canvas.defaultPadding;
      textState.scale = textScale === undefined ? 1 : textScale;
      var textOffsetX = textStyle.getOffsetX();
      var textOffsetY = textStyle.getOffsetY();
      var textRotateWithView = textStyle.getRotateWithView();
      var textRotation = textStyle.getRotation();
      this.text_ = textStyle.getText() || '';
      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
      this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;
      this.textRotation_ = textRotation === undefined ? 0 : textRotation;
      this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : (0, _util.getUid)(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';
      this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?') + (textState.textBaseline || '?');
      this.fillKey_ = fillState ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + (0, _util.getUid)(fillState.fillStyle) : '';
    }
  };

  return CanvasTextBuilder;
}(_Builder.default);

var _default = CanvasTextBuilder;
exports.default = _default;
},{"../../util.js":"node_modules/ol/util.js","../../colorlike.js":"node_modules/ol/colorlike.js","../../extent.js":"node_modules/ol/extent.js","../../geom/flat/straightchunk.js":"node_modules/ol/geom/flat/straightchunk.js","../../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../canvas.js":"node_modules/ol/render/canvas.js","./Instruction.js":"node_modules/ol/render/canvas/Instruction.js","./Builder.js":"node_modules/ol/render/canvas/Builder.js","../../style/TextPlacement.js":"node_modules/ol/style/TextPlacement.js"}],"node_modules/ol/render/canvas/BuilderGroup.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extent = require("../../extent.js");

var _Builder = _interopRequireDefault(require("./Builder.js"));

var _ImageBuilder = _interopRequireDefault(require("./ImageBuilder.js"));

var _LineStringBuilder = _interopRequireDefault(require("./LineStringBuilder.js"));

var _PolygonBuilder = _interopRequireDefault(require("./PolygonBuilder.js"));

var _TextBuilder = _interopRequireDefault(require("./TextBuilder.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render/canvas/BuilderGroup
 */

/**
 * @type {Object<import("./BuilderType").default, typeof Builder>}
 */
var BATCH_CONSTRUCTORS = {
  'Circle': _PolygonBuilder.default,
  'Default': _Builder.default,
  'Image': _ImageBuilder.default,
  'LineString': _LineStringBuilder.default,
  'Polygon': _PolygonBuilder.default,
  'Text': _TextBuilder.default
};

var BuilderGroup =
/** @class */
function () {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} declutter Decluttering enabled.
   */
  function BuilderGroup(tolerance, maxExtent, resolution, pixelRatio, declutter) {
    /**
     * @type {boolean}
     * @private
     */
    this.declutter_ = declutter;
    /**
     * @type {import("../canvas.js").DeclutterGroups}
     * @private
     */

    this.declutterGroups_ = null;
    /**
     * @private
     * @type {number}
     */

    this.tolerance_ = tolerance;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    this.maxExtent_ = maxExtent;
    /**
     * @private
     * @type {number}
     */

    this.pixelRatio_ = pixelRatio;
    /**
     * @private
     * @type {number}
     */

    this.resolution_ = resolution;
    /**
     * @private
     * @type {!Object<string, !Object<import("./BuilderType").default, Builder>>}
     */

    this.buildersByZIndex_ = {};
  }
  /**
   * @param {boolean} group Group with previous builder.
   * @return {import("../canvas").DeclutterGroups} The resulting instruction groups.
   */


  BuilderGroup.prototype.addDeclutter = function (group) {
    var declutter = null;

    if (this.declutter_) {
      if (group) {
        declutter = this.declutterGroups_;
        /** @type {number} */

        declutter[0][4]++;
      } else {
        declutter = [(0, _extent.createEmpty)()];
        this.declutterGroups_ = declutter;
        declutter[0].push(1);
      }
    }

    return declutter;
  };
  /**
   * @return {!Object<string, !Object<import("./BuilderType").default, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */


  BuilderGroup.prototype.finish = function () {
    var builderInstructions = {};

    for (var zKey in this.buildersByZIndex_) {
      builderInstructions[zKey] = builderInstructions[zKey] || {};
      var builders = this.buildersByZIndex_[zKey];

      for (var builderKey in builders) {
        var builderInstruction = builders[builderKey].finish();
        builderInstructions[zKey][builderKey] = builderInstruction;
      }
    }

    return builderInstructions;
  };
  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("./BuilderType.js").default} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */


  BuilderGroup.prototype.getBuilder = function (zIndex, builderType) {
    var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
    var replays = this.buildersByZIndex_[zIndexKey];

    if (replays === undefined) {
      replays = {};
      this.buildersByZIndex_[zIndexKey] = replays;
    }

    var replay = replays[builderType];

    if (replay === undefined) {
      var Constructor = BATCH_CONSTRUCTORS[builderType];
      replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
      replays[builderType] = replay;
    }

    return replay;
  };

  return BuilderGroup;
}();

var _default = BuilderGroup;
exports.default = _default;
},{"../../extent.js":"node_modules/ol/extent.js","./Builder.js":"node_modules/ol/render/canvas/Builder.js","./ImageBuilder.js":"node_modules/ol/render/canvas/ImageBuilder.js","./LineStringBuilder.js":"node_modules/ol/render/canvas/LineStringBuilder.js","./PolygonBuilder.js":"node_modules/ol/render/canvas/PolygonBuilder.js","./TextBuilder.js":"node_modules/ol/render/canvas/TextBuilder.js"}],"node_modules/ol/geom/flat/textpath.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawTextOnPath = drawTextOnPath;

var _math = require("../../math.js");

/**
 * @module ol/geom/flat/textpath
 */

/**
 * @param {Array<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @param {number} scale The product of the text scale and the device pixel ratio.
 * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.
 * @param {string} font The font.
 * @param {Object<string, number>} cache A cache of measured widths.
 * @return {Array<Array<*>>} The result array (or null if `maxAngle` was
 * exceeded). Entries of the array are x, y, anchorX, angle, chunk.
 */
function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache) {
  var result = []; // Keep text upright

  var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];
  var numChars = text.length;
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  offset += stride;
  var x2 = flatCoordinates[offset];
  var y2 = flatCoordinates[offset + 1];
  var segmentM = 0;
  var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  var angleChanged = false;
  var index, previousAngle;

  for (var i = 0; i < numChars; ++i) {
    index = reverse ? numChars - i - 1 : i;
    var char = text[index];
    var charLength = scale * measureAndCacheTextWidth(font, char, cache);
    var charM = startM + charLength / 2;

    while (offset < end - stride && segmentM + segmentLength < charM) {
      x1 = x2;
      y1 = y2;
      offset += stride;
      x2 = flatCoordinates[offset];
      y2 = flatCoordinates[offset + 1];
      segmentM += segmentLength;
      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }

    var segmentPos = charM - segmentM;
    var angle = Math.atan2(y2 - y1, x2 - x1);

    if (reverse) {
      angle += angle > 0 ? -Math.PI : Math.PI;
    }

    if (previousAngle !== undefined) {
      var delta = angle - previousAngle;
      angleChanged = angleChanged || delta !== 0;
      delta += delta > Math.PI ? -2 * Math.PI : delta < -Math.PI ? 2 * Math.PI : 0;

      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }

    previousAngle = angle;
    var interpolate = segmentPos / segmentLength;
    var x = (0, _math.lerp)(x1, x2, interpolate);
    var y = (0, _math.lerp)(y1, y2, interpolate);
    result[index] = [x, y, charLength / 2, angle, char];
    startM += charLength;
  }

  return angleChanged ? result : [[result[0][0], result[0][1], result[0][2], result[0][3], text]];
}
},{"../../math.js":"node_modules/ol/math.js"}],"node_modules/rbush/rbush.js":[function(require,module,exports) {
var define;
var global = arguments[3];
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
typeof define === 'function' && define.amd ? define(factory) :
(global = global || self, global.RBush = factory());
}(this, function () { 'use strict';

function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
}

function quickselectStep(arr, k, left, right, compare) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) { swap(arr, left, right); }

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) { i++; }
            while (compare(arr[j], t) > 0) { j--; }
        }

        if (compare(arr[left], t) === 0) { swap(arr, left, j); }
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) { left = j + 1; }
        if (k <= j) { right = j - 1; }
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

var RBush = function RBush(maxEntries) {
    if ( maxEntries === void 0 ) maxEntries = 9;

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    this.clear();
};

RBush.prototype.all = function all () {
    return this._all(this.data, []);
};

RBush.prototype.search = function search (bbox) {
    var node = this.data;
    var result = [];

    if (!intersects(bbox, node)) { return result; }

    var toBBox = this.toBBox;
    var nodesToSearch = [];

    while (node) {
        for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var childBBox = node.leaf ? toBBox(child) : child;

            if (intersects(bbox, childBBox)) {
                if (node.leaf) { result.push(child); }
                else if (contains(bbox, childBBox)) { this._all(child, result); }
                else { nodesToSearch.push(child); }
            }
        }
        node = nodesToSearch.pop();
    }

    return result;
};

RBush.prototype.collides = function collides (bbox) {
    var node = this.data;

    if (!intersects(bbox, node)) { return false; }

    var nodesToSearch = [];
    while (node) {
        for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var childBBox = node.leaf ? this.toBBox(child) : child;

            if (intersects(bbox, childBBox)) {
                if (node.leaf || contains(bbox, childBBox)) { return true; }
                nodesToSearch.push(child);
            }
        }
        node = nodesToSearch.pop();
    }

    return false;
};

RBush.prototype.load = function load (data) {
    if (!(data && data.length)) { return this; }

    if (data.length < this._minEntries) {
        for (var i = 0; i < data.length; i++) {
            this.insert(data[i]);
        }
        return this;
    }

    // recursively build the tree with the given data from scratch using OMT algorithm
    var node = this._build(data.slice(), 0, data.length - 1, 0);

    if (!this.data.children.length) {
        // save as is if tree is empty
        this.data = node;

    } else if (this.data.height === node.height) {
        // split root if trees have the same height
        this._splitRoot(this.data, node);

    } else {
        if (this.data.height < node.height) {
            // swap trees if inserted one is bigger
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
        }

        // insert the small tree into the large tree at appropriate level
        this._insert(node, this.data.height - node.height - 1, true);
    }

    return this;
};

RBush.prototype.insert = function insert (item) {
    if (item) { this._insert(item, this.data.height - 1); }
    return this;
};

RBush.prototype.clear = function clear () {
    this.data = createNode([]);
    return this;
};

RBush.prototype.remove = function remove (item, equalsFn) {
    if (!item) { return this; }

    var node = this.data;
    var bbox = this.toBBox(item);
    var path = [];
    var indexes = [];
    var i, parent, goingUp;

    // depth-first iterative tree traversal
    while (node || path.length) {

        if (!node) { // go up
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
        }

        if (node.leaf) { // check current node
            var index = findItem(item, node.children, equalsFn);

            if (index !== -1) {
                // item found, remove the item and condense tree upwards
                node.children.splice(index, 1);
                path.push(node);
                this._condense(path);
                return this;
            }
        }

        if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];

        } else if (parent) { // go right
            i++;
            node = parent.children[i];
            goingUp = false;

        } else { node = null; } // nothing found
    }

    return this;
};

RBush.prototype.toBBox = function toBBox (item) { return item; };

RBush.prototype.compareMinX = function compareMinX (a, b) { return a.minX - b.minX; };
RBush.prototype.compareMinY = function compareMinY (a, b) { return a.minY - b.minY; };

RBush.prototype.toJSON = function toJSON () { return this.data; };

RBush.prototype.fromJSON = function fromJSON (data) {
    this.data = data;
    return this;
};

RBush.prototype._all = function _all (node, result) {
    var nodesToSearch = [];
    while (node) {
        if (node.leaf) { result.push.apply(result, node.children); }
        else { nodesToSearch.push.apply(nodesToSearch, node.children); }

        node = nodesToSearch.pop();
    }
    return result;
};

RBush.prototype._build = function _build (items, left, right, height) {

    var N = right - left + 1;
    var M = this._maxEntries;
    var node;

    if (N <= M) {
        // reached leaf level; return leaf
        node = createNode(items.slice(left, right + 1));
        calcBBox(node, this.toBBox);
        return node;
    }

    if (!height) {
        // target height of the bulk-loaded tree
        height = Math.ceil(Math.log(N) / Math.log(M));

        // target number of root entries to maximize storage utilization
        M = Math.ceil(N / Math.pow(M, height - 1));
    }

    node = createNode([]);
    node.leaf = false;
    node.height = height;

    // split the items into M mostly square tiles

    var N2 = Math.ceil(N / M);
    var N1 = N2 * Math.ceil(Math.sqrt(M));

    multiSelect(items, left, right, N1, this.compareMinX);

    for (var i = left; i <= right; i += N1) {

        var right2 = Math.min(i + N1 - 1, right);

        multiSelect(items, i, right2, N2, this.compareMinY);

        for (var j = i; j <= right2; j += N2) {

            var right3 = Math.min(j + N2 - 1, right2);

            // pack each entry recursively
            node.children.push(this._build(items, j, right3, height - 1));
        }
    }

    calcBBox(node, this.toBBox);

    return node;
};

RBush.prototype._chooseSubtree = function _chooseSubtree (bbox, node, level, path) {
    while (true) {
        path.push(node);

        if (node.leaf || path.length - 1 === level) { break; }

        var minArea = Infinity;
        var minEnlargement = Infinity;
        var targetNode = (void 0);

        for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var area = bboxArea(child);
            var enlargement = enlargedArea(bbox, child) - area;

            // choose entry with the least area enlargement
            if (enlargement < minEnlargement) {
                minEnlargement = enlargement;
                minArea = area < minArea ? area : minArea;
                targetNode = child;

            } else if (enlargement === minEnlargement) {
                // otherwise choose one with the smallest area
                if (area < minArea) {
                    minArea = area;
                    targetNode = child;
                }
            }
        }

        node = targetNode || node.children[0];
    }

    return node;
};

RBush.prototype._insert = function _insert (item, level, isNode) {
    var bbox = isNode ? item : this.toBBox(item);
    var insertPath = [];

    // find the best node for accommodating the item, saving all nodes along the path too
    var node = this._chooseSubtree(bbox, this.data, level, insertPath);

    // put the item into the node
    node.children.push(item);
    extend(node, bbox);

    // split on node overflow; propagate upwards if necessary
    while (level >= 0) {
        if (insertPath[level].children.length > this._maxEntries) {
            this._split(insertPath, level);
            level--;
        } else { break; }
    }

    // adjust bboxes along the insertion path
    this._adjustParentBBoxes(bbox, insertPath, level);
};

// split overflowed node into two
RBush.prototype._split = function _split (insertPath, level) {
    var node = insertPath[level];
    var M = node.children.length;
    var m = this._minEntries;

    this._chooseSplitAxis(node, m, M);

    var splitIndex = this._chooseSplitIndex(node, m, M);

    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
    newNode.height = node.height;
    newNode.leaf = node.leaf;

    calcBBox(node, this.toBBox);
    calcBBox(newNode, this.toBBox);

    if (level) { insertPath[level - 1].children.push(newNode); }
    else { this._splitRoot(node, newNode); }
};

RBush.prototype._splitRoot = function _splitRoot (node, newNode) {
    // split root node
    this.data = createNode([node, newNode]);
    this.data.height = node.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
};

RBush.prototype._chooseSplitIndex = function _chooseSplitIndex (node, m, M) {
    var index;
    var minOverlap = Infinity;
    var minArea = Infinity;

    for (var i = m; i <= M - m; i++) {
        var bbox1 = distBBox(node, 0, i, this.toBBox);
        var bbox2 = distBBox(node, i, M, this.toBBox);

        var overlap = intersectionArea(bbox1, bbox2);
        var area = bboxArea(bbox1) + bboxArea(bbox2);

        // choose distribution with minimum overlap
        if (overlap < minOverlap) {
            minOverlap = overlap;
            index = i;

            minArea = area < minArea ? area : minArea;

        } else if (overlap === minOverlap) {
            // otherwise choose distribution with minimum area
            if (area < minArea) {
                minArea = area;
                index = i;
            }
        }
    }

    return index || M - m;
};

// sorts node children by the best axis for split
RBush.prototype._chooseSplitAxis = function _chooseSplitAxis (node, m, M) {
    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
    var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
    var xMargin = this._allDistMargin(node, m, M, compareMinX);
    var yMargin = this._allDistMargin(node, m, M, compareMinY);

    // if total distributions margin value is minimal for x, sort by minX,
    // otherwise it's already sorted by minY
    if (xMargin < yMargin) { node.children.sort(compareMinX); }
};

// total margin of all possible split distributions where each node is at least m full
RBush.prototype._allDistMargin = function _allDistMargin (node, m, M, compare) {
    node.children.sort(compare);

    var toBBox = this.toBBox;
    var leftBBox = distBBox(node, 0, m, toBBox);
    var rightBBox = distBBox(node, M - m, M, toBBox);
    var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);

    for (var i = m; i < M - m; i++) {
        var child = node.children[i];
        extend(leftBBox, node.leaf ? toBBox(child) : child);
        margin += bboxMargin(leftBBox);
    }

    for (var i$1 = M - m - 1; i$1 >= m; i$1--) {
        var child$1 = node.children[i$1];
        extend(rightBBox, node.leaf ? toBBox(child$1) : child$1);
        margin += bboxMargin(rightBBox);
    }

    return margin;
};

RBush.prototype._adjustParentBBoxes = function _adjustParentBBoxes (bbox, path, level) {
    // adjust bboxes along the given tree path
    for (var i = level; i >= 0; i--) {
        extend(path[i], bbox);
    }
};

RBush.prototype._condense = function _condense (path) {
    // go through the path, removing empty nodes and updating bboxes
    for (var i = path.length - 1, siblings = (void 0); i >= 0; i--) {
        if (path[i].children.length === 0) {
            if (i > 0) {
                siblings = path[i - 1].children;
                siblings.splice(siblings.indexOf(path[i]), 1);

            } else { this.clear(); }

        } else { calcBBox(path[i], this.toBBox); }
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) { return items.indexOf(item); }

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) { return i; }
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) { destNode = createNode(null); }
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k; i < p; i++) {
        var child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX);
    var minY = Math.max(a.minY, b.minY);
    var maxX = Math.min(a.maxX, b.maxX);
    var maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right];

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) { continue; }

        var mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}

return RBush;

}));

},{}],"node_modules/ol/render/canvas/Executor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _array = require("../../array.js");

var _extent = require("../../extent.js");

var _length = require("../../geom/flat/length.js");

var _textpath = require("../../geom/flat/textpath.js");

var _transform = require("../../geom/flat/transform.js");

var _canvas = require("../canvas.js");

var _Instruction = _interopRequireDefault(require("./Instruction.js"));

var _TextBuilder = require("./TextBuilder.js");

var _transform2 = require("../../transform.js");

var _rbush = _interopRequireDefault(require("rbush/rbush.js"));

var _has = require("../../has.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render/canvas/Executor
 */

/**
 * @typedef {Object} SerializableInstructions
 * @property {Array<*>} instructions The rendering instructions.
 * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.
 * @property {Array<number>} coordinates The array of all coordinates.
 * @property {!Object<string, import("../canvas.js").TextState>} textStates The text states (decluttering).
 * @property {!Object<string, import("../canvas.js").FillState>} fillStates The fill states (decluttering).
 * @property {!Object<string, import("../canvas.js").StrokeState>} strokeStates The stroke states (decluttering).
 */

/**
 * @type {import("../../extent.js").Extent}
 */
var tmpExtent = (0, _extent.createEmpty)();
/**
 * @type {!import("../../transform.js").Transform}
 */

var tmpTransform = (0, _transform2.create)();
/** @type {import("../../coordinate.js").Coordinate} */

var p1 = [];
/** @type {import("../../coordinate.js").Coordinate} */

var p2 = [];
/** @type {import("../../coordinate.js").Coordinate} */

var p3 = [];
/** @type {import("../../coordinate.js").Coordinate} */

var p4 = [];

var Executor =
/** @class */
function () {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {SerializableInstructions} instructions The serializable instructions
   */
  function Executor(resolution, pixelRatio, overlaps, instructions) {
    /**
     * @protected
     * @type {boolean}
     */
    this.overlaps = overlaps;
    /**
     * @protected
     * @type {number}
     */

    this.pixelRatio = pixelRatio;
    /**
     * @protected
     * @const
     * @type {number}
     */

    this.resolution = resolution;
    /**
     * @private
     * @type {boolean}
     */

    this.alignFill_;
    /**
     * @type {Array<*>}
     */

    this.declutterItems = [];
    /**
     * @protected
     * @type {Array<*>}
     */

    this.instructions = instructions.instructions;
    /**
     * @protected
     * @type {Array<number>}
     */

    this.coordinates = instructions.coordinates;
    /**
     * @private
     * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
     */

    this.coordinateCache_ = {};
    /**
     * @private
     * @type {!import("../../transform.js").Transform}
     */

    this.renderedTransform_ = (0, _transform2.create)();
    /**
     * @protected
     * @type {Array<*>}
     */

    this.hitDetectionInstructions = instructions.hitDetectionInstructions;
    /**
     * @private
     * @type {Array<number>}
     */

    this.pixelCoordinates_ = null;
    /**
     * @private
     * @type {number}
     */

    this.viewRotation_ = 0;
    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */

    this.fillStates = instructions.fillStates || {};
    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */

    this.strokeStates = instructions.strokeStates || {};
    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */

    this.textStates = instructions.textStates || {};
    /**
     * @private
     * @type {Object<string, Object<string, number>>}
     */

    this.widths_ = {};
    /**
     * @private
     * @type {Object<string, import("../canvas.js").Label>}
     */

    this.labels_ = {};
  }
  /**
   * @param {string} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */


  Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {
    var key = text + textKey + fillKey + strokeKey;

    if (this.labels_[key]) {
      return this.labels_[key];
    }

    var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
    var fillState = fillKey ? this.fillStates[fillKey] : null;
    var textState = this.textStates[textKey];
    var pixelRatio = this.pixelRatio;
    var scale = textState.scale * pixelRatio;
    var align = _TextBuilder.TEXT_ALIGN[textState.textAlign || _canvas.defaultTextAlign];
    var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
    var lines = text.split('\n');
    var numLines = lines.length;
    var widths = [];
    var width = (0, _canvas.measureTextWidths)(textState.font, lines, widths);
    var lineHeight = (0, _canvas.measureTextHeight)(textState.font);
    var height = lineHeight * numLines;
    var renderWidth = width + strokeWidth;
    var contextInstructions = [];
    /** @type {import("../canvas.js").Label} */

    var label = {
      // make canvas 2 pixels wider to account for italic text width measurement errors
      width: Math.ceil((renderWidth + 2) * scale),
      height: Math.ceil((height + strokeWidth) * scale),
      contextInstructions: contextInstructions
    };

    if (scale != 1) {
      contextInstructions.push('scale', [scale, scale]);
    }

    contextInstructions.push('font', textState.font);

    if (strokeKey) {
      contextInstructions.push('strokeStyle', strokeState.strokeStyle);
      contextInstructions.push('lineWidth', strokeWidth);
      contextInstructions.push('lineCap', strokeState.lineCap);
      contextInstructions.push('lineJoin', strokeState.lineJoin);
      contextInstructions.push('miterLimit', strokeState.miterLimit); // eslint-disable-next-line

      var Context = _has.WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;

      if (Context.prototype.setLineDash) {
        contextInstructions.push('setLineDash', [strokeState.lineDash]);
        contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);
      }
    }

    if (fillKey) {
      contextInstructions.push('fillStyle', fillState.fillStyle);
    }

    contextInstructions.push('textBaseline', 'middle');
    contextInstructions.push('textAlign', 'center');
    var leftRight = 0.5 - align;
    var x = align * renderWidth + leftRight * strokeWidth;
    var i;

    if (strokeKey) {
      for (i = 0; i < numLines; ++i) {
        contextInstructions.push('strokeText', [lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight]);
      }
    }

    if (fillKey) {
      for (i = 0; i < numLines; ++i) {
        contextInstructions.push('fillText', [lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight]);
      }
    }

    this.labels_[key] = label;
    return label;
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */


  Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
    context.beginPath();
    context.moveTo.apply(context, p1);
    context.lineTo.apply(context, p2);
    context.lineTo.apply(context, p3);
    context.lineTo.apply(context, p4);
    context.lineTo.apply(context, p1);

    if (fillInstruction) {
      this.alignFill_ =
      /** @type {boolean} */
      fillInstruction[2];
      this.fill_(context);
    }

    if (strokeInstruction) {
      this.setStrokeStyle_(context,
      /** @type {Array<*>} */
      strokeInstruction);
      context.stroke();
    }
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
   * @param {number} height Height.
   * @param {number} opacity Opacity.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {number} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {number} width Width.
   * @param {Array<number>} padding Padding.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */


  Executor.prototype.replayImageOrLabel_ = function (context, x, y, imageOrLabel, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {
    var fillStroke = fillInstruction || strokeInstruction;
    anchorX *= scale;
    anchorY *= scale;
    x -= anchorX;
    y -= anchorY;
    var w = width + originX > imageOrLabel.width ? imageOrLabel.width - originX : width;
    var h = height + originY > imageOrLabel.height ? imageOrLabel.height - originY : height;
    var boxW = padding[3] + w * scale + padding[1];
    var boxH = padding[0] + h * scale + padding[2];
    var boxX = x - padding[3];
    var boxY = y - padding[0];

    if (fillStroke || rotation !== 0) {
      p1[0] = boxX;
      p4[0] = boxX;
      p1[1] = boxY;
      p2[1] = boxY;
      p2[0] = boxX + boxW;
      p3[0] = p2[0];
      p3[1] = boxY + boxH;
      p4[1] = p3[1];
    }

    var transform = null;

    if (rotation !== 0) {
      var centerX = x + anchorX;
      var centerY = y + anchorY;
      transform = (0, _transform2.compose)(tmpTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
      (0, _transform2.apply)(tmpTransform, p1);
      (0, _transform2.apply)(tmpTransform, p2);
      (0, _transform2.apply)(tmpTransform, p3);
      (0, _transform2.apply)(tmpTransform, p4);
      (0, _extent.createOrUpdate)(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);
    } else {
      (0, _extent.createOrUpdate)(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);
    }

    var canvas = context.canvas;
    var strokePadding = strokeInstruction ? strokeInstruction[2] * scale / 2 : 0;
    var intersects = tmpExtent[0] - strokePadding <= canvas.width && tmpExtent[2] + strokePadding >= 0 && tmpExtent[1] - strokePadding <= canvas.height && tmpExtent[3] + strokePadding >= 0;

    if (snapToPixel) {
      x = Math.round(x);
      y = Math.round(y);
    }

    if (declutterGroup) {
      if (!intersects && declutterGroup[4] == 1) {
        return;
      }

      (0, _extent.extend)(declutterGroup, tmpExtent);
      var declutterArgs = intersects ? [context, transform ? transform.slice(0) : null, opacity, imageOrLabel, originX, originY, w, h, x, y, scale] : null;

      if (declutterArgs) {
        if (fillStroke) {
          declutterArgs.push(fillInstruction, strokeInstruction, p1.slice(0), p2.slice(0), p3.slice(0), p4.slice(0));
        }

        declutterGroup.push(declutterArgs);
      }
    } else if (intersects) {
      if (fillStroke) {
        this.replayTextBackground_(context, p1, p2, p3, p4,
        /** @type {Array<*>} */
        fillInstruction,
        /** @type {Array<*>} */
        strokeInstruction);
      }

      (0, _canvas.drawImageOrLabel)(context, transform, opacity, imageOrLabel, originX, originY, w, h, x, y, scale);
    }
  };
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */


  Executor.prototype.fill_ = function (context) {
    if (this.alignFill_) {
      var origin_1 = (0, _transform2.apply)(this.renderedTransform_, [0, 0]);
      var repeatSize = 512 * this.pixelRatio;
      context.save();
      context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);
      context.rotate(this.viewRotation_);
    }

    context.fill();

    if (this.alignFill_) {
      context.restore();
    }
  };
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */


  Executor.prototype.setStrokeStyle_ = function (context, instruction) {
    context.strokeStyle =
    /** @type {import("../../colorlike.js").ColorLike} */
    instruction[1];
    context.lineWidth =
    /** @type {number} */
    instruction[2];
    context.lineCap =
    /** @type {CanvasLineCap} */
    instruction[3];
    context.lineJoin =
    /** @type {CanvasLineJoin} */
    instruction[4];
    context.miterLimit =
    /** @type {number} */
    instruction[5];

    if (context.setLineDash) {
      context.lineDashOffset =
      /** @type {number} */
      instruction[7];
      context.setLineDash(
      /** @type {Array<number>} */
      instruction[6]);
    }
  };
  /**
   * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} opacity Layer opacity.
   * @param {?} declutterTree Declutter tree.
   * @return {?} Declutter tree.
   */


  Executor.prototype.renderDeclutter = function (declutterGroup, feature, opacity, declutterTree) {
    if (declutterGroup && declutterGroup.length > 5) {
      var groupCount = declutterGroup[4];

      if (groupCount == 1 || groupCount == declutterGroup.length - 5) {
        /** @type {import("../../structs/RBush.js").Entry} */
        var box = {
          minX:
          /** @type {number} */
          declutterGroup[0],
          minY:
          /** @type {number} */
          declutterGroup[1],
          maxX:
          /** @type {number} */
          declutterGroup[2],
          maxY:
          /** @type {number} */
          declutterGroup[3],
          value: feature
        };

        if (!declutterTree) {
          declutterTree = new _rbush.default(9);
        }

        if (!declutterTree.collides(box)) {
          declutterTree.insert(box);

          for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {
            var declutterData =
            /** @type {Array} */
            declutterGroup[j];
            var context = declutterData[0];
            var currentAlpha = context.globalAlpha;

            if (currentAlpha !== opacity) {
              context.globalAlpha = opacity;
            }

            if (declutterData.length > 11) {
              this.replayTextBackground_(declutterData[0], declutterData[13], declutterData[14], declutterData[15], declutterData[16], declutterData[11], declutterData[12]);
            }

            _canvas.drawImageOrLabel.apply(undefined, declutterData);

            if (currentAlpha !== opacity) {
              context.globalAlpha = currentAlpha;
            }
          }
        }

        declutterGroup.length = 5;
        (0, _extent.createOrUpdateEmpty)(declutterGroup);
      }
    }

    return declutterTree;
  };
  /**
   * @private
   * @param {string} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */


  Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {
    var textState = this.textStates[textKey];
    var label = this.createLabel(text, textKey, fillKey, strokeKey);
    var strokeState = this.strokeStates[strokeKey];
    var pixelRatio = this.pixelRatio;
    var align = _TextBuilder.TEXT_ALIGN[textState.textAlign || _canvas.defaultTextAlign];
    var baseline = _TextBuilder.TEXT_ALIGN[textState.textBaseline || _canvas.defaultTextBaseline];
    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0; // Remove the 2 pixels we added in createLabel() for the anchor

    var width = label.width / pixelRatio - 2 * textState.scale;
    var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
    return {
      label: label,
      anchorX: anchorX,
      anchorY: anchorY
    };
  };
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {function(import("../../Feature.js").FeatureLike): T|undefined} featureCallback Feature callback.
   * @param {import("../../extent.js").Extent=} opt_hitExtent Only check features that intersect this
   *     extent.
   * @return {T|undefined} Callback result.
   * @template T
   */


  Executor.prototype.execute_ = function (context, transform, instructions, snapToPixel, featureCallback, opt_hitExtent) {
    this.declutterItems.length = 0;
    /** @type {Array<number>} */

    var pixelCoordinates;

    if (this.pixelCoordinates_ && (0, _array.equals)(transform, this.renderedTransform_)) {
      pixelCoordinates = this.pixelCoordinates_;
    } else {
      if (!this.pixelCoordinates_) {
        this.pixelCoordinates_ = [];
      }

      pixelCoordinates = (0, _transform.transform2D)(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);
      (0, _transform2.setFromArray)(this.renderedTransform_, transform);
    }

    var i = 0; // instruction index

    var ii = instructions.length; // end of instructions

    var d = 0; // data index

    var dd; // end of per-instruction data

    var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, declutterGroups, image, text, textKey;
    var strokeKey, fillKey;
    var pendingFill = 0;
    var pendingStroke = 0;
    var lastFillInstruction = null;
    var lastStrokeInstruction = null;
    var coordinateCache = this.coordinateCache_;
    var viewRotation = this.viewRotation_;
    var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;
    var state =
    /** @type {import("../../render.js").State} */
    {
      context: context,
      pixelRatio: this.pixelRatio,
      resolution: this.resolution,
      rotation: viewRotation
    }; // When the batch size gets too big, performance decreases. 200 is a good
    // balance between batch size and number of fill/stroke instructions.

    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
    var
    /** @type {import("../../Feature.js").FeatureLike} */
    feature;
    var x, y;

    while (i < ii) {
      var instruction = instructions[i];
      var type =
      /** @type {CanvasInstruction} */
      instruction[0];

      switch (type) {
        case _Instruction.default.BEGIN_GEOMETRY:
          feature =
          /** @type {import("../../Feature.js").FeatureLike} */
          instruction[1];

          if (!feature.getGeometry()) {
            i =
            /** @type {number} */
            instruction[2];
          } else if (opt_hitExtent !== undefined && !(0, _extent.intersects)(opt_hitExtent, instruction[3])) {
            i =
            /** @type {number} */
            instruction[2] + 1;
          } else {
            ++i;
          }

          break;

        case _Instruction.default.BEGIN_PATH:
          if (pendingFill > batchSize) {
            this.fill_(context);
            pendingFill = 0;
          }

          if (pendingStroke > batchSize) {
            context.stroke();
            pendingStroke = 0;
          }

          if (!pendingFill && !pendingStroke) {
            context.beginPath();
            prevX = NaN;
            prevY = NaN;
          }

          ++i;
          break;

        case _Instruction.default.CIRCLE:
          d =
          /** @type {number} */
          instruction[1];
          var x1 = pixelCoordinates[d];
          var y1 = pixelCoordinates[d + 1];
          var x2 = pixelCoordinates[d + 2];
          var y2 = pixelCoordinates[d + 3];
          var dx = x2 - x1;
          var dy = y2 - y1;
          var r = Math.sqrt(dx * dx + dy * dy);
          context.moveTo(x1 + r, y1);
          context.arc(x1, y1, r, 0, 2 * Math.PI, true);
          ++i;
          break;

        case _Instruction.default.CLOSE_PATH:
          context.closePath();
          ++i;
          break;

        case _Instruction.default.CUSTOM:
          d =
          /** @type {number} */
          instruction[1];
          dd = instruction[2];
          var geometry =
          /** @type {import("../../geom/SimpleGeometry.js").default} */
          instruction[3];
          var renderer = instruction[4];
          var fn = instruction.length == 6 ? instruction[5] : undefined;
          state.geometry = geometry;
          state.feature = feature;

          if (!(i in coordinateCache)) {
            coordinateCache[i] = [];
          }

          var coords = coordinateCache[i];

          if (fn) {
            fn(pixelCoordinates, d, dd, 2, coords);
          } else {
            coords[0] = pixelCoordinates[d];
            coords[1] = pixelCoordinates[d + 1];
            coords.length = 2;
          }

          renderer(coords, state);
          ++i;
          break;

        case _Instruction.default.DRAW_IMAGE:
          d =
          /** @type {number} */
          instruction[1];
          dd =
          /** @type {number} */
          instruction[2];
          image =
          /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
          instruction[3]; // Remaining arguments in DRAW_IMAGE are in alphabetical order

          anchorX =
          /** @type {number} */
          instruction[4];
          anchorY =
          /** @type {number} */
          instruction[5];
          declutterGroups = featureCallback ? null : instruction[6];
          var height =
          /** @type {number} */
          instruction[7];
          var opacity =
          /** @type {number} */
          instruction[8];
          var originX =
          /** @type {number} */
          instruction[9];
          var originY =
          /** @type {number} */
          instruction[10];
          var rotateWithView =
          /** @type {boolean} */
          instruction[11];
          var rotation =
          /** @type {number} */
          instruction[12];
          var scale =
          /** @type {number} */
          instruction[13];
          var width =
          /** @type {number} */
          instruction[14];

          if (!image && instruction.length >= 19) {
            // create label images
            text =
            /** @type {string} */
            instruction[18];
            textKey =
            /** @type {string} */
            instruction[19];
            strokeKey =
            /** @type {string} */
            instruction[20];
            fillKey =
            /** @type {string} */
            instruction[21];
            var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
            image = labelWithAnchor.label;
            instruction[3] = image;
            var textOffsetX =
            /** @type {number} */
            instruction[22];
            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
            instruction[4] = anchorX;
            var textOffsetY =
            /** @type {number} */
            instruction[23];
            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
            instruction[5] = anchorY;
            height = image.height;
            instruction[7] = height;
            width = image.width;
            instruction[14] = width;
          }

          var geometryWidths = void 0;

          if (instruction.length > 24) {
            geometryWidths =
            /** @type {number} */
            instruction[24];
          }

          var padding = void 0,
              backgroundFill = void 0,
              backgroundStroke = void 0;

          if (instruction.length > 16) {
            padding =
            /** @type {Array<number>} */
            instruction[15];
            backgroundFill =
            /** @type {boolean} */
            instruction[16];
            backgroundStroke =
            /** @type {boolean} */
            instruction[17];
          } else {
            padding = _canvas.defaultPadding;
            backgroundFill = false;
            backgroundStroke = false;
          }

          if (rotateWithView && viewRotationFromTransform) {
            // Canvas is expected to be rotated to reverse view rotation.
            rotation += viewRotation;
          } else if (!rotateWithView && !viewRotationFromTransform) {
            // Canvas is not rotated, images need to be rotated back to be north-up.
            rotation -= viewRotation;
          }

          var widthIndex = 0;
          var declutterGroupIndex = 0;

          for (; d < dd; d += 2) {
            if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
              continue;
            }

            if (declutterGroups) {
              var index = Math.floor(declutterGroupIndex);

              if (declutterGroups.length < index + 1) {
                declutterGroup = (0, _extent.createEmpty)();
                declutterGroup.push(declutterGroups[0][4]);
                declutterGroups.push(declutterGroup);
              }

              declutterGroup = declutterGroups[index];
            }

            this.replayImageOrLabel_(context, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill ?
            /** @type {Array<*>} */
            lastFillInstruction : null, backgroundStroke ?
            /** @type {Array<*>} */
            lastStrokeInstruction : null);

            if (declutterGroup) {
              if (declutterGroupIndex === Math.floor(declutterGroupIndex)) {
                this.declutterItems.push(this, declutterGroup, feature);
              }

              declutterGroupIndex += 1 / declutterGroup[4];
            }
          }

          ++i;
          break;

        case _Instruction.default.DRAW_CHARS:
          var begin =
          /** @type {number} */
          instruction[1];
          var end =
          /** @type {number} */
          instruction[2];
          var baseline =
          /** @type {number} */
          instruction[3];
          declutterGroup = featureCallback ? null : instruction[4];
          var overflow =
          /** @type {number} */
          instruction[5];
          fillKey =
          /** @type {string} */
          instruction[6];
          var maxAngle =
          /** @type {number} */
          instruction[7];
          var measurePixelRatio =
          /** @type {number} */
          instruction[8];
          var offsetY =
          /** @type {number} */
          instruction[9];
          strokeKey =
          /** @type {string} */
          instruction[10];
          var strokeWidth =
          /** @type {number} */
          instruction[11];
          text =
          /** @type {string} */
          instruction[12];
          textKey =
          /** @type {string} */
          instruction[13];
          var pixelRatioScale =
          /** @type {number} */
          instruction[14];
          var textState = this.textStates[textKey];
          var font = textState.font;
          var textScale = textState.scale * measurePixelRatio;
          var cachedWidths = void 0;

          if (font in this.widths_) {
            cachedWidths = this.widths_[font];
          } else {
            cachedWidths = {};
            this.widths_[font] = cachedWidths;
          }

          var pathLength = (0, _length.lineStringLength)(pixelCoordinates, begin, end, 2);
          var textLength = textScale * (0, _canvas.measureAndCacheTextWidth)(font, text, cachedWidths);

          if (overflow || textLength <= pathLength) {
            var textAlign = this.textStates[textKey].textAlign;
            var startM = (pathLength - textLength) * _TextBuilder.TEXT_ALIGN[textAlign];
            var parts = (0, _textpath.drawTextOnPath)(pixelCoordinates, begin, end, 2, text, startM, maxAngle, textScale, _canvas.measureAndCacheTextWidth, font, cachedWidths);

            if (parts) {
              var c = void 0,
                  cc = void 0,
                  chars = void 0,
                  label = void 0,
                  part = void 0;

              if (strokeKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c]; // x, y, anchorX, rotation, chunk

                  chars =
                  /** @type {string} */
                  part[4];
                  label = this.createLabel(chars, textKey, '', strokeKey);
                  anchorX =
                  /** @type {number} */
                  part[2] + strokeWidth;
                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;
                  this.replayImageOrLabel_(context,
                  /** @type {number} */
                  part[0],
                  /** @type {number} */
                  part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,
                  /** @type {number} */
                  part[3], pixelRatioScale, false, label.width, _canvas.defaultPadding, null, null);
                }
              }

              if (fillKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c]; // x, y, anchorX, rotation, chunk

                  chars =
                  /** @type {string} */
                  part[4];
                  label = this.createLabel(chars, textKey, fillKey, '');
                  anchorX =
                  /** @type {number} */
                  part[2];
                  anchorY = baseline * label.height - offsetY;
                  this.replayImageOrLabel_(context,
                  /** @type {number} */
                  part[0],
                  /** @type {number} */
                  part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,
                  /** @type {number} */
                  part[3], pixelRatioScale, false, label.width, _canvas.defaultPadding, null, null);
                }
              }
            }
          }

          this.declutterItems.push(this, declutterGroup, feature);
          ++i;
          break;

        case _Instruction.default.END_GEOMETRY:
          if (featureCallback !== undefined) {
            feature =
            /** @type {import("../../Feature.js").FeatureLike} */
            instruction[1];
            var result = featureCallback(feature);

            if (result) {
              return result;
            }
          }

          ++i;
          break;

        case _Instruction.default.FILL:
          if (batchSize) {
            pendingFill++;
          } else {
            this.fill_(context);
          }

          ++i;
          break;

        case _Instruction.default.MOVE_TO_LINE_TO:
          d =
          /** @type {number} */
          instruction[1];
          dd =
          /** @type {number} */
          instruction[2];
          x = pixelCoordinates[d];
          y = pixelCoordinates[d + 1];
          roundX = x + 0.5 | 0;
          roundY = y + 0.5 | 0;

          if (roundX !== prevX || roundY !== prevY) {
            context.moveTo(x, y);
            prevX = roundX;
            prevY = roundY;
          }

          for (d += 2; d < dd; d += 2) {
            x = pixelCoordinates[d];
            y = pixelCoordinates[d + 1];
            roundX = x + 0.5 | 0;
            roundY = y + 0.5 | 0;

            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
              context.lineTo(x, y);
              prevX = roundX;
              prevY = roundY;
            }
          }

          ++i;
          break;

        case _Instruction.default.SET_FILL_STYLE:
          lastFillInstruction = instruction;
          this.alignFill_ = instruction[2];

          if (pendingFill) {
            this.fill_(context);
            pendingFill = 0;

            if (pendingStroke) {
              context.stroke();
              pendingStroke = 0;
            }
          }

          context.fillStyle =
          /** @type {import("../../colorlike.js").ColorLike} */
          instruction[1];
          ++i;
          break;

        case _Instruction.default.SET_STROKE_STYLE:
          lastStrokeInstruction = instruction;

          if (pendingStroke) {
            context.stroke();
            pendingStroke = 0;
          }

          this.setStrokeStyle_(context,
          /** @type {Array<*>} */
          instruction);
          ++i;
          break;

        case _Instruction.default.STROKE:
          if (batchSize) {
            pendingStroke++;
          } else {
            context.stroke();
          }

          ++i;
          break;

        default:
          ++i; // consume the instruction anyway, to avoid an infinite loop

          break;
      }
    }

    if (pendingFill) {
      this.fill_(context);
    }

    if (pendingStroke) {
      context.stroke();
    }

    return undefined;
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   */


  Executor.prototype.execute = function (context, transform, viewRotation, snapToPixel) {
    this.viewRotation_ = viewRotation;
    this.execute_(context, transform, this.instructions, snapToPixel, undefined, undefined);
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {function(import("../../Feature.js").FeatureLike): T=} opt_featureCallback
   *     Feature callback.
   * @param {import("../../extent.js").Extent=} opt_hitExtent Only check features that intersect this
   *     extent.
   * @return {T|undefined} Callback result.
   * @template T
   */


  Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {
    this.viewRotation_ = viewRotation;
    return this.execute_(context, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);
  };

  return Executor;
}();

var _default = Executor;
exports.default = _default;
},{"../../array.js":"node_modules/ol/array.js","../../extent.js":"node_modules/ol/extent.js","../../geom/flat/length.js":"node_modules/ol/geom/flat/length.js","../../geom/flat/textpath.js":"node_modules/ol/geom/flat/textpath.js","../../geom/flat/transform.js":"node_modules/ol/geom/flat/transform.js","../canvas.js":"node_modules/ol/render/canvas.js","./Instruction.js":"node_modules/ol/render/canvas/Instruction.js","./TextBuilder.js":"node_modules/ol/render/canvas/TextBuilder.js","../../transform.js":"node_modules/ol/transform.js","rbush/rbush.js":"node_modules/rbush/rbush.js","../../has.js":"node_modules/ol/has.js"}],"node_modules/ol/render/canvas/ExecutorGroup.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCircleArray = getCircleArray;
exports.replayDeclutter = replayDeclutter;
exports.default = void 0;

var _array = require("../../array.js");

var _dom = require("../../dom.js");

var _extent = require("../../extent.js");

var _transform = require("../../geom/flat/transform.js");

var _obj = require("../../obj.js");

var _BuilderType = _interopRequireDefault(require("./BuilderType.js"));

var _transform2 = require("../../transform.js");

var _Executor = _interopRequireDefault(require("./Executor.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render/canvas/ExecutorGroup
 */

/**
 * @const
 * @type {Array<BuilderType>}
 */
var ORDER = [_BuilderType.default.POLYGON, _BuilderType.default.CIRCLE, _BuilderType.default.LINE_STRING, _BuilderType.default.IMAGE, _BuilderType.default.TEXT, _BuilderType.default.DEFAULT];

var ExecutorGroup =
/** @class */
function () {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Buillder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceet that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<BuilderType, import("./Builder.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number=} opt_renderBuffer Optional rendering buffer.
   */
  function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.maxExtent_ = maxExtent;
    /**
     * @private
     * @type {boolean}
     */

    this.overlaps_ = overlaps;
    /**
     * @private
     * @type {number}
     */

    this.pixelRatio_ = pixelRatio;
    /**
     * @private
     * @type {number}
     */

    this.resolution_ = resolution;
    /**
     * @private
     * @type {number|undefined}
     */

    this.renderBuffer_ = opt_renderBuffer;
    /**
     * @private
     * @type {!Object<string, !Object<BuilderType, import("./Executor").default>>}
     */

    this.executorsByZIndex_ = {};
    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */

    this.hitDetectionContext_ = null;
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    this.hitDetectionTransform_ = (0, _transform2.create)();
    this.createExecutors_(allInstructions);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */


  ExecutorGroup.prototype.clip = function (context, transform) {
    var flatClipCoords = this.getClipCoords(transform);
    context.beginPath();
    context.moveTo(flatClipCoords[0], flatClipCoords[1]);
    context.lineTo(flatClipCoords[2], flatClipCoords[3]);
    context.lineTo(flatClipCoords[4], flatClipCoords[5]);
    context.lineTo(flatClipCoords[6], flatClipCoords[7]);
    context.clip();
  };
  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<BuilderType, import("./Builder.js").SerializableInstructions>>} allInstructions The serializable instructions
   */


  ExecutorGroup.prototype.createExecutors_ = function (allInstructions) {
    for (var zIndex in allInstructions) {
      var executors = this.executorsByZIndex_[zIndex];

      if (executors === undefined) {
        executors = {};
        this.executorsByZIndex_[zIndex] = executors;
      }

      var instructionByZindex = allInstructions[zIndex];

      for (var builderType in instructionByZindex) {
        var instructions = instructionByZindex[builderType];
        executors[builderType] = new _Executor.default(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);
      }
    }
  };
  /**
   * @param {Array<BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */


  ExecutorGroup.prototype.hasExecutors = function (executors) {
    for (var zIndex in this.executorsByZIndex_) {
      var candidates = this.executorsByZIndex_[zIndex];

      for (var i = 0, ii = executors.length; i < ii; ++i) {
        if (executors[i] in candidates) {
          return true;
        }
      }
    }

    return false;
  };
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */


  ExecutorGroup.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
    hitTolerance = Math.round(hitTolerance);
    var contextSize = hitTolerance * 2 + 1;
    var transform = (0, _transform2.compose)(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);

    if (!this.hitDetectionContext_) {
      this.hitDetectionContext_ = (0, _dom.createCanvasContext2D)(contextSize, contextSize);
    }

    var context = this.hitDetectionContext_;

    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
      context.canvas.width = contextSize;
      context.canvas.height = contextSize;
    } else {
      context.clearRect(0, 0, contextSize, contextSize);
    }
    /**
     * @type {import("../../extent.js").Extent}
     */


    var hitExtent;

    if (this.renderBuffer_ !== undefined) {
      hitExtent = (0, _extent.createEmpty)();
      (0, _extent.extendCoordinate)(hitExtent, coordinate);
      (0, _extent.buffer)(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
    }

    var mask = getCircleArray(hitTolerance);
    var builderType;
    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @return {?} Callback result.
     */

    function featureCallback(feature) {
      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;

      for (var i_1 = 0; i_1 < contextSize; i_1++) {
        for (var j_1 = 0; j_1 < contextSize; j_1++) {
          if (mask[i_1][j_1]) {
            if (imageData[(j_1 * contextSize + i_1) * 4 + 3] > 0) {
              var result_1 = void 0;

              if (!(declutteredFeatures && (builderType == _BuilderType.default.IMAGE || builderType == _BuilderType.default.TEXT)) || declutteredFeatures.indexOf(feature) !== -1) {
                result_1 = callback(feature);
              }

              if (result_1) {
                return result_1;
              } else {
                context.clearRect(0, 0, contextSize, contextSize);
                return undefined;
              }
            }
          }
        }
      }
    }
    /** @type {Array<number>} */


    var zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(_array.numberSafeCompareFunction);
    var i, j, executors, executor, result;

    for (i = zs.length - 1; i >= 0; --i) {
      var zIndexKey = zs[i].toString();
      executors = this.executorsByZIndex_[zIndexKey];

      for (j = ORDER.length - 1; j >= 0; --j) {
        builderType = ORDER[j];
        executor = executors[builderType];

        if (executor !== undefined) {
          result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);

          if (result) {
            return result;
          }
        }
      }
    }

    return undefined;
  };
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>} Clip coordinates.
   */


  ExecutorGroup.prototype.getClipCoords = function (transform) {
    var maxExtent = this.maxExtent_;

    if (!maxExtent) {
      return null;
    }

    var minX = maxExtent[0];
    var minY = maxExtent[1];
    var maxX = maxExtent[2];
    var maxY = maxExtent[3];
    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
    (0, _transform.transform2D)(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
    return flatClipCoords;
  };
  /**
   * @return {boolean} Is empty.
   */


  ExecutorGroup.prototype.isEmpty = function () {
    return (0, _obj.isEmpty)(this.executorsByZIndex_);
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<BuilderType>=} opt_builderTypes Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ORDER}
   * @param {Object<string, import("../canvas.js").DeclutterGroup>=} opt_declutterReplays Declutter replays.
   */


  ExecutorGroup.prototype.execute = function (context, transform, viewRotation, snapToPixel, opt_builderTypes, opt_declutterReplays) {
    /** @type {Array<number>} */
    var zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(_array.numberSafeCompareFunction); // setup clipping so that the parts of over-simplified geometries are not
    // visible outside the current extent when panning

    if (this.maxExtent_) {
      context.save();
      this.clip(context, transform);
    }

    var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;
    var i, ii, j, jj, replays, replay;

    for (i = 0, ii = zs.length; i < ii; ++i) {
      var zIndexKey = zs[i].toString();
      replays = this.executorsByZIndex_[zIndexKey];

      for (j = 0, jj = builderTypes.length; j < jj; ++j) {
        var builderType = builderTypes[j];
        replay = replays[builderType];

        if (replay !== undefined) {
          if (opt_declutterReplays && (builderType == _BuilderType.default.IMAGE || builderType == _BuilderType.default.TEXT)) {
            var declutter = opt_declutterReplays[zIndexKey];

            if (!declutter) {
              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];
            } else {
              declutter.push(replay, transform.slice(0));
            }
          } else {
            replay.execute(context, transform, viewRotation, snapToPixel);
          }
        }
      }
    }

    if (this.maxExtent_) {
      context.restore();
    }
  };

  return ExecutorGroup;
}();
/**
 * This cache is used for storing calculated pixel circles for increasing performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object<number, Array<Array<(boolean|undefined)>>>}
 */


var circleArrayCache = {
  0: [[true]]
};
/**
 * This method fills a row in the array from the given coordinate to the
 * middle with `true`.
 * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 */

function fillCircleArrayRowToMiddle(array, x, y) {
  var i;
  var radius = Math.floor(array.length / 2);

  if (x >= radius) {
    for (i = radius; i < x; i++) {
      array[i][y] = true;
    }
  } else if (x < radius) {
    for (i = x + 1; i < radius; i++) {
      array[i][y] = true;
    }
  }
}
/**
 * This methods creates a circle inside a fitting array. Points inside the
 * circle are marked by true, points on the outside are undefined.
 * It uses the midpoint circle algorithm.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.
 */


function getCircleArray(radius) {
  if (circleArrayCache[radius] !== undefined) {
    return circleArrayCache[radius];
  }

  var arraySize = radius * 2 + 1;
  var arr = new Array(arraySize);

  for (var i = 0; i < arraySize; i++) {
    arr[i] = new Array(arraySize);
  }

  var x = radius;
  var y = 0;
  var error = 0;

  while (x >= y) {
    fillCircleArrayRowToMiddle(arr, radius + x, radius + y);
    fillCircleArrayRowToMiddle(arr, radius + y, radius + x);
    fillCircleArrayRowToMiddle(arr, radius - y, radius + x);
    fillCircleArrayRowToMiddle(arr, radius - x, radius + y);
    fillCircleArrayRowToMiddle(arr, radius - x, radius - y);
    fillCircleArrayRowToMiddle(arr, radius - y, radius - x);
    fillCircleArrayRowToMiddle(arr, radius + y, radius - x);
    fillCircleArrayRowToMiddle(arr, radius + x, radius - y);
    y++;
    error += 1 + 2 * y;

    if (2 * (error - x) + 1 > 0) {
      x -= 1;
      error += 1 - 2 * x;
    }
  }

  circleArrayCache[radius] = arr;
  return arr;
}
/**
 * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} opacity Opacity.
 * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
 * @param {Array<import("../../PluggableMap.js").DeclutterItems>} declutterItems Declutter items.
 */


function replayDeclutter(declutterReplays, context, rotation, opacity, snapToPixel, declutterItems) {
  var zs = Object.keys(declutterReplays).map(Number).sort(_array.numberSafeCompareFunction);

  for (var z = 0, zz = zs.length; z < zz; ++z) {
    var executorData = declutterReplays[zs[z].toString()];
    var currentExecutor = void 0;

    for (var i = 0, ii = executorData.length; i < ii;) {
      var executor = executorData[i++];

      if (executor !== currentExecutor) {
        currentExecutor = executor;
        declutterItems.push({
          items: executor.declutterItems,
          opacity: opacity
        });
      }

      var transform = executorData[i++];
      executor.execute(context, transform, rotation, snapToPixel);
    }
  }
}

var _default = ExecutorGroup;
exports.default = _default;
},{"../../array.js":"node_modules/ol/array.js","../../dom.js":"node_modules/ol/dom.js","../../extent.js":"node_modules/ol/extent.js","../../geom/flat/transform.js":"node_modules/ol/geom/flat/transform.js","../../obj.js":"node_modules/ol/obj.js","./BuilderType.js":"node_modules/ol/render/canvas/BuilderType.js","../../transform.js":"node_modules/ol/transform.js","./Executor.js":"node_modules/ol/render/canvas/Executor.js"}],"node_modules/ol/renderer/Layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("../util.js");

var _ImageState = _interopRequireDefault(require("../ImageState.js"));

var _Observable = _interopRequireDefault(require("../Observable.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _State = _interopRequireDefault(require("../source/State.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/Layer
 */


/**
 * @template {import("../layer/Layer.js").default} LayerType
 */
var LayerRenderer =
/** @class */
function (_super) {
  __extends(LayerRenderer, _super);
  /**
   * @param {LayerType} layer Layer.
   */


  function LayerRenderer(layer) {
    var _this = _super.call(this) || this;
    /** @private */


    _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);
    /**
     * @private
     * @type {LayerType}
     */

    _this.layer_ = layer;
    return _this;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
   * an array of features.
   */


  LayerRenderer.prototype.getFeatures = function (pixel) {
    return (0, _util.abstract)();
  };
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */


  LayerRenderer.prototype.prepareFrame = function (frameState) {
    return (0, _util.abstract)();
  };
  /**
   * Render the layer.
   * @abstract
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */


  LayerRenderer.prototype.renderFrame = function (frameState, target) {
    return (0, _util.abstract)();
  };
  /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   */


  LayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {
    if (!tiles[zoom]) {
      tiles[zoom] = {};
    }

    tiles[zoom][tile.tileCoord.toString()] = tile;
  };
  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */


  LayerRenderer.prototype.createLoadedTileFinder = function (source, projection, tiles) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       * @this {LayerRenderer}
       */
      function (zoom, tileRange) {
        var callback = this.loadedTileCallback.bind(this, tiles, zoom);
        return source.forEachLoadedTile(projection, zoom, tileRange, callback);
      }.bind(this)
    );
  };
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default): T} callback Feature callback.
   * @param {Array<import("../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|void} Callback result.
   * @template T
   */


  LayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, declutteredFeatures) {};
  /**
   * @abstract
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
   *    location, null will be returned.  If there is data, but pixel values cannot be
   *    returned, and empty array will be returned.
   */


  LayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {
    return (0, _util.abstract)();
  };
  /**
   * @return {LayerType} Layer.
   */


  LayerRenderer.prototype.getLayer = function () {
    return this.layer_;
  };
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */


  LayerRenderer.prototype.handleFontsChanged = function () {};
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */


  LayerRenderer.prototype.handleImageChange_ = function (event) {
    var image =
    /** @type {import("../Image.js").default} */
    event.target;

    if (image.getState() === _ImageState.default.LOADED) {
      this.renderIfReadyAndVisible();
    }
  };
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../ImageBase.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */


  LayerRenderer.prototype.loadImage = function (image) {
    var imageState = image.getState();

    if (imageState != _ImageState.default.LOADED && imageState != _ImageState.default.ERROR) {
      image.addEventListener(_EventType.default.CHANGE, this.boundHandleImageChange_);
    }

    if (imageState == _ImageState.default.IDLE) {
      image.load();
      imageState = image.getState();
    }

    return imageState == _ImageState.default.LOADED;
  };
  /**
   * @protected
   */


  LayerRenderer.prototype.renderIfReadyAndVisible = function () {
    var layer = this.getLayer();

    if (layer.getVisible() && layer.getSourceState() == _State.default.READY) {
      layer.changed();
    }
  };

  return LayerRenderer;
}(_Observable.default);

var _default = LayerRenderer;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","../ImageState.js":"node_modules/ol/ImageState.js","../Observable.js":"node_modules/ol/Observable.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../source/State.js":"node_modules/ol/source/State.js"}],"node_modules/ol/renderer/canvas/Layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extent = require("../../extent.js");

var _dom = require("../../dom.js");

var _Event = _interopRequireDefault(require("../../render/Event.js"));

var _EventType = _interopRequireDefault(require("../../render/EventType.js"));

var _canvas = require("../../render/canvas.js");

var _Layer = _interopRequireDefault(require("../Layer.js"));

var _transform = require("../../transform.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/canvas/Layer
 */


/**
 * @abstract
 * @template {import("../../layer/Layer.js").default} LayerType
 */
var CanvasLayerRenderer =
/** @class */
function (_super) {
  __extends(CanvasLayerRenderer, _super);
  /**
   * @param {LayerType} layer Layer.
   */


  function CanvasLayerRenderer(layer) {
    var _this = _super.call(this, layer) || this;
    /**
     * @protected
     * @type {HTMLElement}
     */


    _this.container = null;
    /**
     * @protected
     * @type {number}
     */

    _this.renderedResolution;
    /**
     * A temporary transform.  The values in this transform should only be used in a
     * function that sets the values.
     * @private
     * @type {import("../../transform.js").Transform}
     */

    _this.tempTransform_ = (0, _transform.create)();
    /**
     * The transform for rendered pixels to viewport CSS pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */

    _this.pixelTransform = (0, _transform.create)();
    /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */

    _this.inversePixelTransform = (0, _transform.create)();
    /**
     * @protected
     * @type {CanvasRenderingContext2D}
     */

    _this.context = null;
    /**
     * @type {boolean}
     */

    _this.containerReused = false;
    return _this;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {number} opacity Opacity.
   */


  CanvasLayerRenderer.prototype.useContainer = function (target, transform, opacity) {
    var layerClassName = this.getLayer().getClassName();
    var container, context;

    if (target && target.style.opacity === '' && target.className === layerClassName) {
      var canvas = target.firstElementChild;

      if (canvas instanceof HTMLCanvasElement) {
        context = canvas.getContext('2d');
      }
    }

    if (context && context.canvas.style.transform === transform) {
      // Container of the previous layer renderer can be used.
      this.container = target;
      this.context = context;
      this.containerReused = true;
    } else if (this.containerReused) {
      // Previously reused container cannot be used any more.
      this.container = null;
      this.context = null;
      this.containerReused = false;
    }

    if (!this.container) {
      container = document.createElement('div');
      container.className = layerClassName;
      var style = container.style;
      style.position = 'absolute';
      style.width = '100%';
      style.height = '100%';
      context = (0, _dom.createCanvasContext2D)();
      var canvas = context.canvas;
      container.appendChild(canvas);
      style = canvas.style;
      style.position = 'absolute';
      style.left = '0';
      style.transformOrigin = 'top left';
      this.container = container;
      this.context = context;
    }
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */


  CanvasLayerRenderer.prototype.clip = function (context, frameState, extent) {
    var pixelRatio = frameState.pixelRatio;
    var halfWidth = frameState.size[0] * pixelRatio / 2;
    var halfHeight = frameState.size[1] * pixelRatio / 2;
    var rotation = frameState.viewState.rotation;
    var topLeft = (0, _extent.getTopLeft)(extent);
    var topRight = (0, _extent.getTopRight)(extent);
    var bottomRight = (0, _extent.getBottomRight)(extent);
    var bottomLeft = (0, _extent.getBottomLeft)(extent);
    (0, _transform.apply)(frameState.coordinateToPixelTransform, topLeft);
    (0, _transform.apply)(frameState.coordinateToPixelTransform, topRight);
    (0, _transform.apply)(frameState.coordinateToPixelTransform, bottomRight);
    (0, _transform.apply)(frameState.coordinateToPixelTransform, bottomLeft);
    context.save();
    (0, _canvas.rotateAtOffset)(context, -rotation, halfWidth, halfHeight);
    context.beginPath();
    context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);
    context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);
    context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);
    context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);
    context.clip();
    (0, _canvas.rotateAtOffset)(context, rotation, halfWidth, halfHeight);
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */


  CanvasLayerRenderer.prototype.clipUnrotated = function (context, frameState, extent) {
    var topLeft = (0, _extent.getTopLeft)(extent);
    var topRight = (0, _extent.getTopRight)(extent);
    var bottomRight = (0, _extent.getBottomRight)(extent);
    var bottomLeft = (0, _extent.getBottomLeft)(extent);
    (0, _transform.apply)(frameState.coordinateToPixelTransform, topLeft);
    (0, _transform.apply)(frameState.coordinateToPixelTransform, topRight);
    (0, _transform.apply)(frameState.coordinateToPixelTransform, bottomRight);
    (0, _transform.apply)(frameState.coordinateToPixelTransform, bottomLeft);
    var inverted = this.inversePixelTransform;
    (0, _transform.apply)(inverted, topLeft);
    (0, _transform.apply)(inverted, topRight);
    (0, _transform.apply)(inverted, bottomRight);
    (0, _transform.apply)(inverted, bottomLeft);
    context.save();
    context.beginPath();
    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
    context.clip();
  };
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @private
   */


  CanvasLayerRenderer.prototype.dispatchRenderEvent_ = function (type, context, frameState) {
    var layer = this.getLayer();

    if (layer.hasListener(type)) {
      var event_1 = new _Event.default(type, this.inversePixelTransform, frameState, context);
      layer.dispatchEvent(event_1);
    }
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */


  CanvasLayerRenderer.prototype.preRender = function (context, frameState) {
    this.dispatchRenderEvent_(_EventType.default.PRERENDER, context, frameState);
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */


  CanvasLayerRenderer.prototype.postRender = function (context, frameState) {
    this.dispatchRenderEvent_(_EventType.default.POSTRENDER, context, frameState);
  };
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */


  CanvasLayerRenderer.prototype.getRenderTransform = function (center, resolution, rotation, pixelRatio, width, height, offsetX) {
    var dx1 = width / 2;
    var dy1 = height / 2;
    var sx = pixelRatio / resolution;
    var sy = -sx;
    var dx2 = -center[0] + offsetX;
    var dy2 = -center[1];
    return (0, _transform.compose)(this.tempTransform_, dx1, dy1, sx, sy, -rotation, dx2, dy2);
  };
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @param {import("../../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
   *    location, null will be returned.  If there is data, but pixel values cannot be
   *    returned, and empty array will be returned.
   */


  CanvasLayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {
    var renderPixel = (0, _transform.apply)(this.inversePixelTransform, pixel.slice());
    var context = this.context;
    var data;

    try {
      data = context.getImageData(Math.round(renderPixel[0]), Math.round(renderPixel[1]), 1, 1).data;
    } catch (err) {
      if (err.name === 'SecurityError') {
        // tainted canvas, we assume there is data at the given pixel (although there might not be)
        return new Uint8Array();
      }

      return data;
    }

    if (data[3] === 0) {
      return null;
    }

    return data;
  };

  return CanvasLayerRenderer;
}(_Layer.default);

var _default = CanvasLayerRenderer;
exports.default = _default;
},{"../../extent.js":"node_modules/ol/extent.js","../../dom.js":"node_modules/ol/dom.js","../../render/Event.js":"node_modules/ol/render/Event.js","../../render/EventType.js":"node_modules/ol/render/EventType.js","../../render/canvas.js":"node_modules/ol/render/canvas.js","../Layer.js":"node_modules/ol/renderer/Layer.js","../../transform.js":"node_modules/ol/transform.js"}],"node_modules/ol/style/IconAnchorUnits.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/style/IconAnchorUnits
 */

/**
 * Icon anchor units. One of 'fraction', 'pixels'.
 * @enum {string}
 */
var _default = {
  /**
   * Anchor is a fraction
   * @api
   */
  FRACTION: 'fraction',

  /**
   * Anchor is in pixels
   * @api
   */
  PIXELS: 'pixels'
};
exports.default = _default;
},{}],"node_modules/ol/ImageBase.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("./util.js");

var _Target = _interopRequireDefault(require("./events/Target.js"));

var _EventType = _interopRequireDefault(require("./events/EventType.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/ImageBase
 */


/**
 * @abstract
 */
var ImageBase =
/** @class */
function (_super) {
  __extends(ImageBase, _super);
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default} state State.
   */


  function ImageBase(extent, resolution, pixelRatio, state) {
    var _this = _super.call(this) || this;
    /**
     * @protected
     * @type {import("./extent.js").Extent}
     */


    _this.extent = extent;
    /**
     * @private
     * @type {number}
     */

    _this.pixelRatio_ = pixelRatio;
    /**
     * @protected
     * @type {number|undefined}
     */

    _this.resolution = resolution;
    /**
     * @protected
     * @type {import("./ImageState.js").default}
     */

    _this.state = state;
    return _this;
  }
  /**
   * @protected
   */


  ImageBase.prototype.changed = function () {
    this.dispatchEvent(_EventType.default.CHANGE);
  };
  /**
   * @return {import("./extent.js").Extent} Extent.
   */


  ImageBase.prototype.getExtent = function () {
    return this.extent;
  };
  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */


  ImageBase.prototype.getImage = function () {
    return (0, _util.abstract)();
  };
  /**
   * @return {number} PixelRatio.
   */


  ImageBase.prototype.getPixelRatio = function () {
    return this.pixelRatio_;
  };
  /**
   * @return {number} Resolution.
   */


  ImageBase.prototype.getResolution = function () {
    return (
      /** @type {number} */
      this.resolution
    );
  };
  /**
   * @return {import("./ImageState.js").default} State.
   */


  ImageBase.prototype.getState = function () {
    return this.state;
  };
  /**
   * Load not yet loaded URI.
   * @abstract
   */


  ImageBase.prototype.load = function () {
    (0, _util.abstract)();
  };

  return ImageBase;
}(_Target.default);

var _default = ImageBase;
exports.default = _default;
},{"./util.js":"node_modules/ol/util.js","./events/Target.js":"node_modules/ol/events/Target.js","./events/EventType.js":"node_modules/ol/events/EventType.js"}],"node_modules/ol/Image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.listenImage = listenImage;
exports.default = void 0;

var _ImageBase = _interopRequireDefault(require("./ImageBase.js"));

var _ImageState = _interopRequireDefault(require("./ImageState.js"));

var _events = require("./events.js");

var _EventType = _interopRequireDefault(require("./events/EventType.js"));

var _extent = require("./extent.js");

var _has = require("./has.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/Image
 */


/**
 * A function that takes an {@link module:ol/Image~Image} for the image and a
 * `{string}` for the src as arguments. It is supposed to make it so the
 * underlying image {@link module:ol/Image~Image#getImage} is assigned the
 * content specified by the src. If not specified, the default is
 *
 *     function(image, src) {
 *       image.getImage().src = src;
 *     }
 *
 * Providing a custom `imageLoadFunction` can be useful to load images with
 * post requests or - in general - through XHR requests, where the src of the
 * image element would be set to a data URI when the content is loaded.
 *
 * @typedef {function(ImageWrapper, string): void} LoadFunction
 * @api
 */
var ImageWrapper =
/** @class */
function (_super) {
  __extends(ImageWrapper, _super);
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {LoadFunction} imageLoadFunction Image load function.
   */


  function ImageWrapper(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
    var _this = _super.call(this, extent, resolution, pixelRatio, _ImageState.default.IDLE) || this;
    /**
     * @private
     * @type {string}
     */


    _this.src_ = src;
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
     */

    _this.image_ = new Image();

    if (crossOrigin !== null) {
      _this.image_.crossOrigin = crossOrigin;
    }
    /**
     * @private
     * @type {?function():void}
     */


    _this.unlisten_ = null;
    /**
     * @protected
     * @type {ImageState}
     */

    _this.state = _ImageState.default.IDLE;
    /**
     * @private
     * @type {LoadFunction}
     */

    _this.imageLoadFunction_ = imageLoadFunction;
    return _this;
  }
  /**
   * @inheritDoc
   * @api
   */


  ImageWrapper.prototype.getImage = function () {
    return this.image_;
  };
  /**
   * Tracks loading or read errors.
   *
   * @private
   */


  ImageWrapper.prototype.handleImageError_ = function () {
    this.state = _ImageState.default.ERROR;
    this.unlistenImage_();
    this.changed();
  };
  /**
   * Tracks successful image load.
   *
   * @private
   */


  ImageWrapper.prototype.handleImageLoad_ = function () {
    if (this.resolution === undefined) {
      this.resolution = (0, _extent.getHeight)(this.extent) / this.image_.height;
    }

    this.state = _ImageState.default.LOADED;
    this.unlistenImage_();
    this.changed();
  };
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @override
   * @api
   */


  ImageWrapper.prototype.load = function () {
    if (this.state == _ImageState.default.IDLE || this.state == _ImageState.default.ERROR) {
      this.state = _ImageState.default.LOADING;
      this.changed();
      this.imageLoadFunction_(this, this.src_);
      this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
    }
  };
  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   */


  ImageWrapper.prototype.setImage = function (image) {
    this.image_ = image;
  };
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */


  ImageWrapper.prototype.unlistenImage_ = function () {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  };

  return ImageWrapper;
}(_ImageBase.default);
/**
 * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image element.
 * @param {function():any} loadHandler Load callback function.
 * @param {function():any} errorHandler Error callback function.
 * @return {function():void} Callback to stop listening.
 */


function listenImage(image, loadHandler, errorHandler) {
  var img =
  /** @type {HTMLImageElement} */
  image;

  if (img.src && _has.IMAGE_DECODE) {
    var promise = img.decode();
    var listening_1 = true;

    var unlisten = function () {
      listening_1 = false;
    };

    promise.then(function () {
      if (listening_1) {
        loadHandler();
      }
    }).catch(function (error) {
      if (listening_1) {
        // FIXME: Unconditionally call errorHandler() when this bug is fixed upstream:
        //        https://bugs.webkit.org/show_bug.cgi?id=198527
        if (error.name === 'EncodingError' && error.message === 'Invalid image type.') {
          loadHandler();
        } else {
          errorHandler();
        }
      }
    });
    return unlisten;
  }

  var listenerKeys = [(0, _events.listenOnce)(img, _EventType.default.LOAD, loadHandler), (0, _events.listenOnce)(img, _EventType.default.ERROR, errorHandler)];
  return function unlisten() {
    listenerKeys.forEach(_events.unlistenByKey);
  };
}

var _default = ImageWrapper;
exports.default = _default;
},{"./ImageBase.js":"node_modules/ol/ImageBase.js","./ImageState.js":"node_modules/ol/ImageState.js","./events.js":"node_modules/ol/events.js","./events/EventType.js":"node_modules/ol/events/EventType.js","./extent.js":"node_modules/ol/extent.js","./has.js":"node_modules/ol/has.js"}],"node_modules/ol/style/IconImage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.get = get;
exports.default = void 0;

var _dom = require("../dom.js");

var _Target = _interopRequireDefault(require("../events/Target.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _ImageState = _interopRequireDefault(require("../ImageState.js"));

var _IconImageCache = require("./IconImageCache.js");

var _Image = require("../Image.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/style/IconImage
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var IconImage =
/** @class */
function (_super) {
  __extends(IconImage, _super);
  /**
   * @param {HTMLImageElement|HTMLCanvasElement} image Image.
   * @param {string|undefined} src Src.
   * @param {import("../size.js").Size} size Size.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default} imageState Image state.
   * @param {import("../color.js").Color} color Color.
   */


  function IconImage(image, src, size, crossOrigin, imageState, color) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */


    _this.hitDetectionImage_ = null;
    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */

    _this.image_ = !image ? new Image() : image;

    if (crossOrigin !== null) {
      /** @type {HTMLImageElement} */
      _this.image_.crossOrigin = crossOrigin;
    }
    /**
     * @private
     * @type {HTMLCanvasElement}
     */


    _this.canvas_ = color ? document.createElement('canvas') : null;
    /**
     * @private
     * @type {import("../color.js").Color}
     */

    _this.color_ = color;
    /**
     * @private
     * @type {?function():void}
     */

    _this.unlisten_ = null;
    /**
     * @private
     * @type {import("../ImageState.js").default}
     */

    _this.imageState_ = imageState;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.size_ = size;
    /**
     * @private
     * @type {string|undefined}
     */

    _this.src_ = src;
    /**
     * @private
     * @type {boolean|undefined}
     */

    _this.tainted_;
    return _this;
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D=} context A context with the image already drawn into.
   * @return {boolean} The image canvas is tainted.
   */


  IconImage.prototype.isTainted_ = function (context) {
    if (this.tainted_ === undefined && this.imageState_ === _ImageState.default.LOADED) {
      if (!context) {
        context = (0, _dom.createCanvasContext2D)(1, 1);
        context.drawImage(this.image_, 0, 0);
      }

      try {
        context.getImageData(0, 0, 1, 1);
        this.tainted_ = false;
      } catch (e) {
        this.tainted_ = true;
      }
    }

    return this.tainted_ === true;
  };
  /**
   * @private
   */


  IconImage.prototype.dispatchChangeEvent_ = function () {
    this.dispatchEvent(_EventType.default.CHANGE);
  };
  /**
   * @private
   */


  IconImage.prototype.handleImageError_ = function () {
    this.imageState_ = _ImageState.default.ERROR;
    this.unlistenImage_();
    this.dispatchChangeEvent_();
  };
  /**
   * @private
   */


  IconImage.prototype.handleImageLoad_ = function () {
    this.imageState_ = _ImageState.default.LOADED;

    if (this.size_) {
      this.image_.width = this.size_[0];
      this.image_.height = this.size_[1];
    }

    this.size_ = [this.image_.width, this.image_.height];
    this.unlistenImage_();
    this.replaceColor_();
    this.dispatchChangeEvent_();
  };
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   */


  IconImage.prototype.getImage = function (pixelRatio) {
    return this.canvas_ ? this.canvas_ : this.image_;
  };
  /**
   * @return {import("../ImageState.js").default} Image state.
   */


  IconImage.prototype.getImageState = function () {
    return this.imageState_;
  };
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */


  IconImage.prototype.getHitDetectionImage = function (pixelRatio) {
    if (!this.hitDetectionImage_) {
      if (this.isTainted_()) {
        var width = this.size_[0];
        var height = this.size_[1];
        var context = (0, _dom.createCanvasContext2D)(width, height);
        context.fillRect(0, 0, width, height);
        this.hitDetectionImage_ = context.canvas;
      } else {
        this.hitDetectionImage_ = this.image_;
      }
    }

    return this.hitDetectionImage_;
  };
  /**
   * @return {import("../size.js").Size} Image size.
   */


  IconImage.prototype.getSize = function () {
    return this.size_;
  };
  /**
   * @return {string|undefined} Image src.
   */


  IconImage.prototype.getSrc = function () {
    return this.src_;
  };
  /**
   * Load not yet loaded URI.
   */


  IconImage.prototype.load = function () {
    if (this.imageState_ == _ImageState.default.IDLE) {
      this.imageState_ = _ImageState.default.LOADING;

      try {
        /** @type {HTMLImageElement} */
        this.image_.src = this.src_;
      } catch (e) {
        this.handleImageError_();
      }

      this.unlisten_ = (0, _Image.listenImage)(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
    }
  };
  /**
   * @private
   */


  IconImage.prototype.replaceColor_ = function () {
    if (!this.color_) {
      return;
    }

    this.canvas_.width = this.image_.width;
    this.canvas_.height = this.image_.height;
    var ctx = this.canvas_.getContext('2d');
    ctx.drawImage(this.image_, 0, 0);

    if (this.isTainted_(ctx)) {
      // If reading from the canvas throws a SecurityError the same effect can be
      // achieved with globalCompositeOperation.
      // This could be used as the default, but it is not fully supported by all
      // browsers. E. g. Internet Explorer 11 does not support the multiply
      // operation and the resulting image shape will be completelly filled with
      // the provided color.
      // So this is only used as a fallback. It is still better than having no icon
      // at all.
      var c = this.color_;
      ctx.globalCompositeOperation = 'multiply';
      ctx.fillStyle = 'rgb(' + c[0] + ',' + c[1] + ',' + c[2] + ')';
      ctx.fillRect(0, 0, this.image_.width, this.image_.height);
      ctx.globalCompositeOperation = 'destination-in';
      ctx.drawImage(this.image_, 0, 0);
      return;
    }

    var imgData = ctx.getImageData(0, 0, this.image_.width, this.image_.height);
    var data = imgData.data;
    var r = this.color_[0] / 255.0;
    var g = this.color_[1] / 255.0;
    var b = this.color_[2] / 255.0;

    for (var i = 0, ii = data.length; i < ii; i += 4) {
      data[i] *= r;
      data[i + 1] *= g;
      data[i + 2] *= b;
    }

    ctx.putImageData(imgData, 0, 0);
  };
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */


  IconImage.prototype.unlistenImage_ = function () {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  };

  return IconImage;
}(_Target.default);
/**
 * @param {HTMLImageElement|HTMLCanvasElement} image Image.
 * @param {string} src Src.
 * @param {import("../size.js").Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../ImageState.js").default} imageState Image state.
 * @param {import("../color.js").Color} color Color.
 * @return {IconImage} Icon image.
 */


function get(image, src, size, crossOrigin, imageState, color) {
  var iconImage = _IconImageCache.shared.get(src, crossOrigin, color);

  if (!iconImage) {
    iconImage = new IconImage(image, src, size, crossOrigin, imageState, color);

    _IconImageCache.shared.set(src, crossOrigin, color, iconImage);
  }

  return iconImage;
}

var _default = IconImage;
exports.default = _default;
},{"../dom.js":"node_modules/ol/dom.js","../events/Target.js":"node_modules/ol/events/Target.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../ImageState.js":"node_modules/ol/ImageState.js","./IconImageCache.js":"node_modules/ol/style/IconImageCache.js","../Image.js":"node_modules/ol/Image.js"}],"node_modules/ol/style/IconOrigin.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/style/IconOrigin
 */

/**
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 * @enum {string}
 */
var _default = {
  /**
   * Origin is at bottom left
   * @api
   */
  BOTTOM_LEFT: 'bottom-left',

  /**
   * Origin is at bottom right
   * @api
   */
  BOTTOM_RIGHT: 'bottom-right',

  /**
   * Origin is at top left
   * @api
   */
  TOP_LEFT: 'top-left',

  /**
   * Origin is at top right
   * @api
   */
  TOP_RIGHT: 'top-right'
};
exports.default = _default;
},{}],"node_modules/ol/style/Icon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("../util.js");

var _ImageState = _interopRequireDefault(require("../ImageState.js"));

var _asserts = require("../asserts.js");

var _color = require("../color.js");

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _IconAnchorUnits = _interopRequireDefault(require("./IconAnchorUnits.js"));

var _IconImage = require("./IconImage.js");

var _IconOrigin = _interopRequireDefault(require("./IconOrigin.js"));

var _Image = _interopRequireDefault(require("./Image.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/style/Icon
 */


/**
 * @typedef {Object} Options
 * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {import("./IconOrigin.js").default} [anchorOrigin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("./IconAnchorUnits.js").default} [anchorXUnits='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {import("./IconAnchorUnits.js").default} [anchorYUnits='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {HTMLImageElement|HTMLCanvasElement} [img] Image object for the icon. If the `src` option is not provided then the
 * provided image must already be loaded. And in that case, it is required
 * to provide the size of the image, with the `imgSize` option.
 * @property {Array<number>} [offset=[0, 0]] Offset, which, together with the size and the offset origin, define the
 * sub-rectangle to use from the original icon image.
 * @property {Array<number>} [displacement=[0,0]] Displacement the icon
 * @property {import("./IconOrigin.js").default} [offsetOrigin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {number} [opacity=1] Opacity of the icon.
 * @property {number} [scale=1] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {import("../size.js").Size} [size] Icon size in pixel. Can be used together with `offset` to define the
 * sub-rectangle to use from the origin (sprite) icon image.
 * @property {import("../size.js").Size} [imgSize] Image size in pixels. Only required if `img` is set and `src` is not, and
 * for SVG images in Internet Explorer 11. The provided `imgSize` needs to match the actual size of the image.
 * @property {string} [src] Image source URI.
 */

/**
 * @classdesc
 * Set icon style for vector features.
 * @api
 */
var Icon =
/** @class */
function (_super) {
  __extends(Icon, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function Icon(opt_options) {
    var _this = this;

    var options = opt_options || {};
    /**
     * @type {number}
     */

    var opacity = options.opacity !== undefined ? options.opacity : 1;
    /**
     * @type {number}
     */

    var rotation = options.rotation !== undefined ? options.rotation : 0;
    /**
     * @type {number}
     */

    var scale = options.scale !== undefined ? options.scale : 1;
    /**
     * @type {boolean}
     */

    var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
    _this = _super.call(this, {
      opacity: opacity,
      rotation: rotation,
      scale: scale,
      displacement: options.displacement !== undefined ? options.displacement : [0, 0],
      rotateWithView: rotateWithView
    }) || this;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];
    /**
     * @private
     * @type {Array<number>}
     */

    _this.normalizedAnchor_ = null;
    /**
     * @private
     * @type {import("./IconOrigin.js").default}
     */

    _this.anchorOrigin_ = options.anchorOrigin !== undefined ? options.anchorOrigin : _IconOrigin.default.TOP_LEFT;
    /**
     * @private
     * @type {import("./IconAnchorUnits.js").default}
     */

    _this.anchorXUnits_ = options.anchorXUnits !== undefined ? options.anchorXUnits : _IconAnchorUnits.default.FRACTION;
    /**
     * @private
     * @type {import("./IconAnchorUnits.js").default}
     */

    _this.anchorYUnits_ = options.anchorYUnits !== undefined ? options.anchorYUnits : _IconAnchorUnits.default.FRACTION;
    /**
     * @private
     * @type {?string}
     */

    _this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
    /**
     * @type {HTMLImageElement|HTMLCanvasElement}
     */

    var image = options.img !== undefined ? options.img : null;
    /**
     * @type {import("../size.js").Size}
     */

    var imgSize = options.imgSize !== undefined ? options.imgSize : null;
    /**
     * @type {string|undefined}
     */

    var src = options.src;
    (0, _asserts.assert)(!(src !== undefined && image), 4); // `image` and `src` cannot be provided at the same time

    (0, _asserts.assert)(!image || image && imgSize, 5); // `imgSize` must be set when `image` is provided

    if ((src === undefined || src.length === 0) && image) {
      src =
      /** @type {HTMLImageElement} */
      image.src || (0, _util.getUid)(image);
    }

    (0, _asserts.assert)(src !== undefined && src.length > 0, 6); // A defined and non-empty `src` or `image` must be provided

    /**
     * @type {import("../ImageState.js").default}
     */

    var imageState = options.src !== undefined ? _ImageState.default.IDLE : _ImageState.default.LOADED;
    /**
     * @private
     * @type {import("../color.js").Color}
     */

    _this.color_ = options.color !== undefined ? (0, _color.asArray)(options.color) : null;
    /**
     * @private
     * @type {import("./IconImage.js").default}
     */

    _this.iconImage_ = (0, _IconImage.get)(image,
    /** @type {string} */
    src, imgSize, _this.crossOrigin_, imageState, _this.color_);
    /**
     * @private
     * @type {Array<number>}
     */

    _this.offset_ = options.offset !== undefined ? options.offset : [0, 0];
    /**
     * @private
     * @type {import("./IconOrigin.js").default}
     */

    _this.offsetOrigin_ = options.offsetOrigin !== undefined ? options.offsetOrigin : _IconOrigin.default.TOP_LEFT;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.origin_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.size_ = options.size !== undefined ? options.size : null;
    return _this;
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */


  Icon.prototype.clone = function () {
    return new Icon({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      crossOrigin: this.crossOrigin_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || undefined,
      src: this.getSrc(),
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      size: this.size_ !== null ? this.size_.slice() : undefined,
      opacity: this.getOpacity(),
      scale: this.getScale(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView()
    });
  };
  /**
   * @inheritDoc
   * @api
   */


  Icon.prototype.getAnchor = function () {
    if (this.normalizedAnchor_) {
      return this.normalizedAnchor_;
    }

    var anchor = this.anchor_;
    var size = this.getSize();

    if (this.anchorXUnits_ == _IconAnchorUnits.default.FRACTION || this.anchorYUnits_ == _IconAnchorUnits.default.FRACTION) {
      if (!size) {
        return null;
      }

      anchor = this.anchor_.slice();

      if (this.anchorXUnits_ == _IconAnchorUnits.default.FRACTION) {
        anchor[0] *= size[0];
      }

      if (this.anchorYUnits_ == _IconAnchorUnits.default.FRACTION) {
        anchor[1] *= size[1];
      }
    }

    if (this.anchorOrigin_ != _IconOrigin.default.TOP_LEFT) {
      if (!size) {
        return null;
      }

      if (anchor === this.anchor_) {
        anchor = this.anchor_.slice();
      }

      if (this.anchorOrigin_ == _IconOrigin.default.TOP_RIGHT || this.anchorOrigin_ == _IconOrigin.default.BOTTOM_RIGHT) {
        anchor[0] = -anchor[0] + size[0];
      }

      if (this.anchorOrigin_ == _IconOrigin.default.BOTTOM_LEFT || this.anchorOrigin_ == _IconOrigin.default.BOTTOM_RIGHT) {
        anchor[1] = -anchor[1] + size[1];
      }
    }

    this.normalizedAnchor_ = anchor;
    return this.normalizedAnchor_;
  };
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */


  Icon.prototype.setAnchor = function (anchor) {
    this.anchor_ = anchor;
    this.normalizedAnchor_ = null;
  };
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */


  Icon.prototype.getColor = function () {
    return this.color_;
  };
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   * @override
   * @api
   */


  Icon.prototype.getImage = function (pixelRatio) {
    return this.iconImage_.getImage(pixelRatio);
  };
  /**
   * @override
   */


  Icon.prototype.getImageSize = function () {
    return this.iconImage_.getSize();
  };
  /**
   * @override
   */


  Icon.prototype.getHitDetectionImageSize = function () {
    return this.getImageSize();
  };
  /**
   * @override
   */


  Icon.prototype.getImageState = function () {
    return this.iconImage_.getImageState();
  };
  /**
   * @override
   */


  Icon.prototype.getHitDetectionImage = function (pixelRatio) {
    return this.iconImage_.getHitDetectionImage(pixelRatio);
  };
  /**
   * @inheritDoc
   * @api
   */


  Icon.prototype.getOrigin = function () {
    if (this.origin_) {
      return this.origin_;
    }

    var offset = this.offset_;
    var displacement = this.getDisplacement();

    if (this.offsetOrigin_ != _IconOrigin.default.TOP_LEFT) {
      var size = this.getSize();
      var iconImageSize = this.iconImage_.getSize();

      if (!size || !iconImageSize) {
        return null;
      }

      offset = offset.slice();

      if (this.offsetOrigin_ == _IconOrigin.default.TOP_RIGHT || this.offsetOrigin_ == _IconOrigin.default.BOTTOM_RIGHT) {
        offset[0] = iconImageSize[0] - size[0] - offset[0];
      }

      if (this.offsetOrigin_ == _IconOrigin.default.BOTTOM_LEFT || this.offsetOrigin_ == _IconOrigin.default.BOTTOM_RIGHT) {
        offset[1] = iconImageSize[1] - size[1] - offset[1];
      }
    }

    offset[0] += displacement[0];
    offset[1] += displacement[1];
    this.origin_ = offset;
    return this.origin_;
  };
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */


  Icon.prototype.getSrc = function () {
    return this.iconImage_.getSrc();
  };
  /**
   * @inheritDoc
   * @api
   */


  Icon.prototype.getSize = function () {
    return !this.size_ ? this.iconImage_.getSize() : this.size_;
  };
  /**
   * @override
   */


  Icon.prototype.listenImageChange = function (listener) {
    this.iconImage_.addEventListener(_EventType.default.CHANGE, listener);
  };
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @override
   * @api
   */


  Icon.prototype.load = function () {
    this.iconImage_.load();
  };
  /**
   * @override
   */


  Icon.prototype.unlistenImageChange = function (listener) {
    this.iconImage_.removeEventListener(_EventType.default.CHANGE, listener);
  };

  return Icon;
}(_Image.default);

var _default = Icon;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","../ImageState.js":"node_modules/ol/ImageState.js","../asserts.js":"node_modules/ol/asserts.js","../color.js":"node_modules/ol/color.js","../events/EventType.js":"node_modules/ol/events/EventType.js","./IconAnchorUnits.js":"node_modules/ol/style/IconAnchorUnits.js","./IconImage.js":"node_modules/ol/style/IconImage.js","./IconOrigin.js":"node_modules/ol/style/IconOrigin.js","./Image.js":"node_modules/ol/style/Image.js"}],"node_modules/ol/style/Text.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Fill = _interopRequireDefault(require("./Fill.js"));

var _TextPlacement = _interopRequireDefault(require("./TextPlacement.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/style/Text
 */

/**
 * The default fill color to use if no fill was set at construction time; a
 * blackish `#333`.
 *
 * @const {string}
 */
var DEFAULT_FILL_COLOR = '#333';
/**
 * @typedef {Object} Options
 * @property {string} [font] Font style as CSS 'font' value, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is '10px sans-serif'
 * @property {number} [maxAngle=Math.PI/4] When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
 * @property {number} [offsetX=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {number} [offsetY=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {boolean} [overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {import("./TextPlacement.js").default|string} [placement='point'] Text placement.
 * @property {number} [scale] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the text with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {string} [text] Text content.
 * @property {string} [textAlign] Text alignment. Possible values: 'left', 'right', 'center', 'end' or 'start'.
 * Default is 'center' for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a
 * placement where `maxAngle` is not exceeded.
 * @property {string} [textBaseline='middle'] Text base line. Possible values: 'bottom', 'top', 'middle', 'alphabetic',
 * 'hanging', 'ideographic'.
 * @property {import("./Fill.js").default} [fill] Fill style. If none is provided, we'll use a dark fill-style (#333).
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Fill.js").default} [backgroundFill] Fill style for the text background when `placement` is
 * `'point'`. Default is no fill.
 * @property {import("./Stroke.js").default} [backgroundStroke] Stroke style for the text background  when `placement`
 * is `'point'`. Default is no stroke.
 * @property {Array<number>} [padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 */

/**
 * @classdesc
 * Set text style for vector features.
 * @api
 */

var Text =
/** @class */
function () {
  /**
   * @param {Options=} opt_options Options.
   */
  function Text(opt_options) {
    var options = opt_options || {};
    /**
     * @private
     * @type {string|undefined}
     */

    this.font_ = options.font;
    /**
     * @private
     * @type {number|undefined}
     */

    this.rotation_ = options.rotation;
    /**
     * @private
     * @type {boolean|undefined}
     */

    this.rotateWithView_ = options.rotateWithView;
    /**
     * @private
     * @type {number|undefined}
     */

    this.scale_ = options.scale;
    /**
     * @private
     * @type {string|undefined}
     */

    this.text_ = options.text;
    /**
     * @private
     * @type {string|undefined}
     */

    this.textAlign_ = options.textAlign;
    /**
     * @private
     * @type {string|undefined}
     */

    this.textBaseline_ = options.textBaseline;
    /**
     * @private
     * @type {import("./Fill.js").default}
     */

    this.fill_ = options.fill !== undefined ? options.fill : new _Fill.default({
      color: DEFAULT_FILL_COLOR
    });
    /**
     * @private
     * @type {number}
     */

    this.maxAngle_ = options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;
    /**
     * @private
     * @type {import("./TextPlacement.js").default|string}
     */

    this.placement_ = options.placement !== undefined ? options.placement : _TextPlacement.default.POINT;
    /**
     * @private
     * @type {boolean}
     */

    this.overflow_ = !!options.overflow;
    /**
     * @private
     * @type {import("./Stroke.js").default}
     */

    this.stroke_ = options.stroke !== undefined ? options.stroke : null;
    /**
     * @private
     * @type {number}
     */

    this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;
    /**
     * @private
     * @type {number}
     */

    this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;
    /**
     * @private
     * @type {import("./Fill.js").default}
     */

    this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
    /**
     * @private
     * @type {import("./Stroke.js").default}
     */

    this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
    /**
     * @private
     * @type {Array<number>}
     */

    this.padding_ = options.padding === undefined ? null : options.padding;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */


  Text.prototype.clone = function () {
    return new Text({
      font: this.getFont(),
      placement: this.getPlacement(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: this.getScale(),
      text: this.getText(),
      textAlign: this.getTextAlign(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : undefined,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : undefined,
      padding: this.getPadding()
    });
  };
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */


  Text.prototype.getOverflow = function () {
    return this.overflow_;
  };
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */


  Text.prototype.getFont = function () {
    return this.font_;
  };
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */


  Text.prototype.getMaxAngle = function () {
    return this.maxAngle_;
  };
  /**
   * Get the label placement.
   * @return {import("./TextPlacement.js").default|string} Text placement.
   * @api
   */


  Text.prototype.getPlacement = function () {
    return this.placement_;
  };
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */


  Text.prototype.getOffsetX = function () {
    return this.offsetX_;
  };
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */


  Text.prototype.getOffsetY = function () {
    return this.offsetY_;
  };
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */


  Text.prototype.getFill = function () {
    return this.fill_;
  };
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */


  Text.prototype.getRotateWithView = function () {
    return this.rotateWithView_;
  };
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */


  Text.prototype.getRotation = function () {
    return this.rotation_;
  };
  /**
   * Get the text scale.
   * @return {number|undefined} Scale.
   * @api
   */


  Text.prototype.getScale = function () {
    return this.scale_;
  };
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */


  Text.prototype.getStroke = function () {
    return this.stroke_;
  };
  /**
   * Get the text to be rendered.
   * @return {string|undefined} Text.
   * @api
   */


  Text.prototype.getText = function () {
    return this.text_;
  };
  /**
   * Get the text alignment.
   * @return {string|undefined} Text align.
   * @api
   */


  Text.prototype.getTextAlign = function () {
    return this.textAlign_;
  };
  /**
   * Get the text baseline.
   * @return {string|undefined} Text baseline.
   * @api
   */


  Text.prototype.getTextBaseline = function () {
    return this.textBaseline_;
  };
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */


  Text.prototype.getBackgroundFill = function () {
    return this.backgroundFill_;
  };
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */


  Text.prototype.getBackgroundStroke = function () {
    return this.backgroundStroke_;
  };
  /**
   * Get the padding for the text.
   * @return {Array<number>} Padding.
   * @api
   */


  Text.prototype.getPadding = function () {
    return this.padding_;
  };
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */


  Text.prototype.setOverflow = function (overflow) {
    this.overflow_ = overflow;
  };
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */


  Text.prototype.setFont = function (font) {
    this.font_ = font;
  };
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */


  Text.prototype.setMaxAngle = function (maxAngle) {
    this.maxAngle_ = maxAngle;
  };
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */


  Text.prototype.setOffsetX = function (offsetX) {
    this.offsetX_ = offsetX;
  };
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */


  Text.prototype.setOffsetY = function (offsetY) {
    this.offsetY_ = offsetY;
  };
  /**
   * Set the text placement.
   *
   * @param {import("./TextPlacement.js").default|string} placement Placement.
   * @api
   */


  Text.prototype.setPlacement = function (placement) {
    this.placement_ = placement;
  };
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */


  Text.prototype.setRotateWithView = function (rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  };
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */


  Text.prototype.setFill = function (fill) {
    this.fill_ = fill;
  };
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */


  Text.prototype.setRotation = function (rotation) {
    this.rotation_ = rotation;
  };
  /**
   * Set the scale.
   *
   * @param {number|undefined} scale Scale.
   * @api
   */


  Text.prototype.setScale = function (scale) {
    this.scale_ = scale;
  };
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */


  Text.prototype.setStroke = function (stroke) {
    this.stroke_ = stroke;
  };
  /**
   * Set the text.
   *
   * @param {string|undefined} text Text.
   * @api
   */


  Text.prototype.setText = function (text) {
    this.text_ = text;
  };
  /**
   * Set the text alignment.
   *
   * @param {string|undefined} textAlign Text align.
   * @api
   */


  Text.prototype.setTextAlign = function (textAlign) {
    this.textAlign_ = textAlign;
  };
  /**
   * Set the text baseline.
   *
   * @param {string|undefined} textBaseline Text baseline.
   * @api
   */


  Text.prototype.setTextBaseline = function (textBaseline) {
    this.textBaseline_ = textBaseline;
  };
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */


  Text.prototype.setBackgroundFill = function (fill) {
    this.backgroundFill_ = fill;
  };
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */


  Text.prototype.setBackgroundStroke = function (stroke) {
    this.backgroundStroke_ = stroke;
  };
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {!Array<number>} padding Padding.
   * @api
   */


  Text.prototype.setPadding = function (padding) {
    this.padding_ = padding;
  };

  return Text;
}();

var _default = Text;
exports.default = _default;
},{"./Fill.js":"node_modules/ol/style/Fill.js","./TextPlacement.js":"node_modules/ol/style/TextPlacement.js"}],"node_modules/ol/style.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function () {
    return _Circle.default;
  }
});
Object.defineProperty(exports, "Fill", {
  enumerable: true,
  get: function () {
    return _Fill.default;
  }
});
Object.defineProperty(exports, "Icon", {
  enumerable: true,
  get: function () {
    return _Icon.default;
  }
});
Object.defineProperty(exports, "IconImage", {
  enumerable: true,
  get: function () {
    return _IconImage.default;
  }
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function () {
    return _Image.default;
  }
});
Object.defineProperty(exports, "RegularShape", {
  enumerable: true,
  get: function () {
    return _RegularShape.default;
  }
});
Object.defineProperty(exports, "Stroke", {
  enumerable: true,
  get: function () {
    return _Stroke.default;
  }
});
Object.defineProperty(exports, "Style", {
  enumerable: true,
  get: function () {
    return _Style.default;
  }
});
Object.defineProperty(exports, "Text", {
  enumerable: true,
  get: function () {
    return _Text.default;
  }
});

var _Circle = _interopRequireDefault(require("./style/Circle.js"));

var _Fill = _interopRequireDefault(require("./style/Fill.js"));

var _Icon = _interopRequireDefault(require("./style/Icon.js"));

var _IconImage = _interopRequireDefault(require("./style/IconImage.js"));

var _Image = _interopRequireDefault(require("./style/Image.js"));

var _RegularShape = _interopRequireDefault(require("./style/RegularShape.js"));

var _Stroke = _interopRequireDefault(require("./style/Stroke.js"));

var _Style = _interopRequireDefault(require("./style/Style.js"));

var _Text = _interopRequireDefault(require("./style/Text.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./style/Circle.js":"node_modules/ol/style/Circle.js","./style/Fill.js":"node_modules/ol/style/Fill.js","./style/Icon.js":"node_modules/ol/style/Icon.js","./style/IconImage.js":"node_modules/ol/style/IconImage.js","./style/Image.js":"node_modules/ol/style/Image.js","./style/RegularShape.js":"node_modules/ol/style/RegularShape.js","./style/Stroke.js":"node_modules/ol/style/Stroke.js","./style/Style.js":"node_modules/ol/style/Style.js","./style/Text.js":"node_modules/ol/style/Text.js"}],"node_modules/ol/render/canvas/hitdetect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createHitDetectionImageData = createHitDetectionImageData;
exports.hitDetect = hitDetect;

var _Immediate = _interopRequireDefault(require("./Immediate.js"));

var _dom = require("../../dom.js");

var _style = require("../../style.js");

var _IconAnchorUnits = _interopRequireDefault(require("../../style/IconAnchorUnits.js"));

var _GeometryType = _interopRequireDefault(require("../../geom/GeometryType.js"));

var _extent = require("../../extent.js");

var _array = require("../../array.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render/canvas/hitdetet
 */

/**
 * @param {import("../../size.js").Size} size Canvas size in css pixels.
 * @param {Array<import("../../transform.js").Transform>} transforms Transforms
 * for rendering features to all worlds of the viewport, from coordinates to css
 * pixels.
 * @param {Array<import("../../Feature.js").FeatureLike>} features
 * Features to consider for hit detection.
 * @param {import("../../style/Style.js").StyleFunction|undefined} styleFunction
 * Layer style function.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {ImageData} Hit detection image data.
 */
function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation) {
  var width = size[0] / 2;
  var height = size[1] / 2;
  var context = (0, _dom.createCanvasContext2D)(width, height);
  context.imageSmoothingEnabled = false;
  var canvas = context.canvas;
  var renderer = new _Immediate.default(context, 0.5, extent, null, rotation);
  var featureCount = features.length; // Stretch hit detection index to use the whole available color range

  var indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
  var featuresByZIndex = {};

  for (var i = 1; i <= featureCount; ++i) {
    var feature = features[i - 1];
    var featureStyleFunction = feature.getStyleFunction() || styleFunction;

    if (!styleFunction) {
      continue;
    }

    var styles = featureStyleFunction(feature, resolution);

    if (!styles) {
      continue;
    }

    if (!Array.isArray(styles)) {
      styles = [styles];
    }

    var index = i * indexFactor;
    var color = '#' + ('000000' + index.toString(16)).slice(-6);

    for (var j = 0, jj = styles.length; j < jj; ++j) {
      var originalStyle = styles[j];
      var style = originalStyle.clone();
      var fill = style.getFill();

      if (fill) {
        fill.setColor(color);
      }

      var stroke = style.getStroke();

      if (stroke) {
        stroke.setColor(color);
      }

      style.setText(undefined);
      var image = originalStyle.getImage();

      if (image) {
        var imgSize = image.getImageSize();

        if (!imgSize) {
          continue;
        }

        var canvas_1 = document.createElement('canvas');
        canvas_1.width = imgSize[0];
        canvas_1.height = imgSize[1];
        var imgContext = canvas_1.getContext('2d', {
          alpha: false
        });
        imgContext.fillStyle = color;
        var img = imgContext.canvas;
        imgContext.fillRect(0, 0, img.width, img.height);
        var width_1 = imgSize ? imgSize[0] : img.width;
        var height_1 = imgSize ? imgSize[1] : img.height;
        var iconContext = (0, _dom.createCanvasContext2D)(width_1, height_1);
        iconContext.drawImage(img, 0, 0);
        style.setImage(new _style.Icon({
          img: img,
          imgSize: imgSize,
          anchor: image.getAnchor(),
          anchorXUnits: _IconAnchorUnits.default.PIXELS,
          anchorYUnits: _IconAnchorUnits.default.PIXELS,
          offset: image.getOrigin(),
          size: image.getSize(),
          opacity: image.getOpacity(),
          scale: image.getScale(),
          rotation: image.getRotation(),
          rotateWithView: image.getRotateWithView()
        }));
      }

      var zIndex = Number(style.getZIndex());
      var byGeometryType = featuresByZIndex[zIndex];

      if (!byGeometryType) {
        byGeometryType = {};
        featuresByZIndex[zIndex] = byGeometryType;
        byGeometryType[_GeometryType.default.POLYGON] = [];
        byGeometryType[_GeometryType.default.CIRCLE] = [];
        byGeometryType[_GeometryType.default.LINE_STRING] = [];
        byGeometryType[_GeometryType.default.POINT] = [];
      }

      var geometry = style.getGeometryFunction()(feature);

      if (geometry && (0, _extent.intersects)(extent, geometry.getExtent())) {
        byGeometryType[geometry.getType().replace('Multi', '')].push(geometry, style);
      }
    }
  }

  var zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(_array.numberSafeCompareFunction);

  for (var i = 0, ii = zIndexKeys.length; i < ii; ++i) {
    var byGeometryType = featuresByZIndex[zIndexKeys[i]];

    for (var type in byGeometryType) {
      var geomAndStyle = byGeometryType[type];

      for (var j = 0, jj = geomAndStyle.length; j < jj; j += 2) {
        renderer.setStyle(geomAndStyle[j + 1]);

        for (var k = 0, kk = transforms.length; k < kk; ++k) {
          renderer.setTransform(transforms[k]);
          renderer.drawGeometry(geomAndStyle[j]);
        }
      }
    }
  }

  document.body.appendChild(context.canvas);
  return context.getImageData(0, 0, canvas.width, canvas.height);
}
/**
 * @param {import("../../pixel").Pixel} pixel Pixel coordinate on the hit
 * detection canvas in css pixels.
 * @param {Array<import("../../Feature").FeatureLike>} features Features. Has to
 * match the `features` array that was passed to `createHitDetectionImageData()`.
 * @param {ImageData} imageData Hit detection image data generated by
 * `createHitDetectionImageData()`.
 * @return {Array<import("../../Feature").FeatureLike>} features Features.
 */


function hitDetect(pixel, features, imageData) {
  var resultFeatures = [];

  if (imageData) {
    var index = (Math.round(pixel[0] / 2) + Math.round(pixel[1] / 2) * imageData.width) * 4;
    var r = imageData.data[index];
    var g = imageData.data[index + 1];
    var b = imageData.data[index + 2];
    var i = b + 256 * (g + 256 * r);
    var indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);

    if (i && i % indexFactor === 0) {
      resultFeatures.push(features[i / indexFactor - 1]);
    }
  }

  return resultFeatures;
}
},{"./Immediate.js":"node_modules/ol/render/canvas/Immediate.js","../../dom.js":"node_modules/ol/dom.js","../../style.js":"node_modules/ol/style.js","../../style/IconAnchorUnits.js":"node_modules/ol/style/IconAnchorUnits.js","../../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../../extent.js":"node_modules/ol/extent.js","../../array.js":"node_modules/ol/array.js"}],"node_modules/ol/renderer/canvas/VectorLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("../../util.js");

var _ViewHint = _interopRequireDefault(require("../../ViewHint.js"));

var _extent = require("../../extent.js");

var _coordinate = require("../../coordinate.js");

var _proj = require("../../proj.js");

var _BuilderGroup = _interopRequireDefault(require("../../render/canvas/BuilderGroup.js"));

var _ExecutorGroup = _interopRequireWildcard(require("../../render/canvas/ExecutorGroup.js"));

var _Layer = _interopRequireDefault(require("./Layer.js"));

var _vector = require("../vector.js");

var _transform = require("../../transform.js");

var _hitdetect = require("../../render/canvas/hitdetect.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/canvas/VectorLayer
 */


/**
 * @classdesc
 * Canvas renderer for vector layers.
 * @api
 */
var CanvasVectorLayerRenderer =
/** @class */
function (_super) {
  __extends(CanvasVectorLayerRenderer, _super);
  /**
   * @param {import("../../layer/Vector.js").default} vectorLayer Vector layer.
   */


  function CanvasVectorLayerRenderer(vectorLayer) {
    var _this = _super.call(this, vectorLayer) || this;
    /** @private */


    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
    /**
     * @type {boolean}
     */

    _this.animatingOrInteracting_;
    /**
     * @private
     * @type {boolean}
     */

    _this.dirty_ = false;
    /**
     * @type {ImageData}
     */

    _this.hitDetectionImageData_ = null;
    /**
     * @type {Array<import("../../Feature.js").default>}
     */

    _this.renderedFeatures_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.renderedRevision_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.renderedResolution_ = NaN;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    _this.renderedExtent_ = (0, _extent.createEmpty)();
    /**
     * @private
     * @type {number}
     */

    _this.renderedRotation_;
    /**
     * @private
     * @type {import("../../coordinate").Coordinate}
     */

    _this.renderedCenter_ = null;
    /**
     * @private
     * @type {import("../../proj/Projection").default}
     */

    _this.renderedProjection_ = null;
    /**
     * @private
     * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
     */

    _this.renderedRenderOrder_ = null;
    /**
     * @private
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */

    _this.replayGroup_ = null;
    /**
     * A new replay group had to be created by `prepareFrame()`
     * @type {boolean}
     */

    _this.replayGroupChanged = true;
    return _this;
  }
  /**
   * @inheritDoc
   */


  CanvasVectorLayerRenderer.prototype.useContainer = function (target, transform, opacity) {
    if (opacity < 1) {
      target = null;
    }

    _super.prototype.useContainer.call(this, target, transform, opacity);
  };
  /**
   * @inheritDoc
   */


  CanvasVectorLayerRenderer.prototype.renderFrame = function (frameState, target) {
    var pixelRatio = frameState.pixelRatio;
    var layerState = frameState.layerStatesArray[frameState.layerIndex]; // set forward and inverse pixel transforms

    (0, _transform.makeScale)(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
    (0, _transform.makeInverse)(this.inversePixelTransform, this.pixelTransform);
    var canvasTransform = (0, _transform.toString)(this.pixelTransform);
    this.useContainer(target, canvasTransform, layerState.opacity);
    var context = this.context;
    var canvas = context.canvas;
    var replayGroup = this.replayGroup_;

    if (!replayGroup || replayGroup.isEmpty()) {
      if (!this.containerReused && canvas.width > 0) {
        canvas.width = 0;
      }

      return this.container;
    } // resize and clear


    var width = Math.round(frameState.size[0] * pixelRatio);
    var height = Math.round(frameState.size[1] * pixelRatio);

    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;

      if (canvas.style.transform !== canvasTransform) {
        canvas.style.transform = canvasTransform;
      }
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }

    this.preRender(context, frameState);
    var extent = frameState.extent;
    var viewState = frameState.viewState;
    var center = viewState.center;
    var resolution = viewState.resolution;
    var projection = viewState.projection;
    var rotation = viewState.rotation;
    var projectionExtent = projection.getExtent();
    var vectorSource = this.getLayer().getSource(); // clipped rendering if layer extent is set

    var clipped = false;

    if (layerState.extent) {
      var layerExtent = (0, _proj.fromUserExtent)(layerState.extent, projection);
      clipped = !(0, _extent.containsExtent)(layerExtent, frameState.extent) && (0, _extent.intersects)(layerExtent, frameState.extent);

      if (clipped) {
        this.clip(context, frameState, layerExtent);
      }
    }

    var viewHints = frameState.viewHints;
    var snapToPixel = !(viewHints[_ViewHint.default.ANIMATING] || viewHints[_ViewHint.default.INTERACTING]);
    var transform = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, 0);
    var declutterReplays = this.getLayer().getDeclutter() ? {} : null;
    replayGroup.execute(context, transform, rotation, snapToPixel, undefined, declutterReplays);

    if (vectorSource.getWrapX() && projection.canWrapX() && !(0, _extent.containsExtent)(projectionExtent, extent)) {
      var startX = extent[0];
      var worldWidth = (0, _extent.getWidth)(projectionExtent);
      var world = 0;
      var offsetX = void 0;

      while (startX < projectionExtent[0]) {
        --world;
        offsetX = worldWidth * world;
        var transform_1 = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX);
        replayGroup.execute(context, transform_1, rotation, snapToPixel, undefined, declutterReplays);
        startX += worldWidth;
      }

      world = 0;
      startX = extent[2];

      while (startX > projectionExtent[2]) {
        ++world;
        offsetX = worldWidth * world;
        var transform_2 = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX);
        replayGroup.execute(context, transform_2, rotation, snapToPixel, undefined, declutterReplays);
        startX -= worldWidth;
      }
    }

    if (declutterReplays) {
      var viewHints_1 = frameState.viewHints;
      var hifi = !(viewHints_1[_ViewHint.default.ANIMATING] || viewHints_1[_ViewHint.default.INTERACTING]);
      (0, _ExecutorGroup.replayDeclutter)(declutterReplays, context, rotation, 1, hifi, frameState.declutterItems);
    }

    if (clipped) {
      context.restore();
    }

    this.postRender(context, frameState);
    var opacity = layerState.opacity;
    var container = this.container;

    if (opacity !== parseFloat(container.style.opacity)) {
      container.style.opacity = opacity === 1 ? '' : opacity;
    }

    return this.container;
  };
  /**
   * @inheritDoc
   */


  CanvasVectorLayerRenderer.prototype.getFeatures = function (pixel) {
    return new Promise(function (resolve, reject) {
      if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        var size = [this.context.canvas.width, this.context.canvas.height];
        (0, _transform.apply)(this.pixelTransform, size);
        var center = this.renderedCenter_;
        var resolution = this.renderedResolution_;
        var rotation = this.renderedRotation_;
        var projection = this.renderedProjection_;
        var extent = this.renderedExtent_;
        var layer = this.getLayer();
        var transforms = [];
        var width = size[0] / 2;
        var height = size[1] / 2;
        transforms.push(this.getRenderTransform(center, resolution, rotation, 0.5, width, height, 0).slice());
        var source = layer.getSource();
        var projectionExtent = projection.getExtent();

        if (source.getWrapX() && projection.canWrapX() && !(0, _extent.containsExtent)(projectionExtent, extent)) {
          var startX = extent[0];
          var worldWidth = (0, _extent.getWidth)(projectionExtent);
          var world = 0;
          var offsetX = void 0;

          while (startX < projectionExtent[0]) {
            --world;
            offsetX = worldWidth * world;
            transforms.push(this.getRenderTransform(center, resolution, rotation, 0.5, width, height, offsetX).slice());
            startX += worldWidth;
          }

          world = 0;
          startX = extent[2];

          while (startX > projectionExtent[2]) {
            ++world;
            offsetX = worldWidth * world;
            transforms.push(this.getRenderTransform(center, resolution, rotation, 0.5, width, height, offsetX).slice());
            startX -= worldWidth;
          }
        }

        this.hitDetectionImageData_ = (0, _hitdetect.createHitDetectionImageData)(size, transforms, this.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation);
      }

      resolve((0, _hitdetect.hitDetect)(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
    }.bind(this));
  };
  /**
   * @inheritDoc
   */


  CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, declutteredFeatures) {
    if (!this.replayGroup_) {
      return undefined;
    } else {
      var resolution = frameState.viewState.resolution;
      var rotation = frameState.viewState.rotation;
      var layer_1 = this.getLayer();
      /** @type {!Object<string, boolean>} */

      var features_1 = {};
      var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance,
      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @return {?} Callback result.
       */
      function (feature) {
        var key = (0, _util.getUid)(feature);

        if (!(key in features_1)) {
          features_1[key] = true;
          return callback(feature, layer_1);
        }
      }, layer_1.getDeclutter() ? declutteredFeatures : null);
      return result;
    }
  };
  /**
   * @inheritDoc
   */


  CanvasVectorLayerRenderer.prototype.handleFontsChanged = function () {
    var layer = this.getLayer();

    if (layer.getVisible() && this.replayGroup_) {
      layer.changed();
    }
  };
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */


  CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function (event) {
    this.renderIfReadyAndVisible();
  };
  /**
   * @inheritDoc
   */


  CanvasVectorLayerRenderer.prototype.prepareFrame = function (frameState) {
    var vectorLayer = this.getLayer();
    var vectorSource = vectorLayer.getSource();

    if (!vectorSource) {
      return false;
    }

    var animating = frameState.viewHints[_ViewHint.default.ANIMATING];
    var interacting = frameState.viewHints[_ViewHint.default.INTERACTING];
    var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
    var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

    if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
      this.animatingOrInteracting_ = true;
      return true;
    }

    this.animatingOrInteracting_ = false;
    var frameStateExtent = frameState.extent;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var resolution = viewState.resolution;
    var pixelRatio = frameState.pixelRatio;
    var vectorLayerRevision = vectorLayer.getRevision();
    var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
    var vectorLayerRenderOrder = vectorLayer.getRenderOrder();

    if (vectorLayerRenderOrder === undefined) {
      vectorLayerRenderOrder = _vector.defaultOrder;
    }

    var center = viewState.center.slice();
    var extent = (0, _extent.buffer)(frameStateExtent, vectorLayerRenderBuffer * resolution);
    var loadExtents = [extent.slice()];
    var projectionExtent = projection.getExtent();

    if (vectorSource.getWrapX() && projection.canWrapX() && !(0, _extent.containsExtent)(projectionExtent, frameState.extent)) {
      // For the replay group, we need an extent that intersects the real world
      // (-180° to +180°). To support geometries in a coordinate range from -540°
      // to +540°, we add at least 1 world width on each side of the projection
      // extent. If the viewport is wider than the world, we need to add half of
      // the viewport width to make sure we cover the whole viewport.
      var worldWidth = (0, _extent.getWidth)(projectionExtent);
      var gutter = Math.max((0, _extent.getWidth)(extent) / 2, worldWidth);
      extent[0] = projectionExtent[0] - gutter;
      extent[2] = projectionExtent[2] + gutter;
      (0, _coordinate.wrapX)(center, projection);
      var loadExtent = (0, _extent.wrapX)(loadExtents[0], projection); // If the extent crosses the date line, we load data for both edges of the worlds

      if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
        loadExtents.push([loadExtent[0] + worldWidth, loadExtent[1], loadExtent[2] + worldWidth, loadExtent[3]]);
      } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
        loadExtents.push([loadExtent[0] - worldWidth, loadExtent[1], loadExtent[2] - worldWidth, loadExtent[3]]);
      }
    }

    if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && (0, _extent.containsExtent)(this.renderedExtent_, extent)) {
      this.replayGroupChanged = false;
      return true;
    }

    this.replayGroup_ = null;
    this.dirty_ = false;
    var replayGroup = new _BuilderGroup.default((0, _vector.getTolerance)(resolution, pixelRatio), extent, resolution, pixelRatio, vectorLayer.getDeclutter());
    var userProjection = (0, _proj.getUserProjection)();
    var userTransform;

    if (userProjection) {
      for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
        vectorSource.loadFeatures((0, _proj.toUserExtent)(loadExtents[i], projection), resolution, userProjection);
      }

      userTransform = (0, _proj.getTransformFromProjections)(userProjection, projection);
    } else {
      for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
        vectorSource.loadFeatures(loadExtents[i], resolution, projection);
      }
    }

    var squaredTolerance = (0, _vector.getSquaredTolerance)(resolution, pixelRatio);
    /**
     * @param {import("../../Feature.js").default} feature Feature.
     * @this {CanvasVectorLayerRenderer}
     */

    var render = function (feature) {
      var styles;
      var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();

      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }

      if (styles) {
        var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform);
        this.dirty_ = this.dirty_ || dirty;
      }
    }.bind(this);

    var userExtent = (0, _proj.toUserExtent)(extent, projection);
    /** @type {Array<import("../../Feature.js").default>} */

    var features = vectorSource.getFeaturesInExtent(userExtent);

    if (vectorLayerRenderOrder) {
      features.sort(vectorLayerRenderOrder);
    }

    for (var i = 0, ii = features.length; i < ii; ++i) {
      render(features[i]);
    }

    this.renderedFeatures_ = features;
    var replayGroupInstructions = replayGroup.finish();
    var executorGroup = new _ExecutorGroup.default(extent, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());
    this.renderedResolution_ = resolution;
    this.renderedRevision_ = vectorLayerRevision;
    this.renderedRenderOrder_ = vectorLayerRenderOrder;
    this.renderedExtent_ = extent;
    this.renderedRotation_ = viewState.rotation;
    this.renderedCenter_ = center;
    this.renderedProjection_ = projection;
    this.replayGroup_ = executorGroup;
    this.hitDetectionImageData_ = null;
    this.replayGroupChanged = true;
    return true;
  };
  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction=} opt_transform Transform from user to view projection.
   * @return {boolean} `true` if an image is loading.
   */


  CanvasVectorLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, builderGroup, opt_transform) {
    if (!styles) {
      return false;
    }

    var loading = false;

    if (Array.isArray(styles)) {
      for (var i = 0, ii = styles.length; i < ii; ++i) {
        loading = (0, _vector.renderFeature)(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, opt_transform) || loading;
      }
    } else {
      loading = (0, _vector.renderFeature)(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, opt_transform);
    }

    return loading;
  };

  return CanvasVectorLayerRenderer;
}(_Layer.default);

var _default = CanvasVectorLayerRenderer;
exports.default = _default;
},{"../../util.js":"node_modules/ol/util.js","../../ViewHint.js":"node_modules/ol/ViewHint.js","../../extent.js":"node_modules/ol/extent.js","../../coordinate.js":"node_modules/ol/coordinate.js","../../proj.js":"node_modules/ol/proj.js","../../render/canvas/BuilderGroup.js":"node_modules/ol/render/canvas/BuilderGroup.js","../../render/canvas/ExecutorGroup.js":"node_modules/ol/render/canvas/ExecutorGroup.js","./Layer.js":"node_modules/ol/renderer/canvas/Layer.js","../vector.js":"node_modules/ol/renderer/vector.js","../../transform.js":"node_modules/ol/transform.js","../../render/canvas/hitdetect.js":"node_modules/ol/render/canvas/hitdetect.js"}],"node_modules/ol/layer/Vector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _BaseVector = _interopRequireDefault(require("./BaseVector.js"));

var _VectorLayer = _interopRequireDefault(require("../renderer/canvas/VectorLayer.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/Vector
 */


/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @extends {BaseVectorLayer<import("../source/Vector.js").default>}
 * @api
 */
var VectorLayer =
/** @class */
function (_super) {
  __extends(VectorLayer, _super);
  /**
   * @param {import("./BaseVector.js").Options=} opt_options Options.
   */


  function VectorLayer(opt_options) {
    return _super.call(this, opt_options) || this;
  }
  /**
   * Create a renderer for this layer.
   * @return {import("../renderer/Layer.js").default} A layer renderer.
   * @protected
   */


  VectorLayer.prototype.createRenderer = function () {
    return new _VectorLayer.default(this);
  };

  return VectorLayer;
}(_BaseVector.default);

var _default = VectorLayer;
exports.default = _default;
},{"./BaseVector.js":"node_modules/ol/layer/BaseVector.js","../renderer/canvas/VectorLayer.js":"node_modules/ol/renderer/canvas/VectorLayer.js"}],"node_modules/ol/featureloader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadFeaturesXhr = loadFeaturesXhr;
exports.xhr = xhr;
exports.setWithCredentials = setWithCredentials;

var _functions = require("./functions.js");

var _FormatType = _interopRequireDefault(require("./format/FormatType.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/featureloader
 */

/**
 *
 * @type {boolean}
 * @private
 */
var withCredentials = false;
/**
 * {@link module:ol/source/Vector} sources use a function of this type to
 * load features.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area to be loaded,
 * a `{number}` representing the resolution (map units per pixel) and an
 * {@link module:ol/proj/Projection} for the projection  as
 * arguments. `this` within the function is bound to the
 * {@link module:ol/source/Vector} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default), import("./extent.js").Extent, number,
 *                    import("./proj/Projection.js").default): void} FeatureLoader
 * @api
 */

/**
 * {@link module:ol/source/Vector} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module:ol/proj/Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
 * @api
 */

/**
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @param {function(this:import("./VectorTile.js").default, Array<import("./Feature.js").default>, import("./proj/Projection.js").default, import("./extent.js").Extent): void|function(this:import("./source/Vector").default, Array<import("./Feature.js").default>): void} success
 *     Function called with the loaded features and optionally with the data
 *     projection. Called with the vector tile or source as `this`.
 * @param {function(this:import("./VectorTile.js").default): void|function(this:import("./source/Vector").default): void} failure
 *     Function called when loading failed. Called with the vector tile or
 *     source as `this`.
 * @return {FeatureLoader} The feature loader.
 */

function loadFeaturesXhr(url, format, success, failure) {
  return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @this {import("./source/Vector").default|import("./VectorTile.js").default}
     */
    function (extent, resolution, projection) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);

      if (format.getType() == _FormatType.default.ARRAY_BUFFER) {
        xhr.responseType = 'arraybuffer';
      }

      xhr.withCredentials = withCredentials;
      /**
       * @param {Event} event Event.
       * @private
       */

      xhr.onload = function (event) {
        // status will be 0 for file:// urls
        if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
          var type = format.getType();
          /** @type {Document|Node|Object|string|undefined} */

          var source = void 0;

          if (type == _FormatType.default.JSON || type == _FormatType.default.TEXT) {
            source = xhr.responseText;
          } else if (type == _FormatType.default.XML) {
            source = xhr.responseXML;

            if (!source) {
              source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
            }
          } else if (type == _FormatType.default.ARRAY_BUFFER) {
            source =
            /** @type {ArrayBuffer} */
            xhr.response;
          }

          if (source) {
            success.call(this, format.readFeatures(source, {
              extent: extent,
              featureProjection: projection
            }), format.readProjection(source));
          } else {
            failure.call(this);
          }
        } else {
          failure.call(this);
        }
      }.bind(this);
      /**
       * @private
       */


      xhr.onerror = function () {
        failure.call(this);
      }.bind(this);

      xhr.send();
    }
  );
}
/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @return {FeatureLoader} The feature loader.
 * @api
 */


function xhr(url, format) {
  return loadFeaturesXhr(url, format,
  /**
   * @param {Array<import("./Feature.js").default>} features The loaded features.
   * @param {import("./proj/Projection.js").default} dataProjection Data
   * projection.
   * @this {import("./source/Vector").default|import("./VectorTile.js").default}
   */
  function (features, dataProjection) {
    var sourceOrTile =
    /** @type {?} */
    this;

    if (typeof sourceOrTile.addFeatures === 'function') {
      /** @type {import("./source/Vector").default} */
      sourceOrTile.addFeatures(features);
    }
  },
  /* FIXME handle error */
  _functions.VOID);
}
/**
 * Setter for the withCredentials configuration for the XHR.
 *
 * @param {boolean} xhrWithCredentials The value of withCredentials to set.
 * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/
 * @api
 */


function setWithCredentials(xhrWithCredentials) {
  withCredentials = xhrWithCredentials;
}
},{"./functions.js":"node_modules/ol/functions.js","./format/FormatType.js":"node_modules/ol/format/FormatType.js"}],"node_modules/ol/loadingstrategy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.all = all;
exports.bbox = bbox;
exports.tile = tile;

/**
 * @module ol/loadingstrategy
 */

/**
 * Strategy function for loading all features with a single request.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
function all(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}
/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */


function bbox(extent, resolution) {
  return [extent];
}
/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {function(import("./extent.js").Extent, number): Array<import("./extent.js").Extent>} Loading strategy.
 * @api
 */


function tile(tileGrid) {
  return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */
    function (extent, resolution) {
      var z = tileGrid.getZForResolution(resolution);
      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
      /** @type {Array<import("./extent.js").Extent>} */

      var extents = [];
      /** @type {import("./tilecoord.js").TileCoord} */

      var tileCoord = [z, 0, 0];

      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
          extents.push(tileGrid.getTileCoordExtent(tileCoord));
        }
      }

      return extents;
    }
  );
}
},{}],"node_modules/ol/source/Source.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("../util.js");

var _Object = _interopRequireDefault(require("../Object.js"));

var _proj = require("../proj.js");

var _State = _interopRequireDefault(require("./State.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/source/Source
 */


/**
 * A function that returns a string or an array of strings representing source
 * attributions.
 *
 * @typedef {function(import("../PluggableMap.js").FrameState): (string|Array<string>)} Attribution
 */

/**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'© Acme Inc.'`)
 * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
 * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */

/**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions]
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {SourceState} [state='ready']
 * @property {boolean} [wrapX=false]
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */
var Source =
/** @class */
function (_super) {
  __extends(Source, _super);
  /**
   * @param {Options} options Source options.
   */


  function Source(options) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */


    _this.projection_ = (0, _proj.get)(options.projection);
    /**
     * @private
     * @type {?Attribution}
     */

    _this.attributions_ = adaptAttributions(options.attributions);
    /**
     * @private
     * @type {boolean}
     */

    _this.attributionsCollapsible_ = options.attributionsCollapsible !== undefined ? options.attributionsCollapsible : true;
    /**
     * This source is currently loading data. Sources that defer loading to the
     * map's tile queue never set this to `true`.
     * @type {boolean}
     */

    _this.loading = false;
    /**
     * @private
     * @type {SourceState}
     */

    _this.state_ = options.state !== undefined ? options.state : _State.default.READY;
    /**
     * @private
     * @type {boolean}
     */

    _this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
    return _this;
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   */


  Source.prototype.getAttributions = function () {
    return this.attributions_;
  };
  /**
   * @return {boolean} Attributions are collapsible.
   */


  Source.prototype.getAttributionsCollapsible = function () {
    return this.attributionsCollapsible_;
  };
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */


  Source.prototype.getProjection = function () {
    return this.projection_;
  };
  /**
   * @abstract
   * @return {Array<number>|undefined} Resolutions.
   */


  Source.prototype.getResolutions = function () {
    return (0, _util.abstract)();
  };
  /**
   * Get the state of the source, see {@link module:ol/source/State~State} for possible states.
   * @return {SourceState} State.
   * @api
   */


  Source.prototype.getState = function () {
    return this.state_;
  };
  /**
   * @return {boolean|undefined} Wrap X.
   */


  Source.prototype.getWrapX = function () {
    return this.wrapX_;
  };
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */


  Source.prototype.refresh = function () {
    this.changed();
  };
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */


  Source.prototype.setAttributions = function (attributions) {
    this.attributions_ = adaptAttributions(attributions);
    this.changed();
  };
  /**
   * Set the state of the source.
   * @param {SourceState} state State.
   * @protected
   */


  Source.prototype.setState = function (state) {
    this.state_ = state;
    this.changed();
  };

  return Source;
}(_Object.default);
/**
 * Turns the attributions option into an attributions function.
 * @param {AttributionLike|undefined} attributionLike The attribution option.
 * @return {?Attribution} An attribution function (or null).
 */


function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }

  if (Array.isArray(attributionLike)) {
    return function (frameState) {
      return attributionLike;
    };
  }

  if (typeof attributionLike === 'function') {
    return attributionLike;
  }

  return function (frameState) {
    return [attributionLike];
  };
}

var _default = Source;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","../Object.js":"node_modules/ol/Object.js","../proj.js":"node_modules/ol/proj.js","./State.js":"node_modules/ol/source/State.js"}],"node_modules/ol/source/VectorEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/source/VectorEventType
 */

/**
 * @enum {string}
 */
var _default = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: 'addfeature',

  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: 'changefeature',

  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: 'clear',

  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: 'removefeature'
};
exports.default = _default;
},{}],"node_modules/ol/structs/RBush.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("../util.js");

var _rbush = _interopRequireDefault(require("rbush/rbush.js"));

var _extent = require("../extent.js");

var _obj = require("../obj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/structs/RBush
 */

/**
 * @typedef {Object} Entry
 * @property {number} minX
 * @property {number} minY
 * @property {number} maxX
 * @property {number} maxY
 * @property {Object} [value]
 */

/**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template T
 */
var RBush =
/** @class */
function () {
  /**
   * @param {number=} opt_maxEntries Max entries.
   */
  function RBush(opt_maxEntries) {
    /**
     * @private
     */
    this.rbush_ = new _rbush.default(opt_maxEntries);
    /**
     * A mapping between the objects added to this rbush wrapper
     * and the objects that are actually added to the internal rbush.
     * @private
     * @type {Object<string, Entry>}
     */

    this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */


  RBush.prototype.insert = function (extent, value) {
    /** @type {Entry} */
    var item = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
      value: value
    };
    this.rbush_.insert(item);
    this.items_[(0, _util.getUid)(value)] = item;
  };
  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */


  RBush.prototype.load = function (extents, values) {
    var items = new Array(values.length);

    for (var i = 0, l = values.length; i < l; i++) {
      var extent = extents[i];
      var value = values[i];
      /** @type {Entry} */

      var item = {
        minX: extent[0],
        minY: extent[1],
        maxX: extent[2],
        maxY: extent[3],
        value: value
      };
      items[i] = item;
      this.items_[(0, _util.getUid)(value)] = item;
    }

    this.rbush_.load(items);
  };
  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */


  RBush.prototype.remove = function (value) {
    var uid = (0, _util.getUid)(value); // get the object in which the value was wrapped when adding to the
    // internal rbush. then use that object to do the removal.

    var item = this.items_[uid];
    delete this.items_[uid];
    return this.rbush_.remove(item) !== null;
  };
  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */


  RBush.prototype.update = function (extent, value) {
    var item = this.items_[(0, _util.getUid)(value)];
    var bbox = [item.minX, item.minY, item.maxX, item.maxY];

    if (!(0, _extent.equals)(bbox, extent)) {
      this.remove(value);
      this.insert(extent, value);
    }
  };
  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */


  RBush.prototype.getAll = function () {
    var items = this.rbush_.all();
    return items.map(function (item) {
      return item.value;
    });
  };
  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */


  RBush.prototype.getInExtent = function (extent) {
    /** @type {Entry} */
    var bbox = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3]
    };
    var items = this.rbush_.search(bbox);
    return items.map(function (item) {
      return item.value;
    });
  };
  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */


  RBush.prototype.forEach = function (callback) {
    return this.forEach_(this.getAll(), callback);
  };
  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */


  RBush.prototype.forEachInExtent = function (extent, callback) {
    return this.forEach_(this.getInExtent(extent), callback);
  };
  /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */


  RBush.prototype.forEach_ = function (values, callback) {
    var result;

    for (var i = 0, l = values.length; i < l; i++) {
      result = callback(values[i]);

      if (result) {
        return result;
      }
    }

    return result;
  };
  /**
   * @return {boolean} Is empty.
   */


  RBush.prototype.isEmpty = function () {
    return (0, _obj.isEmpty)(this.items_);
  };
  /**
   * Remove all values from the RBush.
   */


  RBush.prototype.clear = function () {
    this.rbush_.clear();
    this.items_ = {};
  };
  /**
   * @param {import("../extent.js").Extent=} opt_extent Extent.
   * @return {import("../extent.js").Extent} Extent.
   */


  RBush.prototype.getExtent = function (opt_extent) {
    var data = this.rbush_.toJSON();
    return (0, _extent.createOrUpdate)(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
  };
  /**
   * @param {RBush} rbush R-Tree.
   */


  RBush.prototype.concat = function (rbush) {
    this.rbush_.load(rbush.rbush_.all());

    for (var i in rbush.items_) {
      this.items_[i] = rbush.items_[i];
    }
  };

  return RBush;
}();

var _default = RBush;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","rbush/rbush.js":"node_modules/rbush/rbush.js","../extent.js":"node_modules/ol/extent.js","../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/source/Vector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.VectorSourceEvent = void 0;

var _util = require("../util.js");

var _Collection = _interopRequireDefault(require("../Collection.js"));

var _CollectionEventType = _interopRequireDefault(require("../CollectionEventType.js"));

var _ObjectEventType = _interopRequireDefault(require("../ObjectEventType.js"));

var _array = require("../array.js");

var _asserts = require("../asserts.js");

var _events = require("../events.js");

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _extent = require("../extent.js");

var _featureloader = require("../featureloader.js");

var _functions = require("../functions.js");

var _loadingstrategy = require("../loadingstrategy.js");

var _obj = require("../obj.js");

var _Source = _interopRequireDefault(require("./Source.js"));

var _State = _interopRequireDefault(require("./State.js"));

var _VectorEventType = _interopRequireDefault(require("./VectorEventType.js"));

var _RBush = _interopRequireDefault(require("../structs/RBush.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/Vector
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module:ol/loadingstrategy} strategies.
 *
 * @typedef {function(import("../extent.js").Extent, number): Array<import("../extent.js").Extent>} LoadingStrategy
 * @api
 */

/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Vector} instances are instances of this
 * type.
 * @template {import("../geom/Geometry.js").default} Geometry
 */
var VectorSourceEvent =
/** @class */
function (_super) {
  __extends(VectorSourceEvent, _super);
  /**
   * @param {string} type Type.
   * @param {import("../Feature.js").default<Geometry>=} opt_feature Feature.
   */


  function VectorSourceEvent(type, opt_feature) {
    var _this = _super.call(this, type) || this;
    /**
     * The feature being added or removed.
     * @type {import("../Feature.js").default<Geometry>|undefined}
     * @api
     */


    _this.feature = opt_feature;
    return _this;
  }

  return VectorSourceEvent;
}(_Event.default);

exports.VectorSourceEvent = VectorSourceEvent;

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {Array<import("../Feature.js").default>|Collection<import("../Feature.js").default>} [features]
 * Features. If provided as {@link module:ol/Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {import("../featureloader.js").FeatureLoader} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader.
 *
 * Example:
 *
 * ```js
 * import {Vector} from 'ol/source';
 * import {GeoJSON} from 'ol/format';
 * import {bbox} from 'ol/loadingstrategy';
 *
 * var vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection) {
 *      var proj = projection.getCode();
 *      var url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      var xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      var onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          vectorSource.addFeatures(
 *              vectorSource.getFormat().readFeatures(xhr.responseText));
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:ol/loadingstrategy~all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:ol/featureloader~xhr}). Use a `string` and an
 * {@link module:ol/loadingstrategy~all} for a one-off download of all features from
 * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:ol/Collection}, which can be retrieved through
 * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180° and 180° meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 */

/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires VectorSourceEvent
 * @api
 * @template {import("../geom/Geometry.js").default} Geometry
 */
var VectorSource =
/** @class */
function (_super) {
  __extends(VectorSource, _super);
  /**
   * @param {Options=} opt_options Vector source options.
   */


  function VectorSource(opt_options) {
    var _this = this;

    var options = opt_options || {};
    _this = _super.call(this, {
      attributions: options.attributions,
      projection: undefined,
      state: _State.default.READY,
      wrapX: options.wrapX !== undefined ? options.wrapX : true
    }) || this;
    /**
     * @private
     * @type {import("../featureloader.js").FeatureLoader}
     */

    _this.loader_ = _functions.VOID;
    /**
     * @private
     * @type {import("../format/Feature.js").default|undefined}
     */

    _this.format_ = options.format;
    /**
     * @private
     * @type {boolean}
     */

    _this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;
    /**
     * @private
     * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
     */

    _this.url_ = options.url;

    if (options.loader !== undefined) {
      _this.loader_ = options.loader;
    } else if (_this.url_ !== undefined) {
      (0, _asserts.assert)(_this.format_, 7); // `format` must be set when `url` is set
      // create a XHR feature loader for "url" and "format"

      _this.loader_ = (0, _featureloader.xhr)(_this.url_,
      /** @type {import("../format/Feature.js").default} */
      _this.format_);
    }
    /**
     * @private
     * @type {LoadingStrategy}
     */


    _this.strategy_ = options.strategy !== undefined ? options.strategy : _loadingstrategy.all;
    var useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;
    /**
     * @private
     * @type {RBush<import("../Feature.js").default<Geometry>>}
     */

    _this.featuresRtree_ = useSpatialIndex ? new _RBush.default() : null;
    /**
     * @private
     * @type {RBush<{extent: import("../extent.js").Extent}>}
     */

    _this.loadedExtentsRtree_ = new _RBush.default();
    /**
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */

    _this.nullGeometryFeatures_ = {};
    /**
     * A lookup of features by id (the return from feature.getId()).
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */

    _this.idIndex_ = {};
    /**
     * A lookup of features by uid (using getUid(feature)).
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */

    _this.uidIndex_ = {};
    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */

    _this.featureChangeKeys_ = {};
    /**
     * @private
     * @type {Collection<import("../Feature.js").default<Geometry>>}
     */

    _this.featuresCollection_ = null;
    var collection, features;

    if (Array.isArray(options.features)) {
      features = options.features;
    } else if (options.features) {
      collection = options.features;
      features = collection.getArray();
    }

    if (!useSpatialIndex && collection === undefined) {
      collection = new _Collection.default(features);
    }

    if (features !== undefined) {
      _this.addFeaturesInternal(features);
    }

    if (collection !== undefined) {
      _this.bindFeaturesCollection_(collection);
    }

    return _this;
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to add.
   * @api
   */


  VectorSource.prototype.addFeature = function (feature) {
    this.addFeatureInternal(feature);
    this.changed();
  };
  /**
   * Add a feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @protected
   */


  VectorSource.prototype.addFeatureInternal = function (feature) {
    var featureKey = (0, _util.getUid)(feature);

    if (!this.addToIndex_(featureKey, feature)) {
      if (this.featuresCollection_) {
        this.featuresCollection_.remove(feature);
      }

      return;
    }

    this.setupChangeEvents_(featureKey, feature);
    var geometry = feature.getGeometry();

    if (geometry) {
      var extent = geometry.getExtent();

      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent, feature);
      }
    } else {
      this.nullGeometryFeatures_[featureKey] = feature;
    }

    this.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.ADDFEATURE, feature));
  };
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @private
   */


  VectorSource.prototype.setupChangeEvents_ = function (featureKey, feature) {
    this.featureChangeKeys_[featureKey] = [(0, _events.listen)(feature, _EventType.default.CHANGE, this.handleFeatureChange_, this), (0, _events.listen)(feature, _ObjectEventType.default.PROPERTYCHANGE, this.handleFeatureChange_, this)];
  };
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */


  VectorSource.prototype.addToIndex_ = function (featureKey, feature) {
    var valid = true;
    var id = feature.getId();

    if (id !== undefined) {
      if (!(id.toString() in this.idIndex_)) {
        this.idIndex_[id.toString()] = feature;
      } else {
        valid = false;
      }
    }

    if (valid) {
      (0, _asserts.assert)(!(featureKey in this.uidIndex_), 30); // The passed `feature` was already added to the source

      this.uidIndex_[featureKey] = feature;
    }

    return valid;
  };
  /**
   * Add a batch of features to the source.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features to add.
   * @api
   */


  VectorSource.prototype.addFeatures = function (features) {
    this.addFeaturesInternal(features);
    this.changed();
  };
  /**
   * Add features without firing a `change` event.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features.
   * @protected
   */


  VectorSource.prototype.addFeaturesInternal = function (features) {
    var extents = [];
    var newFeatures = [];
    var geometryFeatures = [];

    for (var i = 0, length_1 = features.length; i < length_1; i++) {
      var feature = features[i];
      var featureKey = (0, _util.getUid)(feature);

      if (this.addToIndex_(featureKey, feature)) {
        newFeatures.push(feature);
      }
    }

    for (var i = 0, length_2 = newFeatures.length; i < length_2; i++) {
      var feature = newFeatures[i];
      var featureKey = (0, _util.getUid)(feature);
      this.setupChangeEvents_(featureKey, feature);
      var geometry = feature.getGeometry();

      if (geometry) {
        var extent = geometry.getExtent();
        extents.push(extent);
        geometryFeatures.push(feature);
      } else {
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    }

    if (this.featuresRtree_) {
      this.featuresRtree_.load(extents, geometryFeatures);
    }

    for (var i = 0, length_3 = newFeatures.length; i < length_3; i++) {
      this.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.ADDFEATURE, newFeatures[i]));
    }
  };
  /**
   * @param {!Collection<import("../Feature.js").default<Geometry>>} collection Collection.
   * @private
   */


  VectorSource.prototype.bindFeaturesCollection_ = function (collection) {
    var modifyingCollection = false;
    this.addEventListener(_VectorEventType.default.ADDFEATURE,
    /**
     * @param {VectorSourceEvent<Geometry>} evt The vector source event
     */
    function (evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        collection.push(evt.feature);
        modifyingCollection = false;
      }
    });
    this.addEventListener(_VectorEventType.default.REMOVEFEATURE,
    /**
     * @param {VectorSourceEvent<Geometry>} evt The vector source event
     */
    function (evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        collection.remove(evt.feature);
        modifyingCollection = false;
      }
    });
    collection.addEventListener(_CollectionEventType.default.ADD,
    /**
     * @param {import("../Collection.js").CollectionEvent} evt The collection event
     */
    function (evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        this.addFeature(
        /** @type {import("../Feature.js").default<Geometry>} */
        evt.element);
        modifyingCollection = false;
      }
    }.bind(this));
    collection.addEventListener(_CollectionEventType.default.REMOVE,
    /**
     * @param {import("../Collection.js").CollectionEvent} evt The collection event
     */
    function (evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        this.removeFeature(
        /** @type {import("../Feature.js").default<Geometry>} */
        evt.element);
        modifyingCollection = false;
      }
    }.bind(this));
    this.featuresCollection_ = collection;
  };
  /**
   * Remove all features from the source.
   * @param {boolean=} opt_fast Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.
   * @api
   */


  VectorSource.prototype.clear = function (opt_fast) {
    if (opt_fast) {
      for (var featureId in this.featureChangeKeys_) {
        var keys = this.featureChangeKeys_[featureId];
        keys.forEach(_events.unlistenByKey);
      }

      if (!this.featuresCollection_) {
        this.featureChangeKeys_ = {};
        this.idIndex_ = {};
        this.uidIndex_ = {};
      }
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.forEach(this.removeFeatureInternal.bind(this));

        for (var id in this.nullGeometryFeatures_) {
          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
        }
      }
    }

    if (this.featuresCollection_) {
      this.featuresCollection_.clear();
    }

    if (this.featuresRtree_) {
      this.featuresRtree_.clear();
    }

    this.nullGeometryFeatures_ = {};
    var clearEvent = new VectorSourceEvent(_VectorEventType.default.CLEAR);
    this.dispatchEvent(clearEvent);
    this.changed();
  };
  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */


  VectorSource.prototype.forEachFeature = function (callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEach(callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  };
  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */


  VectorSource.prototype.forEachFeatureAtCoordinateDirect = function (coordinate, callback) {
    var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
    return this.forEachFeatureInExtent(extent, function (feature) {
      var geometry = feature.getGeometry();

      if (geometry.intersectsCoordinate(coordinate)) {
        return callback(feature);
      } else {
        return undefined;
      }
    });
  };
  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */


  VectorSource.prototype.forEachFeatureInExtent = function (extent, callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEachInExtent(extent, callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  };
  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */


  VectorSource.prototype.forEachFeatureIntersectingExtent = function (extent, callback) {
    return this.forEachFeatureInExtent(extent,
    /**
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     * @return {T|undefined} The return value from the last call to the callback.
     */
    function (feature) {
      var geometry = feature.getGeometry();

      if (geometry.intersectsExtent(extent)) {
        var result = callback(feature);

        if (result) {
          return result;
        }
      }
    });
  };
  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection} as `features`.
   * @return {Collection<import("../Feature.js").default<Geometry>>} The collection of features.
   * @api
   */


  VectorSource.prototype.getFeaturesCollection = function () {
    return this.featuresCollection_;
  };
  /**
   * Get all features on the source in random order.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */


  VectorSource.prototype.getFeatures = function () {
    var features;

    if (this.featuresCollection_) {
      features = this.featuresCollection_.getArray();
    } else if (this.featuresRtree_) {
      features = this.featuresRtree_.getAll();

      if (!(0, _obj.isEmpty)(this.nullGeometryFeatures_)) {
        (0, _array.extend)(features, (0, _obj.getValues)(this.nullGeometryFeatures_));
      }
    }

    return (
      /** @type {Array<import("../Feature.js").default<Geometry>>} */
      features
    );
  };
  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */


  VectorSource.prototype.getFeaturesAtCoordinate = function (coordinate) {
    var features = [];
    this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {
      features.push(feature);
    });
    return features;
  };
  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */


  VectorSource.prototype.getFeaturesInExtent = function (extent) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.getInExtent(extent);
    } else if (this.featuresCollection_) {
      return this.featuresCollection_.getArray();
    } else {
      return [];
    }
  };
  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>):boolean=} opt_filter Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {import("../Feature.js").default<Geometry>} Closest feature.
   * @api
   */


  VectorSource.prototype.getClosestFeatureToCoordinate = function (coordinate, opt_filter) {
    // Find the closest feature using branch and bound.  We start searching an
    // infinite extent, and find the distance from the first feature found.  This
    // becomes the closest feature.  We then compute a smaller extent which any
    // closer feature must intersect.  We continue searching with this smaller
    // extent, trying to find a closer feature.  Every time we find a closer
    // feature, we update the extent being searched so that any even closer
    // feature must intersect it.  We continue until we run out of features.
    var x = coordinate[0];
    var y = coordinate[1];
    var closestFeature = null;
    var closestPoint = [NaN, NaN];
    var minSquaredDistance = Infinity;
    var extent = [-Infinity, -Infinity, Infinity, Infinity];
    var filter = opt_filter ? opt_filter : _functions.TRUE;
    this.featuresRtree_.forEachInExtent(extent,
    /**
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     */
    function (feature) {
      if (filter(feature)) {
        var geometry = feature.getGeometry();
        var previousMinSquaredDistance = minSquaredDistance;
        minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);

        if (minSquaredDistance < previousMinSquaredDistance) {
          closestFeature = feature; // This is sneaky.  Reduce the extent that it is currently being
          // searched while the R-Tree traversal using this same extent object
          // is still in progress.  This is safe because the new extent is
          // strictly contained by the old extent.

          var minDistance = Math.sqrt(minSquaredDistance);
          extent[0] = x - minDistance;
          extent[1] = y - minDistance;
          extent[2] = x + minDistance;
          extent[3] = y + minDistance;
        }
      }
    });
    return closestFeature;
  };
  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent=} opt_extent Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */


  VectorSource.prototype.getExtent = function (opt_extent) {
    return this.featuresRtree_.getExtent(opt_extent);
  };
  /**
   * Get a feature by its identifier (the value returned by feature.getId()).
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {import("../Feature.js").default<Geometry>} The feature (or `null` if not found).
   * @api
   */


  VectorSource.prototype.getFeatureById = function (id) {
    var feature = this.idIndex_[id.toString()];
    return feature !== undefined ? feature : null;
  };
  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {import("../Feature.js").default<Geometry>} The feature (or `null` if not found).
   */


  VectorSource.prototype.getFeatureByUid = function (uid) {
    var feature = this.uidIndex_[uid];
    return feature !== undefined ? feature : null;
  };
  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default|undefined} The feature format.
   * @api
   */


  VectorSource.prototype.getFormat = function () {
    return this.format_;
  };
  /**
   * @return {boolean} The source can have overlapping geometries.
   */


  VectorSource.prototype.getOverlaps = function () {
    return this.overlaps_;
  };
  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */


  VectorSource.prototype.getUrl = function () {
    return this.url_;
  };
  /**
   * @param {Event} event Event.
   * @private
   */


  VectorSource.prototype.handleFeatureChange_ = function (event) {
    var feature =
    /** @type {import("../Feature.js").default<Geometry>} */
    event.target;
    var featureKey = (0, _util.getUid)(feature);
    var geometry = feature.getGeometry();

    if (!geometry) {
      if (!(featureKey in this.nullGeometryFeatures_)) {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature);
        }

        this.nullGeometryFeatures_[featureKey] = feature;
      }
    } else {
      var extent = geometry.getExtent();

      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];

        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent, feature);
        }
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.update(extent, feature);
        }
      }
    }

    var id = feature.getId();

    if (id !== undefined) {
      var sid = id.toString();

      if (this.idIndex_[sid] !== feature) {
        this.removeFromIdIndex_(feature);
        this.idIndex_[sid] = feature;
      }
    } else {
      this.removeFromIdIndex_(feature);
      this.uidIndex_[featureKey] = feature;
    }

    this.changed();
    this.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.CHANGEFEATURE, feature));
  };
  /**
   * Returns true if the feature is contained within the source.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */


  VectorSource.prototype.hasFeature = function (feature) {
    var id = feature.getId();

    if (id !== undefined) {
      return id in this.idIndex_;
    } else {
      return (0, _util.getUid)(feature) in this.uidIndex_;
    }
  };
  /**
   * @return {boolean} Is empty.
   */


  VectorSource.prototype.isEmpty = function () {
    return this.featuresRtree_.isEmpty() && (0, _obj.isEmpty)(this.nullGeometryFeatures_);
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */


  VectorSource.prototype.loadFeatures = function (extent, resolution, projection) {
    var loadedExtentsRtree = this.loadedExtentsRtree_;
    var extentsToLoad = this.strategy_(extent, resolution);
    this.loading = false;

    var _loop_1 = function (i, ii) {
      var extentToLoad = extentsToLoad[i];
      var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,
      /**
       * @param {{extent: import("../extent.js").Extent}} object Object.
       * @return {boolean} Contains.
       */
      function (object) {
        return (0, _extent.containsExtent)(object.extent, extentToLoad);
      });

      if (!alreadyLoaded) {
        this_1.loader_.call(this_1, extentToLoad, resolution, projection);
        loadedExtentsRtree.insert(extentToLoad, {
          extent: extentToLoad.slice()
        });
        this_1.loading = this_1.loader_ !== _functions.VOID;
      }
    };

    var this_1 = this;

    for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) {
      _loop_1(i, ii);
    }
  };

  VectorSource.prototype.refresh = function () {
    this.clear(true);
    this.loadedExtentsRtree_.clear();

    _super.prototype.refresh.call(this);
  };
  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */


  VectorSource.prototype.removeLoadedExtent = function (extent) {
    var loadedExtentsRtree = this.loadedExtentsRtree_;
    var obj;
    loadedExtentsRtree.forEachInExtent(extent, function (object) {
      if ((0, _extent.equals)(object.extent, extent)) {
        obj = object;
        return true;
      }
    });

    if (obj) {
      loadedExtentsRtree.remove(obj);
    }
  };
  /**
   * Remove a single feature from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to remove.
   * @api
   */


  VectorSource.prototype.removeFeature = function (feature) {
    var featureKey = (0, _util.getUid)(feature);

    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }
    }

    this.removeFeatureInternal(feature);
    this.changed();
  };
  /**
   * Remove feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @protected
   */


  VectorSource.prototype.removeFeatureInternal = function (feature) {
    var featureKey = (0, _util.getUid)(feature);
    this.featureChangeKeys_[featureKey].forEach(_events.unlistenByKey);
    delete this.featureChangeKeys_[featureKey];
    var id = feature.getId();

    if (id !== undefined) {
      delete this.idIndex_[id.toString()];
    }

    delete this.uidIndex_[featureKey];
    this.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.REMOVEFEATURE, feature));
  };
  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */


  VectorSource.prototype.removeFromIdIndex_ = function (feature) {
    var removed = false;

    for (var id in this.idIndex_) {
      if (this.idIndex_[id] === feature) {
        delete this.idIndex_[id];
        removed = true;
        break;
      }
    }

    return removed;
  };
  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */


  VectorSource.prototype.setLoader = function (loader) {
    this.loader_ = loader;
  };
  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */


  VectorSource.prototype.setUrl = function (url) {
    (0, _asserts.assert)(this.format_, 7); // `format` must be set when `url` is set

    this.setLoader((0, _featureloader.xhr)(url, this.format_));
  };

  return VectorSource;
}(_Source.default);

var _default = VectorSource;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","../Collection.js":"node_modules/ol/Collection.js","../CollectionEventType.js":"node_modules/ol/CollectionEventType.js","../ObjectEventType.js":"node_modules/ol/ObjectEventType.js","../array.js":"node_modules/ol/array.js","../asserts.js":"node_modules/ol/asserts.js","../events.js":"node_modules/ol/events.js","../events/Event.js":"node_modules/ol/events/Event.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../extent.js":"node_modules/ol/extent.js","../featureloader.js":"node_modules/ol/featureloader.js","../functions.js":"node_modules/ol/functions.js","../loadingstrategy.js":"node_modules/ol/loadingstrategy.js","../obj.js":"node_modules/ol/obj.js","./Source.js":"node_modules/ol/source/Source.js","./State.js":"node_modules/ol/source/State.js","./VectorEventType.js":"node_modules/ol/source/VectorEventType.js","../structs/RBush.js":"node_modules/ol/structs/RBush.js"}],"node_modules/ol/interaction/Draw.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRegularPolygon = createRegularPolygon;
exports.createBox = createBox;
exports.default = void 0;

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Feature = _interopRequireDefault(require("../Feature.js"));

var _MapBrowserEventType = _interopRequireDefault(require("../MapBrowserEventType.js"));

var _MapBrowserPointerEvent = _interopRequireDefault(require("../MapBrowserPointerEvent.js"));

var _Object = require("../Object.js");

var _coordinate = require("../coordinate.js");

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _condition = require("../events/condition.js");

var _extent = require("../extent.js");

var _functions = require("../functions.js");

var _Circle = _interopRequireDefault(require("../geom/Circle.js"));

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _LineString = _interopRequireDefault(require("../geom/LineString.js"));

var _MultiLineString = _interopRequireDefault(require("../geom/MultiLineString.js"));

var _MultiPoint = _interopRequireDefault(require("../geom/MultiPoint.js"));

var _MultiPolygon = _interopRequireDefault(require("../geom/MultiPolygon.js"));

var _Point = _interopRequireDefault(require("../geom/Point.js"));

var _Polygon = _interopRequireWildcard(require("../geom/Polygon.js"));

var _Pointer = _interopRequireDefault(require("./Pointer.js"));

var _Property = _interopRequireDefault(require("./Property.js"));

var _Vector = _interopRequireDefault(require("../layer/Vector.js"));

var _Vector2 = _interopRequireDefault(require("../source/Vector.js"));

var _Style = require("../style/Style.js");

var _proj = require("../proj.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/Draw
 */


/**
 * @typedef {Object} Options
 * @property {GeometryType} type Geometry type of
 * the geometries being drawn with this instance.
 * @property {number} [clickTolerance=6] The maximum distance in pixels between
 * "down" and "up" for a "up" event to be considered a "click" event and
 * actually add a point/vertex to the geometry being drawn.  The default of `6`
 * was chosen for the draw interaction to behave correctly on mouse as well as
 * on touch devices.
 * @property {import("../Collection.js").default<Feature>} [features]
 * Destination collection for the drawn features.
 * @property {VectorSource} [source] Destination source for
 * the drawn features.
 * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown
 * before the current vertex can be dragged to its exact position.
 * @property {number} [snapTolerance=12] Pixel distance for snapping to the
 * drawing finish.
 * @property {boolean} [stopClick=false] Stop click, singleclick, and
 * doubleclick events from firing during drawing.
 * @property {number} [maxPoints] The number of points that can be drawn before
 * a polygon ring or line string is finished. By default there is no
 * restriction.
 * @property {number} [minPoints] The number of points that must be drawn
 * before a polygon ring or line string can be finished. Default is `3` for
 * polygon rings and `2` for line strings.
 * @property {import("../events/condition.js").Condition} [finishCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether the drawing can be finished.
 * @property {import("../style/Style.js").StyleLike} [style]
 * Style for sketch features.
 * @property {GeometryFunction} [geometryFunction]
 * Function that is called when a geometry's coordinates are updated.
 * @property {string} [geometryName] Geometry name to use for features created
 * by the draw interaction.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default {@link module:ol/events/condition~noModifierKeys}, i.e. a click,
 * adds a vertex or deactivates freehand drawing.
 * @property {boolean} [freehand=false] Operate in freehand mode for lines,
 * polygons, and circles.  This makes the interaction always operate in freehand
 * mode and takes precedence over any `freehandCondition` option.
 * @property {import("../events/condition.js").Condition} [freehandCondition]
 * Condition that activates freehand drawing for lines and polygons. This
 * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether that event should be handled. The
 * default is {@link module:ol/events/condition~shiftKeyOnly}, meaning that the
 * Shift key activates freehand drawing.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 */

/**
 * Coordinate type when drawing points.
 * @typedef {import("../coordinate.js").Coordinate} PointCoordType
 */

/**
 * Coordinate type when drawing lines.
 * @typedef {Array<import("../coordinate.js").Coordinate>} LineCoordType
 */

/**
 * Coordinate type when drawing polygons.
 * @typedef {Array<Array<import("../coordinate.js").Coordinate>>} PolyCoordType
 */

/**
 * Types used for drawing coordinates.
 * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType
 */

/**
 * Function that takes an array of coordinates and an optional existing geometry
 * and a projection as arguments, and returns a geometry. The optional existing
 * geometry is the geometry that is returned when the function is called without
 * a second argument.
 * @typedef {function(!SketchCoordType, import("../geom/SimpleGeometry.js").default=,
 *     import("../proj/Projection.js").default=):
 *     import("../geom/SimpleGeometry.js").default} GeometryFunction
 */

/**
 * Draw mode.  This collapses multi-part geometry types with their single-part
 * cousins.
 * @enum {string}
 */
var Mode = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  POLYGON: 'Polygon',
  CIRCLE: 'Circle'
};
/**
 * @enum {string}
 */

var DrawEventType = {
  /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */
  DRAWSTART: 'drawstart',

  /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */
  DRAWEND: 'drawend',

  /**
   * Triggered upon feature draw abortion
   * @event DrawEvent#drawabort
   * @api
   */
  DRAWABORT: 'drawabort'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are
 * instances of this type.
 */

var DrawEvent =
/** @class */
function (_super) {
  __extends(DrawEvent, _super);
  /**
   * @param {DrawEventType} type Type.
   * @param {Feature} feature The feature drawn.
   */


  function DrawEvent(type, feature) {
    var _this = _super.call(this, type) || this;
    /**
     * The feature being drawn.
     * @type {Feature}
     * @api
     */


    _this.feature = feature;
    return _this;
  }

  return DrawEvent;
}(_Event.default);
/**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @fires DrawEvent
 * @api
 */


var Draw =
/** @class */
function (_super) {
  __extends(Draw, _super);
  /**
   * @param {Options} options Options.
   */


  function Draw(options) {
    var _this = this;

    var pointerOptions =
    /** @type {import("./Pointer.js").Options} */
    options;

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions.FALSE;
    }

    _this = _super.call(this, pointerOptions) || this;
    /**
     * @type {boolean}
     * @private
     */

    _this.shouldHandle_ = false;
    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */

    _this.downPx_ = null;
    /**
     * @type {?}
     * @private
     */

    _this.downTimeout_;
    /**
     * @type {number|undefined}
     * @private
     */

    _this.lastDragTime_;
    /**
     * @type {boolean}
     * @private
     */

    _this.freehand_ = false;
    /**
     * Target source for drawn features.
     * @type {VectorSource}
     * @private
     */

    _this.source_ = options.source ? options.source : null;
    /**
     * Target collection for drawn features.
     * @type {import("../Collection.js").default<Feature>}
     * @private
     */

    _this.features_ = options.features ? options.features : null;
    /**
     * Pixel distance for snapping.
     * @type {number}
     * @private
     */

    _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;
    /**
     * Geometry type.
     * @type {GeometryType}
     * @private
     */

    _this.type_ =
    /** @type {GeometryType} */
    options.type;
    /**
     * Drawing mode (derived from geometry type.
     * @type {Mode}
     * @private
     */

    _this.mode_ = getMode(_this.type_);
    /**
     * Stop click, singleclick, and doubleclick events from firing during drawing.
     * Default is `false`.
     * @type {boolean}
     * @private
     */

    _this.stopClick_ = !!options.stopClick;
    /**
     * The number of points that must be drawn before a polygon ring or line
     * string can be finished.  The default is 3 for polygon rings and 2 for
     * line strings.
     * @type {number}
     * @private
     */

    _this.minPoints_ = options.minPoints ? options.minPoints : _this.mode_ === Mode.POLYGON ? 3 : 2;
    /**
     * The number of points that can be drawn before a polygon ring or line string
     * is finished. The default is no restriction.
     * @type {number}
     * @private
     */

    _this.maxPoints_ = options.maxPoints ? options.maxPoints : Infinity;
    /**
     * A function to decide if a potential finish coordinate is permissible
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.finishCondition_ = options.finishCondition ? options.finishCondition : _functions.TRUE;
    var geometryFunction = options.geometryFunction;

    if (!geometryFunction) {
      if (_this.type_ === _GeometryType.default.CIRCLE) {
        /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default=} opt_geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */
        geometryFunction = function (coordinates, opt_geometry, projection) {
          var circle = opt_geometry ?
          /** @type {Circle} */
          opt_geometry : new _Circle.default([NaN, NaN]);
          var center = (0, _proj.fromUserCoordinate)(coordinates[0], projection);
          var squaredLength = (0, _coordinate.squaredDistance)(center, (0, _proj.fromUserCoordinate)(coordinates[1], projection));
          circle.setCenterAndRadius(center, Math.sqrt(squaredLength));
          var userProjection = (0, _proj.getUserProjection)();

          if (userProjection) {
            circle.transform(projection, userProjection);
          }

          return circle;
        };
      } else {
        var Constructor_1;
        var mode_1 = _this.mode_;

        if (mode_1 === Mode.POINT) {
          Constructor_1 = _Point.default;
        } else if (mode_1 === Mode.LINE_STRING) {
          Constructor_1 = _LineString.default;
        } else if (mode_1 === Mode.POLYGON) {
          Constructor_1 = _Polygon.default;
        }
        /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default=} opt_geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */


        geometryFunction = function (coordinates, opt_geometry, projection) {
          var geometry = opt_geometry;

          if (geometry) {
            if (mode_1 === Mode.POLYGON) {
              if (coordinates[0].length) {
                // Add a closing coordinate to match the first
                geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);
              } else {
                geometry.setCoordinates([]);
              }
            } else {
              geometry.setCoordinates(coordinates);
            }
          } else {
            geometry = new Constructor_1(coordinates);
          }

          return geometry;
        };
      }
    }
    /**
     * @type {GeometryFunction}
     * @private
     */


    _this.geometryFunction_ = geometryFunction;
    /**
     * @type {number}
     * @private
     */

    _this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;
    /**
     * Finish coordinate for the feature (first point for polygons, last point for
     * linestrings).
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.finishCoordinate_ = null;
    /**
     * Sketch feature.
     * @type {Feature}
     * @private
     */

    _this.sketchFeature_ = null;
    /**
     * Sketch point.
     * @type {Feature<Point>}
     * @private
     */

    _this.sketchPoint_ = null;
    /**
     * Sketch coordinates. Used when drawing a line or polygon.
     * @type {SketchCoordType}
     * @private
     */

    _this.sketchCoords_ = null;
    /**
     * Sketch line. Used when drawing polygon.
     * @type {Feature<LineString>}
     * @private
     */

    _this.sketchLine_ = null;
    /**
     * Sketch line coordinates. Used when drawing a polygon or circle.
     * @type {LineCoordType}
     * @private
     */

    _this.sketchLineCoords_ = null;
    /**
     * Squared tolerance for handling up events.  If the squared distance
     * between a down and up event is greater than this tolerance, up events
     * will not be handled.
     * @type {number}
     * @private
     */

    _this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;
    /**
     * Draw overlay where our sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */

    _this.overlay_ = new _Vector.default({
      source: new _Vector2.default({
        useSpatialIndex: false,
        wrapX: options.wrapX ? options.wrapX : false
      }),
      style: options.style ? options.style : getDefaultStyleFunction(),
      updateWhileInteracting: true
    });
    /**
     * Name of the geometry attribute for newly created features.
     * @type {string|undefined}
     * @private
     */

    _this.geometryName_ = options.geometryName;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _condition.noModifierKeys;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.freehandCondition_;

    if (options.freehand) {
      _this.freehandCondition_ = _condition.always;
    } else {
      _this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : _condition.shiftKeyOnly;
    }

    _this.addEventListener((0, _Object.getChangeEventType)(_Property.default.ACTIVE), _this.updateState_);

    return _this;
  }
  /**
   * @inheritDoc
   */


  Draw.prototype.setMap = function (map) {
    _super.prototype.setMap.call(this, map);

    this.updateState_();
  };
  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */


  Draw.prototype.getOverlay = function () {
    return this.overlay_;
  };
  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @override
   * @api
   */


  Draw.prototype.handleEvent = function (event) {
    if (event.originalEvent.type === _EventType.default.CONTEXTMENU) {
      // Avoid context menu for long taps when drawing on mobile
      event.preventDefault();
    }

    this.freehand_ = this.mode_ !== Mode.POINT && this.freehandCondition_(event);
    var move = event.type === _MapBrowserEventType.default.POINTERMOVE;
    var pass = true;

    if (!this.freehand_ && this.lastDragTime_ && event.type === _MapBrowserEventType.default.POINTERDRAG) {
      var now = Date.now();

      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
        this.downPx_ = event.pixel;
        this.shouldHandle_ = !this.freehand_;
        move = true;
      } else {
        this.lastDragTime_ = undefined;
      }

      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {
        clearTimeout(this.downTimeout_);
        this.downTimeout_ = undefined;
      }
    }

    if (this.freehand_ && event.type === _MapBrowserEventType.default.POINTERDRAG && this.sketchFeature_ !== null) {
      this.addToDrawing_(event.coordinate);
      pass = false;
    } else if (this.freehand_ && event.type === _MapBrowserEventType.default.POINTERDOWN) {
      pass = false;
    } else if (move) {
      pass = event.type === _MapBrowserEventType.default.POINTERMOVE;

      if (pass && this.freehand_) {
        pass = this.handlePointerMove_(event);
      } else if (
      /** @type {MapBrowserPointerEvent} */
      event.pointerEvent.pointerType == 'mouse' || event.type === _MapBrowserEventType.default.POINTERDRAG && this.downTimeout_ === undefined) {
        this.handlePointerMove_(event);
      }
    } else if (event.type === _MapBrowserEventType.default.DBLCLICK) {
      pass = false;
    }

    return _super.prototype.handleEvent.call(this, event) && pass;
  };
  /**
   * @inheritDoc
   */


  Draw.prototype.handleDownEvent = function (event) {
    this.shouldHandle_ = !this.freehand_;

    if (this.freehand_) {
      this.downPx_ = event.pixel;

      if (!this.finishCoordinate_) {
        this.startDrawing_(event);
      }

      return true;
    } else if (this.condition_(event)) {
      this.lastDragTime_ = Date.now();
      this.downTimeout_ = setTimeout(function () {
        this.handlePointerMove_(new _MapBrowserPointerEvent.default(_MapBrowserEventType.default.POINTERMOVE, event.map, event.pointerEvent, false, event.frameState));
      }.bind(this), this.dragVertexDelay_);
      this.downPx_ = event.pixel;
      return true;
    } else {
      this.lastDragTime_ = undefined;
      return false;
    }
  };
  /**
   * @inheritDoc
   */


  Draw.prototype.handleUpEvent = function (event) {
    var pass = true;

    if (this.downTimeout_) {
      clearTimeout(this.downTimeout_);
      this.downTimeout_ = undefined;
    }

    this.handlePointerMove_(event);
    var circleMode = this.mode_ === Mode.CIRCLE;

    if (this.shouldHandle_) {
      if (!this.finishCoordinate_) {
        this.startDrawing_(event);

        if (this.mode_ === Mode.POINT) {
          this.finishDrawing();
        }
      } else if (this.freehand_ || circleMode) {
        this.finishDrawing();
      } else if (this.atFinish_(event)) {
        if (this.finishCondition_(event)) {
          this.finishDrawing();
        }
      } else {
        this.addToDrawing_(event.coordinate);
      }

      pass = false;
    } else if (this.freehand_) {
      this.abortDrawing();
    }

    if (!pass && this.stopClick_) {
      event.stopPropagation();
    }

    return pass;
  };
  /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default} event A move event.
   * @return {boolean} Pass the event to other interactions.
   * @private
   */


  Draw.prototype.handlePointerMove_ = function (event) {
    if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
      var downPx = this.downPx_;
      var clickPx = event.pixel;
      var dx = downPx[0] - clickPx[0];
      var dy = downPx[1] - clickPx[1];
      var squaredDistance = dx * dx + dy * dy;
      this.shouldHandle_ = this.freehand_ ? squaredDistance > this.squaredClickTolerance_ : squaredDistance <= this.squaredClickTolerance_;

      if (!this.shouldHandle_) {
        return true;
      }
    }

    if (this.finishCoordinate_) {
      this.modifyDrawing_(event);
    } else {
      this.createOrUpdateSketchPoint_(event);
    }

    return true;
  };
  /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */


  Draw.prototype.atFinish_ = function (event) {
    var at = false;

    if (this.sketchFeature_) {
      var potentiallyDone = false;
      var potentiallyFinishCoordinates = [this.finishCoordinate_];

      if (this.mode_ === Mode.LINE_STRING) {
        potentiallyDone = this.sketchCoords_.length > this.minPoints_;
      } else if (this.mode_ === Mode.POLYGON) {
        var sketchCoords =
        /** @type {PolyCoordType} */
        this.sketchCoords_;
        potentiallyDone = sketchCoords[0].length > this.minPoints_;
        potentiallyFinishCoordinates = [sketchCoords[0][0], sketchCoords[0][sketchCoords[0].length - 2]];
      }

      if (potentiallyDone) {
        var map = event.map;

        for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {
          var finishCoordinate = potentiallyFinishCoordinates[i];
          var finishPixel = map.getPixelFromCoordinate(finishCoordinate);
          var pixel = event.pixel;
          var dx = pixel[0] - finishPixel[0];
          var dy = pixel[1] - finishPixel[1];
          var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;

          if (at) {
            this.finishCoordinate_ = finishCoordinate;
            break;
          }
        }
      }
    }

    return at;
  };
  /**
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */


  Draw.prototype.createOrUpdateSketchPoint_ = function (event) {
    var coordinates = event.coordinate.slice();

    if (!this.sketchPoint_) {
      this.sketchPoint_ = new _Feature.default(new _Point.default(coordinates));
      this.updateSketchFeatures_();
    } else {
      var sketchPointGeom = this.sketchPoint_.getGeometry();
      sketchPointGeom.setCoordinates(coordinates);
    }
  };
  /**
   * Start the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */


  Draw.prototype.startDrawing_ = function (event) {
    var start = event.coordinate;
    var projection = event.map.getView().getProjection();
    this.finishCoordinate_ = start;

    if (this.mode_ === Mode.POINT) {
      this.sketchCoords_ = start.slice();
    } else if (this.mode_ === Mode.POLYGON) {
      this.sketchCoords_ = [[start.slice(), start.slice()]];
      this.sketchLineCoords_ = this.sketchCoords_[0];
    } else {
      this.sketchCoords_ = [start.slice(), start.slice()];
    }

    if (this.sketchLineCoords_) {
      this.sketchLine_ = new _Feature.default(new _LineString.default(this.sketchLineCoords_));
    }

    var geometry = this.geometryFunction_(this.sketchCoords_, undefined, projection);
    this.sketchFeature_ = new _Feature.default();

    if (this.geometryName_) {
      this.sketchFeature_.setGeometryName(this.geometryName_);
    }

    this.sketchFeature_.setGeometry(geometry);
    this.updateSketchFeatures_();
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
  };
  /**
   * Modify the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */


  Draw.prototype.modifyDrawing_ = function (event) {
    var coordinate = event.coordinate;
    var geometry = this.sketchFeature_.getGeometry();
    var projection = event.map.getView().getProjection();
    var coordinates, last;

    if (this.mode_ === Mode.POINT) {
      last = this.sketchCoords_;
    } else if (this.mode_ === Mode.POLYGON) {
      coordinates =
      /** @type {PolyCoordType} */
      this.sketchCoords_[0];
      last = coordinates[coordinates.length - 1];

      if (this.atFinish_(event)) {
        // snap to finish
        coordinate = this.finishCoordinate_.slice();
      }
    } else {
      coordinates = this.sketchCoords_;
      last = coordinates[coordinates.length - 1];
    }

    last[0] = coordinate[0];
    last[1] = coordinate[1];
    this.geometryFunction_(
    /** @type {!LineCoordType} */
    this.sketchCoords_, geometry, projection);

    if (this.sketchPoint_) {
      var sketchPointGeom = this.sketchPoint_.getGeometry();
      sketchPointGeom.setCoordinates(coordinate);
    }
    /** @type {LineString} */


    var sketchLineGeom;

    if (geometry.getType() == _GeometryType.default.POLYGON && this.mode_ !== Mode.POLYGON) {
      if (!this.sketchLine_) {
        this.sketchLine_ = new _Feature.default();
      }

      var ring = geometry.getLinearRing(0);
      sketchLineGeom = this.sketchLine_.getGeometry();

      if (!sketchLineGeom) {
        sketchLineGeom = new _LineString.default(ring.getFlatCoordinates(), ring.getLayout());
        this.sketchLine_.setGeometry(sketchLineGeom);
      } else {
        sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());
        sketchLineGeom.changed();
      }
    } else if (this.sketchLineCoords_) {
      sketchLineGeom = this.sketchLine_.getGeometry();
      sketchLineGeom.setCoordinates(this.sketchLineCoords_);
    }

    this.updateSketchFeatures_();
  };
  /**
   * Add a new coordinate to the drawing.
   * @param {!PointCoordType} coordinate Coordinate
   * @private
   */


  Draw.prototype.addToDrawing_ = function (coordinate) {
    var geometry = this.sketchFeature_.getGeometry();
    var projection = this.getMap().getView().getProjection();
    var done;
    var coordinates;

    if (this.mode_ === Mode.LINE_STRING) {
      this.finishCoordinate_ = coordinate.slice();
      coordinates =
      /** @type {LineCoordType} */
      this.sketchCoords_;

      if (coordinates.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates.pop();
        } else {
          done = true;
        }
      }

      coordinates.push(coordinate.slice());
      this.geometryFunction_(coordinates, geometry, projection);
    } else if (this.mode_ === Mode.POLYGON) {
      coordinates =
      /** @type {PolyCoordType} */
      this.sketchCoords_[0];

      if (coordinates.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates.pop();
        } else {
          done = true;
        }
      }

      coordinates.push(coordinate.slice());

      if (done) {
        this.finishCoordinate_ = coordinates[0];
      }

      this.geometryFunction_(this.sketchCoords_, geometry, projection);
    }

    this.updateSketchFeatures_();

    if (done) {
      this.finishDrawing();
    }
  };
  /**
   * Remove last point of the feature currently being drawn.
   * @api
   */


  Draw.prototype.removeLastPoint = function () {
    if (!this.sketchFeature_) {
      return;
    }

    var geometry = this.sketchFeature_.getGeometry();
    var projection = this.getMap().getView().getProjection();
    var coordinates;
    /** @type {LineString} */

    var sketchLineGeom;

    if (this.mode_ === Mode.LINE_STRING) {
      coordinates =
      /** @type {LineCoordType} */
      this.sketchCoords_;
      coordinates.splice(-2, 1);
      this.geometryFunction_(coordinates, geometry, projection);

      if (coordinates.length >= 2) {
        this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
      }
    } else if (this.mode_ === Mode.POLYGON) {
      coordinates =
      /** @type {PolyCoordType} */
      this.sketchCoords_[0];
      coordinates.splice(-2, 1);
      sketchLineGeom = this.sketchLine_.getGeometry();
      sketchLineGeom.setCoordinates(coordinates);
      this.geometryFunction_(this.sketchCoords_, geometry, projection);
    }

    if (coordinates.length === 0) {
      this.abortDrawing();
    }

    this.updateSketchFeatures_();
  };
  /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @api
   */


  Draw.prototype.finishDrawing = function () {
    var sketchFeature = this.abortDrawing_();

    if (!sketchFeature) {
      return;
    }

    var coordinates = this.sketchCoords_;
    var geometry = sketchFeature.getGeometry();
    var projection = this.getMap().getView().getProjection();

    if (this.mode_ === Mode.LINE_STRING) {
      // remove the redundant last point
      coordinates.pop();
      this.geometryFunction_(coordinates, geometry, projection);
    } else if (this.mode_ === Mode.POLYGON) {
      // remove the redundant last point in ring

      /** @type {PolyCoordType} */
      coordinates[0].pop();
      this.geometryFunction_(coordinates, geometry, projection);
      coordinates = geometry.getCoordinates();
    } // cast multi-part geometries


    if (this.type_ === _GeometryType.default.MULTI_POINT) {
      sketchFeature.setGeometry(new _MultiPoint.default([
      /** @type {PointCoordType} */
      coordinates]));
    } else if (this.type_ === _GeometryType.default.MULTI_LINE_STRING) {
      sketchFeature.setGeometry(new _MultiLineString.default([
      /** @type {LineCoordType} */
      coordinates]));
    } else if (this.type_ === _GeometryType.default.MULTI_POLYGON) {
      sketchFeature.setGeometry(new _MultiPolygon.default([
      /** @type {PolyCoordType} */
      coordinates]));
    } // First dispatch event to allow full set up of feature


    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature)); // Then insert feature

    if (this.features_) {
      this.features_.push(sketchFeature);
    }

    if (this.source_) {
      this.source_.addFeature(sketchFeature);
    }
  };
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature} The sketch feature (or null if none).
   * @private
   */


  Draw.prototype.abortDrawing_ = function () {
    this.finishCoordinate_ = null;
    var sketchFeature = this.sketchFeature_;
    this.sketchFeature_ = null;
    this.sketchPoint_ = null;
    this.sketchLine_ = null;
    this.overlay_.getSource().clear(true);
    return sketchFeature;
  };
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @api
   */


  Draw.prototype.abortDrawing = function () {
    var sketchFeature = this.abortDrawing_();

    if (sketchFeature) {
      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));
    }
  };
  /**
   * Append coordinates to the end of the geometry that is currently being drawn.
   * This can be used when drawing LineStrings or Polygons. Coordinates will
   * either be appended to the current LineString or the outer ring of the current
   * Polygon.
   * @param {!LineCoordType} coordinates Linear coordinates to be appended into
   * the coordinate array.
   * @api
   */


  Draw.prototype.appendCoordinates = function (coordinates) {
    var mode = this.mode_;
    var sketchCoords = [];

    if (mode === Mode.LINE_STRING) {
      sketchCoords =
      /** @type {LineCoordType} */
      this.sketchCoords_;
    } else if (mode === Mode.POLYGON) {
      sketchCoords = this.sketchCoords_ && this.sketchCoords_.length ?
      /** @type {PolyCoordType} */
      this.sketchCoords_[0] : [];
    } // Remove last coordinate from sketch drawing (this coordinate follows cursor position)


    var ending = sketchCoords.pop(); // Append coordinate list

    for (var i = 0; i < coordinates.length; i++) {
      this.addToDrawing_(coordinates[i]);
    } // Duplicate last coordinate for sketch drawing


    this.addToDrawing_(ending);
  };
  /**
   * Initiate draw mode by starting from an existing geometry which will
   * receive new additional points. This only works on features with
   * `LineString` geometries, where the interaction will extend lines by adding
   * points to the end of the coordinates array.
   * This will change the original feature, instead of drawing a copy.
   *
   * The function will dispatch a `drawstart` event.
   *
   * @param {!Feature<LineString>} feature Feature to be extended.
   * @api
   */


  Draw.prototype.extend = function (feature) {
    var geometry = feature.getGeometry();
    var lineString = geometry;
    this.sketchFeature_ = feature;
    this.sketchCoords_ = lineString.getCoordinates();
    var last = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = last.slice();
    this.sketchCoords_.push(last.slice());
    this.updateSketchFeatures_();
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
  };
  /**
   * Redraw the sketch features.
   * @private
   */


  Draw.prototype.updateSketchFeatures_ = function () {
    var sketchFeatures = [];

    if (this.sketchFeature_) {
      sketchFeatures.push(this.sketchFeature_);
    }

    if (this.sketchLine_) {
      sketchFeatures.push(this.sketchLine_);
    }

    if (this.sketchPoint_) {
      sketchFeatures.push(this.sketchPoint_);
    }

    var overlaySource = this.overlay_.getSource();
    overlaySource.clear(true);
    overlaySource.addFeatures(sketchFeatures);
  };
  /**
   * @private
   */


  Draw.prototype.updateState_ = function () {
    var map = this.getMap();
    var active = this.getActive();

    if (!map || !active) {
      this.abortDrawing();
    }

    this.overlay_.setMap(active ? map : null);
  };

  return Draw;
}(_Pointer.default);
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */


function getDefaultStyleFunction() {
  var styles = (0, _Style.createEditingStyle)();
  return function (feature, resolution) {
    return styles[feature.getGeometry().getType()];
  };
}
/**
 * Create a `geometryFunction` for `type: 'Circle'` that will create a regular
 * polygon with a user specified number of sides and start angle instead of an
 * `import("../geom/Circle.js").Circle` geometry.
 * @param {number=} opt_sides Number of sides of the regular polygon. Default is
 *     32.
 * @param {number=} opt_angle Angle of the first point in radians. 0 means East.
 *     Default is the angle defined by the heading from the center of the
 *     regular polygon to the current pointer position.
 * @return {GeometryFunction} Function that draws a
 *     polygon.
 * @api
 */


function createRegularPolygon(opt_sides, opt_angle) {
  return function (coordinates, opt_geometry, projection) {
    var center = (0, _proj.fromUserCoordinate)(
    /** @type {LineCoordType} */
    coordinates[0], projection);
    var end = (0, _proj.fromUserCoordinate)(
    /** @type {LineCoordType} */
    coordinates[1], projection);
    var radius = Math.sqrt((0, _coordinate.squaredDistance)(center, end));
    var geometry = opt_geometry ?
    /** @type {Polygon} */
    opt_geometry : (0, _Polygon.fromCircle)(new _Circle.default(center), opt_sides);
    var angle = opt_angle;

    if (!opt_angle) {
      var x = end[0] - center[0];
      var y = end[1] - center[1];
      angle = Math.atan(y / x) - (x < 0 ? Math.PI : 0);
    }

    (0, _Polygon.makeRegular)(geometry, center, radius, angle);
    var userProjection = (0, _proj.getUserProjection)();

    if (userProjection) {
      geometry.transform(projection, userProjection);
    }

    return geometry;
  };
}
/**
 * Create a `geometryFunction` that will create a box-shaped polygon (aligned
 * with the coordinate system axes).  Use this with the draw interaction and
 * `type: 'Circle'` to return a box instead of a circle geometry.
 * @return {GeometryFunction} Function that draws a box-shaped polygon.
 * @api
 */


function createBox() {
  return function (coordinates, opt_geometry, projection) {
    var extent = (0, _extent.boundingExtent)(
    /** @type {LineCoordType} */
    coordinates.map(function (coordinate) {
      return (0, _proj.fromUserCoordinate)(coordinate, projection);
    }));
    var boxCoordinates = [[(0, _extent.getBottomLeft)(extent), (0, _extent.getBottomRight)(extent), (0, _extent.getTopRight)(extent), (0, _extent.getTopLeft)(extent), (0, _extent.getBottomLeft)(extent)]];
    var geometry = opt_geometry;

    if (geometry) {
      geometry.setCoordinates(boxCoordinates);
    } else {
      geometry = new _Polygon.default(boxCoordinates);
    }

    var userProjection = (0, _proj.getUserProjection)();

    if (userProjection) {
      geometry.transform(projection, userProjection);
    }

    return geometry;
  };
}
/**
 * Get the drawing mode.  The mode for mult-part geometries is the same as for
 * their single-part cousins.
 * @param {GeometryType} type Geometry type.
 * @return {Mode} Drawing mode.
 */


function getMode(type) {
  var mode;

  if (type === _GeometryType.default.POINT || type === _GeometryType.default.MULTI_POINT) {
    mode = Mode.POINT;
  } else if (type === _GeometryType.default.LINE_STRING || type === _GeometryType.default.MULTI_LINE_STRING) {
    mode = Mode.LINE_STRING;
  } else if (type === _GeometryType.default.POLYGON || type === _GeometryType.default.MULTI_POLYGON) {
    mode = Mode.POLYGON;
  } else if (type === _GeometryType.default.CIRCLE) {
    mode = Mode.CIRCLE;
  }

  return (
    /** @type {!Mode} */
    mode
  );
}

var _default = Draw;
exports.default = _default;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","../Feature.js":"node_modules/ol/Feature.js","../MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","../MapBrowserPointerEvent.js":"node_modules/ol/MapBrowserPointerEvent.js","../Object.js":"node_modules/ol/Object.js","../coordinate.js":"node_modules/ol/coordinate.js","../events/Event.js":"node_modules/ol/events/Event.js","../events/condition.js":"node_modules/ol/events/condition.js","../extent.js":"node_modules/ol/extent.js","../functions.js":"node_modules/ol/functions.js","../geom/Circle.js":"node_modules/ol/geom/Circle.js","../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../geom/LineString.js":"node_modules/ol/geom/LineString.js","../geom/MultiLineString.js":"node_modules/ol/geom/MultiLineString.js","../geom/MultiPoint.js":"node_modules/ol/geom/MultiPoint.js","../geom/MultiPolygon.js":"node_modules/ol/geom/MultiPolygon.js","../geom/Point.js":"node_modules/ol/geom/Point.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js","./Property.js":"node_modules/ol/interaction/Property.js","../layer/Vector.js":"node_modules/ol/layer/Vector.js","../source/Vector.js":"node_modules/ol/source/Vector.js","../style/Style.js":"node_modules/ol/style/Style.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/interaction/Extent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Feature = _interopRequireDefault(require("../Feature.js"));

var _MapBrowserEventType = _interopRequireDefault(require("../MapBrowserEventType.js"));

var _coordinate = require("../coordinate.js");

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _extent = require("../extent.js");

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _Point = _interopRequireDefault(require("../geom/Point.js"));

var _Polygon = require("../geom/Polygon.js");

var _Pointer = _interopRequireDefault(require("./Pointer.js"));

var _Vector = _interopRequireDefault(require("../layer/Vector.js"));

var _Vector2 = _interopRequireDefault(require("../source/Vector.js"));

var _Style = require("../style/Style.js");

var _proj = require("../proj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/Extent
 */


/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Initial extent. Defaults to no
 * initial extent.
 * @property {import("../style/Style.js").StyleLike} [boxStyle]
 * Style for the drawn extent box. Defaults to
 * {@link module:ol/style/Style~createEditing()['Polygon']}
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike} [pointerStyle]
 * Style for the cursor used to draw the extent. Defaults to
 * {@link module:ol/style/Style~createEditing()['Point']}
 * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps
 * in the X direction? Only affects visuals, not functionality.
 */

/**
 * @enum {string}
 */
var ExtentEventType = {
  /**
   * Triggered after the extent is changed
   * @event ExtentEvent#extentchanged
   * @api
   */
  EXTENTCHANGED: 'extentchanged'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Extent~Extent} instances are
 * instances of this type.
 */

var ExtentEvent =
/** @class */
function (_super) {
  __extends(ExtentEvent, _super);
  /**
   * @param {import("../extent.js").Extent} extent the new extent
   */


  function ExtentEvent(extent) {
    var _this = _super.call(this, ExtentEventType.EXTENTCHANGED) || this;
    /**
     * The current extent.
     * @type {import("../extent.js").Extent}
     * @api
     */


    _this.extent = extent;
    return _this;
  }

  return ExtentEvent;
}(_Event.default);
/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map.
 * Once drawn, the vector box can be modified by dragging its vertices or edges.
 * This interaction is only supported for mouse devices.
 *
 * @fires ExtentEvent
 * @api
 */


var Extent =
/** @class */
function (_super) {
  __extends(Extent, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function Extent(opt_options) {
    var _this = this;

    var options = opt_options || {};
    _this = _super.call(this,
    /** @type {import("./Pointer.js").Options} */
    options) || this;
    /**
     * Extent of the drawn box
     * @type {import("../extent.js").Extent}
     * @private
     */

    _this.extent_ = null;
    /**
     * Handler for pointer move events
     * @type {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent|null}
     * @private
     */

    _this.pointerHandler_ = null;
    /**
     * Pixel threshold to snap to extent
     * @type {number}
     * @private
     */

    _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
    /**
     * Is the pointer snapped to an extent vertex
     * @type {boolean}
     * @private
     */

    _this.snappedToVertex_ = false;
    /**
     * Feature for displaying the visible extent
     * @type {Feature}
     * @private
     */

    _this.extentFeature_ = null;
    /**
     * Feature for displaying the visible pointer
     * @type {Feature<Point>}
     * @private
     */

    _this.vertexFeature_ = null;

    if (!opt_options) {
      opt_options = {};
    }
    /**
     * Layer for the extentFeature
     * @type {VectorLayer}
     * @private
     */


    _this.extentOverlay_ = new _Vector.default({
      source: new _Vector2.default({
        useSpatialIndex: false,
        wrapX: !!opt_options.wrapX
      }),
      style: opt_options.boxStyle ? opt_options.boxStyle : getDefaultExtentStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });
    /**
     * Layer for the vertexFeature
     * @type {VectorLayer}
     * @private
     */

    _this.vertexOverlay_ = new _Vector.default({
      source: new _Vector2.default({
        useSpatialIndex: false,
        wrapX: !!opt_options.wrapX
      }),
      style: opt_options.pointerStyle ? opt_options.pointerStyle : getDefaultPointerStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });

    if (opt_options.extent) {
      _this.setExtent(opt_options.extent);
    }

    return _this;
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel cursor location
   * @param {import("../PluggableMap.js").default} map map
   * @returns {import("../coordinate.js").Coordinate|null} snapped vertex on extent
   * @private
   */


  Extent.prototype.snapToVertex_ = function (pixel, map) {
    var pixelCoordinate = map.getCoordinateFromPixelInternal(pixel);

    var sortByDistance = function (a, b) {
      return (0, _coordinate.squaredDistanceToSegment)(pixelCoordinate, a) - (0, _coordinate.squaredDistanceToSegment)(pixelCoordinate, b);
    };

    var extent = this.getExtentInternal();

    if (extent) {
      //convert extents to line segments and find the segment closest to pixelCoordinate
      var segments = getSegments(extent);
      segments.sort(sortByDistance);
      var closestSegment = segments[0];
      var vertex = (0, _coordinate.closestOnSegment)(pixelCoordinate, closestSegment);
      var vertexPixel = map.getPixelFromCoordinateInternal(vertex); //if the distance is within tolerance, snap to the segment

      if ((0, _coordinate.distance)(pixel, vertexPixel) <= this.pixelTolerance_) {
        //test if we should further snap to a vertex
        var pixel1 = map.getPixelFromCoordinateInternal(closestSegment[0]);
        var pixel2 = map.getPixelFromCoordinateInternal(closestSegment[1]);
        var squaredDist1 = (0, _coordinate.squaredDistance)(vertexPixel, pixel1);
        var squaredDist2 = (0, _coordinate.squaredDistance)(vertexPixel, pixel2);
        var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
        this.snappedToVertex_ = dist <= this.pixelTolerance_;

        if (this.snappedToVertex_) {
          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
        }

        return vertex;
      }
    }

    return null;
  };
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent pointer move event
   * @private
   */


  Extent.prototype.handlePointerMove_ = function (mapBrowserEvent) {
    var pixel = mapBrowserEvent.pixel;
    var map = mapBrowserEvent.map;
    var vertex = this.snapToVertex_(pixel, map);

    if (!vertex) {
      vertex = map.getCoordinateFromPixelInternal(pixel);
    }

    this.createOrUpdatePointerFeature_(vertex);
  };
  /**
   * @param {import("../extent.js").Extent} extent extent
   * @returns {Feature} extent as featrue
   * @private
   */


  Extent.prototype.createOrUpdateExtentFeature_ = function (extent) {
    var extentFeature = this.extentFeature_;

    if (!extentFeature) {
      if (!extent) {
        extentFeature = new _Feature.default({});
      } else {
        extentFeature = new _Feature.default((0, _Polygon.fromExtent)(extent));
      }

      this.extentFeature_ = extentFeature;
      this.extentOverlay_.getSource().addFeature(extentFeature);
    } else {
      if (!extent) {
        extentFeature.setGeometry(undefined);
      } else {
        extentFeature.setGeometry((0, _Polygon.fromExtent)(extent));
      }
    }

    return extentFeature;
  };
  /**
   * @param {import("../coordinate.js").Coordinate} vertex location of feature
   * @returns {Feature} vertex as feature
   * @private
   */


  Extent.prototype.createOrUpdatePointerFeature_ = function (vertex) {
    var vertexFeature = this.vertexFeature_;

    if (!vertexFeature) {
      vertexFeature = new _Feature.default(new _Point.default(vertex));
      this.vertexFeature_ = vertexFeature;
      this.vertexOverlay_.getSource().addFeature(vertexFeature);
    } else {
      var geometry = vertexFeature.getGeometry();
      geometry.setCoordinates(vertex);
    }

    return vertexFeature;
  };
  /**
   * @inheritDoc
   */


  Extent.prototype.handleEvent = function (mapBrowserEvent) {
    if (!
    /** @type {import("../MapBrowserPointerEvent.js").default} */
    mapBrowserEvent.pointerEvent) {
      return true;
    } //display pointer (if not dragging)


    if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERMOVE && !this.handlingDownUpSequence) {
      this.handlePointerMove_(mapBrowserEvent);
    } //call pointer to determine up/down/drag


    _super.prototype.handleEvent.call(this, mapBrowserEvent); //return false to stop propagation


    return false;
  };
  /**
   * @inheritDoc
   */


  Extent.prototype.handleDownEvent = function (mapBrowserEvent) {
    var pixel = mapBrowserEvent.pixel;
    var map = mapBrowserEvent.map;
    var extent = this.getExtentInternal();
    var vertex = this.snapToVertex_(pixel, map); //find the extent corner opposite the passed corner

    var getOpposingPoint = function (point) {
      var x_ = null;
      var y_ = null;

      if (point[0] == extent[0]) {
        x_ = extent[2];
      } else if (point[0] == extent[2]) {
        x_ = extent[0];
      }

      if (point[1] == extent[1]) {
        y_ = extent[3];
      } else if (point[1] == extent[3]) {
        y_ = extent[1];
      }

      if (x_ !== null && y_ !== null) {
        return [x_, y_];
      }

      return null;
    };

    if (vertex && extent) {
      var x = vertex[0] == extent[0] || vertex[0] == extent[2] ? vertex[0] : null;
      var y = vertex[1] == extent[1] || vertex[1] == extent[3] ? vertex[1] : null; //snap to point

      if (x !== null && y !== null) {
        this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex)); //snap to edge
      } else if (x !== null) {
        this.pointerHandler_ = getEdgeHandler(getOpposingPoint([x, extent[1]]), getOpposingPoint([x, extent[3]]));
      } else if (y !== null) {
        this.pointerHandler_ = getEdgeHandler(getOpposingPoint([extent[0], y]), getOpposingPoint([extent[2], y]));
      } //no snap - new bbox

    } else {
      vertex = map.getCoordinateFromPixelInternal(pixel);
      this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);
      this.pointerHandler_ = getPointHandler(vertex);
    }

    return true; //event handled; start downup sequence
  };
  /**
   * @inheritDoc
   */


  Extent.prototype.handleDragEvent = function (mapBrowserEvent) {
    if (this.pointerHandler_) {
      var pixelCoordinate = mapBrowserEvent.coordinate;
      this.setExtent(this.pointerHandler_(pixelCoordinate));
      this.createOrUpdatePointerFeature_(pixelCoordinate);
    }

    return true;
  };
  /**
   * @inheritDoc
   */


  Extent.prototype.handleUpEvent = function (mapBrowserEvent) {
    this.pointerHandler_ = null; //If bbox is zero area, set to null;

    var extent = this.getExtentInternal();

    if (!extent || (0, _extent.getArea)(extent) === 0) {
      this.setExtent(null);
    }

    return false; //Stop handling downup sequence
  };
  /**
   * @inheritDoc
   */


  Extent.prototype.setMap = function (map) {
    this.extentOverlay_.setMap(map);
    this.vertexOverlay_.setMap(map);

    _super.prototype.setMap.call(this, map);
  };
  /**
   * Returns the current drawn extent in the view projection (or user projection if set)
   *
   * @return {import("../extent.js").Extent} Drawn extent in the view projection.
   * @api
   */


  Extent.prototype.getExtent = function () {
    return (0, _proj.toUserExtent)(this.getExtentInternal(), this.getMap().getView().getProjection());
  };
  /**
   * Returns the current drawn extent in the view projection
   *
   * @return {import("../extent.js").Extent} Drawn extent in the view projection.
   * @api
   */


  Extent.prototype.getExtentInternal = function () {
    return this.extent_;
  };
  /**
   * Manually sets the drawn extent, using the view projection.
   *
   * @param {import("../extent.js").Extent} extent Extent
   * @api
   */


  Extent.prototype.setExtent = function (extent) {
    //Null extent means no bbox
    this.extent_ = extent ? extent : null;
    this.createOrUpdateExtentFeature_(extent);
    this.dispatchEvent(new ExtentEvent(this.extent_));
  };

  return Extent;
}(_Pointer.default);
/**
 * Returns the default style for the drawn bbox
 *
 * @return {import("../style/Style.js").StyleFunction} Default Extent style
 */


function getDefaultExtentStyleFunction() {
  var style = (0, _Style.createEditingStyle)();
  return function (feature, resolution) {
    return style[_GeometryType.default.POLYGON];
  };
}
/**
 * Returns the default style for the pointer
 *
 * @return {import("../style/Style.js").StyleFunction} Default pointer style
 */


function getDefaultPointerStyleFunction() {
  var style = (0, _Style.createEditingStyle)();
  return function (feature, resolution) {
    return style[_GeometryType.default.POINT];
  };
}
/**
 * @param {import("../coordinate.js").Coordinate} fixedPoint corner that will be unchanged in the new extent
 * @returns {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent} event handler
 */


function getPointHandler(fixedPoint) {
  return function (point) {
    return (0, _extent.boundingExtent)([fixedPoint, point]);
  };
}
/**
 * @param {import("../coordinate.js").Coordinate} fixedP1 first corner that will be unchanged in the new extent
 * @param {import("../coordinate.js").Coordinate} fixedP2 second corner that will be unchanged in the new extent
 * @returns {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent|null} event handler
 */


function getEdgeHandler(fixedP1, fixedP2) {
  if (fixedP1[0] == fixedP2[0]) {
    return function (point) {
      return (0, _extent.boundingExtent)([fixedP1, [point[0], fixedP2[1]]]);
    };
  } else if (fixedP1[1] == fixedP2[1]) {
    return function (point) {
      return (0, _extent.boundingExtent)([fixedP1, [fixedP2[0], point[1]]]);
    };
  } else {
    return null;
  }
}
/**
 * @param {import("../extent.js").Extent} extent extent
 * @returns {Array<Array<import("../coordinate.js").Coordinate>>} extent line segments
 */


function getSegments(extent) {
  return [[[extent[0], extent[1]], [extent[0], extent[3]]], [[extent[0], extent[3]], [extent[2], extent[3]]], [[extent[2], extent[3]], [extent[2], extent[1]]], [[extent[2], extent[1]], [extent[0], extent[1]]]];
}

var _default = Extent;
exports.default = _default;
},{"../Feature.js":"node_modules/ol/Feature.js","../MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","../coordinate.js":"node_modules/ol/coordinate.js","../events/Event.js":"node_modules/ol/events/Event.js","../extent.js":"node_modules/ol/extent.js","../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../geom/Point.js":"node_modules/ol/geom/Point.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js","../layer/Vector.js":"node_modules/ol/layer/Vector.js","../source/Vector.js":"node_modules/ol/source/Vector.js","../style/Style.js":"node_modules/ol/style/Style.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/interaction/Modify.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ModifyEvent = void 0;

var _util = require("../util.js");

var _Collection = _interopRequireDefault(require("../Collection.js"));

var _CollectionEventType = _interopRequireDefault(require("../CollectionEventType.js"));

var _Feature = _interopRequireDefault(require("../Feature.js"));

var _MapBrowserEventType = _interopRequireDefault(require("../MapBrowserEventType.js"));

var _array = require("../array.js");

var _coordinate = require("../coordinate.js");

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _condition = require("../events/condition.js");

var _extent = require("../extent.js");

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _Point = _interopRequireDefault(require("../geom/Point.js"));

var _Polygon = require("../geom/Polygon.js");

var _Pointer = _interopRequireDefault(require("./Pointer.js"));

var _Vector = _interopRequireDefault(require("../layer/Vector.js"));

var _Vector2 = _interopRequireDefault(require("../source/Vector.js"));

var _VectorEventType = _interopRequireDefault(require("../source/VectorEventType.js"));

var _RBush = _interopRequireDefault(require("../structs/RBush.js"));

var _Style = require("../style/Style.js");

var _proj = require("../proj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/Modify
 */


/**
 * The segment index assigned to a circle's center when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */
var CIRCLE_CENTER_INDEX = 0;
/**
 * The segment index assigned to a circle's circumference when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */

var CIRCLE_CIRCUMFERENCE_INDEX = 1;
var tempExtent = [0, 0, 0, 0];
var tempSegment = [];
/**
 * @enum {string}
 */

var ModifyEventType = {
  /**
   * Triggered upon feature modification start
   * @event ModifyEvent#modifystart
   * @api
   */
  MODIFYSTART: 'modifystart',

  /**
   * Triggered upon feature modification end
   * @event ModifyEvent#modifyend
   * @api
   */
  MODIFYEND: 'modifyend'
};
/**
 * @typedef {Object} SegmentData
 * @property {Array<number>} [depth]
 * @property {Feature} feature
 * @property {import("../geom/SimpleGeometry.js").default} geometry
 * @property {number} [index]
 * @property {Array<import("../extent.js").Extent>} segment
 * @property {Array<SegmentData>} [featureSegments]
 */

/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event will be considered to add or move a
 * vertex to the sketch. Default is
 * {@link module:ol/events/condition~primaryAction}.
 * @property {import("../events/condition.js").Condition} [deleteCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. By default,
 * {@link module:ol/events/condition~singleClick} with
 * {@link module:ol/events/condition~altKeyOnly} results in a vertex deletion.
 * @property {import("../events/condition.js").Condition} [insertVertexCondition] A
 * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether a new vertex should be added to the sketch
 * features. Default is {@link module:ol/events/condition~always}.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike} [style]
 * Style used for the features being modified. By default the default edit
 * style is used (see {@link module:ol/style}).
 * @property {VectorSource} [source] The vector source with
 * features to modify.  If a vector source is not provided, a feature collection
 * must be provided with the features option.
 * @property {Collection<Feature>} [features]
 * The features the interaction works on.  If a feature collection is not
 * provided, a vector source must be provided with the source option.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 */

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are
 * instances of this type.
 */

var ModifyEvent =
/** @class */
function (_super) {
  __extends(ModifyEvent, _super);
  /**
   * @param {ModifyEventType} type Type.
   * @param {Collection<Feature>} features
   * The features modified.
   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserPointerEvent
   * Associated {@link module:ol/MapBrowserPointerEvent}.
   */


  function ModifyEvent(type, features, mapBrowserPointerEvent) {
    var _this = _super.call(this, type) || this;
    /**
     * The features being modified.
     * @type {Collection<Feature>}
     * @api
     */


    _this.features = features;
    /**
     * Associated {@link module:ol/MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */

    _this.mapBrowserEvent = mapBrowserPointerEvent;
    return _this;
  }

  return ModifyEvent;
}(_Event.default);

exports.ModifyEvent = ModifyEvent;

/**
 * @classdesc
 * Interaction for modifying feature geometries.  To modify features that have
 * been added to an existing source, construct the modify interaction with the
 * `source` option.  If you want to modify features in a collection (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.  The interaction must be constructed with either a
 * `source` or `features` option.
 *
 * By default, the interaction will allow deletion of vertices when the `alt`
 * key is pressed.  To configure the interaction with a different condition
 * for deletion, use the `deleteCondition` option.
 * @fires ModifyEvent
 * @api
 */
var Modify =
/** @class */
function (_super) {
  __extends(Modify, _super);
  /**
   * @param {Options} options Options.
   */


  function Modify(options) {
    var _this = _super.call(this,
    /** @type {import("./Pointer.js").Options} */
    options) || this;
    /** @private */


    _this.boundHandleFeatureChange_ = _this.handleFeatureChange_.bind(_this);
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _condition.primaryAction;
    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */

    _this.defaultDeleteCondition_ = function (mapBrowserEvent) {
      return (0, _condition.altKeyOnly)(mapBrowserEvent) && (0, _condition.singleClick)(mapBrowserEvent);
    };
    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */


    _this.deleteCondition_ = options.deleteCondition ? options.deleteCondition : _this.defaultDeleteCondition_;
    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */

    _this.insertVertexCondition_ = options.insertVertexCondition ? options.insertVertexCondition : _condition.always;
    /**
     * Editing vertex.
     * @type {Feature}
     * @private
     */

    _this.vertexFeature_ = null;
    /**
     * Segments intersecting {@link this.vertexFeature_} by segment uid.
     * @type {Object<string, boolean>}
     * @private
     */

    _this.vertexSegments_ = null;
    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */

    _this.lastPixel_ = [0, 0];
    /**
     * Tracks if the next `singleclick` event should be ignored to prevent
     * accidental deletion right after vertex creation.
     * @type {boolean}
     * @private
     */

    _this.ignoreNextSingleClick_ = false;
    /**
     * @type {boolean}
     * @private
     */

    _this.modified_ = false;
    /**
     * Segment RTree for each layer
     * @type {RBush<SegmentData>}
     * @private
     */

    _this.rBush_ = new _RBush.default();
    /**
     * @type {number}
     * @private
     */

    _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
    /**
     * @type {boolean}
     * @private
     */

    _this.snappedToVertex_ = false;
    /**
     * Indicate whether the interaction is currently changing a feature's
     * coordinates.
     * @type {boolean}
     * @private
     */

    _this.changingFeature_ = false;
    /**
     * @type {Array}
     * @private
     */

    _this.dragSegments_ = [];
    /**
     * Draw overlay where sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */

    _this.overlay_ = new _Vector.default({
      source: new _Vector2.default({
        useSpatialIndex: false,
        wrapX: !!options.wrapX
      }),
      style: options.style ? options.style : getDefaultStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });
    /**
     * @const
     * @private
     * @type {!Object<string, function(Feature, import("../geom/Geometry.js").default): void>}
     */

    _this.SEGMENT_WRITERS_ = {
      'Point': _this.writePointGeometry_.bind(_this),
      'LineString': _this.writeLineStringGeometry_.bind(_this),
      'LinearRing': _this.writeLineStringGeometry_.bind(_this),
      'Polygon': _this.writePolygonGeometry_.bind(_this),
      'MultiPoint': _this.writeMultiPointGeometry_.bind(_this),
      'MultiLineString': _this.writeMultiLineStringGeometry_.bind(_this),
      'MultiPolygon': _this.writeMultiPolygonGeometry_.bind(_this),
      'Circle': _this.writeCircleGeometry_.bind(_this),
      'GeometryCollection': _this.writeGeometryCollectionGeometry_.bind(_this)
    };
    /**
     * @type {VectorSource}
     * @private
     */

    _this.source_ = null;
    var features;

    if (options.source) {
      _this.source_ = options.source;
      features = new _Collection.default(_this.source_.getFeatures());

      _this.source_.addEventListener(_VectorEventType.default.ADDFEATURE, _this.handleSourceAdd_.bind(_this));

      _this.source_.addEventListener(_VectorEventType.default.REMOVEFEATURE, _this.handleSourceRemove_.bind(_this));
    } else {
      features = options.features;
    }

    if (!features) {
      throw new Error('The modify interaction requires features or a source');
    }
    /**
     * @type {Collection<Feature>}
     * @private
     */


    _this.features_ = features;

    _this.features_.forEach(_this.addFeature_.bind(_this));

    _this.features_.addEventListener(_CollectionEventType.default.ADD, _this.handleFeatureAdd_.bind(_this));

    _this.features_.addEventListener(_CollectionEventType.default.REMOVE, _this.handleFeatureRemove_.bind(_this));
    /**
     * @type {import("../MapBrowserPointerEvent.js").default}
     * @private
     */


    _this.lastPointerEvent_ = null;
    return _this;
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */


  Modify.prototype.addFeature_ = function (feature) {
    var geometry = feature.getGeometry();

    if (geometry) {
      var writer = this.SEGMENT_WRITERS_[geometry.getType()];

      if (writer) {
        writer(feature, geometry);
      }
    }

    var map = this.getMap();

    if (map && map.isRendered() && this.getActive()) {
      this.handlePointerAtPixel_(this.lastPixel_, map);
    }

    feature.addEventListener(_EventType.default.CHANGE, this.boundHandleFeatureChange_);
  };
  /**
   * @param {import("../MapBrowserPointerEvent.js").default} evt Map browser event
   * @private
   */


  Modify.prototype.willModifyFeatures_ = function (evt) {
    if (!this.modified_) {
      this.modified_ = true;
      this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART, this.features_, evt));
    }
  };
  /**
   * @param {Feature} feature Feature.
   * @private
   */


  Modify.prototype.removeFeature_ = function (feature) {
    this.removeFeatureSegmentData_(feature); // Remove the vertex feature if the collection of canditate features is empty.

    if (this.vertexFeature_ && this.features_.getLength() === 0) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }

    feature.removeEventListener(_EventType.default.CHANGE, this.boundHandleFeatureChange_);
  };
  /**
   * @param {Feature} feature Feature.
   * @private
   */


  Modify.prototype.removeFeatureSegmentData_ = function (feature) {
    var rBush = this.rBush_;
    /** @type {Array<SegmentData>} */

    var nodesToRemove = [];
    rBush.forEach(
    /**
     * @param {SegmentData} node RTree node.
     */
    function (node) {
      if (feature === node.feature) {
        nodesToRemove.push(node);
      }
    });

    for (var i = nodesToRemove.length - 1; i >= 0; --i) {
      var nodeToRemove = nodesToRemove[i];

      for (var j = this.dragSegments_.length - 1; j >= 0; --j) {
        if (this.dragSegments_[j][0] === nodeToRemove) {
          this.dragSegments_.splice(j, 1);
        }
      }

      rBush.remove(nodeToRemove);
    }
  };
  /**
   * @inheritDoc
   */


  Modify.prototype.setActive = function (active) {
    if (this.vertexFeature_ && !active) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }

    _super.prototype.setActive.call(this, active);
  };
  /**
   * @inheritDoc
   */


  Modify.prototype.setMap = function (map) {
    this.overlay_.setMap(map);

    _super.prototype.setMap.call(this, map);
  };
  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */


  Modify.prototype.getOverlay = function () {
    return this.overlay_;
  };
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */


  Modify.prototype.handleSourceAdd_ = function (event) {
    if (event.feature) {
      this.features_.push(event.feature);
    }
  };
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */


  Modify.prototype.handleSourceRemove_ = function (event) {
    if (event.feature) {
      this.features_.remove(event.feature);
    }
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Modify.prototype.handleFeatureAdd_ = function (evt) {
    this.addFeature_(
    /** @type {Feature} */
    evt.element);
  };
  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */


  Modify.prototype.handleFeatureChange_ = function (evt) {
    if (!this.changingFeature_) {
      var feature =
      /** @type {Feature} */
      evt.target;
      this.removeFeature_(feature);
      this.addFeature_(feature);
    }
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Modify.prototype.handleFeatureRemove_ = function (evt) {
    var feature =
    /** @type {Feature} */
    evt.element;
    this.removeFeature_(feature);
  };
  /**
   * @param {Feature} feature Feature
   * @param {Point} geometry Geometry.
   * @private
   */


  Modify.prototype.writePointGeometry_ = function (feature, geometry) {
    var coordinates = geometry.getCoordinates();
    /** @type {SegmentData} */

    var segmentData = {
      feature: feature,
      geometry: geometry,
      segment: [coordinates, coordinates]
    };
    this.rBush_.insert(geometry.getExtent(), segmentData);
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeMultiPointGeometry_ = function (feature, geometry) {
    var points = geometry.getCoordinates();

    for (var i = 0, ii = points.length; i < ii; ++i) {
      var coordinates = points[i];
      /** @type {SegmentData} */

      var segmentData = {
        feature: feature,
        geometry: geometry,
        depth: [i],
        index: i,
        segment: [coordinates, coordinates]
      };
      this.rBush_.insert(geometry.getExtent(), segmentData);
    }
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeLineStringGeometry_ = function (feature, geometry) {
    var coordinates = geometry.getCoordinates();

    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      /** @type {SegmentData} */

      var segmentData = {
        feature: feature,
        geometry: geometry,
        index: i,
        segment: segment
      };
      this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
    }
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeMultiLineStringGeometry_ = function (feature, geometry) {
    var lines = geometry.getCoordinates();

    for (var j = 0, jj = lines.length; j < jj; ++j) {
      var coordinates = lines[j];

      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        /** @type {SegmentData} */

        var segmentData = {
          feature: feature,
          geometry: geometry,
          depth: [j],
          index: i,
          segment: segment
        };
        this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
      }
    }
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writePolygonGeometry_ = function (feature, geometry) {
    var rings = geometry.getCoordinates();

    for (var j = 0, jj = rings.length; j < jj; ++j) {
      var coordinates = rings[j];

      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        /** @type {SegmentData} */

        var segmentData = {
          feature: feature,
          geometry: geometry,
          depth: [j],
          index: i,
          segment: segment
        };
        this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
      }
    }
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeMultiPolygonGeometry_ = function (feature, geometry) {
    var polygons = geometry.getCoordinates();

    for (var k = 0, kk = polygons.length; k < kk; ++k) {
      var rings = polygons[k];

      for (var j = 0, jj = rings.length; j < jj; ++j) {
        var coordinates = rings[j];

        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          var segment = coordinates.slice(i, i + 2);
          /** @type {SegmentData} */

          var segmentData = {
            feature: feature,
            geometry: geometry,
            depth: [j, k],
            index: i,
            segment: segment
          };
          this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
        }
      }
    }
  };
  /**
   * We convert a circle into two segments.  The segment at index
   * {@link CIRCLE_CENTER_INDEX} is the
   * circle's center (a point).  The segment at index
   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
   * the circumference, and is not a line segment.
   *
   * @param {Feature} feature Feature.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeCircleGeometry_ = function (feature, geometry) {
    var coordinates = geometry.getCenter();
    /** @type {SegmentData} */

    var centerSegmentData = {
      feature: feature,
      geometry: geometry,
      index: CIRCLE_CENTER_INDEX,
      segment: [coordinates, coordinates]
    };
    /** @type {SegmentData} */

    var circumferenceSegmentData = {
      feature: feature,
      geometry: geometry,
      index: CIRCLE_CIRCUMFERENCE_INDEX,
      segment: [coordinates, coordinates]
    };
    var featureSegments = [centerSegmentData, circumferenceSegmentData];
    centerSegmentData.featureSegments = featureSegments;
    circumferenceSegmentData.featureSegments = featureSegments;
    this.rBush_.insert((0, _extent.createOrUpdateFromCoordinate)(coordinates), centerSegmentData);
    var circleGeometry =
    /** @type {import("../geom/Geometry.js").default} */
    geometry;
    var userProjection = (0, _proj.getUserProjection)();

    if (userProjection && this.getMap()) {
      var projection = this.getMap().getView().getProjection();
      circleGeometry = circleGeometry.clone().transform(userProjection, projection);
      circleGeometry = (0, _Polygon.fromCircle)(
      /** @type {import("../geom/Circle.js").default} */
      circleGeometry).transform(projection, userProjection);
    }

    this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeGeometryCollectionGeometry_ = function (feature, geometry) {
    var geometries = geometry.getGeometriesArray();

    for (var i = 0; i < geometries.length; ++i) {
      var geometry_1 = geometries[i];
      var writer = this.SEGMENT_WRITERS_[geometry_1.getType()];
      writer(feature, geometry_1);
    }
  };
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @return {Feature} Vertex feature.
   * @private
   */


  Modify.prototype.createOrUpdateVertexFeature_ = function (coordinates) {
    var vertexFeature = this.vertexFeature_;

    if (!vertexFeature) {
      vertexFeature = new _Feature.default(new _Point.default(coordinates));
      this.vertexFeature_ = vertexFeature;
      this.overlay_.getSource().addFeature(vertexFeature);
    } else {
      var geometry = vertexFeature.getGeometry();
      geometry.setCoordinates(coordinates);
    }

    return vertexFeature;
  };
  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may modify the geometry.
   * @override
   */


  Modify.prototype.handleEvent = function (mapBrowserEvent) {
    if (!
    /** @type {import("../MapBrowserPointerEvent.js").default} */
    mapBrowserEvent.pointerEvent) {
      return true;
    }

    this.lastPointerEvent_ = mapBrowserEvent;
    var handled;

    if (!mapBrowserEvent.map.getView().getInteracting() && mapBrowserEvent.type == _MapBrowserEventType.default.POINTERMOVE && !this.handlingDownUpSequence) {
      this.handlePointerMove_(mapBrowserEvent);
    }

    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
      if (mapBrowserEvent.type != _MapBrowserEventType.default.SINGLECLICK || !this.ignoreNextSingleClick_) {
        handled = this.removePoint();
      } else {
        handled = true;
      }
    }

    if (mapBrowserEvent.type == _MapBrowserEventType.default.SINGLECLICK) {
      this.ignoreNextSingleClick_ = false;
    }

    return _super.prototype.handleEvent.call(this, mapBrowserEvent) && !handled;
  };
  /**
   * @inheritDoc
   */


  Modify.prototype.handleDragEvent = function (evt) {
    this.ignoreNextSingleClick_ = false;
    this.willModifyFeatures_(evt);
    var vertex = evt.coordinate;

    for (var i = 0, ii = this.dragSegments_.length; i < ii; ++i) {
      var dragSegment = this.dragSegments_[i];
      var segmentData = dragSegment[0];
      var depth = segmentData.depth;
      var geometry = segmentData.geometry;
      var coordinates = void 0;
      var segment = segmentData.segment;
      var index = dragSegment[1];

      while (vertex.length < geometry.getStride()) {
        vertex.push(segment[index][vertex.length]);
      }

      switch (geometry.getType()) {
        case _GeometryType.default.POINT:
          coordinates = vertex;
          segment[0] = vertex;
          segment[1] = vertex;
          break;

        case _GeometryType.default.MULTI_POINT:
          coordinates = geometry.getCoordinates();
          coordinates[segmentData.index] = vertex;
          segment[0] = vertex;
          segment[1] = vertex;
          break;

        case _GeometryType.default.LINE_STRING:
          coordinates = geometry.getCoordinates();
          coordinates[segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;

        case _GeometryType.default.MULTI_LINE_STRING:
          coordinates = geometry.getCoordinates();
          coordinates[depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;

        case _GeometryType.default.POLYGON:
          coordinates = geometry.getCoordinates();
          coordinates[depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;

        case _GeometryType.default.MULTI_POLYGON:
          coordinates = geometry.getCoordinates();
          coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;

        case _GeometryType.default.CIRCLE:
          segment[0] = vertex;
          segment[1] = vertex;

          if (segmentData.index === CIRCLE_CENTER_INDEX) {
            this.changingFeature_ = true;
            geometry.setCenter(vertex);
            this.changingFeature_ = false;
          } else {
            // We're dragging the circle's circumference:
            this.changingFeature_ = true;
            var projection = evt.map.getView().getProjection();
            var radius = (0, _coordinate.distance)((0, _proj.fromUserCoordinate)(geometry.getCenter(), projection), (0, _proj.fromUserCoordinate)(vertex, projection));
            var userProjection = (0, _proj.getUserProjection)();

            if (userProjection) {
              var circleGeometry = geometry.clone().transform(userProjection, projection);
              circleGeometry.setRadius(radius);
              radius = circleGeometry.transform(projection, userProjection).getRadius();
            }

            geometry.setRadius(radius);
            this.changingFeature_ = false;
          }

          break;

        default: // pass

      }

      if (coordinates) {
        this.setGeometryCoordinates_(geometry, coordinates);
      }
    }

    this.createOrUpdateVertexFeature_(vertex);
  };
  /**
   * @inheritDoc
   */


  Modify.prototype.handleDownEvent = function (evt) {
    if (!this.condition_(evt)) {
      return false;
    }

    var pixelCoordinate = evt.coordinate;
    this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);
    this.dragSegments_.length = 0;
    this.modified_ = false;
    var vertexFeature = this.vertexFeature_;

    if (vertexFeature) {
      var projection = evt.map.getView().getProjection();
      var insertVertices = [];
      var vertex = vertexFeature.getGeometry().getCoordinates();
      var vertexExtent = (0, _extent.boundingExtent)([vertex]);
      var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
      var componentSegments = {};
      segmentDataMatches.sort(compareIndexes);

      for (var i = 0, ii = segmentDataMatches.length; i < ii; ++i) {
        var segmentDataMatch = segmentDataMatches[i];
        var segment = segmentDataMatch.segment;
        var uid = (0, _util.getUid)(segmentDataMatch.feature);
        var depth = segmentDataMatch.depth;

        if (depth) {
          uid += '-' + depth.join('-'); // separate feature components
        }

        if (!componentSegments[uid]) {
          componentSegments[uid] = new Array(2);
        }

        if (segmentDataMatch.geometry.getType() === _GeometryType.default.CIRCLE && segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {
          var closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch, projection);

          if ((0, _coordinate.equals)(closestVertex, vertex) && !componentSegments[uid][0]) {
            this.dragSegments_.push([segmentDataMatch, 0]);
            componentSegments[uid][0] = segmentDataMatch;
          }

          continue;
        }

        if ((0, _coordinate.equals)(segment[0], vertex) && !componentSegments[uid][0]) {
          this.dragSegments_.push([segmentDataMatch, 0]);
          componentSegments[uid][0] = segmentDataMatch;
          continue;
        }

        if ((0, _coordinate.equals)(segment[1], vertex) && !componentSegments[uid][1]) {
          // prevent dragging closed linestrings by the connecting node
          if ((segmentDataMatch.geometry.getType() === _GeometryType.default.LINE_STRING || segmentDataMatch.geometry.getType() === _GeometryType.default.MULTI_LINE_STRING) && componentSegments[uid][0] && componentSegments[uid][0].index === 0) {
            continue;
          }

          this.dragSegments_.push([segmentDataMatch, 1]);
          componentSegments[uid][1] = segmentDataMatch;
          continue;
        }

        if ((0, _util.getUid)(segment) in this.vertexSegments_ && !componentSegments[uid][0] && !componentSegments[uid][1] && this.insertVertexCondition_(evt)) {
          insertVertices.push([segmentDataMatch, vertex]);
        }
      }

      if (insertVertices.length) {
        this.willModifyFeatures_(evt);
      }

      for (var j = insertVertices.length - 1; j >= 0; --j) {
        this.insertVertex_.apply(this, insertVertices[j]);
      }
    }

    return !!this.vertexFeature_;
  };
  /**
   * @inheritDoc
   */


  Modify.prototype.handleUpEvent = function (evt) {
    for (var i = this.dragSegments_.length - 1; i >= 0; --i) {
      var segmentData = this.dragSegments_[i][0];
      var geometry = segmentData.geometry;

      if (geometry.getType() === _GeometryType.default.CIRCLE) {
        // Update a circle object in the R* bush:
        var coordinates = geometry.getCenter();
        var centerSegmentData = segmentData.featureSegments[0];
        var circumferenceSegmentData = segmentData.featureSegments[1];
        centerSegmentData.segment[0] = coordinates;
        centerSegmentData.segment[1] = coordinates;
        circumferenceSegmentData.segment[0] = coordinates;
        circumferenceSegmentData.segment[1] = coordinates;
        this.rBush_.update((0, _extent.createOrUpdateFromCoordinate)(coordinates), centerSegmentData);
        var circleGeometry = geometry;
        var userProjection = (0, _proj.getUserProjection)();

        if (userProjection) {
          var projection = evt.map.getView().getProjection();
          circleGeometry = circleGeometry.clone().transform(userProjection, projection);
          circleGeometry = (0, _Polygon.fromCircle)(circleGeometry).transform(projection, userProjection);
        }

        this.rBush_.update(circleGeometry.getExtent(), circumferenceSegmentData);
      } else {
        this.rBush_.update((0, _extent.boundingExtent)(segmentData.segment), segmentData);
      }
    }

    if (this.modified_) {
      this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.features_, evt));
      this.modified_ = false;
    }

    return false;
  };
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @private
   */


  Modify.prototype.handlePointerMove_ = function (evt) {
    this.lastPixel_ = evt.pixel;
    this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);
  };
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../PluggableMap.js").default} map Map.
   * @param {import("../coordinate.js").Coordinate=} opt_coordinate The pixel Coordinate.
   * @private
   */


  Modify.prototype.handlePointerAtPixel_ = function (pixel, map, opt_coordinate) {
    var pixelCoordinate = opt_coordinate || map.getCoordinateFromPixel(pixel);
    var projection = map.getView().getProjection();

    var sortByDistance = function (a, b) {
      return projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) - projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection);
    };

    var viewExtent = (0, _proj.fromUserExtent)((0, _extent.createOrUpdateFromCoordinate)(pixelCoordinate, tempExtent), projection);
    var buffer = map.getView().getResolution() * this.pixelTolerance_;
    var box = (0, _proj.toUserExtent)((0, _extent.buffer)(viewExtent, buffer, tempExtent), projection);
    var rBush = this.rBush_;
    var nodes = rBush.getInExtent(box);

    if (nodes.length > 0) {
      nodes.sort(sortByDistance);
      var node = nodes[0];
      var closestSegment = node.segment;
      var vertex = closestOnSegmentData(pixelCoordinate, node, projection);
      var vertexPixel = map.getPixelFromCoordinate(vertex);
      var dist = (0, _coordinate.distance)(pixel, vertexPixel);

      if (dist <= this.pixelTolerance_) {
        /** @type {Object<string, boolean>} */
        var vertexSegments = {};

        if (node.geometry.getType() === _GeometryType.default.CIRCLE && node.index === CIRCLE_CIRCUMFERENCE_INDEX) {
          this.snappedToVertex_ = true;
          this.createOrUpdateVertexFeature_(vertex);
        } else {
          var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
          var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
          var squaredDist1 = (0, _coordinate.squaredDistance)(vertexPixel, pixel1);
          var squaredDist2 = (0, _coordinate.squaredDistance)(vertexPixel, pixel2);
          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
          this.snappedToVertex_ = dist <= this.pixelTolerance_;

          if (this.snappedToVertex_) {
            vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
          }

          this.createOrUpdateVertexFeature_(vertex);

          for (var i = 1, ii = nodes.length; i < ii; ++i) {
            var segment = nodes[i].segment;

            if ((0, _coordinate.equals)(closestSegment[0], segment[0]) && (0, _coordinate.equals)(closestSegment[1], segment[1]) || (0, _coordinate.equals)(closestSegment[0], segment[1]) && (0, _coordinate.equals)(closestSegment[1], segment[0])) {
              vertexSegments[(0, _util.getUid)(segment)] = true;
            } else {
              break;
            }
          }
        }

        vertexSegments[(0, _util.getUid)(closestSegment)] = true;
        this.vertexSegments_ = vertexSegments;
        return;
      }
    }

    if (this.vertexFeature_) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
  };
  /**
   * @param {SegmentData} segmentData Segment data.
   * @param {import("../coordinate.js").Coordinate} vertex Vertex.
   * @private
   */


  Modify.prototype.insertVertex_ = function (segmentData, vertex) {
    var segment = segmentData.segment;
    var feature = segmentData.feature;
    var geometry = segmentData.geometry;
    var depth = segmentData.depth;
    var index = segmentData.index;
    var coordinates;

    while (vertex.length < geometry.getStride()) {
      vertex.push(0);
    }

    switch (geometry.getType()) {
      case _GeometryType.default.MULTI_LINE_STRING:
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;

      case _GeometryType.default.POLYGON:
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;

      case _GeometryType.default.MULTI_POLYGON:
        coordinates = geometry.getCoordinates();
        coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
        break;

      case _GeometryType.default.LINE_STRING:
        coordinates = geometry.getCoordinates();
        coordinates.splice(index + 1, 0, vertex);
        break;

      default:
        return;
    }

    this.setGeometryCoordinates_(geometry, coordinates);
    var rTree = this.rBush_;
    rTree.remove(segmentData);
    this.updateSegmentIndices_(geometry, index, depth, 1);
    /** @type {SegmentData} */

    var newSegmentData = {
      segment: [segment[0], vertex],
      feature: feature,
      geometry: geometry,
      depth: depth,
      index: index
    };
    rTree.insert((0, _extent.boundingExtent)(newSegmentData.segment), newSegmentData);
    this.dragSegments_.push([newSegmentData, 1]);
    /** @type {SegmentData} */

    var newSegmentData2 = {
      segment: [vertex, segment[1]],
      feature: feature,
      geometry: geometry,
      depth: depth,
      index: index + 1
    };
    rTree.insert((0, _extent.boundingExtent)(newSegmentData2.segment), newSegmentData2);
    this.dragSegments_.push([newSegmentData2, 0]);
    this.ignoreNextSingleClick_ = true;
  };
  /**
   * Removes the vertex currently being pointed.
   * @return {boolean} True when a vertex was removed.
   * @api
   */


  Modify.prototype.removePoint = function () {
    if (this.lastPointerEvent_ && this.lastPointerEvent_.type != _MapBrowserEventType.default.POINTERDRAG) {
      var evt = this.lastPointerEvent_;
      this.willModifyFeatures_(evt);
      var removed = this.removeVertex_();
      this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.features_, evt));
      this.modified_ = false;
      return removed;
    }

    return false;
  };
  /**
   * Removes a vertex from all matching features.
   * @return {boolean} True when a vertex was removed.
   * @private
   */


  Modify.prototype.removeVertex_ = function () {
    var dragSegments = this.dragSegments_;
    var segmentsByFeature = {};
    var deleted = false;
    var component, coordinates, dragSegment, geometry, i, index, left;
    var newIndex, right, segmentData, uid;

    for (i = dragSegments.length - 1; i >= 0; --i) {
      dragSegment = dragSegments[i];
      segmentData = dragSegment[0];
      uid = (0, _util.getUid)(segmentData.feature);

      if (segmentData.depth) {
        // separate feature components
        uid += '-' + segmentData.depth.join('-');
      }

      if (!(uid in segmentsByFeature)) {
        segmentsByFeature[uid] = {};
      }

      if (dragSegment[1] === 0) {
        segmentsByFeature[uid].right = segmentData;
        segmentsByFeature[uid].index = segmentData.index;
      } else if (dragSegment[1] == 1) {
        segmentsByFeature[uid].left = segmentData;
        segmentsByFeature[uid].index = segmentData.index + 1;
      }
    }

    for (uid in segmentsByFeature) {
      right = segmentsByFeature[uid].right;
      left = segmentsByFeature[uid].left;
      index = segmentsByFeature[uid].index;
      newIndex = index - 1;

      if (left !== undefined) {
        segmentData = left;
      } else {
        segmentData = right;
      }

      if (newIndex < 0) {
        newIndex = 0;
      }

      geometry = segmentData.geometry;
      coordinates = geometry.getCoordinates();
      component = coordinates;
      deleted = false;

      switch (geometry.getType()) {
        case _GeometryType.default.MULTI_LINE_STRING:
          if (coordinates[segmentData.depth[0]].length > 2) {
            coordinates[segmentData.depth[0]].splice(index, 1);
            deleted = true;
          }

          break;

        case _GeometryType.default.LINE_STRING:
          if (coordinates.length > 2) {
            coordinates.splice(index, 1);
            deleted = true;
          }

          break;

        case _GeometryType.default.MULTI_POLYGON:
          component = component[segmentData.depth[1]];

        /* falls through */

        case _GeometryType.default.POLYGON:
          component = component[segmentData.depth[0]];

          if (component.length > 4) {
            if (index == component.length - 1) {
              index = 0;
            }

            component.splice(index, 1);
            deleted = true;

            if (index === 0) {
              // close the ring again
              component.pop();
              component.push(component[0]);
              newIndex = component.length - 1;
            }
          }

          break;

        default: // pass

      }

      if (deleted) {
        this.setGeometryCoordinates_(geometry, coordinates);
        var segments = [];

        if (left !== undefined) {
          this.rBush_.remove(left);
          segments.push(left.segment[0]);
        }

        if (right !== undefined) {
          this.rBush_.remove(right);
          segments.push(right.segment[1]);
        }

        if (left !== undefined && right !== undefined) {
          /** @type {SegmentData} */
          var newSegmentData = {
            depth: segmentData.depth,
            feature: segmentData.feature,
            geometry: segmentData.geometry,
            index: newIndex,
            segment: segments
          };
          this.rBush_.insert((0, _extent.boundingExtent)(newSegmentData.segment), newSegmentData);
        }

        this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);

        if (this.vertexFeature_) {
          this.overlay_.getSource().removeFeature(this.vertexFeature_);
          this.vertexFeature_ = null;
        }

        dragSegments.length = 0;
      }
    }

    return deleted;
  };
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {Array} coordinates Coordinates.
   * @private
   */


  Modify.prototype.setGeometryCoordinates_ = function (geometry, coordinates) {
    this.changingFeature_ = true;
    geometry.setCoordinates(coordinates);
    this.changingFeature_ = false;
  };
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {number} index Index.
   * @param {Array<number>|undefined} depth Depth.
   * @param {number} delta Delta (1 or -1).
   * @private
   */


  Modify.prototype.updateSegmentIndices_ = function (geometry, index, depth, delta) {
    this.rBush_.forEachInExtent(geometry.getExtent(), function (segmentDataMatch) {
      if (segmentDataMatch.geometry === geometry && (depth === undefined || segmentDataMatch.depth === undefined || (0, _array.equals)(segmentDataMatch.depth, depth)) && segmentDataMatch.index > index) {
        segmentDataMatch.index += delta;
      }
    });
  };

  return Modify;
}(_Pointer.default);
/**
 * @param {SegmentData} a The first segment data.
 * @param {SegmentData} b The second segment data.
 * @return {number} The difference in indexes.
 */


function compareIndexes(a, b) {
  return a.index - b.index;
}
/**
 * Returns the distance from a point to a line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The coordinates of the point from
 *        which to calculate the distance.
 * @param {SegmentData} segmentData The object describing the line
 *        segment we are calculating the distance to.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {number} The square of the distance between a point and a line segment.
 */


function projectedDistanceToSegmentDataSquared(pointCoordinates, segmentData, projection) {
  var geometry = segmentData.geometry;

  if (geometry.getType() === _GeometryType.default.CIRCLE) {
    var circleGeometry =
    /** @type {import("../geom/Circle.js").default} */
    geometry;

    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
      var userProjection = (0, _proj.getUserProjection)();

      if (userProjection) {
        circleGeometry =
        /** @type {import("../geom/Circle.js").default} */
        circleGeometry.clone().transform(userProjection, projection);
      }

      var distanceToCenterSquared = (0, _coordinate.squaredDistance)(circleGeometry.getCenter(), (0, _proj.fromUserCoordinate)(pointCoordinates, projection));
      var distanceToCircumference = Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
      return distanceToCircumference * distanceToCircumference;
    }
  }

  var coordinate = (0, _proj.fromUserCoordinate)(pointCoordinates, projection);
  tempSegment[0] = (0, _proj.fromUserCoordinate)(segmentData.segment[0], projection);
  tempSegment[1] = (0, _proj.fromUserCoordinate)(segmentData.segment[1], projection);
  return (0, _coordinate.squaredDistanceToSegment)(coordinate, tempSegment);
}
/**
 * Returns the point closest to a given line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The point to which a closest point
 *        should be found.
 * @param {SegmentData} segmentData The object describing the line
 *        segment which should contain the closest point.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {import("../coordinate.js").Coordinate} The point closest to the specified line segment.
 */


function closestOnSegmentData(pointCoordinates, segmentData, projection) {
  var geometry = segmentData.geometry;

  if (geometry.getType() === _GeometryType.default.CIRCLE && segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
    var circleGeometry =
    /** @type {import("../geom/Circle.js").default} */
    geometry;
    var userProjection = (0, _proj.getUserProjection)();

    if (userProjection) {
      circleGeometry =
      /** @type {import("../geom/Circle.js").default} */
      circleGeometry.clone().transform(userProjection, projection);
    }

    return (0, _proj.toUserCoordinate)(circleGeometry.getClosestPoint((0, _proj.fromUserCoordinate)(pointCoordinates, projection)), projection);
  }

  var coordinate = (0, _proj.fromUserCoordinate)(pointCoordinates, projection);
  tempSegment[0] = (0, _proj.fromUserCoordinate)(segmentData.segment[0], projection);
  tempSegment[1] = (0, _proj.fromUserCoordinate)(segmentData.segment[1], projection);
  return (0, _proj.toUserCoordinate)((0, _coordinate.closestOnSegment)(coordinate, tempSegment), projection);
}
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */


function getDefaultStyleFunction() {
  var style = (0, _Style.createEditingStyle)();
  return function (feature, resolution) {
    return style[_GeometryType.default.POINT];
  };
}

var _default = Modify;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","../Collection.js":"node_modules/ol/Collection.js","../CollectionEventType.js":"node_modules/ol/CollectionEventType.js","../Feature.js":"node_modules/ol/Feature.js","../MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","../array.js":"node_modules/ol/array.js","../coordinate.js":"node_modules/ol/coordinate.js","../events/Event.js":"node_modules/ol/events/Event.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../events/condition.js":"node_modules/ol/events/condition.js","../extent.js":"node_modules/ol/extent.js","../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../geom/Point.js":"node_modules/ol/geom/Point.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js","../layer/Vector.js":"node_modules/ol/layer/Vector.js","../source/Vector.js":"node_modules/ol/source/Vector.js","../source/VectorEventType.js":"node_modules/ol/source/VectorEventType.js","../structs/RBush.js":"node_modules/ol/structs/RBush.js","../style/Style.js":"node_modules/ol/style/Style.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/interaction/Select.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("../util.js");

var _CollectionEventType = _interopRequireDefault(require("../CollectionEventType.js"));

var _array = require("../array.js");

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _condition = require("../events/condition.js");

var _functions = require("../functions.js");

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _Interaction = _interopRequireDefault(require("./Interaction.js"));

var _obj = require("../obj.js");

var _Style = require("../style/Style.js");

var _Collection = _interopRequireDefault(require("../Collection.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/Select
 */


/**
 * @enum {string}
 */
var SelectEventType = {
  /**
   * Triggered when feature(s) has been (de)selected.
   * @event SelectEvent#select
   * @api
   */
  SELECT: 'select'
};
/**
 * A function that takes an {@link module:ol/Feature} or
 * {@link module:ol/render/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default):boolean} FilterFunction
 */

/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [addCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition~never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is the event
 * for the selected features as a whole. By default, this is
 * {@link module:ol/events/condition~singleClick}. Clicking on a feature selects that
 * feature and removes any that were in the selection. Clicking outside any
 * feature removes all from the selection.
 * See `toggle`, `add`, `remove` options for adding/removing extra features to/
 * from the selection.
 * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default): boolean} [layers]
 * A list of layers from which features should be selected. Alternatively, a
 * filter function can be provided. The function will be called for each layer
 * in the map and should return `true` for layers that you want to be
 * selectable. If the option is absent, all visible layers will be considered
 * selectable.
 * @property {import("../style/Style.js").StyleLike} [style]
 * Style for the selected features. By default the default edit style is used
 * (see {@link module:ol/style}).
 * If set to a falsey value, the selected feature's style will not change.
 * @property {import("../events/condition.js").Condition} [removeCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition~never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [toggleCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is in addition
 * to the `condition` event. By default,
 * {@link module:ol/events/condition~shiftKeyOnly}, i.e. pressing `shift` as
 * well as the `condition` event, adds that feature to the current selection if
 * it is not currently selected, and removes it if it is. See `add` and `remove`
 * if you want to use different events instead of a toggle.
 * @property {boolean} [multi=false] A boolean that determines if the default
 * behaviour should select only single features or all (overlapping) features at
 * the clicked map position. The default of `false` means single select.
 * @property {import("../Collection.js").default<import("../Feature.js").default>} [features]
 * Collection where the interaction will place selected features. Optional. If
 * not set the interaction will create a collection. In any case the collection
 * used by the interaction is returned by
 * {@link module:ol/interaction/Select~Select#getFeatures}.
 * @property {FilterFunction} [filter] A function
 * that takes an {@link module:ol/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside
 * the radius around the given position will be checked for features.
 */

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of
 * this type.
 */

var SelectEvent =
/** @class */
function (_super) {
  __extends(SelectEvent, _super);
  /**
   * @param {SelectEventType} type The event type.
   * @param {Array<import("../Feature.js").default>} selected Selected features.
   * @param {Array<import("../Feature.js").default>} deselected Deselected features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Associated
   *     {@link module:ol/MapBrowserEvent}.
   */


  function SelectEvent(type, selected, deselected, mapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    /**
     * Selected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */


    _this.selected = selected;
    /**
     * Deselected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */

    _this.deselected = deselected;
    /**
     * Associated {@link module:ol/MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */

    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }

  return SelectEvent;
}(_Event.default);
/**
 * Original feature styles to reset to when features are no longer selected.
 * @type {Object.<number, import("../style/Style.js").default|Array.<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction>}
 */


var originalFeatureStyles = {};
/**
 * @classdesc
 * Interaction for selecting vector features. By default, selected features are
 * styled differently, so this interaction can be used for visual highlighting,
 * as well as selecting features for other actions, such as modification or
 * output. There are three ways of controlling which features are selected:
 * using the browser event as defined by the `condition` and optionally the
 * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
 * further feature filter using the `filter` option.
 *
 * Selected features are added to an internal unmanaged layer.
 *
 * @fires SelectEvent
 * @api
 */

var Select =
/** @class */
function (_super) {
  __extends(Select, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function Select(opt_options) {
    var _this = _super.call(this, {
      handleEvent: handleEvent
    }) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @private
     */

    _this.boundAddFeature_ = _this.addFeature_.bind(_this);
    /**
     * @private
     */

    _this.boundRemoveFeature_ = _this.removeFeature_.bind(_this);
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _condition.singleClick;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.addCondition_ = options.addCondition ? options.addCondition : _condition.never;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.removeCondition_ = options.removeCondition ? options.removeCondition : _condition.never;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : _condition.shiftKeyOnly;
    /**
     * @private
     * @type {boolean}
     */

    _this.multi_ = options.multi ? options.multi : false;
    /**
     * @private
     * @type {FilterFunction}
     */

    _this.filter_ = options.filter ? options.filter : _functions.TRUE;
    /**
     * @private
     * @type {number}
     */

    _this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
    /**
     * @private
     * @type {import("../style/Style.js").default|Array.<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction|null}
     */

    _this.style_ = options.style !== undefined ? options.style : getDefaultStyleFunction();
    /**
     * @private
     * @type {import("../Collection.js").default}
     */

    _this.features_ = options.features || new _Collection.default();
    /** @type {function(import("../layer/Layer.js").default): boolean} */

    var layerFilter;

    if (options.layers) {
      if (typeof options.layers === 'function') {
        layerFilter = options.layers;
      } else {
        var layers_1 = options.layers;

        layerFilter = function (layer) {
          return (0, _array.includes)(layers_1, layer);
        };
      }
    } else {
      layerFilter = _functions.TRUE;
    }
    /**
     * @private
     * @type {function(import("../layer/Layer.js").default): boolean}
     */


    _this.layerFilter_ = layerFilter;
    /**
     * An association between selected feature (key)
     * and layer (value)
     * @private
     * @type {Object<string, import("../layer/Layer.js").default>}
     */

    _this.featureLayerAssociation_ = {};
    return _this;
  }
  /**
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {import("../layer/Layer.js").default} layer Layer.
   * @private
   */


  Select.prototype.addFeatureLayerAssociation_ = function (feature, layer) {
    this.featureLayerAssociation_[(0, _util.getUid)(feature)] = layer;
  };
  /**
   * Get the selected features.
   * @return {import("../Collection.js").default<import("../Feature.js").default>} Features collection.
   * @api
   */


  Select.prototype.getFeatures = function () {
    return this.features_;
  };
  /**
   * Returns the Hit-detection tolerance.
   * @returns {number} Hit tolerance in pixels.
   * @api
   */


  Select.prototype.getHitTolerance = function () {
    return this.hitTolerance_;
  };
  /**
   * Returns the associated {@link module:ol/layer/Vector~Vector vectorlayer} of
   * the (last) selected feature. Note that this will not work with any
   * programmatic method like pushing features to
   * {@link module:ol/interaction/Select~Select#getFeatures collection}.
   * @param {import("../Feature.js").FeatureLike} feature Feature
   * @return {import('../layer/Vector.js').default} Layer.
   * @api
   */


  Select.prototype.getLayer = function (feature) {
    return (
      /** @type {import('../layer/Vector.js').default} */
      this.featureLayerAssociation_[(0, _util.getUid)(feature)]
    );
  };
  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */


  Select.prototype.setHitTolerance = function (hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  };
  /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {import("../PluggableMap.js").default} map Map.
   * @override
   * @api
   */


  Select.prototype.setMap = function (map) {
    var currentMap = this.getMap();

    if (currentMap && this.style_) {
      this.features_.forEach(this.restorePreviousStyle_.bind(this));
    }

    _super.prototype.setMap.call(this, map);

    if (map) {
      this.features_.addEventListener(_CollectionEventType.default.ADD, this.boundAddFeature_);
      this.features_.addEventListener(_CollectionEventType.default.REMOVE, this.boundRemoveFeature_);

      if (this.style_) {
        this.features_.forEach(this.applySelectedStyle_.bind(this));
      }
    } else {
      this.features_.removeEventListener(_CollectionEventType.default.ADD, this.boundAddFeature_);
      this.features_.removeEventListener(_CollectionEventType.default.REMOVE, this.boundRemoveFeature_);
    }
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Select.prototype.addFeature_ = function (evt) {
    var feature = evt.element;

    if (this.style_) {
      this.applySelectedStyle_(feature);
    }
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Select.prototype.removeFeature_ = function (evt) {
    var feature = evt.element;

    if (this.style_) {
      this.restorePreviousStyle_(feature);
    }
  };
  /**
   * @return {import("../style/Style.js").default|Array.<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction|null} Select style.
   */


  Select.prototype.getStyle = function () {
    return this.style_;
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @private
   */


  Select.prototype.applySelectedStyle_ = function (feature) {
    var key = (0, _util.getUid)(feature);

    if (!(key in originalFeatureStyles)) {
      originalFeatureStyles[key] = feature.getStyle();
    }

    feature.setStyle(this.style_);
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @private
   */


  Select.prototype.restorePreviousStyle_ = function (feature) {
    var key = (0, _util.getUid)(feature);
    var selectInteractions =
    /** @type {Array<Select>} */
    this.getMap().getInteractions().getArray().filter(function (interaction) {
      return interaction instanceof Select && interaction.getStyle() && interaction.getFeatures().getArray().indexOf(feature) !== -1;
    });

    if (selectInteractions.length > 0) {
      feature.setStyle(selectInteractions[selectInteractions.length - 1].getStyle());
    } else {
      feature.setStyle(originalFeatureStyles[key]);
      delete originalFeatureStyles[key];
    }
  };
  /**
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @private
   */


  Select.prototype.removeFeatureLayerAssociation_ = function (feature) {
    delete this.featureLayerAssociation_[(0, _util.getUid)(feature)];
  };

  return Select;
}(_Interaction.default);
/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} and may change the
 * selected state of features.
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {Select}
 */


function handleEvent(mapBrowserEvent) {
  if (!this.condition_(mapBrowserEvent)) {
    return true;
  }

  var add = this.addCondition_(mapBrowserEvent);
  var remove = this.removeCondition_(mapBrowserEvent);
  var toggle = this.toggleCondition_(mapBrowserEvent);
  var set = !add && !remove && !toggle;
  var map = mapBrowserEvent.map;
  var features = this.getFeatures();
  var deselected = [];
  var selected = [];

  if (set) {
    // Replace the currently selected feature(s) with the feature(s) at the
    // pixel, or clear the selected feature(s) if there is no feature at
    // the pixel.
    (0, _obj.clear)(this.featureLayerAssociation_);
    map.forEachFeatureAtPixel(mapBrowserEvent.pixel,
    /**
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../layer/Layer.js").default} layer Layer.
     * @return {boolean|undefined} Continue to iterate over the features.
     */
    function (feature, layer) {
      if (this.filter_(feature, layer)) {
        selected.push(feature);
        this.addFeatureLayerAssociation_(feature, layer);
        return !this.multi_;
      }
    }.bind(this), {
      layerFilter: this.layerFilter_,
      hitTolerance: this.hitTolerance_
    });

    for (var i = features.getLength() - 1; i >= 0; --i) {
      var feature = features.item(i);
      var index = selected.indexOf(feature);

      if (index > -1) {
        // feature is already selected
        selected.splice(index, 1);
      } else {
        features.remove(feature);
        deselected.push(feature);
      }
    }

    if (selected.length !== 0) {
      features.extend(selected);
    }
  } else {
    // Modify the currently selected feature(s).
    map.forEachFeatureAtPixel(mapBrowserEvent.pixel,
    /**
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../layer/Layer.js").default} layer Layer.
     * @return {boolean|undefined} Continue to iterate over the features.
     */
    function (feature, layer) {
      if (this.filter_(feature, layer)) {
        if ((add || toggle) && !(0, _array.includes)(features.getArray(), feature)) {
          selected.push(feature);
          this.addFeatureLayerAssociation_(feature, layer);
        } else if ((remove || toggle) && (0, _array.includes)(features.getArray(), feature)) {
          deselected.push(feature);
          this.removeFeatureLayerAssociation_(feature);
        }

        return !this.multi_;
      }
    }.bind(this), {
      layerFilter: this.layerFilter_,
      hitTolerance: this.hitTolerance_
    });

    for (var j = deselected.length - 1; j >= 0; --j) {
      features.remove(deselected[j]);
    }

    features.extend(selected);
  }

  if (selected.length > 0 || deselected.length > 0) {
    this.dispatchEvent(new SelectEvent(SelectEventType.SELECT, selected, deselected, mapBrowserEvent));
  }

  return true;
}
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */


function getDefaultStyleFunction() {
  var styles = (0, _Style.createEditingStyle)();
  (0, _array.extend)(styles[_GeometryType.default.POLYGON], styles[_GeometryType.default.LINE_STRING]);
  (0, _array.extend)(styles[_GeometryType.default.GEOMETRY_COLLECTION], styles[_GeometryType.default.LINE_STRING]);
  return function (feature) {
    if (!feature.getGeometry()) {
      return null;
    }

    return styles[feature.getGeometry().getType()];
  };
}

var _default = Select;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","../CollectionEventType.js":"node_modules/ol/CollectionEventType.js","../array.js":"node_modules/ol/array.js","../events/Event.js":"node_modules/ol/events/Event.js","../events/condition.js":"node_modules/ol/events/condition.js","../functions.js":"node_modules/ol/functions.js","../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","./Interaction.js":"node_modules/ol/interaction/Interaction.js","../obj.js":"node_modules/ol/obj.js","../style/Style.js":"node_modules/ol/style/Style.js","../Collection.js":"node_modules/ol/Collection.js"}],"node_modules/ol/interaction/Snap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("../util.js");

var _CollectionEventType = _interopRequireDefault(require("../CollectionEventType.js"));

var _coordinate = require("../coordinate.js");

var _events = require("../events.js");

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _extent = require("../extent.js");

var _functions = require("../functions.js");

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _Polygon = require("../geom/Polygon.js");

var _Pointer = _interopRequireDefault(require("./Pointer.js"));

var _obj = require("../obj.js");

var _VectorEventType = _interopRequireDefault(require("../source/VectorEventType.js"));

var _RBush = _interopRequireDefault(require("../structs/RBush.js"));

var _proj = require("../proj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/Snap
 */


/**
 * @typedef {Object} Result
 * @property {boolean} snapped
 * @property {import("../coordinate.js").Coordinate|null} vertex
 * @property {import("../pixel.js").Pixel|null} vertexPixel
 */

/**
 * @typedef {Object} SegmentData
 * @property {import("../Feature.js").default} feature
 * @property {Array<import("../coordinate.js").Coordinate>} segment
 */

/**
 * @typedef {Object} Options
 * @property {import("../Collection.js").default<import("../Feature.js").default>} [features] Snap to these features. Either this option or source should be provided.
 * @property {boolean} [edge=true] Snap to edges.
 * @property {boolean} [vertex=true] Snap to vertices.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or
 * vertex for snapping.
 * @property {import("../source/Vector.js").default} [source] Snap to features from this source. Either this option or features should be provided
 */

/**
 * @param  {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
 * @return {import("../Feature.js").default} Feature.
 */
function getFeatureFromEvent(evt) {
  if (
  /** @type {import("../source/Vector.js").VectorSourceEvent} */
  evt.feature) {
    return (
      /** @type {import("../source/Vector.js").VectorSourceEvent} */
      evt.feature
    );
  } else if (
  /** @type {import("../Collection.js").CollectionEvent} */
  evt.element) {
    return (
      /** @type {import("../Feature.js").default} */

      /** @type {import("../Collection.js").CollectionEvent} */
      evt.element
    );
  }
}

var tempSegment = [];
/**
 * @classdesc
 * Handles snapping of vector features while modifying or drawing them.  The
 * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}
 * Any interaction object that allows the user to interact
 * with the features using the mouse can benefit from the snapping, as long
 * as it is added before.
 *
 * The snap interaction modifies map browser event `coordinate` and `pixel`
 * properties to force the snap to occur to any interaction that them.
 *
 * Example:
 *
 *     import Snap from 'ol/interaction/Snap';
 *
 *     const snap = new Snap({
 *       source: source
 *     });
 *
 *     map.addInteraction(snap);
 *
 * @api
 */

var Snap =
/** @class */
function (_super) {
  __extends(Snap, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function Snap(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var pointerOptions =
    /** @type {import("./Pointer.js").Options} */
    options;

    if (!pointerOptions.handleDownEvent) {
      pointerOptions.handleDownEvent = _functions.TRUE;
    }

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions.FALSE;
    }

    _this = _super.call(this, pointerOptions) || this;
    /**
     * @type {import("../source/Vector.js").default}
     * @private
     */

    _this.source_ = options.source ? options.source : null;
    /**
     * @private
     * @type {boolean}
     */

    _this.vertex_ = options.vertex !== undefined ? options.vertex : true;
    /**
     * @private
     * @type {boolean}
     */

    _this.edge_ = options.edge !== undefined ? options.edge : true;
    /**
     * @type {import("../Collection.js").default<import("../Feature.js").default>}
     * @private
     */

    _this.features_ = options.features ? options.features : null;
    /**
     * @type {Array<import("../events.js").EventsKey>}
     * @private
     */

    _this.featuresListenerKeys_ = [];
    /**
     * @type {Object<string, import("../events.js").EventsKey>}
     * @private
     */

    _this.featureChangeListenerKeys_ = {};
    /**
     * Extents are preserved so indexed segment can be quickly removed
     * when its feature geometry changes
     * @type {Object<string, import("../extent.js").Extent>}
     * @private
     */

    _this.indexedFeaturesExtents_ = {};
    /**
     * If a feature geometry changes while a pointer drag|move event occurs, the
     * feature doesn't get updated right away.  It will be at the next 'pointerup'
     * event fired.
     * @type {!Object<string, import("../Feature.js").default>}
     * @private
     */

    _this.pendingFeatures_ = {};
    /**
     * @type {number}
     * @private
     */

    _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
    /**
    * Segment RTree for each layer
    * @type {import("../structs/RBush.js").default<SegmentData>}
    * @private
    */

    _this.rBush_ = new _RBush.default();
    /**
    * @const
    * @private
    * @type {Object<string, function(import("../Feature.js").default, import("../geom/Geometry.js").default): void>}
    */

    _this.SEGMENT_WRITERS_ = {
      'Point': _this.writePointGeometry_.bind(_this),
      'LineString': _this.writeLineStringGeometry_.bind(_this),
      'LinearRing': _this.writeLineStringGeometry_.bind(_this),
      'Polygon': _this.writePolygonGeometry_.bind(_this),
      'MultiPoint': _this.writeMultiPointGeometry_.bind(_this),
      'MultiLineString': _this.writeMultiLineStringGeometry_.bind(_this),
      'MultiPolygon': _this.writeMultiPolygonGeometry_.bind(_this),
      'GeometryCollection': _this.writeGeometryCollectionGeometry_.bind(_this),
      'Circle': _this.writeCircleGeometry_.bind(_this)
    };
    return _this;
  }
  /**
   * Add a feature to the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {boolean=} opt_listen Whether to listen to the feature change or not
   *     Defaults to `true`.
   * @api
   */


  Snap.prototype.addFeature = function (feature, opt_listen) {
    var register = opt_listen !== undefined ? opt_listen : true;
    var feature_uid = (0, _util.getUid)(feature);
    var geometry = feature.getGeometry();

    if (geometry) {
      var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];

      if (segmentWriter) {
        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent((0, _extent.createEmpty)());
        segmentWriter(feature, geometry);
      }
    }

    if (register) {
      this.featureChangeListenerKeys_[feature_uid] = (0, _events.listen)(feature, _EventType.default.CHANGE, this.handleFeatureChange_, this);
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @private
   */


  Snap.prototype.forEachFeatureAdd_ = function (feature) {
    this.addFeature(feature);
  };
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @private
   */


  Snap.prototype.forEachFeatureRemove_ = function (feature) {
    this.removeFeature(feature);
  };
  /**
   * @return {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} Features.
   * @private
   */


  Snap.prototype.getFeatures_ = function () {
    var features;

    if (this.features_) {
      features = this.features_;
    } else if (this.source_) {
      features = this.source_.getFeatures();
    }

    return features;
  };
  /**
   * @inheritDoc
   */


  Snap.prototype.handleEvent = function (evt) {
    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);

    if (result.snapped) {
      evt.coordinate = result.vertex.slice(0, 2);
      evt.pixel = result.vertexPixel;
    }

    return _super.prototype.handleEvent.call(this, evt);
  };
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Snap.prototype.handleFeatureAdd_ = function (evt) {
    var feature = getFeatureFromEvent(evt);
    this.addFeature(feature);
  };
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Snap.prototype.handleFeatureRemove_ = function (evt) {
    var feature = getFeatureFromEvent(evt);
    this.removeFeature(feature);
  };
  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */


  Snap.prototype.handleFeatureChange_ = function (evt) {
    var feature =
    /** @type {import("../Feature.js").default} */
    evt.target;

    if (this.handlingDownUpSequence) {
      var uid = (0, _util.getUid)(feature);

      if (!(uid in this.pendingFeatures_)) {
        this.pendingFeatures_[uid] = feature;
      }
    } else {
      this.updateFeature_(feature);
    }
  };
  /**
   * @inheritDoc
   */


  Snap.prototype.handleUpEvent = function (evt) {
    var featuresToUpdate = (0, _obj.getValues)(this.pendingFeatures_);

    if (featuresToUpdate.length) {
      featuresToUpdate.forEach(this.updateFeature_.bind(this));
      this.pendingFeatures_ = {};
    }

    return false;
  };
  /**
   * Remove a feature from the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature
   * @param {boolean=} opt_unlisten Whether to unlisten to the feature change
   *     or not. Defaults to `true`.
   * @api
   */


  Snap.prototype.removeFeature = function (feature, opt_unlisten) {
    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;
    var feature_uid = (0, _util.getUid)(feature);
    var extent = this.indexedFeaturesExtents_[feature_uid];

    if (extent) {
      var rBush = this.rBush_;
      var nodesToRemove_1 = [];
      rBush.forEachInExtent(extent, function (node) {
        if (feature === node.feature) {
          nodesToRemove_1.push(node);
        }
      });

      for (var i = nodesToRemove_1.length - 1; i >= 0; --i) {
        rBush.remove(nodesToRemove_1[i]);
      }
    }

    if (unregister) {
      (0, _events.unlistenByKey)(this.featureChangeListenerKeys_[feature_uid]);
      delete this.featureChangeListenerKeys_[feature_uid];
    }
  };
  /**
   * @inheritDoc
   */


  Snap.prototype.setMap = function (map) {
    var currentMap = this.getMap();
    var keys = this.featuresListenerKeys_;
    var features =
    /** @type {Array<import("../Feature.js").default>} */
    this.getFeatures_();

    if (currentMap) {
      keys.forEach(_events.unlistenByKey);
      keys.length = 0;
      features.forEach(this.forEachFeatureRemove_.bind(this));
    }

    _super.prototype.setMap.call(this, map);

    if (map) {
      if (this.features_) {
        keys.push((0, _events.listen)(this.features_, _CollectionEventType.default.ADD, this.handleFeatureAdd_, this), (0, _events.listen)(this.features_, _CollectionEventType.default.REMOVE, this.handleFeatureRemove_, this));
      } else if (this.source_) {
        keys.push((0, _events.listen)(this.source_, _VectorEventType.default.ADDFEATURE, this.handleFeatureAdd_, this), (0, _events.listen)(this.source_, _VectorEventType.default.REMOVEFEATURE, this.handleFeatureRemove_, this));
      }

      features.forEach(this.forEachFeatureAdd_.bind(this));
    }
  };
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../coordinate.js").Coordinate} pixelCoordinate Coordinate
   * @param {import("../PluggableMap.js").default} map Map.
   * @return {Result} Snap result
   */


  Snap.prototype.snapTo = function (pixel, pixelCoordinate, map) {
    var lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);
    var upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);
    var box = (0, _extent.boundingExtent)([lowerLeft, upperRight]);
    var segments = this.rBush_.getInExtent(box); // If snapping on vertices only, don't consider circles

    if (this.vertex_ && !this.edge_) {
      segments = segments.filter(function (segment) {
        return segment.feature.getGeometry().getType() !== _GeometryType.default.CIRCLE;
      });
    }

    var snapped = false;
    var vertex = null;
    var vertexPixel = null;

    if (segments.length === 0) {
      return {
        snapped: snapped,
        vertex: vertex,
        vertexPixel: vertexPixel
      };
    }

    var projection = map.getView().getProjection();
    var projectedCoordinate = (0, _proj.fromUserCoordinate)(pixelCoordinate, projection);
    var closestSegmentData;
    var minSquaredDistance = Infinity;

    for (var i = 0; i < segments.length; ++i) {
      var segmentData = segments[i];
      tempSegment[0] = (0, _proj.fromUserCoordinate)(segmentData.segment[0], projection);
      tempSegment[1] = (0, _proj.fromUserCoordinate)(segmentData.segment[1], projection);
      var delta = (0, _coordinate.squaredDistanceToSegment)(projectedCoordinate, tempSegment);

      if (delta < minSquaredDistance) {
        closestSegmentData = segmentData;
        minSquaredDistance = delta;
      }
    }

    var closestSegment = closestSegmentData.segment;

    if (this.vertex_ && !this.edge_) {
      var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
      var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
      var squaredDist1 = (0, _coordinate.squaredDistance)(pixel, pixel1);
      var squaredDist2 = (0, _coordinate.squaredDistance)(pixel, pixel2);
      var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));

      if (dist <= this.pixelTolerance_) {
        snapped = true;
        vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
        vertexPixel = map.getPixelFromCoordinate(vertex);
      }
    } else if (this.edge_) {
      var isCircle = closestSegmentData.feature.getGeometry().getType() === _GeometryType.default.CIRCLE;

      if (isCircle) {
        var circleGeometry = closestSegmentData.feature.getGeometry();
        var userProjection = (0, _proj.getUserProjection)();

        if (userProjection) {
          circleGeometry = circleGeometry.clone().transform(userProjection, projection);
        }

        vertex = (0, _proj.toUserCoordinate)((0, _coordinate.closestOnCircle)(projectedCoordinate,
        /** @type {import("../geom/Circle.js").default} */
        circleGeometry), projection);
      } else {
        tempSegment[0] = (0, _proj.fromUserCoordinate)(closestSegment[0], projection);
        tempSegment[1] = (0, _proj.fromUserCoordinate)(closestSegment[1], projection);
        vertex = (0, _proj.toUserCoordinate)((0, _coordinate.closestOnSegment)(projectedCoordinate, tempSegment), projection);
      }

      vertexPixel = map.getPixelFromCoordinate(vertex);

      if ((0, _coordinate.distance)(pixel, vertexPixel) <= this.pixelTolerance_) {
        snapped = true;

        if (this.vertex_ && !isCircle) {
          var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
          var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
          var squaredDist1 = (0, _coordinate.squaredDistance)(vertexPixel, pixel1);
          var squaredDist2 = (0, _coordinate.squaredDistance)(vertexPixel, pixel2);
          var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));

          if (dist <= this.pixelTolerance_) {
            vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
            vertexPixel = map.getPixelFromCoordinate(vertex);
          }
        }
      }
    }

    if (snapped) {
      vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];
    }

    return {
      snapped: snapped,
      vertex: vertex,
      vertexPixel: vertexPixel
    };
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @private
   */


  Snap.prototype.updateFeature_ = function (feature) {
    this.removeFeature(feature, false);
    this.addFeature(feature, false);
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeCircleGeometry_ = function (feature, geometry) {
    var projection = this.getMap().getView().getProjection();
    var circleGeometry = geometry;
    var userProjection = (0, _proj.getUserProjection)();

    if (userProjection) {
      circleGeometry =
      /** @type {import("../geom/Circle.js").default} */
      circleGeometry.clone().transform(userProjection, projection);
    }

    var polygon = (0, _Polygon.fromCircle)(circleGeometry);

    if (userProjection) {
      polygon.transform(projection, userProjection);
    }

    var coordinates = polygon.getCoordinates()[0];

    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      var segmentData = {
        feature: feature,
        segment: segment
      };
      this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeGeometryCollectionGeometry_ = function (feature, geometry) {
    var geometries = geometry.getGeometriesArray();

    for (var i = 0; i < geometries.length; ++i) {
      var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];

      if (segmentWriter) {
        segmentWriter(feature, geometries[i]);
      }
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeLineStringGeometry_ = function (feature, geometry) {
    var coordinates = geometry.getCoordinates();

    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      var segmentData = {
        feature: feature,
        segment: segment
      };
      this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeMultiLineStringGeometry_ = function (feature, geometry) {
    var lines = geometry.getCoordinates();

    for (var j = 0, jj = lines.length; j < jj; ++j) {
      var coordinates = lines[j];

      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = {
          feature: feature,
          segment: segment
        };
        this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
      }
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeMultiPointGeometry_ = function (feature, geometry) {
    var points = geometry.getCoordinates();

    for (var i = 0, ii = points.length; i < ii; ++i) {
      var coordinates = points[i];
      var segmentData = {
        feature: feature,
        segment: [coordinates, coordinates]
      };
      this.rBush_.insert(geometry.getExtent(), segmentData);
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeMultiPolygonGeometry_ = function (feature, geometry) {
    var polygons = geometry.getCoordinates();

    for (var k = 0, kk = polygons.length; k < kk; ++k) {
      var rings = polygons[k];

      for (var j = 0, jj = rings.length; j < jj; ++j) {
        var coordinates = rings[j];

        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          var segment = coordinates.slice(i, i + 2);
          var segmentData = {
            feature: feature,
            segment: segment
          };
          this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
        }
      }
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/Point.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writePointGeometry_ = function (feature, geometry) {
    var coordinates = geometry.getCoordinates();
    var segmentData = {
      feature: feature,
      segment: [coordinates, coordinates]
    };
    this.rBush_.insert(geometry.getExtent(), segmentData);
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writePolygonGeometry_ = function (feature, geometry) {
    var rings = geometry.getCoordinates();

    for (var j = 0, jj = rings.length; j < jj; ++j) {
      var coordinates = rings[j];

      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = {
          feature: feature,
          segment: segment
        };
        this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
      }
    }
  };

  return Snap;
}(_Pointer.default);

var _default = Snap;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","../CollectionEventType.js":"node_modules/ol/CollectionEventType.js","../coordinate.js":"node_modules/ol/coordinate.js","../events.js":"node_modules/ol/events.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../extent.js":"node_modules/ol/extent.js","../functions.js":"node_modules/ol/functions.js","../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js","../obj.js":"node_modules/ol/obj.js","../source/VectorEventType.js":"node_modules/ol/source/VectorEventType.js","../structs/RBush.js":"node_modules/ol/structs/RBush.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/interaction/Translate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TranslateEvent = void 0;

var _Collection = _interopRequireDefault(require("../Collection.js"));

var _Object = require("../Object.js");

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _functions = require("../functions.js");

var _array = require("../array.js");

var _Pointer = _interopRequireDefault(require("./Pointer.js"));

var _Property = _interopRequireDefault(require("./Property.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/Translate
 */


/**
 * @enum {string}
 */
var TranslateEventType = {
  /**
   * Triggered upon feature translation start.
   * @event TranslateEvent#translatestart
   * @api
   */
  TRANSLATESTART: 'translatestart',

  /**
   * Triggered upon feature translation.
   * @event TranslateEvent#translating
   * @api
   */
  TRANSLATING: 'translating',

  /**
   * Triggered upon feature translation end.
   * @event TranslateEvent#translateend
   * @api
   */
  TRANSLATEEND: 'translateend'
};
/**
 * A function that takes an {@link module:ol/Feature} or
 * {@link module:ol/render/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * translated or `false` otherwise.
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default):boolean} FilterFunction
 */

/**
 * @typedef {Object} Options
 * @property {Collection<import("../Feature.js").default>} [features] Only features contained in this collection will be able to be translated. If
 * not specified, all features on the map will be able to be translated.
 * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default): boolean} [layers] A list of layers from which features should be
 * translated. Alternatively, a filter function can be provided. The
 * function will be called for each layer in the map and should return
 * `true` for layers that you want to be translatable. If the option is
 * absent, all visible layers will be considered translatable.
 * @property {FilterFunction} [filter] A function
 * that takes an {@link module:ol/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * translated or `false` otherwise.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position
 * will be checked for features.
 */

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Translate~Translate} instances
 * are instances of this type.
 */

var TranslateEvent =
/** @class */
function (_super) {
  __extends(TranslateEvent, _super);
  /**
   * @param {TranslateEventType} type Type.
   * @param {Collection<import("../Feature.js").default>} features The features translated.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../coordinate.js").Coordinate} startCoordinate The original coordinates before.translation started
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   */


  function TranslateEvent(type, features, coordinate, startCoordinate, mapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    /**
     * The features being translated.
     * @type {Collection<import("../Feature.js").default>}
     * @api
     */


    _this.features = features;
    /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */

    _this.coordinate = coordinate;
    /**
     * The coordinate of the start position before translation started.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */

    _this.startCoordinate = startCoordinate;
    /**
     * Associated {@link module:ol/MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */

    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }

  return TranslateEvent;
}(_Event.default);

exports.TranslateEvent = TranslateEvent;

/**
 * @classdesc
 * Interaction for translating (moving) features.
 *
 * @fires TranslateEvent
 * @api
 */
var Translate =
/** @class */
function (_super) {
  __extends(Translate, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function Translate(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this,
    /** @type {import("./Pointer.js").Options} */
    options) || this;
    /**
     * The last position we translated to.
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.lastCoordinate_ = null;
    /**
     * The start position before translation started.
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.startCoordinate_ = null;
    /**
     * @type {Collection<import("../Feature.js").default>}
     * @private
     */

    _this.features_ = options.features !== undefined ? options.features : null;
    /** @type {function(import("../layer/Layer.js").default): boolean} */

    var layerFilter;

    if (options.layers) {
      if (typeof options.layers === 'function') {
        layerFilter = options.layers;
      } else {
        var layers_1 = options.layers;

        layerFilter = function (layer) {
          return (0, _array.includes)(layers_1, layer);
        };
      }
    } else {
      layerFilter = _functions.TRUE;
    }
    /**
     * @private
     * @type {function(import("../layer/Layer.js").default): boolean}
     */


    _this.layerFilter_ = layerFilter;
    /**
     * @private
     * @type {FilterFunction}
     */

    _this.filter_ = options.filter ? options.filter : _functions.TRUE;
    /**
     * @private
     * @type {number}
     */

    _this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
    /**
     * @type {import("../Feature.js").default}
     * @private
     */

    _this.lastFeature_ = null;

    _this.addEventListener((0, _Object.getChangeEventType)(_Property.default.ACTIVE), _this.handleActiveChanged_);

    return _this;
  }
  /**
   * @inheritDoc
   */


  Translate.prototype.handleDownEvent = function (event) {
    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);

    if (!this.lastCoordinate_ && this.lastFeature_) {
      this.startCoordinate_ = event.coordinate;
      this.lastCoordinate_ = event.coordinate;
      this.handleMoveEvent(event);
      var features = this.features_ || new _Collection.default([this.lastFeature_]);
      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATESTART, features, event.coordinate, this.startCoordinate_, event));
      return true;
    }

    return false;
  };
  /**
   * @inheritDoc
   */


  Translate.prototype.handleUpEvent = function (event) {
    if (this.lastCoordinate_) {
      this.lastCoordinate_ = null;
      this.handleMoveEvent(event);
      var features = this.features_ || new _Collection.default([this.lastFeature_]);
      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATEEND, features, event.coordinate, this.startCoordinate_, event)); // cleanup

      this.startCoordinate_ = null;
      return true;
    }

    return false;
  };
  /**
   * @inheritDoc
   */


  Translate.prototype.handleDragEvent = function (event) {
    if (this.lastCoordinate_) {
      var newCoordinate = event.coordinate;
      var deltaX_1 = newCoordinate[0] - this.lastCoordinate_[0];
      var deltaY_1 = newCoordinate[1] - this.lastCoordinate_[1];
      var features = this.features_ || new _Collection.default([this.lastFeature_]);
      features.forEach(function (feature) {
        var geom = feature.getGeometry();
        geom.translate(deltaX_1, deltaY_1);
        feature.setGeometry(geom);
      });
      this.lastCoordinate_ = newCoordinate;
      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATING, features, newCoordinate, this.startCoordinate_, event));
    }
  };
  /**
   * @inheritDoc
   */


  Translate.prototype.handleMoveEvent = function (event) {
    var elem = event.map.getViewport(); // Change the cursor to grab/grabbing if hovering any of the features managed
    // by the interaction

    if (this.featuresAtPixel_(event.pixel, event.map)) {
      elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');
      elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');
    } else {
      elem.classList.remove('ol-grab', 'ol-grabbing');
    }
  };
  /**
   * Tests to see if the given coordinates intersects any of our selected
   * features.
   * @param {import("../pixel.js").Pixel} pixel Pixel coordinate to test for intersection.
   * @param {import("../PluggableMap.js").default} map Map to test the intersection on.
   * @return {import("../Feature.js").default} Returns the feature found at the specified pixel
   * coordinates.
   * @private
   */


  Translate.prototype.featuresAtPixel_ = function (pixel, map) {
    return map.forEachFeatureAtPixel(pixel, function (feature, layer) {
      if (this.filter_(feature, layer)) {
        if (!this.features_ || (0, _array.includes)(this.features_.getArray(), feature)) {
          return feature;
        }
      }
    }.bind(this), {
      layerFilter: this.layerFilter_,
      hitTolerance: this.hitTolerance_
    });
  };
  /**
   * Returns the Hit-detection tolerance.
   * @returns {number} Hit tolerance in pixels.
   * @api
   */


  Translate.prototype.getHitTolerance = function () {
    return this.hitTolerance_;
  };
  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */


  Translate.prototype.setHitTolerance = function (hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  };
  /**
   * @inheritDoc
   */


  Translate.prototype.setMap = function (map) {
    var oldMap = this.getMap();

    _super.prototype.setMap.call(this, map);

    this.updateState_(oldMap);
  };
  /**
   * @private
   */


  Translate.prototype.handleActiveChanged_ = function () {
    this.updateState_(null);
  };
  /**
   * @param {import("../PluggableMap.js").default} oldMap Old map.
   * @private
   */


  Translate.prototype.updateState_ = function (oldMap) {
    var map = this.getMap();
    var active = this.getActive();

    if (!map || !active) {
      map = map || oldMap;

      if (map) {
        var elem = map.getViewport();
        elem.classList.remove('ol-grab', 'ol-grabbing');
      }
    }
  };

  return Translate;
}(_Pointer.default);

var _default = Translate;
exports.default = _default;
},{"../Collection.js":"node_modules/ol/Collection.js","../Object.js":"node_modules/ol/Object.js","../events/Event.js":"node_modules/ol/events/Event.js","../functions.js":"node_modules/ol/functions.js","../array.js":"node_modules/ol/array.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js","./Property.js":"node_modules/ol/interaction/Property.js"}],"node_modules/ol/interaction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaults = defaults;
Object.defineProperty(exports, "DoubleClickZoom", {
  enumerable: true,
  get: function () {
    return _DoubleClickZoom.default;
  }
});
Object.defineProperty(exports, "DragPan", {
  enumerable: true,
  get: function () {
    return _DragPan.default;
  }
});
Object.defineProperty(exports, "DragRotate", {
  enumerable: true,
  get: function () {
    return _DragRotate.default;
  }
});
Object.defineProperty(exports, "DragZoom", {
  enumerable: true,
  get: function () {
    return _DragZoom.default;
  }
});
Object.defineProperty(exports, "KeyboardPan", {
  enumerable: true,
  get: function () {
    return _KeyboardPan.default;
  }
});
Object.defineProperty(exports, "KeyboardZoom", {
  enumerable: true,
  get: function () {
    return _KeyboardZoom.default;
  }
});
Object.defineProperty(exports, "MouseWheelZoom", {
  enumerable: true,
  get: function () {
    return _MouseWheelZoom.default;
  }
});
Object.defineProperty(exports, "PinchRotate", {
  enumerable: true,
  get: function () {
    return _PinchRotate.default;
  }
});
Object.defineProperty(exports, "PinchZoom", {
  enumerable: true,
  get: function () {
    return _PinchZoom.default;
  }
});
Object.defineProperty(exports, "DragAndDrop", {
  enumerable: true,
  get: function () {
    return _DragAndDrop.default;
  }
});
Object.defineProperty(exports, "DragBox", {
  enumerable: true,
  get: function () {
    return _DragBox.default;
  }
});
Object.defineProperty(exports, "DragRotateAndZoom", {
  enumerable: true,
  get: function () {
    return _DragRotateAndZoom.default;
  }
});
Object.defineProperty(exports, "Draw", {
  enumerable: true,
  get: function () {
    return _Draw.default;
  }
});
Object.defineProperty(exports, "Extent", {
  enumerable: true,
  get: function () {
    return _Extent.default;
  }
});
Object.defineProperty(exports, "Interaction", {
  enumerable: true,
  get: function () {
    return _Interaction.default;
  }
});
Object.defineProperty(exports, "Modify", {
  enumerable: true,
  get: function () {
    return _Modify.default;
  }
});
Object.defineProperty(exports, "Pointer", {
  enumerable: true,
  get: function () {
    return _Pointer.default;
  }
});
Object.defineProperty(exports, "Select", {
  enumerable: true,
  get: function () {
    return _Select.default;
  }
});
Object.defineProperty(exports, "Snap", {
  enumerable: true,
  get: function () {
    return _Snap.default;
  }
});
Object.defineProperty(exports, "Translate", {
  enumerable: true,
  get: function () {
    return _Translate.default;
  }
});

var _Collection = _interopRequireDefault(require("./Collection.js"));

var _Kinetic = _interopRequireDefault(require("./Kinetic.js"));

var _DoubleClickZoom = _interopRequireDefault(require("./interaction/DoubleClickZoom.js"));

var _DragPan = _interopRequireDefault(require("./interaction/DragPan.js"));

var _DragRotate = _interopRequireDefault(require("./interaction/DragRotate.js"));

var _DragZoom = _interopRequireDefault(require("./interaction/DragZoom.js"));

var _KeyboardPan = _interopRequireDefault(require("./interaction/KeyboardPan.js"));

var _KeyboardZoom = _interopRequireDefault(require("./interaction/KeyboardZoom.js"));

var _MouseWheelZoom = _interopRequireDefault(require("./interaction/MouseWheelZoom.js"));

var _PinchRotate = _interopRequireDefault(require("./interaction/PinchRotate.js"));

var _PinchZoom = _interopRequireDefault(require("./interaction/PinchZoom.js"));

var _condition = require("./events/condition.js");

var _DragAndDrop = _interopRequireDefault(require("./interaction/DragAndDrop.js"));

var _DragBox = _interopRequireDefault(require("./interaction/DragBox.js"));

var _DragRotateAndZoom = _interopRequireDefault(require("./interaction/DragRotateAndZoom.js"));

var _Draw = _interopRequireDefault(require("./interaction/Draw.js"));

var _Extent = _interopRequireDefault(require("./interaction/Extent.js"));

var _Interaction = _interopRequireDefault(require("./interaction/Interaction.js"));

var _Modify = _interopRequireDefault(require("./interaction/Modify.js"));

var _Pointer = _interopRequireDefault(require("./interaction/Pointer.js"));

var _Select = _interopRequireDefault(require("./interaction/Select.js"));

var _Snap = _interopRequireDefault(require("./interaction/Snap.js"));

var _Translate = _interopRequireDefault(require("./interaction/Translate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/interaction
 */

/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
 * desired.
 * @property {boolean} [onFocusOnly=false] Interact only when the map has the
 * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
 * useful when page scroll is desired for maps that do not have the browser's
 * focus.
 * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
 * desired.
 * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
 * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
 * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
 * @property {boolean} [dragPan=true] Whether drag pan is desired.
 * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
 * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
 * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.
 * @property {number} [zoomDuration] Duration of the zoom animation in
 * milliseconds.
 */

/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link module:ol/interaction/Interaction} instances and insert
 * them into a {@link module:ol/Collection} in the order you want
 * before creating your {@link module:ol/Map~Map} instance. Changing the order can
 * be of interest if the event propagation needs to be stopped at a point.
 * The default set of interactions, in sequence, is:
 * * {@link module:ol/interaction/DragRotate~DragRotate}
 * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
 * * {@link module:ol/interaction/DragPan~DragPan}
 * * {@link module:ol/interaction/PinchRotate~PinchRotate}
 * * {@link module:ol/interaction/PinchZoom~PinchZoom}
 * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
 * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
 * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
 * * {@link module:ol/interaction/DragZoom~DragZoom}
 *
 * @param {DefaultsOptions=} opt_options Defaults options.
 * @return {import("./Collection.js").default<import("./interaction/Interaction.js").default>}
 * A collection of interactions to be used with the {@link module:ol/Map~Map}
 * constructor's `interactions` option.
 * @api
 */
function defaults(opt_options) {
  var options = opt_options ? opt_options : {};
  var interactions = new _Collection.default();
  var kinetic = new _Kinetic.default(-0.005, 0.05, 100);
  var altShiftDragRotate = options.altShiftDragRotate !== undefined ? options.altShiftDragRotate : true;

  if (altShiftDragRotate) {
    interactions.push(new _DragRotate.default());
  }

  var doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;

  if (doubleClickZoom) {
    interactions.push(new _DoubleClickZoom.default({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var dragPan = options.dragPan !== undefined ? options.dragPan : true;

  if (dragPan) {
    interactions.push(new _DragPan.default({
      condition: options.onFocusOnly ? _condition.focus : undefined,
      kinetic: kinetic
    }));
  }

  var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;

  if (pinchRotate) {
    interactions.push(new _PinchRotate.default());
  }

  var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;

  if (pinchZoom) {
    interactions.push(new _PinchZoom.default({
      duration: options.zoomDuration
    }));
  }

  var keyboard = options.keyboard !== undefined ? options.keyboard : true;

  if (keyboard) {
    interactions.push(new _KeyboardPan.default());
    interactions.push(new _KeyboardZoom.default({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;

  if (mouseWheelZoom) {
    interactions.push(new _MouseWheelZoom.default({
      condition: options.onFocusOnly ? _condition.focus : undefined,
      duration: options.zoomDuration
    }));
  }

  var shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;

  if (shiftDragZoom) {
    interactions.push(new _DragZoom.default({
      duration: options.zoomDuration
    }));
  }

  return interactions;
}
},{"./Collection.js":"node_modules/ol/Collection.js","./Kinetic.js":"node_modules/ol/Kinetic.js","./interaction/DoubleClickZoom.js":"node_modules/ol/interaction/DoubleClickZoom.js","./interaction/DragPan.js":"node_modules/ol/interaction/DragPan.js","./interaction/DragRotate.js":"node_modules/ol/interaction/DragRotate.js","./interaction/DragZoom.js":"node_modules/ol/interaction/DragZoom.js","./interaction/KeyboardPan.js":"node_modules/ol/interaction/KeyboardPan.js","./interaction/KeyboardZoom.js":"node_modules/ol/interaction/KeyboardZoom.js","./interaction/MouseWheelZoom.js":"node_modules/ol/interaction/MouseWheelZoom.js","./interaction/PinchRotate.js":"node_modules/ol/interaction/PinchRotate.js","./interaction/PinchZoom.js":"node_modules/ol/interaction/PinchZoom.js","./events/condition.js":"node_modules/ol/events/condition.js","./interaction/DragAndDrop.js":"node_modules/ol/interaction/DragAndDrop.js","./interaction/DragBox.js":"node_modules/ol/interaction/DragBox.js","./interaction/DragRotateAndZoom.js":"node_modules/ol/interaction/DragRotateAndZoom.js","./interaction/Draw.js":"node_modules/ol/interaction/Draw.js","./interaction/Extent.js":"node_modules/ol/interaction/Extent.js","./interaction/Interaction.js":"node_modules/ol/interaction/Interaction.js","./interaction/Modify.js":"node_modules/ol/interaction/Modify.js","./interaction/Pointer.js":"node_modules/ol/interaction/Pointer.js","./interaction/Select.js":"node_modules/ol/interaction/Select.js","./interaction/Snap.js":"node_modules/ol/interaction/Snap.js","./interaction/Translate.js":"node_modules/ol/interaction/Translate.js"}],"node_modules/ol/Map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _PluggableMap = _interopRequireDefault(require("./PluggableMap.js"));

var _control = require("./control.js");

var _interaction = require("./interaction.js");

var _obj = require("./obj.js");

var _Composite = _interopRequireDefault(require("./renderer/Composite.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/Map
 */


/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     import Map from 'ol/Map';
 *     import View from 'ol/View';
 *     import TileLayer from 'ol/layer/Tile';
 *     import OSM from 'ol/source/OSM';
 *
 *     var map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1
 *       }),
 *       layers: [
 *         new TileLayer({
 *           source: new OSM()
 *         })
 *       ],
 *       target: 'map'
 *     });
 *
 * The above snippet creates a map using a {@link module:ol/layer/Tile} to
 * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
 * element with the id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link module:ol/Overlay~Overlay} for the difference). The map
 * itself is placed in a further element within the viewport.
 *
 * Layers are stored as a {@link module:ol/Collection~Collection} in
 * layerGroups. A top-level group is provided by the library. This is what is
 * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
 * options are added to this group, and `addLayer` and `removeLayer` change the
 * layer collection in the group. `getLayers` is a convenience function for
 * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~Group}
 * is a subclass of {@link module:ol/layer/Base}, so layers entered in the
 * options or added with `addLayer` can be groups, which can contain further
 * groups, and so on.
 *
 * @api
 */
var Map =
/** @class */
function (_super) {
  __extends(Map, _super);
  /**
   * @param {import("./PluggableMap.js").MapOptions} options Map options.
   */


  function Map(options) {
    var _this = this;

    options = (0, _obj.assign)({}, options);

    if (!options.controls) {
      options.controls = (0, _control.defaults)();
    }

    if (!options.interactions) {
      options.interactions = (0, _interaction.defaults)();
    }

    _this = _super.call(this, options) || this;
    return _this;
  }

  Map.prototype.createRenderer = function () {
    return new _Composite.default(this);
  };

  return Map;
}(_PluggableMap.default);

var _default = Map;
exports.default = _default;
},{"./PluggableMap.js":"node_modules/ol/PluggableMap.js","./control.js":"node_modules/ol/control.js","./interaction.js":"node_modules/ol/interaction.js","./obj.js":"node_modules/ol/obj.js","./renderer/Composite.js":"node_modules/ol/renderer/Composite.js"}],"node_modules/ol/reproj/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ENABLE_RASTER_REPROJECTION = exports.ERROR_THRESHOLD = void 0;

/**
 * @module ol/reproj/common
 */

/**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */
var ERROR_THRESHOLD = 0.5;
/**
 * Enable automatic reprojection of raster sources. Default is `true`.
 * TODO: decide if we want to expose this as a build flag or remove it
 * @type {boolean}
 */

exports.ERROR_THRESHOLD = ERROR_THRESHOLD;
var ENABLE_RASTER_REPROJECTION = true;
exports.ENABLE_RASTER_REPROJECTION = ENABLE_RASTER_REPROJECTION;
},{}],"node_modules/ol/Tile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _TileState = _interopRequireDefault(require("./TileState.js"));

var _easing = require("./easing.js");

var _Target = _interopRequireDefault(require("./events/Target.js"));

var _EventType = _interopRequireDefault(require("./events/EventType.js"));

var _util = require("./util.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/Tile
 */


/**
 * A function that takes an {@link module:ol/Tile} for the tile and a
 * `{string}` for the url as arguments. The default is
 * ```js
 * source.setTileLoadFunction(function(tile, src) {
 *   tile.getImage().src = src;
 * });
 * ```
 * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
 * error handling:
 *
 * ```js
 * import TileState from 'ol/TileState';
 *
 * source.setTileLoadFunction(function(tile, src) {
 *   var xhr = new XMLHttpRequest();
 *   xhr.responseType = 'blob';
 *   xhr.addEventListener('loadend', function (evt) {
 *     var data = this.response;
 *     if (data !== undefined) {
 *       tile.getImage().src = URL.createObjectURL(data);
 *     } else {
 *       tile.setState(TileState.ERROR);
 *     }
 *   });
 *   xhr.addEventListener('error', function () {
 *     tile.setState(TileState.ERROR);
 *   });
 *   xhr.open('GET', src);
 *   xhr.send();
 * });
 * ```
 *
 * @typedef {function(Tile, string): void} LoadFunction
 * @api
 */

/**
 * {@link module:ol/source/Tile~Tile} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(import("./tilecoord.js").TileCoord, number,
 *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
 * @api
 */

/**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @api
 */

/**
 * @classdesc
 * Base class for tiles.
 *
 * @abstract
 */
var Tile =
/** @class */
function (_super) {
  __extends(Tile, _super);
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {TileState} state State.
   * @param {Options=} opt_options Tile options.
   */


  function Tile(tileCoord, state, opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @type {import("./tilecoord.js").TileCoord}
     */

    _this.tileCoord = tileCoord;
    /**
     * @protected
     * @type {TileState}
     */

    _this.state = state;
    /**
     * An "interim" tile for this tile. The interim tile may be used while this
     * one is loading, for "smooth" transitions when changing params/dimensions
     * on the source.
     * @type {Tile}
     */

    _this.interimTile = null;
    /**
     * The tile is available at the highest possible resolution. Subclasses can
     * set this to `false` initially. Tile load listeners will not be
     * unregistered before this is set to `true` and a `#changed()` is called.
     * @type {boolean}
     */

    _this.hifi = true;
    /**
     * A key assigned to the tile. This is used by the tile source to determine
     * if this tile can effectively be used, or if a new tile should be created
     * and this one be used as an interim tile for this new tile.
     * @type {string}
     */

    _this.key = '';
    /**
     * The duration for the opacity transition.
     * @type {number}
     */

    _this.transition_ = options.transition === undefined ? 250 : options.transition;
    /**
     * Lookup of start times for rendering transitions.  If the start time is
     * equal to -1, the transition is complete.
     * @type {Object<string, number>}
     */

    _this.transitionStarts_ = {};
    return _this;
  }
  /**
   * @protected
   */


  Tile.prototype.changed = function () {
    this.dispatchEvent(_EventType.default.CHANGE);
  };
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */


  Tile.prototype.release = function () {};
  /**
   * @return {string} Key.
   */


  Tile.prototype.getKey = function () {
    return this.key + '/' + this.tileCoord;
  };
  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */


  Tile.prototype.getInterimTile = function () {
    if (!this.interimTile) {
      //empty chain
      return this;
    }

    var tile = this.interimTile; // find the first loaded tile and return it. Since the chain is sorted in
    // decreasing order of creation time, there is no need to search the remainder
    // of the list (all those tiles correspond to older requests and will be
    // cleaned up by refreshInterimChain)

    do {
      if (tile.getState() == _TileState.default.LOADED) {
        // Show tile immediately instead of fading it in after loading, because
        // the interim tile is in place already
        this.transition_ = 0;
        return tile;
      }

      tile = tile.interimTile;
    } while (tile); // we can not find a better tile


    return this;
  };
  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */


  Tile.prototype.refreshInterimChain = function () {
    if (!this.interimTile) {
      return;
    }

    var tile = this.interimTile;
    var prev =
    /** @type {Tile} */
    this;

    do {
      if (tile.getState() == _TileState.default.LOADED) {
        //we have a loaded tile, we can discard the rest of the list
        //we would could abort any LOADING tile request
        //older than this tile (i.e. any LOADING tile following this entry in the chain)
        tile.interimTile = null;
        break;
      } else if (tile.getState() == _TileState.default.LOADING) {
        //keep this LOADING tile any loaded tiles later in the chain are
        //older than this tile, so we're still interested in the request
        prev = tile;
      } else if (tile.getState() == _TileState.default.IDLE) {
        //the head of the list is the most current tile, we don't need
        //to start any other requests for this chain
        prev.interimTile = tile.interimTile;
      } else {
        prev = tile;
      }

      tile = prev.interimTile;
    } while (tile);
  };
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */


  Tile.prototype.getTileCoord = function () {
    return this.tileCoord;
  };
  /**
   * @return {TileState} State.
   */


  Tile.prototype.getState = function () {
    return this.state;
  };
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {TileState} state State.
   * @api
   */


  Tile.prototype.setState = function (state) {
    if (this.state !== _TileState.default.ERROR && this.state > state) {
      throw new Error('Tile load sequence violation');
    }

    this.state = state;
    this.changed();
  };
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */


  Tile.prototype.load = function () {
    (0, _util.abstract)();
  };
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */


  Tile.prototype.getAlpha = function (id, time) {
    if (!this.transition_) {
      return 1;
    }

    var start = this.transitionStarts_[id];

    if (!start) {
      start = time;
      this.transitionStarts_[id] = start;
    } else if (start === -1) {
      return 1;
    }

    var delta = time - start + 1000 / 60; // avoid rendering at 0

    if (delta >= this.transition_) {
      return 1;
    }

    return (0, _easing.easeIn)(delta / this.transition_);
  };
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */


  Tile.prototype.inTransition = function (id) {
    if (!this.transition_) {
      return false;
    }

    return this.transitionStarts_[id] !== -1;
  };
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */


  Tile.prototype.endTransition = function (id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  };

  return Tile;
}(_Target.default);

var _default = Tile;
exports.default = _default;
},{"./TileState.js":"node_modules/ol/TileState.js","./easing.js":"node_modules/ol/easing.js","./events/Target.js":"node_modules/ol/events/Target.js","./events/EventType.js":"node_modules/ol/events/EventType.js","./util.js":"node_modules/ol/util.js"}],"node_modules/ol/ImageTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Tile = _interopRequireDefault(require("./Tile.js"));

var _TileState = _interopRequireDefault(require("./TileState.js"));

var _dom = require("./dom.js");

var _Image = require("./Image.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/ImageTile
 */


var ImageTile =
/** @class */
function (_super) {
  __extends(ImageTile, _super);
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {TileState} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options=} opt_options Tile options.
   */


  function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
    var _this = _super.call(this, tileCoord, state, opt_options) || this;
    /**
     * @private
     * @type {?string}
     */


    _this.crossOrigin_ = crossOrigin;
    /**
     * Image URI
     *
     * @private
     * @type {string}
     */

    _this.src_ = src;
    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */

    _this.image_ = new Image();

    if (crossOrigin !== null) {
      _this.image_.crossOrigin = crossOrigin;
    }
    /**
     * @private
     * @type {?function():void}
     */


    _this.unlisten_ = null;
    /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */

    _this.tileLoadFunction_ = tileLoadFunction;
    return _this;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */


  ImageTile.prototype.getImage = function () {
    return this.image_;
  };
  /**
   * @inheritDoc
   */


  ImageTile.prototype.getKey = function () {
    return this.src_;
  };
  /**
   * Tracks loading or read errors.
   *
   * @private
   */


  ImageTile.prototype.handleImageError_ = function () {
    this.state = _TileState.default.ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  };
  /**
   * Tracks successful image load.
   *
   * @private
   */


  ImageTile.prototype.handleImageLoad_ = function () {
    var image =
    /** @type {HTMLImageElement} */
    this.image_;

    if (image.naturalWidth && image.naturalHeight) {
      this.state = _TileState.default.LOADED;
    } else {
      this.state = _TileState.default.EMPTY;
    }

    this.unlistenImage_();
    this.changed();
  };
  /**
   * @inheritDoc
   * @api
   */


  ImageTile.prototype.load = function () {
    if (this.state == _TileState.default.ERROR) {
      this.state = _TileState.default.IDLE;
      this.image_ = new Image();

      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }

    if (this.state == _TileState.default.IDLE) {
      this.state = _TileState.default.LOADING;
      this.changed();
      this.tileLoadFunction_(this, this.src_);
      this.unlisten_ = (0, _Image.listenImage)(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
    }
  };
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */


  ImageTile.prototype.unlistenImage_ = function () {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  };

  return ImageTile;
}(_Tile.default);
/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */


function getBlankImage() {
  var ctx = (0, _dom.createCanvasContext2D)(1, 1);
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}

var _default = ImageTile;
exports.default = _default;
},{"./Tile.js":"node_modules/ol/Tile.js","./TileState.js":"node_modules/ol/TileState.js","./dom.js":"node_modules/ol/dom.js","./Image.js":"node_modules/ol/Image.js"}],"node_modules/ol/structs/LRUCache.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _asserts = require("../asserts.js");

/**
 * @module ol/structs/LRUCache
 */

/**
 * @typedef {Object} Entry
 * @property {string} key_
 * @property {Object} newer
 * @property {Object} older
 * @property {*} value_
 */

/**
 * @classdesc
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 *
 * @fires import("../events/Event.js").default
 * @template T
 */
var LRUCache =
/** @class */
function () {
  /**
   * @param {number=} opt_highWaterMark High water mark.
   */
  function LRUCache(opt_highWaterMark) {
    /**
     * @type {number}
     */
    this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;
    /**
     * @private
     * @type {number}
     */

    this.count_ = 0;
    /**
     * @private
     * @type {!Object<string, Entry>}
     */

    this.entries_ = {};
    /**
     * @private
     * @type {?Entry}
     */

    this.oldest_ = null;
    /**
     * @private
     * @type {?Entry}
     */

    this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */


  LRUCache.prototype.canExpireCache = function () {
    return this.getCount() > this.highWaterMark;
  };
  /**
   * FIXME empty description for jsdoc
   */


  LRUCache.prototype.clear = function () {
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  };
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */


  LRUCache.prototype.containsKey = function (key) {
    return this.entries_.hasOwnProperty(key);
  };
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */


  LRUCache.prototype.forEach = function (f) {
    var entry = this.oldest_;

    while (entry) {
      f(entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  };
  /**
   * @param {string} key Key.
   * @param {*=} opt_options Options (reserverd for subclasses).
   * @return {T} Value.
   */


  LRUCache.prototype.get = function (key, opt_options) {
    var entry = this.entries_[key];
    (0, _asserts.assert)(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache

    if (entry === this.newest_) {
      return entry.value_;
    } else if (entry === this.oldest_) {
      this.oldest_ =
      /** @type {Entry} */
      this.oldest_.newer;
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }

    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  };
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */


  LRUCache.prototype.remove = function (key) {
    var entry = this.entries_[key];
    (0, _asserts.assert)(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache

    if (entry === this.newest_) {
      this.newest_ =
      /** @type {Entry} */
      entry.older;

      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ =
      /** @type {Entry} */
      entry.newer;

      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }

    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  };
  /**
   * @return {number} Count.
   */


  LRUCache.prototype.getCount = function () {
    return this.count_;
  };
  /**
   * @return {Array<string>} Keys.
   */


  LRUCache.prototype.getKeys = function () {
    var keys = new Array(this.count_);
    var i = 0;
    var entry;

    for (entry = this.newest_; entry; entry = entry.older) {
      keys[i++] = entry.key_;
    }

    return keys;
  };
  /**
   * @return {Array<T>} Values.
   */


  LRUCache.prototype.getValues = function () {
    var values = new Array(this.count_);
    var i = 0;
    var entry;

    for (entry = this.newest_; entry; entry = entry.older) {
      values[i++] = entry.value_;
    }

    return values;
  };
  /**
   * @return {T} Last value.
   */


  LRUCache.prototype.peekLast = function () {
    return this.oldest_.value_;
  };
  /**
   * @return {string} Last key.
   */


  LRUCache.prototype.peekLastKey = function () {
    return this.oldest_.key_;
  };
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */


  LRUCache.prototype.peekFirstKey = function () {
    return this.newest_.key_;
  };
  /**
   * @return {T} value Value.
   */


  LRUCache.prototype.pop = function () {
    var entry = this.oldest_;
    delete this.entries_[entry.key_];

    if (entry.newer) {
      entry.newer.older = null;
    }

    this.oldest_ =
    /** @type {Entry} */
    entry.newer;

    if (!this.oldest_) {
      this.newest_ = null;
    }

    --this.count_;
    return entry.value_;
  };
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */


  LRUCache.prototype.replace = function (key, value) {
    this.get(key); // update `newest_`

    this.entries_[key].value_ = value;
  };
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */


  LRUCache.prototype.set = function (key, value) {
    (0, _asserts.assert)(!(key in this.entries_), 16); // Tried to set a value for a key that is used already

    var entry = {
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value
    };

    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }

    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  };
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */


  LRUCache.prototype.setSize = function (size) {
    this.highWaterMark = size;
  };

  return LRUCache;
}();

var _default = LRUCache;
exports.default = _default;
},{"../asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/tilecoord.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOrUpdate = createOrUpdate;
exports.getKeyZXY = getKeyZXY;
exports.getKey = getKey;
exports.fromKey = fromKey;
exports.hash = hash;
exports.withinExtentAndZ = withinExtentAndZ;

/**
 * @module ol/tilecoord
 */

/**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
 * @typedef {Array<number>} TileCoord
 * @api
 */

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {TileCoord=} opt_tileCoord Tile coordinate.
 * @return {TileCoord} Tile coordinate.
 */
function createOrUpdate(z, x, y, opt_tileCoord) {
  if (opt_tileCoord !== undefined) {
    opt_tileCoord[0] = z;
    opt_tileCoord[1] = x;
    opt_tileCoord[2] = y;
    return opt_tileCoord;
  } else {
    return [z, x, y];
  }
}
/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */


function getKeyZXY(z, x, y) {
  return z + '/' + x + '/' + y;
}
/**
 * Get the key for a tile coord.
 * @param {TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */


function getKey(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {TileCoord} The tile coord.
 */


function fromKey(key) {
  return key.split('/').map(Number);
}
/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */


function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}
/**
 * @param {TileCoord} tileCoord Tile coordinate.
 * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */


function withinExtentAndZ(tileCoord, tileGrid) {
  var z = tileCoord[0];
  var x = tileCoord[1];
  var y = tileCoord[2];

  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }

  var extent = tileGrid.getExtent();
  var tileRange;

  if (!extent) {
    tileRange = tileGrid.getFullTileRange(z);
  } else {
    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  }

  if (!tileRange) {
    return true;
  } else {
    return tileRange.containsXY(x, y);
  }
}
},{}],"node_modules/ol/TileCache.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _LRUCache = _interopRequireDefault(require("./structs/LRUCache.js"));

var _tilecoord = require("./tilecoord.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/TileCache
 */


var TileCache =
/** @class */
function (_super) {
  __extends(TileCache, _super);

  function TileCache() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */


  TileCache.prototype.expireCache = function (usedTiles) {
    while (this.canExpireCache()) {
      var tile = this.peekLast();

      if (tile.getKey() in usedTiles) {
        break;
      } else {
        this.pop().release();
      }
    }
  };
  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */


  TileCache.prototype.pruneExceptNewestZ = function () {
    if (this.getCount() === 0) {
      return;
    }

    var key = this.peekFirstKey();
    var tileCoord = (0, _tilecoord.fromKey)(key);
    var z = tileCoord[0];
    this.forEach(function (tile) {
      if (tile.tileCoord[0] !== z) {
        this.remove((0, _tilecoord.getKey)(tile.tileCoord));
        tile.release();
      }
    }.bind(this));
  };

  return TileCache;
}(_LRUCache.default);

var _default = TileCache;
exports.default = _default;
},{"./structs/LRUCache.js":"node_modules/ol/structs/LRUCache.js","./tilecoord.js":"node_modules/ol/tilecoord.js"}],"node_modules/ol/reproj.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateSourceResolution = calculateSourceResolution;
exports.render = render;

var _dom = require("./dom.js");

var _extent = require("./extent.js");

var _math = require("./math.js");

var _proj = require("./proj.js");

/**
 * @module ol/reproj
 */

/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
  var sourceCenter = (0, _proj.transform)(targetCenter, targetProj, sourceProj); // calculate the ideal resolution of the source data

  var sourceResolution = (0, _proj.getPointResolution)(targetProj, targetResolution, targetCenter);
  var targetMetersPerUnit = targetProj.getMetersPerUnit();

  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }

  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();

  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  } // Based on the projection properties, the point resolution at the specified
  // coordinates may be slightly different. We need to reverse-compensate this
  // in order to achieve optimal results.


  var sourceExtent = sourceProj.getExtent();

  if (!sourceExtent || (0, _extent.containsCoordinate)(sourceExtent, sourceCenter)) {
    var compensationFactor = (0, _proj.getPointResolution)(sourceProj, sourceResolution, sourceCenter) / sourceResolution;

    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }

  return sourceResolution;
}
/**
 * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap
 * in order to mask gaps caused by antialiasing.
 *
 * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).
 * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).
 * @param {number} x X coordinate of the point (in pixels).
 * @param {number} y Y coordinate of the point (in pixels).
 * @return {import("./coordinate.js").Coordinate} New point 1 px farther from the centroid.
 */


function enlargeClipPoint(centroidX, centroidY, x, y) {
  var dX = x - centroidX;
  var dY = y - centroidY;
  var distance = Math.sqrt(dX * dX + dY * dY);
  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];
}
/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {import("./extent.js").Extent} targetExtent Target extent.
 * @param {import("./reproj/Triangulation.js").default} triangulation
 * Calculated triangulation.
 * @param {Array<{extent: import("./extent.js").Extent,
 *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources
 * Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */


function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges) {
  var context = (0, _dom.createCanvasContext2D)(Math.round(pixelRatio * width), Math.round(pixelRatio * height));

  if (sources.length === 0) {
    return context.canvas;
  }

  context.scale(pixelRatio, pixelRatio);
  var sourceDataExtent = (0, _extent.createEmpty)();
  sources.forEach(function (src, i, arr) {
    (0, _extent.extend)(sourceDataExtent, src.extent);
  });
  var canvasWidthInUnits = (0, _extent.getWidth)(sourceDataExtent);
  var canvasHeightInUnits = (0, _extent.getHeight)(sourceDataExtent);
  var stitchContext = (0, _dom.createCanvasContext2D)(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));
  var stitchScale = pixelRatio / sourceResolution;
  sources.forEach(function (src, i, arr) {
    var xPos = src.extent[0] - sourceDataExtent[0];
    var yPos = -(src.extent[3] - sourceDataExtent[3]);
    var srcWidth = (0, _extent.getWidth)(src.extent);
    var srcHeight = (0, _extent.getHeight)(src.extent);
    stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
  });
  var targetTopLeft = (0, _extent.getTopLeft)(targetExtent);
  triangulation.getTriangles().forEach(function (triangle, i, arr) {
    /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */
    var source = triangle.source;
    var target = triangle.target;
    var x0 = source[0][0],
        y0 = source[0][1];
    var x1 = source[1][0],
        y1 = source[1][1];
    var x2 = source[2][0],
        y2 = source[2][1];
    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
    var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
    var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
    var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution; // Shift all the source points to improve numerical stability
    // of all the subsequent calculations. The [x0, y0] is used here.
    // This is also used to simplify the linear system.

    var sourceNumericalShiftX = x0;
    var sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];
    var affineCoefs = (0, _math.solveLinearSystem)(augmentedMatrix);

    if (!affineCoefs) {
      return;
    }

    context.save();
    context.beginPath();
    var centroidX = (u0 + u1 + u2) / 3;
    var centroidY = (v0 + v1 + v2) / 3;
    var p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);
    var p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);
    var p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);
    context.moveTo(p1[0], p1[1]);
    context.lineTo(p0[0], p0[1]);
    context.lineTo(p2[0], p2[1]);
    context.clip();
    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });

  if (opt_renderEdges) {
    context.save();
    context.strokeStyle = 'black';
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function (triangle, i, arr) {
      var target = triangle.target;
      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }

  return context.canvas;
}
},{"./dom.js":"node_modules/ol/dom.js","./extent.js":"node_modules/ol/extent.js","./math.js":"node_modules/ol/math.js","./proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/reproj/Triangulation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extent = require("../extent.js");

var _math = require("../math.js");

var _proj = require("../proj.js");

/**
 * @module ol/reproj/Triangulation
 */

/**
 * Single triangle; consists of 3 source points and 3 target points.
 * @typedef {Object} Triangle
 * @property {Array<import("../coordinate.js").Coordinate>} source
 * @property {Array<import("../coordinate.js").Coordinate>} target
 */

/**
 * Maximum number of subdivision steps during raster reprojection triangulation.
 * Prevents high memory usage and large number of proj4 calls (for certain
 * transformations and areas). At most `2*(2^this)` triangles are created for
 * each triangulated extent (tile/image).
 * @type {number}
 */
var MAX_SUBDIVISION = 10;
/**
 * Maximum allowed size of triangle relative to world width. When transforming
 * corners of world extent between certain projections, the resulting
 * triangulation seems to have zero error and no subdivision is performed. If
 * the triangle width is more than this (relative to world width; 0-1),
 * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
 * @type {number}
 */

var MAX_TRIANGLE_WIDTH = 0.25;
/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 */

var Triangulation =
/** @class */
function () {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} opt_destinationResolution The (optional) resolution of the destination.
   */
  function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {
    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */
    this.sourceProj_ = sourceProj;
    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */

    this.targetProj_ = targetProj;
    /** @type {!Object<string, import("../coordinate.js").Coordinate>} */

    var transformInvCache = {};
    var transformInv = (0, _proj.getTransform)(this.targetProj_, this.sourceProj_);
    /**
     * @param {import("../coordinate.js").Coordinate} c A coordinate.
     * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
     * @private
     */

    this.transformInv_ = function (c) {
      var key = c[0] + '/' + c[1];

      if (!transformInvCache[key]) {
        transformInvCache[key] = transformInv(c);
      }

      return transformInvCache[key];
    };
    /**
     * @type {import("../extent.js").Extent}
     * @private
     */


    this.maxSourceExtent_ = maxSourceExtent;
    /**
     * @type {number}
     * @private
     */

    this.errorThresholdSquared_ = errorThreshold * errorThreshold;
    /**
     * @type {Array<Triangle>}
     * @private
     */

    this.triangles_ = [];
    /**
     * Indicates that the triangulation crosses edge of the source projection.
     * @type {boolean}
     * @private
     */

    this.wrapsXInSource_ = false;
    /**
     * @type {boolean}
     * @private
     */

    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && (0, _extent.getWidth)(maxSourceExtent) == (0, _extent.getWidth)(this.sourceProj_.getExtent());
    /**
     * @type {?number}
     * @private
     */

    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? (0, _extent.getWidth)(this.sourceProj_.getExtent()) : null;
    /**
     * @type {?number}
     * @private
     */

    this.targetWorldWidth_ = this.targetProj_.getExtent() ? (0, _extent.getWidth)(this.targetProj_.getExtent()) : null;
    var destinationTopLeft = (0, _extent.getTopLeft)(targetExtent);
    var destinationTopRight = (0, _extent.getTopRight)(targetExtent);
    var destinationBottomRight = (0, _extent.getBottomRight)(targetExtent);
    var destinationBottomLeft = (0, _extent.getBottomLeft)(targetExtent);
    var sourceTopLeft = this.transformInv_(destinationTopLeft);
    var sourceTopRight = this.transformInv_(destinationTopRight);
    var sourceBottomRight = this.transformInv_(destinationBottomRight);
    var sourceBottomLeft = this.transformInv_(destinationBottomLeft);
    /*
     * The maxSubdivision controls how many splittings of the target area can
     * be done. The idea here is to do a linear mapping of the target areas
     * but the actual overal reprojection (can be) extremely non-linear. The
     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256
     * tile size. However this function is also called to remap canvas rendered
     * layers which can be much larger. This calculation increases the maxSubdivision
     * value by the right factor so that each 256x256 pixel area has
     * MAX_SUBDIVISION divisions.
     */

    var maxSubdivision = MAX_SUBDIVISION + (opt_destinationResolution ? Math.max(0, Math.ceil(Math.log2((0, _extent.getArea)(targetExtent) / (opt_destinationResolution * opt_destinationResolution * 256 * 256)))) : 0);
    this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);

    if (this.wrapsXInSource_) {
      var leftBound_1 = Infinity;
      this.triangles_.forEach(function (triangle, i, arr) {
        leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
      }); // Shift triangles to be as close to `leftBound` as possible
      // (if the distance is more than `worldWidth / 2` it can be closer.

      this.triangles_.forEach(function (triangle) {
        if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound_1 > this.sourceWorldWidth_ / 2) {
          var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];

          if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
            newTriangle[0][0] -= this.sourceWorldWidth_;
          }

          if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
            newTriangle[1][0] -= this.sourceWorldWidth_;
          }

          if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
            newTriangle[2][0] -= this.sourceWorldWidth_;
          } // Rarely (if the extent contains both the dateline and prime meridian)
          // the shift can in turn break some triangles.
          // Detect this here and don't shift in such cases.


          var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
          var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);

          if (maxX - minX < this.sourceWorldWidth_ / 2) {
            triangle.source = newTriangle;
          }
        }
      }.bind(this));
    }

    transformInvCache = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */


  Triangulation.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {
    this.triangles_.push({
      source: [aSrc, bSrc, cSrc],
      target: [a, b, c]
    });
  };
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */


  Triangulation.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
    var sourceQuadExtent = (0, _extent.boundingExtent)([aSrc, bSrc, cSrc, dSrc]);
    var sourceCoverageX = this.sourceWorldWidth_ ? (0, _extent.getWidth)(sourceQuadExtent) / this.sourceWorldWidth_ : null;
    var sourceWorldWidth =
    /** @type {number} */
    this.sourceWorldWidth_; // when the quad is wrapped in the source projection
    // it covers most of the projection extent, but not fully

    var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
    var needsSubdivision = false;

    if (maxSubdivision > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        var targetQuadExtent = (0, _extent.boundingExtent)([a, b, c, d]);
        var targetCoverageX = (0, _extent.getWidth)(targetQuadExtent) / this.targetWorldWidth_;
        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }

      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
    }

    if (!needsSubdivision && this.maxSourceExtent_) {
      if (!(0, _extent.intersects)(sourceQuadExtent, this.maxSourceExtent_)) {
        // whole quad outside source projection extent -> ignore
        return;
      }
    }

    if (!needsSubdivision) {
      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
        if (maxSubdivision > 0) {
          needsSubdivision = true;
        } else {
          return;
        }
      }
    }

    if (maxSubdivision > 0) {
      if (!needsSubdivision) {
        var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
        var centerSrc = this.transformInv_(center);
        var dx = void 0;

        if (wrapsX) {
          var centerSrcEstimX = ((0, _math.modulo)(aSrc[0], sourceWorldWidth) + (0, _math.modulo)(cSrc[0], sourceWorldWidth)) / 2;
          dx = centerSrcEstimX - (0, _math.modulo)(centerSrc[0], sourceWorldWidth);
        } else {
          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
        }

        var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
        var centerSrcErrorSquared = dx * dx + dy * dy;
        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
      }

      if (needsSubdivision) {
        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
          // split horizontally (top & bottom)
          var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
          var bcSrc = this.transformInv_(bc);
          var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
          var daSrc = this.transformInv_(da);
          this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
          this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
        } else {
          // split vertically (left & right)
          var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
          var abSrc = this.transformInv_(ab);
          var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
          var cdSrc = this.transformInv_(cd);
          this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
          this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
        }

        return;
      }
    }

    if (wrapsX) {
      if (!this.canWrapXInSource_) {
        return;
      }

      this.wrapsXInSource_ = true;
    }

    this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
    this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);
  };
  /**
   * Calculates extent of the 'source' coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */


  Triangulation.prototype.calculateSourceExtent = function () {
    var extent = (0, _extent.createEmpty)();
    this.triangles_.forEach(function (triangle, i, arr) {
      var src = triangle.source;
      (0, _extent.extendCoordinate)(extent, src[0]);
      (0, _extent.extendCoordinate)(extent, src[1]);
      (0, _extent.extendCoordinate)(extent, src[2]);
    });
    return extent;
  };
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */


  Triangulation.prototype.getTriangles = function () {
    return this.triangles_;
  };

  return Triangulation;
}();

var _default = Triangulation;
exports.default = _default;
},{"../extent.js":"node_modules/ol/extent.js","../math.js":"node_modules/ol/math.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/reproj/Tile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _common = require("./common.js");

var _Tile = _interopRequireDefault(require("../Tile.js"));

var _TileState = _interopRequireDefault(require("../TileState.js"));

var _events = require("../events.js");

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _extent = require("../extent.js");

var _math = require("../math.js");

var _reproj = require("../reproj.js");

var _Triangulation = _interopRequireDefault(require("./Triangulation.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/reproj/Tile
 */


/**
 * @typedef {function(number, number, number, number) : import("../Tile.js").default} FunctionType
 */

/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:ol/source/TileImage~TileImage}.
 *
 */
var ReprojTile =
/** @class */
function (_super) {
  __extends(ReprojTile, _super);
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).
   * @param {boolean=} opt_renderEdges Render reprojection edges.
   */


  function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges) {
    var _this = _super.call(this, tileCoord, _TileState.default.IDLE) || this;
    /**
     * @private
     * @type {boolean}
     */


    _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;
    /**
     * @private
     * @type {number}
     */

    _this.pixelRatio_ = pixelRatio;
    /**
     * @private
     * @type {number}
     */

    _this.gutter_ = gutter;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.canvas_ = null;
    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */

    _this.sourceTileGrid_ = sourceTileGrid;
    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */

    _this.targetTileGrid_ = targetTileGrid;
    /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */

    _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
    /**
     * @private
     * @type {!Array<import("../Tile.js").default>}
     */

    _this.sourceTiles_ = [];
    /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */

    _this.sourcesListenerKeys_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.sourceZ_ = 0;
    var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);

    var maxTargetExtent = _this.targetTileGrid_.getExtent();

    var maxSourceExtent = _this.sourceTileGrid_.getExtent();

    var limitedTargetExtent = maxTargetExtent ? (0, _extent.getIntersection)(targetExtent, maxTargetExtent) : targetExtent;

    if ((0, _extent.getArea)(limitedTargetExtent) === 0) {
      // Tile is completely outside range -> EMPTY
      // TODO: is it actually correct that the source even creates the tile ?
      _this.state = _TileState.default.EMPTY;
      return _this;
    }

    var sourceProjExtent = sourceProj.getExtent();

    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = (0, _extent.getIntersection)(maxSourceExtent, sourceProjExtent);
      }
    }

    var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);
    var targetCenter = (0, _extent.getCenter)(limitedTargetExtent);
    var sourceResolution = (0, _reproj.calculateSourceResolution)(sourceProj, targetProj, targetCenter, targetResolution);

    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      // invalid sourceResolution -> EMPTY
      // probably edges of the projections when no extent is defined
      _this.state = _TileState.default.EMPTY;
      return _this;
    }

    var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : _common.ERROR_THRESHOLD;
    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */

    _this.triangulation_ = new _Triangulation.default(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);

    if (_this.triangulation_.getTriangles().length === 0) {
      // no valid triangles -> EMPTY
      _this.state = _TileState.default.EMPTY;
      return _this;
    }

    _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);

    var sourceExtent = _this.triangulation_.calculateSourceExtent();

    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = (0, _math.clamp)(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
        sourceExtent[3] = (0, _math.clamp)(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
      } else {
        sourceExtent = (0, _extent.getIntersection)(sourceExtent, maxSourceExtent);
      }
    }

    if (!(0, _extent.getArea)(sourceExtent)) {
      _this.state = _TileState.default.EMPTY;
    } else {
      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);

      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);

          if (tile) {
            _this.sourceTiles_.push(tile);
          }
        }
      }

      if (_this.sourceTiles_.length === 0) {
        _this.state = _TileState.default.EMPTY;
      }
    }

    return _this;
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */


  ReprojTile.prototype.getImage = function () {
    return this.canvas_;
  };
  /**
   * @private
   */


  ReprojTile.prototype.reproject_ = function () {
    var sources = [];
    this.sourceTiles_.forEach(function (tile, i, arr) {
      if (tile && tile.getState() == _TileState.default.LOADED) {
        sources.push({
          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
          image: tile.getImage()
        });
      }
    }.bind(this));
    this.sourceTiles_.length = 0;

    if (sources.length === 0) {
      this.state = _TileState.default.ERROR;
    } else {
      var z = this.wrappedTileCoord_[0];
      var size = this.targetTileGrid_.getTileSize(z);
      var width = typeof size === 'number' ? size : size[0];
      var height = typeof size === 'number' ? size : size[1];
      var targetResolution = this.targetTileGrid_.getResolution(z);
      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
      var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
      this.canvas_ = (0, _reproj.render)(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_);
      this.state = _TileState.default.LOADED;
    }

    this.changed();
  };
  /**
   * @inheritDoc
   */


  ReprojTile.prototype.load = function () {
    if (this.state == _TileState.default.IDLE) {
      this.state = _TileState.default.LOADING;
      this.changed();
      var leftToLoad_1 = 0;
      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach(function (tile, i, arr) {
        var state = tile.getState();

        if (state == _TileState.default.IDLE || state == _TileState.default.LOADING) {
          leftToLoad_1++;
          var sourceListenKey_1 = (0, _events.listen)(tile, _EventType.default.CHANGE, function (e) {
            var state = tile.getState();

            if (state == _TileState.default.LOADED || state == _TileState.default.ERROR || state == _TileState.default.EMPTY) {
              (0, _events.unlistenByKey)(sourceListenKey_1);
              leftToLoad_1--;

              if (leftToLoad_1 === 0) {
                this.unlistenSources_();
                this.reproject_();
              }
            }
          }, this);
          this.sourcesListenerKeys_.push(sourceListenKey_1);
        }
      }.bind(this));
      this.sourceTiles_.forEach(function (tile, i, arr) {
        var state = tile.getState();

        if (state == _TileState.default.IDLE) {
          tile.load();
        }
      });

      if (leftToLoad_1 === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      }
    }
  };
  /**
   * @private
   */


  ReprojTile.prototype.unlistenSources_ = function () {
    this.sourcesListenerKeys_.forEach(_events.unlistenByKey);
    this.sourcesListenerKeys_ = null;
  };

  return ReprojTile;
}(_Tile.default);

var _default = ReprojTile;
exports.default = _default;
},{"./common.js":"node_modules/ol/reproj/common.js","../Tile.js":"node_modules/ol/Tile.js","../TileState.js":"node_modules/ol/TileState.js","../events.js":"node_modules/ol/events.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../extent.js":"node_modules/ol/extent.js","../math.js":"node_modules/ol/math.js","../reproj.js":"node_modules/ol/reproj.js","./Triangulation.js":"node_modules/ol/reproj/Triangulation.js"}],"node_modules/ol/tileurlfunction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createFromTemplate = createFromTemplate;
exports.createFromTemplates = createFromTemplates;
exports.createFromTileUrlFunctions = createFromTileUrlFunctions;
exports.nullTileUrlFunction = nullTileUrlFunction;
exports.expandUrl = expandUrl;

var _asserts = require("./asserts.js");

var _math = require("./math.js");

var _tilecoord = require("./tilecoord.js");

/**
 * @module ol/tileurlfunction
 */

/**
 * @param {string} template Template.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplate(template, tileGrid) {
  var zRegEx = /\{z\}/g;
  var xRegEx = /\{x\}/g;
  var yRegEx = /\{y\}/g;
  var dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function () {
          var z = tileCoord[0];
          var range = tileGrid.getFullTileRange(z);
          (0, _asserts.assert)(range, 55); // The {-y} placeholder requires a tile grid with extent

          var y = range.getHeight() - tileCoord[2] - 1;
          return y.toString();
        });
      }
    }
  );
}
/**
 * @param {Array<string>} templates Templates.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */


function createFromTemplates(templates, tileGrid) {
  var len = templates.length;
  var tileUrlFunctions = new Array(len);

  for (var i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }

  return createFromTileUrlFunctions(tileUrlFunctions);
}
/**
 * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */


function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }

  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        var h = (0, _tilecoord.hash)(tileCoord);
        var index = (0, _math.modulo)(h, tileUrlFunctions.length);
        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
      }
    }
  );
}
/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {string|undefined} Tile URL.
 */


function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
  return undefined;
}
/**
 * @param {string} url URL.
 * @return {Array<string>} Array of urls.
 */


function expandUrl(url) {
  var urls = [];
  var match = /\{([a-z])-([a-z])\}/.exec(url);

  if (match) {
    // char range
    var startCharCode = match[1].charCodeAt(0);
    var stopCharCode = match[2].charCodeAt(0);
    var charCode = void 0;

    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }

    return urls;
  }

  match = /\{(\d+)-(\d+)\}/.exec(url);

  if (match) {
    // number range
    var stop_1 = parseInt(match[2], 10);

    for (var i = parseInt(match[1], 10); i <= stop_1; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }

    return urls;
  }

  urls.push(url);
  return urls;
}
},{"./asserts.js":"node_modules/ol/asserts.js","./math.js":"node_modules/ol/math.js","./tilecoord.js":"node_modules/ol/tilecoord.js"}],"node_modules/ol/TileRange.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOrUpdate = createOrUpdate;
exports.default = void 0;

/**
 * @module ol/TileRange
 */

/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 */
var TileRange =
/** @class */
function () {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  function TileRange(minX, maxX, minY, maxY) {
    /**
     * @type {number}
     */
    this.minX = minX;
    /**
     * @type {number}
     */

    this.maxX = maxX;
    /**
     * @type {number}
     */

    this.minY = minY;
    /**
     * @type {number}
     */

    this.maxY = maxY;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */


  TileRange.prototype.contains = function (tileCoord) {
    return this.containsXY(tileCoord[1], tileCoord[2]);
  };
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */


  TileRange.prototype.containsTileRange = function (tileRange) {
    return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
  };
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */


  TileRange.prototype.containsXY = function (x, y) {
    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
  };
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */


  TileRange.prototype.equals = function (tileRange) {
    return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
  };
  /**
   * @param {TileRange} tileRange Tile range.
   */


  TileRange.prototype.extend = function (tileRange) {
    if (tileRange.minX < this.minX) {
      this.minX = tileRange.minX;
    }

    if (tileRange.maxX > this.maxX) {
      this.maxX = tileRange.maxX;
    }

    if (tileRange.minY < this.minY) {
      this.minY = tileRange.minY;
    }

    if (tileRange.maxY > this.maxY) {
      this.maxY = tileRange.maxY;
    }
  };
  /**
   * @return {number} Height.
   */


  TileRange.prototype.getHeight = function () {
    return this.maxY - this.minY + 1;
  };
  /**
   * @return {import("./size.js").Size} Size.
   */


  TileRange.prototype.getSize = function () {
    return [this.getWidth(), this.getHeight()];
  };
  /**
   * @return {number} Width.
   */


  TileRange.prototype.getWidth = function () {
    return this.maxX - this.minX + 1;
  };
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */


  TileRange.prototype.intersects = function (tileRange) {
    return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
  };

  return TileRange;
}();
/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {TileRange=} tileRange TileRange.
 * @return {TileRange} Tile range.
 */


function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  } else {
    return new TileRange(minX, maxX, minY, maxY);
  }
}

var _default = TileRange;
exports.default = _default;
},{}],"node_modules/ol/tilegrid/TileGrid.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _common = require("./common.js");

var _asserts = require("../asserts.js");

var _TileRange = _interopRequireWildcard(require("../TileRange.js"));

var _array = require("../array.js");

var _extent = require("../extent.js");

var _math = require("../math.js");

var _size = require("../size.js");

var _tilecoord = require("../tilecoord.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @module ol/tilegrid/TileGrid
 */

/**
 * @private
 * @type {import("../tilecoord.js").TileCoord}
 */
var tmpTileCoord = [0, 0, 0];
/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. If specified the values
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent
 * for which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array<import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */

/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * @api
 */

var TileGrid =
/** @class */
function () {
  /**
   * @param {Options} options Tile grid options.
   */
  function TileGrid(options) {
    /**
     * @protected
     * @type {number}
     */
    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;
    /**
     * @private
     * @type {!Array<number>}
     */

    this.resolutions_ = options.resolutions;
    (0, _asserts.assert)((0, _array.isSorted)(this.resolutions_, function (a, b) {
      return b - a;
    }, true), 17); // `resolutions` must be sorted in descending order
    // check if we've got a consistent zoom factor and origin

    var zoomFactor;

    if (!options.origins) {
      for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
        if (!zoomFactor) {
          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
        } else {
          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
            zoomFactor = undefined;
            break;
          }
        }
      }
    }
    /**
     * @private
     * @type {number|undefined}
     */


    this.zoomFactor_ = zoomFactor;
    /**
     * @protected
     * @type {number}
     */

    this.maxZoom = this.resolutions_.length - 1;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */

    this.origin_ = options.origin !== undefined ? options.origin : null;
    /**
     * @private
     * @type {Array<import("../coordinate.js").Coordinate>}
     */

    this.origins_ = null;

    if (options.origins !== undefined) {
      this.origins_ = options.origins;
      (0, _asserts.assert)(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal
    }

    var extent = options.extent;

    if (extent !== undefined && !this.origin_ && !this.origins_) {
      this.origin_ = (0, _extent.getTopLeft)(extent);
    }

    (0, _asserts.assert)(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both

    /**
     * @private
     * @type {Array<number|import("../size.js").Size>}
     */

    this.tileSizes_ = null;

    if (options.tileSizes !== undefined) {
      this.tileSizes_ = options.tileSizes;
      (0, _asserts.assert)(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal
    }
    /**
     * @private
     * @type {number|import("../size.js").Size}
     */


    this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? _common.DEFAULT_TILE_SIZE : null;
    (0, _asserts.assert)(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    this.extent_ = extent !== undefined ? extent : null;
    /**
     * @private
     * @type {Array<import("../TileRange.js").default>}
     */

    this.fullTileRanges_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    this.tmpSize_ = [0, 0];

    if (options.sizes !== undefined) {
      this.fullTileRanges_ = options.sizes.map(function (size, z) {
        var tileRange = new _TileRange.default(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
        return tileRange;
      }, this);
    } else if (extent) {
      this.calculateTileRanges_(extent);
    }
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */


  TileGrid.prototype.forEachTileCoord = function (extent, zoom, callback) {
    var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);

    for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
      for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
        callback([zoom, i, j]);
      }
    }
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */


  TileGrid.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_tileRange, opt_extent) {
    var tileRange, x, y;
    var tileCoordExtent = null;
    var z = tileCoord[0] - 1;

    if (this.zoomFactor_ === 2) {
      x = tileCoord[1];
      y = tileCoord[2];
    } else {
      tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
    }

    while (z >= this.minZoom) {
      if (this.zoomFactor_ === 2) {
        x = Math.floor(x / 2);
        y = Math.floor(y / 2);
        tileRange = (0, _TileRange.createOrUpdate)(x, x, y, y, opt_tileRange);
      } else {
        tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
      }

      if (callback(z, tileRange)) {
        return true;
      }

      --z;
    }

    return false;
  };
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */


  TileGrid.prototype.getExtent = function () {
    return this.extent_;
  };
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */


  TileGrid.prototype.getMaxZoom = function () {
    return this.maxZoom;
  };
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */


  TileGrid.prototype.getMinZoom = function () {
    return this.minZoom;
  };
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */


  TileGrid.prototype.getOrigin = function (z) {
    if (this.origin_) {
      return this.origin_;
    } else {
      return this.origins_[z];
    }
  };
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */


  TileGrid.prototype.getResolution = function (z) {
    return this.resolutions_[z];
  };
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */


  TileGrid.prototype.getResolutions = function () {
    return this.resolutions_;
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default} Tile range.
   */


  TileGrid.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {
    if (tileCoord[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        var minX = tileCoord[1] * 2;
        var minY = tileCoord[2] * 2;
        return (0, _TileRange.createOrUpdate)(minX, minX + 1, minY, minY + 1, opt_tileRange);
      }

      var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
      return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
    }

    return null;
  };
  /**
   * Get the extent for a tile range.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
   * @return {import("../extent.js").Extent} Extent.
   */


  TileGrid.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {
    var origin = this.getOrigin(z);
    var resolution = this.getResolution(z);
    var tileSize = (0, _size.toSize)(this.getTileSize(z), this.tmpSize_);
    var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
    var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
    var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
    var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
    return (0, _extent.createOrUpdate)(minX, minY, maxX, maxY, opt_extent);
  };
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default=} opt_tileRange Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */


  TileGrid.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {
    var tileCoord = tmpTileCoord;
    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);
    var minX = tileCoord[1];
    var minY = tileCoord[2];
    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);
    return (0, _TileRange.createOrUpdate)(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */


  TileGrid.prototype.getTileCoordCenter = function (tileCoord) {
    var origin = this.getOrigin(tileCoord[0]);
    var resolution = this.getResolution(tileCoord[0]);
    var tileSize = (0, _size.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
    return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution];
  };
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent=} opt_extent Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */


  TileGrid.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {
    var origin = this.getOrigin(tileCoord[0]);
    var resolution = this.getResolution(tileCoord[0]);
    var tileSize = (0, _size.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
    var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
    var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
    var maxX = minX + tileSize[0] * resolution;
    var maxY = minY + tileSize[1] * resolution;
    return (0, _extent.createOrUpdate)(minX, minY, maxX, maxY, opt_extent);
  };
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */


  TileGrid.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {
    return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
  };
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */


  TileGrid.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
    var z = this.getZForResolution(resolution);
    var scale = resolution / this.getResolution(z);
    var origin = this.getOrigin(z);
    var tileSize = (0, _size.toSize)(this.getTileSize(z), this.tmpSize_);
    var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
    var adjustY = reverseIntersectionPolicy ? 0.5 : 0;
    var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
    var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);
    var tileCoordX = scale * xFromOrigin / tileSize[0];
    var tileCoordY = scale * yFromOrigin / tileSize[1];

    if (reverseIntersectionPolicy) {
      tileCoordX = Math.ceil(tileCoordX) - 1;
      tileCoordY = Math.ceil(tileCoordY) - 1;
    } else {
      tileCoordX = Math.floor(tileCoordX);
      tileCoordY = Math.floor(tileCoordY);
    }

    return (0, _tilecoord.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
  };
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */


  TileGrid.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
    var origin = this.getOrigin(z);
    var resolution = this.getResolution(z);
    var tileSize = (0, _size.toSize)(this.getTileSize(z), this.tmpSize_);
    var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
    var adjustY = reverseIntersectionPolicy ? 0.5 : 0;
    var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
    var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);
    var tileCoordX = xFromOrigin / tileSize[0];
    var tileCoordY = yFromOrigin / tileSize[1];

    if (reverseIntersectionPolicy) {
      tileCoordX = Math.ceil(tileCoordX) - 1;
      tileCoordY = Math.ceil(tileCoordY) - 1;
    } else {
      tileCoordX = Math.floor(tileCoordX);
      tileCoordY = Math.floor(tileCoordY);
    }

    return (0, _tilecoord.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
  };
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Zoom level.
   * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */


  TileGrid.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {
    return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */


  TileGrid.prototype.getTileCoordResolution = function (tileCoord) {
    return this.resolutions_[tileCoord[0]];
  };
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an `import("../size.js").Size`, run the result through `import("../size.js").Size.toSize()`.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */


  TileGrid.prototype.getTileSize = function (z) {
    if (this.tileSize_) {
      return this.tileSize_;
    } else {
      return this.tileSizes_[z];
    }
  };
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
   */


  TileGrid.prototype.getFullTileRange = function (z) {
    if (!this.fullTileRanges_) {
      return null;
    } else {
      return this.fullTileRanges_[z];
    }
  };
  /**
   * @param {number} resolution Resolution.
   * @param {number=} opt_direction If 0, the nearest resolution will be used.
   *     If 1, the nearest lower resolution will be used. If -1, the nearest
   *     higher resolution will be used. Default is 0.
   * @return {number} Z.
   * @api
   */


  TileGrid.prototype.getZForResolution = function (resolution, opt_direction) {
    var z = (0, _array.linearFindNearest)(this.resolutions_, resolution, opt_direction || 0);
    return (0, _math.clamp)(z, this.minZoom, this.maxZoom);
  };
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */


  TileGrid.prototype.calculateTileRanges_ = function (extent) {
    var length = this.resolutions_.length;
    var fullTileRanges = new Array(length);

    for (var z = this.minZoom; z < length; ++z) {
      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
    }

    this.fullTileRanges_ = fullTileRanges;
  };

  return TileGrid;
}();

var _default = TileGrid;
exports.default = _default;
},{"./common.js":"node_modules/ol/tilegrid/common.js","../asserts.js":"node_modules/ol/asserts.js","../TileRange.js":"node_modules/ol/TileRange.js","../array.js":"node_modules/ol/array.js","../extent.js":"node_modules/ol/extent.js","../math.js":"node_modules/ol/math.js","../size.js":"node_modules/ol/size.js","../tilecoord.js":"node_modules/ol/tilecoord.js"}],"node_modules/ol/tilegrid.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getForProjection = getForProjection;
exports.wrapX = wrapX;
exports.createForExtent = createForExtent;
exports.createXYZ = createXYZ;
exports.createForProjection = createForProjection;
exports.extentFromProjection = extentFromProjection;

var _common = require("./tilegrid/common.js");

var _size = require("./size.js");

var _extent = require("./extent.js");

var _Corner = _interopRequireDefault(require("./extent/Corner.js"));

var _proj = require("./proj.js");

var _Units = _interopRequireDefault(require("./proj/Units.js"));

var _TileGrid = _interopRequireDefault(require("./tilegrid/TileGrid.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/tilegrid
 */

/**
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {!TileGrid} Default tile grid for the
 * passed projection.
 */
function getForProjection(projection) {
  var tileGrid = projection.getDefaultTileGrid();

  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }

  return tileGrid;
}
/**
 * @param {TileGrid} tileGrid Tile grid.
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
 */


function wrapX(tileGrid, tileCoord, projection) {
  var z = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);
  var projectionExtent = extentFromProjection(projection);

  if (!(0, _extent.containsCoordinate)(projectionExtent, center)) {
    var worldWidth = (0, _extent.getWidth)(projectionExtent);
    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  } else {
    return tileCoord;
  }
}
/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {Corner=} opt_corner Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */


function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {
  var corner = opt_corner !== undefined ? opt_corner : _Corner.default.TOP_LEFT;
  var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);
  return new _TileGrid.default({
    extent: extent,
    origin: (0, _extent.getCorner)(extent, corner),
    resolutions: resolutions,
    tileSize: opt_tileSize
  });
}
/**
 * @typedef {Object} XYZOptions
 * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution
 * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxResolution] Resolution at level zero.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
 */

/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {XYZOptions=} opt_options Tile grid options.
 * @return {!TileGrid} Tile grid instance.
 * @api
 */


function createXYZ(opt_options) {
  var xyzOptions = opt_options || {};
  var extent = xyzOptions.extent || (0, _proj.get)('EPSG:3857').getExtent();
  var gridOptions = {
    extent: extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution)
  };
  return new _TileGrid.default(gridOptions);
}
/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {number=} opt_maxResolution Resolution at level zero.
 * @return {!Array<number>} Resolutions array.
 */


function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize, opt_maxResolution) {
  var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : _common.DEFAULT_MAX_ZOOM;
  var height = (0, _extent.getHeight)(extent);
  var width = (0, _extent.getWidth)(extent);
  var tileSize = (0, _size.toSize)(opt_tileSize !== undefined ? opt_tileSize : _common.DEFAULT_TILE_SIZE);
  var maxResolution = opt_maxResolution > 0 ? opt_maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  var length = maxZoom + 1;
  var resolutions = new Array(length);

  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }

  return resolutions;
}
/**
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {Corner=} opt_corner Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */


function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
  var extent = extentFromProjection(projection);
  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
}
/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @return {import("./extent.js").Extent} Extent.
 */


function extentFromProjection(projection) {
  projection = (0, _proj.get)(projection);
  var extent = projection.getExtent();

  if (!extent) {
    var half = 180 * _proj.METERS_PER_UNIT[_Units.default.DEGREES] / projection.getMetersPerUnit();
    extent = (0, _extent.createOrUpdate)(-half, -half, half, half);
  }

  return extent;
}
},{"./tilegrid/common.js":"node_modules/ol/tilegrid/common.js","./size.js":"node_modules/ol/size.js","./extent.js":"node_modules/ol/extent.js","./extent/Corner.js":"node_modules/ol/extent/Corner.js","./proj.js":"node_modules/ol/proj.js","./proj/Units.js":"node_modules/ol/proj/Units.js","./tilegrid/TileGrid.js":"node_modules/ol/tilegrid/TileGrid.js"}],"node_modules/ol/source/Tile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TileSourceEvent = void 0;

var _util = require("../util.js");

var _TileCache = _interopRequireDefault(require("../TileCache.js"));

var _TileState = _interopRequireDefault(require("../TileState.js"));

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _proj = require("../proj.js");

var _size = require("../size.js");

var _Source = _interopRequireDefault(require("./Source.js"));

var _tilecoord = require("../tilecoord.js");

var _tilegrid = require("../tilegrid.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/source/Tile
 */


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions]
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize]
 * @property {boolean} [opaque]
 * @property {number} [tilePixelRatio]
 * @property {import("../proj.js").ProjectionLike} [projection]
 * @property {import("./State.js").default} [state]
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]
 * @property {boolean} [wrapX=true]
 * @property {number} [transition]
 * @property {string} [key]
 * @property {number} [zDirection=0]
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 * @abstract
 * @api
 */
var TileSource =
/** @class */
function (_super) {
  __extends(TileSource, _super);
  /**
   * @param {Options} options SourceTile source options.
   */


  function TileSource(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX
    }) || this;
    /**
     * @private
     * @type {boolean}
     */


    _this.opaque_ = options.opaque !== undefined ? options.opaque : false;
    /**
     * @private
     * @type {number}
     */

    _this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;
    /**
     * @protected
     * @type {import("../tilegrid/TileGrid.js").default}
     */

    _this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;
    var tileSize = [256, 256];
    var tileGrid = options.tileGrid;

    if (tileGrid) {
      (0, _size.toSize)(tileGrid.getTileSize(tileGrid.getMinZoom()), tileSize);
    }

    var canUseScreen = typeof screen !== 'undefined';
    var width = canUseScreen ? screen.availWidth || screen.width : 1920;
    var height = canUseScreen ? screen.availHeight || screen.height : 1080;
    var minCacheSize = 4 * Math.ceil(width / tileSize[0]) * Math.ceil(height / tileSize[1]);
    /**
     * @protected
     * @type {import("../TileCache.js").default}
     */

    _this.tileCache = new _TileCache.default(Math.max(minCacheSize, options.cacheSize || 0));
    /**
     * @protected
     * @type {import("../size.js").Size}
     */

    _this.tmpSize = [0, 0];
    /**
     * @private
     * @type {string}
     */

    _this.key_ = options.key || '';
    /**
     * @protected
     * @type {import("../Tile.js").Options}
     */

    _this.tileOptions = {
      transition: options.transition
    };
    /**
     * zDirection hint, read by the renderer. Indicates which resolution should be used
     * by a renderer if the views resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @type {number}
     */

    _this.zDirection = options.zDirection ? options.zDirection : 0;
    return _this;
  }
  /**
   * @return {boolean} Can expire cache.
   */


  TileSource.prototype.canExpireCache = function () {
    return this.tileCache.canExpireCache();
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */


  TileSource.prototype.expireCache = function (projection, usedTiles) {
    var tileCache = this.getTileCacheForProjection(projection);

    if (tileCache) {
      tileCache.expireCache(usedTiles);
    }
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */


  TileSource.prototype.forEachLoadedTile = function (projection, z, tileRange, callback) {
    var tileCache = this.getTileCacheForProjection(projection);

    if (!tileCache) {
      return false;
    }

    var covered = true;
    var tile, tileCoordKey, loaded;

    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
        tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
        loaded = false;

        if (tileCache.containsKey(tileCoordKey)) {
          tile =
          /** @type {!import("../Tile.js").default} */
          tileCache.get(tileCoordKey);
          loaded = tile.getState() === _TileState.default.LOADED;

          if (loaded) {
            loaded = callback(tile) !== false;
          }
        }

        if (!loaded) {
          covered = false;
        }
      }
    }

    return covered;
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */


  TileSource.prototype.getGutterForProjection = function (projection) {
    return 0;
  };
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   * @protected
   */


  TileSource.prototype.getKey = function () {
    return this.key_;
  };
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */


  TileSource.prototype.setKey = function (key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */


  TileSource.prototype.getOpaque = function (projection) {
    return this.opaque_;
  };
  /**
   * @inheritDoc
   */


  TileSource.prototype.getResolutions = function () {
    return this.tileGrid.getResolutions();
  };
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */


  TileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {
    return (0, _util.abstract)();
  };
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default} Tile grid.
   * @api
   */


  TileSource.prototype.getTileGrid = function () {
    return this.tileGrid;
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */


  TileSource.prototype.getTileGridForProjection = function (projection) {
    if (!this.tileGrid) {
      return (0, _tilegrid.getForProjection)(projection);
    } else {
      return this.tileGrid;
    }
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */


  TileSource.prototype.getTileCacheForProjection = function (projection) {
    var thisProj = this.getProjection();

    if (thisProj && !(0, _proj.equivalent)(thisProj, projection)) {
      return null;
    } else {
      return this.tileCache;
    }
  };
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */


  TileSource.prototype.getTilePixelRatio = function (pixelRatio) {
    return this.tilePixelRatio_;
  };
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */


  TileSource.prototype.getTilePixelSize = function (z, pixelRatio, projection) {
    var tileGrid = this.getTileGridForProjection(projection);
    var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    var tileSize = (0, _size.toSize)(tileGrid.getTileSize(z), this.tmpSize);

    if (tilePixelRatio == 1) {
      return tileSize;
    } else {
      return (0, _size.scale)(tileSize, tilePixelRatio, this.tmpSize);
    }
  };
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default=} opt_projection Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */


  TileSource.prototype.getTileCoordForTileUrlFunction = function (tileCoord, opt_projection) {
    var projection = opt_projection !== undefined ? opt_projection : this.getProjection();
    var tileGrid = this.getTileGridForProjection(projection);

    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = (0, _tilegrid.wrapX)(tileGrid, tileCoord, projection);
    }

    return (0, _tilecoord.withinExtentAndZ)(tileCoord, tileGrid) ? tileCoord : null;
  };
  /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */


  TileSource.prototype.clear = function () {
    this.tileCache.clear();
  };

  TileSource.prototype.refresh = function () {
    this.clear();

    _super.prototype.refresh.call(this);
  };
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */


  TileSource.prototype.useTile = function (z, x, y, projection) {};

  return TileSource;
}(_Source.default);
/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 */


var TileSourceEvent =
/** @class */
function (_super) {
  __extends(TileSourceEvent, _super);
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */


  function TileSourceEvent(type, tile) {
    var _this = _super.call(this, type) || this;
    /**
     * The tile related to the event.
     * @type {import("../Tile.js").default}
     * @api
     */


    _this.tile = tile;
    return _this;
  }

  return TileSourceEvent;
}(_Event.default);

exports.TileSourceEvent = TileSourceEvent;
var _default = TileSource;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","../TileCache.js":"node_modules/ol/TileCache.js","../TileState.js":"node_modules/ol/TileState.js","../events/Event.js":"node_modules/ol/events/Event.js","../proj.js":"node_modules/ol/proj.js","../size.js":"node_modules/ol/size.js","./Source.js":"node_modules/ol/source/Source.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../tilegrid.js":"node_modules/ol/tilegrid.js"}],"node_modules/ol/source/TileEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/source/TileEventType
 */

/**
 * @enum {string}
 */
var _default = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: 'tileloadstart',

  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: 'tileloadend',

  /**
   * Triggered if tile loading results in an error.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: 'tileloaderror'
};
exports.default = _default;
},{}],"node_modules/ol/source/UrlTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("../util.js");

var _TileState = _interopRequireDefault(require("../TileState.js"));

var _tileurlfunction = require("../tileurlfunction.js");

var _Tile = _interopRequireWildcard(require("./Tile.js"));

var _TileEventType = _interopRequireDefault(require("./TileEventType.js"));

var _tilecoord = require("../tilecoord.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/source/UrlTile
 */


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions]
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize]
 * @property {boolean} [opaque]
 * @property {import("../proj.js").ProjectionLike} [projection]
 * @property {import("./State.js").default} [state]
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]
 * @property {import("../Tile.js").LoadFunction} tileLoadFunction
 * @property {number} [tilePixelRatio]
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction]
 * @property {string} [url]
 * @property {Array<string>} [urls]
 * @property {boolean} [wrapX=true]
 * @property {number} [transition]
 * @property {string} [key]
 * @property {number} [zDirection=0]
 */

/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @fires import("./Tile.js").TileSourceEvent
 */
var UrlTile =
/** @class */
function (_super) {
  __extends(UrlTile, _super);
  /**
   * @param {Options} options Image tile options.
   */


  function UrlTile(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    }) || this;
    /**
     * @private
     * @type {boolean}
     */


    _this.generateTileUrlFunction_ = !options.tileUrlFunction;
    /**
     * @protected
     * @type {import("../Tile.js").LoadFunction}
     */

    _this.tileLoadFunction = options.tileLoadFunction;
    /**
     * @protected
     * @type {import("../Tile.js").UrlFunction}
     */

    _this.tileUrlFunction = options.tileUrlFunction ? options.tileUrlFunction.bind(_this) : _tileurlfunction.nullTileUrlFunction;
    /**
     * @protected
     * @type {!Array<string>|null}
     */

    _this.urls = null;

    if (options.urls) {
      _this.setUrls(options.urls);
    } else if (options.url) {
      _this.setUrl(options.url);
    }
    /**
     * @private
     * @type {!Object<string, boolean>}
     */


    _this.tileLoadingKeys_ = {};
    return _this;
  }
  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */


  UrlTile.prototype.getTileLoadFunction = function () {
    return this.tileLoadFunction;
  };
  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */


  UrlTile.prototype.getTileUrlFunction = function () {
    return this.tileUrlFunction;
  };
  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */


  UrlTile.prototype.getUrls = function () {
    return this.urls;
  };
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */


  UrlTile.prototype.handleTileChange = function (event) {
    var tile =
    /** @type {import("../Tile.js").default} */
    event.target;
    var uid = (0, _util.getUid)(tile);
    var tileState = tile.getState();
    var type;

    if (tileState == _TileState.default.LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = _TileEventType.default.TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type = tileState == _TileState.default.ERROR ? _TileEventType.default.TILELOADERROR : tileState == _TileState.default.LOADED ? _TileEventType.default.TILELOADEND : undefined;
    }

    if (type != undefined) {
      this.dispatchEvent(new _Tile.TileSourceEvent(type, tile));
    }
  };
  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */


  UrlTile.prototype.setTileLoadFunction = function (tileLoadFunction) {
    this.tileCache.clear();
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  };
  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string=} key Optional new tile key for the source.
   * @api
   */


  UrlTile.prototype.setTileUrlFunction = function (tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    this.tileCache.pruneExceptNewestZ();

    if (typeof key !== 'undefined') {
      this.setKey(key);
    } else {
      this.changed();
    }
  };
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */


  UrlTile.prototype.setUrl = function (url) {
    var urls = (0, _tileurlfunction.expandUrl)(url);
    this.urls = urls;
    this.setUrls(urls);
  };
  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */


  UrlTile.prototype.setUrls = function (urls) {
    this.urls = urls;
    var key = urls.join('\n');

    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction((0, _tileurlfunction.createFromTemplates)(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  };
  /**
   * @inheritDoc
   */


  UrlTile.prototype.useTile = function (z, x, y) {
    var tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);

    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  };

  return UrlTile;
}(_Tile.default);

var _default = UrlTile;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","../TileState.js":"node_modules/ol/TileState.js","../tileurlfunction.js":"node_modules/ol/tileurlfunction.js","./Tile.js":"node_modules/ol/source/Tile.js","./TileEventType.js":"node_modules/ol/source/TileEventType.js","../tilecoord.js":"node_modules/ol/tilecoord.js"}],"node_modules/ol/source/TileImage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _common = require("../reproj/common.js");

var _util = require("../util.js");

var _ImageTile = _interopRequireDefault(require("../ImageTile.js"));

var _TileCache = _interopRequireDefault(require("../TileCache.js"));

var _TileState = _interopRequireDefault(require("../TileState.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _proj = require("../proj.js");

var _Tile = _interopRequireDefault(require("../reproj/Tile.js"));

var _UrlTile = _interopRequireDefault(require("./UrlTile.js"));

var _tilecoord = require("../tilecoord.js");

var _tilegrid = require("../tilegrid.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/source/TileImage
 */


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Tile cache size. The default depends on the screen size. Will be ignored if too small.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./State.js").default} [state] Source state.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [key] Optional tile key for proper cache fetching
 * @property {number} [zDirection=0] Indicate which resolution should be used
 * by a renderer if the view resolution does not match any resolution of the tile source.
 * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
 * will be used. If -1, the nearest higher resolution will be used.
 */

/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */
var TileImage =
/** @class */
function (_super) {
  __extends(TileImage, _super);
  /**
   * @param {!Options} options Image tile options.
   */


  function TileImage(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    }) || this;
    /**
     * @protected
     * @type {?string}
     */


    _this.crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;
    /**
     * @protected
     * @type {typeof ImageTile}
     */

    _this.tileClass = options.tileClass !== undefined ? options.tileClass : _ImageTile.default;
    /**
     * @protected
     * @type {!Object<string, TileCache>}
     */

    _this.tileCacheForProjection = {};
    /**
     * @protected
     * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
     */

    _this.tileGridForProjection = {};
    /**
     * @private
     * @type {number|undefined}
     */

    _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
    /**
     * @private
     * @type {boolean}
     */

    _this.renderReprojectionEdges_ = false;
    return _this;
  }
  /**
   * @inheritDoc
   */


  TileImage.prototype.canExpireCache = function () {
    if (!_common.ENABLE_RASTER_REPROJECTION) {
      return _super.prototype.canExpireCache.call(this);
    }

    if (this.tileCache.canExpireCache()) {
      return true;
    } else {
      for (var key in this.tileCacheForProjection) {
        if (this.tileCacheForProjection[key].canExpireCache()) {
          return true;
        }
      }
    }

    return false;
  };
  /**
   * @inheritDoc
   */


  TileImage.prototype.expireCache = function (projection, usedTiles) {
    if (!_common.ENABLE_RASTER_REPROJECTION) {
      _super.prototype.expireCache.call(this, projection, usedTiles);

      return;
    }

    var usedTileCache = this.getTileCacheForProjection(projection);
    this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});

    for (var id in this.tileCacheForProjection) {
      var tileCache = this.tileCacheForProjection[id];
      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
    }
  };
  /**
   * @inheritDoc
   */


  TileImage.prototype.getGutterForProjection = function (projection) {
    if (_common.ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !(0, _proj.equivalent)(this.getProjection(), projection)) {
      return 0;
    } else {
      return this.getGutter();
    }
  };
  /**
   * @return {number} Gutter.
   */


  TileImage.prototype.getGutter = function () {
    return 0;
  };
  /**
   * @inheritDoc
   */


  TileImage.prototype.getOpaque = function (projection) {
    if (_common.ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !(0, _proj.equivalent)(this.getProjection(), projection)) {
      return false;
    } else {
      return _super.prototype.getOpaque.call(this, projection);
    }
  };
  /**
   * @inheritDoc
   */


  TileImage.prototype.getTileGridForProjection = function (projection) {
    if (!_common.ENABLE_RASTER_REPROJECTION) {
      return _super.prototype.getTileGridForProjection.call(this, projection);
    }

    var thisProj = this.getProjection();

    if (this.tileGrid && (!thisProj || (0, _proj.equivalent)(thisProj, projection))) {
      return this.tileGrid;
    } else {
      var projKey = (0, _util.getUid)(projection);

      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = (0, _tilegrid.getForProjection)(projection);
      }

      return (
        /** @type {!import("../tilegrid/TileGrid.js").default} */
        this.tileGridForProjection[projKey]
      );
    }
  };
  /**
   * @inheritDoc
   */


  TileImage.prototype.getTileCacheForProjection = function (projection) {
    if (!_common.ENABLE_RASTER_REPROJECTION) {
      return _super.prototype.getTileCacheForProjection.call(this, projection);
    }

    var thisProj = this.getProjection();

    if (!thisProj || (0, _proj.equivalent)(thisProj, projection)) {
      return this.tileCache;
    } else {
      var projKey = (0, _util.getUid)(projection);

      if (!(projKey in this.tileCacheForProjection)) {
        this.tileCacheForProjection[projKey] = new _TileCache.default(this.tileCache.highWaterMark);
      }

      return this.tileCacheForProjection[projKey];
    }
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!import("../Tile.js").default} Tile.
   * @private
   */


  TileImage.prototype.createTile_ = function (z, x, y, pixelRatio, projection, key) {
    var tileCoord = [z, x, y];
    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
    var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
    var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? _TileState.default.IDLE : _TileState.default.EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);
    tile.key = key;
    tile.addEventListener(_EventType.default.CHANGE, this.handleTileChange.bind(this));
    return tile;
  };
  /**
   * @inheritDoc
   */


  TileImage.prototype.getTile = function (z, x, y, pixelRatio, projection) {
    var sourceProjection =
    /** @type {!import("../proj/Projection.js").default} */
    this.getProjection();

    if (!_common.ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || (0, _proj.equivalent)(sourceProjection, projection)) {
      return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
    } else {
      var cache = this.getTileCacheForProjection(projection);
      var tileCoord = [z, x, y];
      var tile = void 0;
      var tileCoordKey = (0, _tilecoord.getKey)(tileCoord);

      if (cache.containsKey(tileCoordKey)) {
        tile =
        /** @type {!import("../Tile.js").default} */
        cache.get(tileCoordKey);
      }

      var key = this.getKey();

      if (tile && tile.key == key) {
        return tile;
      } else {
        var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
        var targetTileGrid = this.getTileGridForProjection(projection);
        var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
        var newTile = new _Tile.default(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function (z, x, y, pixelRatio) {
          return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
        }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_);
        newTile.key = key;

        if (tile) {
          newTile.interimTile = tile;
          newTile.refreshInterimChain();
          cache.replace(tileCoordKey, newTile);
        } else {
          cache.set(tileCoordKey, newTile);
        }

        return newTile;
      }
    }
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   * @protected
   */


  TileImage.prototype.getTileInternal = function (z, x, y, pixelRatio, projection) {
    var tile = null;
    var tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
    var key = this.getKey();

    if (!this.tileCache.containsKey(tileCoordKey)) {
      tile = this.createTile_(z, x, y, pixelRatio, projection, key);
      this.tileCache.set(tileCoordKey, tile);
    } else {
      tile = this.tileCache.get(tileCoordKey);

      if (tile.key != key) {
        // The source's params changed. If the tile has an interim tile and if we
        // can use it then we use it. Otherwise we create a new tile.  In both
        // cases we attempt to assign an interim tile to the new tile.
        var interimTile = tile;
        tile = this.createTile_(z, x, y, pixelRatio, projection, key); //make the new tile the head of the list,

        if (interimTile.getState() == _TileState.default.IDLE) {
          //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
          tile.interimTile = interimTile.interimTile;
        } else {
          tile.interimTile = interimTile;
        }

        tile.refreshInterimChain();
        this.tileCache.replace(tileCoordKey, tile);
      }
    }

    return tile;
  };
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */


  TileImage.prototype.setRenderReprojectionEdges = function (render) {
    if (!_common.ENABLE_RASTER_REPROJECTION || this.renderReprojectionEdges_ == render) {
      return;
    }

    this.renderReprojectionEdges_ = render;

    for (var id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }

    this.changed();
  };
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */


  TileImage.prototype.setTileGridForProjection = function (projection, tilegrid) {
    if (_common.ENABLE_RASTER_REPROJECTION) {
      var proj = (0, _proj.get)(projection);

      if (proj) {
        var projKey = (0, _util.getUid)(proj);

        if (!(projKey in this.tileGridForProjection)) {
          this.tileGridForProjection[projKey] = tilegrid;
        }
      }
    }
  };

  return TileImage;
}(_UrlTile.default);
/**
 * @param {ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */


function defaultTileLoadFunction(imageTile, src) {
  /** @type {HTMLImageElement|HTMLVideoElement} */
  imageTile.getImage().src = src;
}

var _default = TileImage;
exports.default = _default;
},{"../reproj/common.js":"node_modules/ol/reproj/common.js","../util.js":"node_modules/ol/util.js","../ImageTile.js":"node_modules/ol/ImageTile.js","../TileCache.js":"node_modules/ol/TileCache.js","../TileState.js":"node_modules/ol/TileState.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../proj.js":"node_modules/ol/proj.js","../reproj/Tile.js":"node_modules/ol/reproj/Tile.js","./UrlTile.js":"node_modules/ol/source/UrlTile.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../tilegrid.js":"node_modules/ol/tilegrid.js"}],"node_modules/ol/source/XYZ.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _TileImage = _interopRequireDefault(require("./TileImage.js"));

var _tilegrid = require("../tilegrid.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/XYZ
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Tile cache size. The default depends on the screen size. Will be ignored if too small.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * Not used if `tileGrid` is provided.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get
 * tile URL given a tile coordinate and the projection.
 * Required if `url` or `urls` are not provided.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
 * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
 * may be used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number} [zDirection=0] Indicate which resolution should be used
 * by a renderer if the view resolution does not match any resolution of the tile source.
 * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
 * will be used. If -1, the nearest higher resolution will be used.
 */

/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case,
 * {@link module:ol/source/TileImage} can be used with a `tileUrlFunction`
 * such as:
 *
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *        coordinate[1] + '/' + coordinate[2] + '.png';
 *    }
 *
 * @api
 */
var XYZ =
/** @class */
function (_super) {
  __extends(XYZ, _super);
  /**
   * @param {Options=} opt_options XYZ options.
   */


  function XYZ(opt_options) {
    var _this = this;

    var options = opt_options || {};
    var projection = options.projection !== undefined ? options.projection : 'EPSG:3857';
    var tileGrid = options.tileGrid !== undefined ? options.tileGrid : (0, _tilegrid.createXYZ)({
      extent: (0, _tilegrid.extentFromProjection)(projection),
      maxResolution: options.maxResolution,
      maxZoom: options.maxZoom,
      minZoom: options.minZoom,
      tileSize: options.tileSize
    });
    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      opaque: options.opaque,
      projection: projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    }) || this;
    return _this;
  }

  return XYZ;
}(_TileImage.default);

var _default = XYZ;
exports.default = _default;
},{"./TileImage.js":"node_modules/ol/source/TileImage.js","../tilegrid.js":"node_modules/ol/tilegrid.js"}],"node_modules/ol/source/OSM.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ATTRIBUTION = void 0;

var _XYZ = _interopRequireDefault(require("./XYZ.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/OSM
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * The attribution containing a link to the OpenStreetMap Copyright and License
 * page.
 * @const
 * @type {string}
 * @api
 */
var ATTRIBUTION = '&#169; ' + '<a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> ' + 'contributors.';
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Tile cache size. The default depends on the screen size. Will be ignored if too small.
 * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {number} [maxZoom=19] Max zoom.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {number} [reprojectionErrorThreshold=1.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url='https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
 * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */

/**
 * @classdesc
 * Layer source for the OpenStreetMap tile server.
 * @api
 */

exports.ATTRIBUTION = ATTRIBUTION;

var OSM =
/** @class */
function (_super) {
  __extends(OSM, _super);
  /**
   * @param {Options=} [opt_options] Open Street Map options.
   */


  function OSM(opt_options) {
    var _this = this;

    var options = opt_options || {};
    var attributions;

    if (options.attributions !== undefined) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }

    var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';
    var url = options.url !== undefined ? options.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';
    _this = _super.call(this, {
      attributions: attributions,
      cacheSize: options.cacheSize,
      crossOrigin: crossOrigin,
      opaque: options.opaque !== undefined ? options.opaque : true,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      url: url,
      wrapX: options.wrapX,
      attributionsCollapsible: false
    }) || this;
    return _this;
  }

  return OSM;
}(_XYZ.default);

var _default = OSM;
exports.default = _default;
},{"./XYZ.js":"node_modules/ol/source/XYZ.js"}],"node_modules/ol/geom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function () {
    return _Circle.default;
  }
});
Object.defineProperty(exports, "Geometry", {
  enumerable: true,
  get: function () {
    return _Geometry.default;
  }
});
Object.defineProperty(exports, "GeometryCollection", {
  enumerable: true,
  get: function () {
    return _GeometryCollection.default;
  }
});
Object.defineProperty(exports, "LineString", {
  enumerable: true,
  get: function () {
    return _LineString.default;
  }
});
Object.defineProperty(exports, "MultiLineString", {
  enumerable: true,
  get: function () {
    return _MultiLineString.default;
  }
});
Object.defineProperty(exports, "MultiPoint", {
  enumerable: true,
  get: function () {
    return _MultiPoint.default;
  }
});
Object.defineProperty(exports, "MultiPolygon", {
  enumerable: true,
  get: function () {
    return _MultiPolygon.default;
  }
});
Object.defineProperty(exports, "Point", {
  enumerable: true,
  get: function () {
    return _Point.default;
  }
});
Object.defineProperty(exports, "Polygon", {
  enumerable: true,
  get: function () {
    return _Polygon.default;
  }
});
Object.defineProperty(exports, "LinearRing", {
  enumerable: true,
  get: function () {
    return _LinearRing.default;
  }
});

var _Circle = _interopRequireDefault(require("./geom/Circle.js"));

var _Geometry = _interopRequireDefault(require("./geom/Geometry.js"));

var _GeometryCollection = _interopRequireDefault(require("./geom/GeometryCollection.js"));

var _LineString = _interopRequireDefault(require("./geom/LineString.js"));

var _MultiLineString = _interopRequireDefault(require("./geom/MultiLineString.js"));

var _MultiPoint = _interopRequireDefault(require("./geom/MultiPoint.js"));

var _MultiPolygon = _interopRequireDefault(require("./geom/MultiPolygon.js"));

var _Point = _interopRequireDefault(require("./geom/Point.js"));

var _Polygon = _interopRequireDefault(require("./geom/Polygon.js"));

var _LinearRing = _interopRequireDefault(require("./geom/LinearRing.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./geom/Circle.js":"node_modules/ol/geom/Circle.js","./geom/Geometry.js":"node_modules/ol/geom/Geometry.js","./geom/GeometryCollection.js":"node_modules/ol/geom/GeometryCollection.js","./geom/LineString.js":"node_modules/ol/geom/LineString.js","./geom/MultiLineString.js":"node_modules/ol/geom/MultiLineString.js","./geom/MultiPoint.js":"node_modules/ol/geom/MultiPoint.js","./geom/MultiPolygon.js":"node_modules/ol/geom/MultiPolygon.js","./geom/Point.js":"node_modules/ol/geom/Point.js","./geom/Polygon.js":"node_modules/ol/geom/Polygon.js","./geom/LinearRing.js":"node_modules/ol/geom/LinearRing.js"}],"node_modules/ol/layer/TileProperty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/layer/TileProperty
 */

/**
 * @enum {string}
 */
var _default = {
  PRELOAD: 'preload',
  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'
};
exports.default = _default;
},{}],"node_modules/ol/layer/BaseTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Layer = _interopRequireDefault(require("./Layer.js"));

var _TileProperty = _interopRequireDefault(require("./TileProperty.js"));

var _obj = require("../obj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/BaseTile
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {import("../source/Tile.js").default} [source] Source for this layer.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 */

/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @extends {Layer<import("../source/Tile.js").default>}
 * @api
 */
var BaseTileLayer =
/** @class */
function (_super) {
  __extends(BaseTileLayer, _super);
  /**
   * @param {Options=} opt_options Tile layer options.
   */


  function BaseTileLayer(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var baseOptions = (0, _obj.assign)({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    _this = _super.call(this, baseOptions) || this;

    _this.setPreload(options.preload !== undefined ? options.preload : 0);

    _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);

    return _this;
  }
  /**
  * Return the level as number to which we will preload tiles up to.
  * @return {number} The level to preload tiles up to.
  * @observable
  * @api
  */


  BaseTileLayer.prototype.getPreload = function () {
    return (
      /** @type {number} */
      this.get(_TileProperty.default.PRELOAD)
    );
  };
  /**
  * Set the level as number to which we will preload tiles up to.
  * @param {number} preload The level to preload tiles up to.
  * @observable
  * @api
  */


  BaseTileLayer.prototype.setPreload = function (preload) {
    this.set(_TileProperty.default.PRELOAD, preload);
  };
  /**
  * Whether we use interim tiles on error.
  * @return {boolean} Use interim tiles on error.
  * @observable
  * @api
  */


  BaseTileLayer.prototype.getUseInterimTilesOnError = function () {
    return (
      /** @type {boolean} */
      this.get(_TileProperty.default.USE_INTERIM_TILES_ON_ERROR)
    );
  };
  /**
  * Set whether we use interim tiles on error.
  * @param {boolean} useInterimTilesOnError Use interim tiles on error.
  * @observable
  * @api
  */


  BaseTileLayer.prototype.setUseInterimTilesOnError = function (useInterimTilesOnError) {
    this.set(_TileProperty.default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  };

  return BaseTileLayer;
}(_Layer.default);

var _default = BaseTileLayer;
exports.default = _default;
},{"./Layer.js":"node_modules/ol/layer/Layer.js","./TileProperty.js":"node_modules/ol/layer/TileProperty.js","../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/renderer/canvas/TileLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("../../util.js");

var _proj = require("../../proj.js");

var _TileRange = _interopRequireDefault(require("../../TileRange.js"));

var _TileState = _interopRequireDefault(require("../../TileState.js"));

var _extent = require("../../extent.js");

var _Layer = _interopRequireDefault(require("./Layer.js"));

var _transform = require("../../transform.js");

var _array = require("../../array.js");

var _canvas = require("../../render/canvas.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/canvas/TileLayer
 */


/**
 * @classdesc
 * Canvas renderer for tile layers.
 * @api
 */
var CanvasTileLayerRenderer =
/** @class */
function (_super) {
  __extends(CanvasTileLayerRenderer, _super);
  /**
   * @param {import("../../layer/Tile.js").default|import("../../layer/VectorTile.js").default} tileLayer Tile layer.
   */


  function CanvasTileLayerRenderer(tileLayer) {
    var _this = _super.call(this, tileLayer) || this;
    /**
     * Rendered extent has changed since the previous `renderFrame()` call
     * @type {boolean}
     */


    _this.extentChanged = true;
    /**
     * @private
     * @type {?import("../../extent.js").Extent}
     */

    _this.renderedExtent_ = null;
    /**
     * @protected
     * @type {number}
     */

    _this.renderedPixelRatio;
    /**
     * @protected
     * @type {import("../../proj/Projection.js").default}
     */

    _this.renderedProjection = null;
    /**
     * @protected
     * @type {number}
     */

    _this.renderedRevision;
    /**
     * @protected
     * @type {!Array<import("../../Tile.js").default>}
     */

    _this.renderedTiles = [];
    /**
     * @private
     * @type {boolean}
     */

    _this.newTiles_ = false;
    /**
     * @protected
     * @type {import("../../extent.js").Extent}
     */

    _this.tmpExtent = (0, _extent.createEmpty)();
    /**
     * @private
     * @type {import("../../TileRange.js").default}
     */

    _this.tmpTileRange_ = new _TileRange.default(0, 0, 0, 0);
    return _this;
  }
  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */


  CanvasTileLayerRenderer.prototype.isDrawableTile = function (tile) {
    var tileLayer = this.getLayer();
    var tileState = tile.getState();
    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == _TileState.default.LOADED || tileState == _TileState.default.EMPTY || tileState == _TileState.default.ERROR && !useInterimTilesOnError;
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */


  CanvasTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {
    var pixelRatio = frameState.pixelRatio;
    var projection = frameState.viewState.projection;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getSource();
    var tile = tileSource.getTile(z, x, y, pixelRatio, projection);

    if (tile.getState() == _TileState.default.ERROR) {
      if (!tileLayer.getUseInterimTilesOnError()) {
        // When useInterimTilesOnError is false, we consider the error tile as loaded.
        tile.setState(_TileState.default.LOADED);
      } else if (tileLayer.getPreload() > 0) {
        // Preloaded tiles for lower resolutions might have finished loading.
        this.newTiles_ = true;
      }
    }

    if (!this.isDrawableTile(tile)) {
      tile = tile.getInterimTile();
    }

    return tile;
  };
  /**
   * @inheritDoc
   */


  CanvasTileLayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {
    if (this.isDrawableTile(tile)) {
      return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);
    }

    return false;
  };
  /**
   * @inheritDoc
   */


  CanvasTileLayerRenderer.prototype.prepareFrame = function (frameState) {
    return !!this.getLayer().getSource();
  };
  /**
   * TODO: File a TypeScript issue about inheritDoc not being followed
   * all the way.  Without this explicit return type, the VectorTileLayer
   * renderFrame function does not pass.
   *
   * @inheritDoc
   * @returns {HTMLElement} The rendered element.
   */


  CanvasTileLayerRenderer.prototype.renderFrame = function (frameState, target) {
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var viewResolution = viewState.resolution;
    var viewCenter = viewState.center;
    var rotation = viewState.rotation;
    var pixelRatio = frameState.pixelRatio;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getSource();
    var sourceRevision = tileSource.getRevision();
    var tileGrid = tileSource.getTileGridForProjection(projection);
    var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
    var tileResolution = tileGrid.getResolution(z);
    var extent = frameState.extent;
    var layerExtent = layerState.extent && (0, _proj.fromUserExtent)(layerState.extent, projection);

    if (layerExtent) {
      extent = (0, _extent.getIntersection)(extent, (0, _proj.fromUserExtent)(layerState.extent, projection));
    }

    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio); // desired dimensions of the canvas in pixels

    var width = Math.round(frameState.size[0] * tilePixelRatio);
    var height = Math.round(frameState.size[1] * tilePixelRatio);

    if (rotation) {
      var size = Math.round(Math.sqrt(width * width + height * height));
      width = size;
      height = size;
    }

    var dx = tileResolution * width / 2 / tilePixelRatio;
    var dy = tileResolution * height / 2 / tilePixelRatio;
    var canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];
    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
    /**
     * @type {Object<number, Object<string, import("../../Tile.js").default>>}
     */

    var tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};
    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
    var tmpExtent = this.tmpExtent;
    var tmpTileRange = this.tmpTileRange_;
    this.newTiles_ = false;

    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
        var tile = this.getTile(z, x, y, frameState);

        if (this.isDrawableTile(tile)) {
          var uid = (0, _util.getUid)(this);

          if (tile.getState() == _TileState.default.LOADED) {
            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
            var inTransition = tile.inTransition(uid);

            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {
              this.newTiles_ = true;
            }
          }

          if (tile.getAlpha(uid, frameState.time) === 1) {
            // don't look for alt tiles if alpha is 1
            continue;
          }
        }

        var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
        var covered = false;

        if (childTileRange) {
          covered = findLoadedTiles(z + 1, childTileRange);
        }

        if (!covered) {
          tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);
        }
      }
    }

    var canvasScale = tileResolution / viewResolution; // set forward and inverse pixel transforms

    (0, _transform.compose)(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / tilePixelRatio, 1 / tilePixelRatio, rotation, -width / 2, -height / 2);
    var canvasTransform = (0, _canvas.createTransformString)(this.pixelTransform);
    this.useContainer(target, canvasTransform, layerState.opacity);
    var context = this.context;
    var canvas = context.canvas;
    (0, _transform.makeInverse)(this.inversePixelTransform, this.pixelTransform); // set scale transform for calculating tile positions on the canvas

    (0, _transform.compose)(this.tempTransform_, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);

    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }

    if (layerExtent) {
      this.clipUnrotated(context, frameState, layerExtent);
    }

    this.preRender(context, frameState);
    this.renderedTiles.length = 0;
    /** @type {Array<number>} */

    var zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(_array.numberSafeCompareFunction);
    var clips, clipZs, currentClip;

    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {
      zs = zs.reverse();
    } else {
      clips = [];
      clipZs = [];
    }

    for (var i = zs.length - 1; i >= 0; --i) {
      var currentZ = zs[i];
      var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
      var currentResolution = tileGrid.getResolution(currentZ);
      var currentScale = currentResolution / tileResolution;
      var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;
      var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;
      var originTileCoord = tileGrid.getTileCoordForCoordAndZ((0, _extent.getTopLeft)(canvasExtent), currentZ);
      var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
      var origin_1 = (0, _transform.apply)(this.tempTransform_, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);
      var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
      var tilesToDraw = tilesToDrawByZ[currentZ];

      for (var tileCoordKey in tilesToDraw) {
        var tile =
        /** @type {import("../../ImageTile.js").default} */
        tilesToDraw[tileCoordKey];
        var tileCoord = tile.tileCoord; // Calculate integer positions and sizes so that tiles align

        var floatX = origin_1[0] - (originTileCoord[1] - tileCoord[1]) * dx_1;
        var nextX = Math.round(floatX + dx_1);
        var floatY = origin_1[1] - (originTileCoord[2] - tileCoord[2]) * dy_1;
        var nextY = Math.round(floatY + dy_1);
        var x = Math.round(floatX);
        var y = Math.round(floatY);
        var w = nextX - x;
        var h = nextY - y;
        var transition = z === currentZ;
        var inTransition = transition && tile.getAlpha((0, _util.getUid)(this), frameState.time) !== 1;

        if (!inTransition) {
          if (clips) {
            // Clip mask for regions in this tile that already filled by a higher z tile
            context.save();
            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];

            for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {
              if (z !== currentZ && currentZ < clipZs[i_1]) {
                var clip = clips[i_1];
                context.beginPath(); // counter-clockwise (outer ring) for current tile

                context.moveTo(currentClip[0], currentClip[1]);
                context.lineTo(currentClip[2], currentClip[3]);
                context.lineTo(currentClip[4], currentClip[5]);
                context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher z tile

                context.moveTo(clip[6], clip[7]);
                context.lineTo(clip[4], clip[5]);
                context.lineTo(clip[2], clip[3]);
                context.lineTo(clip[0], clip[1]);
                context.clip();
              }
            }

            clips.push(currentClip);
            clipZs.push(currentZ);
          } else {
            context.clearRect(x, y, w, h);
          }
        }

        this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition, layerState.opacity);

        if (clips && !inTransition) {
          context.restore();
        }

        this.renderedTiles.push(tile);
        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
      }
    }

    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution;
    this.extentChanged = !this.renderedExtent_ || !(0, _extent.equals)(this.renderedExtent_, canvasExtent);
    this.renderedExtent_ = canvasExtent;
    this.renderedPixelRatio = pixelRatio;
    this.renderedProjection = projection;
    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
    this.scheduleExpireCache(frameState, tileSource);
    this.postRender(context, frameState);

    if (layerState.extent) {
      context.restore();
    }

    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }

    return this.container;
  };
  /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   * @param {number} opacity Opacity.
   */


  CanvasTileLayerRenderer.prototype.drawTileImage = function (tile, frameState, x, y, w, h, gutter, transition, opacity) {
    var image = this.getTileImage(tile);

    if (!image) {
      return;
    }

    var uid = (0, _util.getUid)(this);
    var tileAlpha = transition ? tile.getAlpha(uid, frameState.time) : 1;
    var alpha = opacity * tileAlpha;
    var alphaChanged = alpha !== this.context.globalAlpha;

    if (alphaChanged) {
      this.context.save();
      this.context.globalAlpha = alpha;
    }

    this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);

    if (alphaChanged) {
      this.context.restore();
    }

    if (tileAlpha !== 1) {
      frameState.animate = true;
    } else if (transition) {
      tile.endTransition(uid);
    }
  };
  /**
   * @inheritDoc
   */


  CanvasTileLayerRenderer.prototype.getImage = function () {
    var context = this.context;
    return context ? context.canvas : null;
  };
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */


  CanvasTileLayerRenderer.prototype.getTileImage = function (tile) {
    return tile.getImage();
  };
  /**
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */


  CanvasTileLayerRenderer.prototype.scheduleExpireCache = function (frameState, tileSource) {
    if (tileSource.canExpireCache()) {
      /**
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @param {import("../../PluggableMap.js").default} map Map.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       */
      var postRenderFunction = function (tileSource, map, frameState) {
        var tileSourceKey = (0, _util.getUid)(tileSource);

        if (tileSourceKey in frameState.usedTiles) {
          tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);
        }
      }.bind(null, tileSource);

      frameState.postRenderFunctions.push(
      /** @type {import("../../PluggableMap.js").PostRenderFunction} */
      postRenderFunction);
    }
  };
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */


  CanvasTileLayerRenderer.prototype.updateUsedTiles = function (usedTiles, tileSource, tile) {
    // FIXME should we use tilesToDrawByZ instead?
    var tileSourceKey = (0, _util.getUid)(tileSource);

    if (!(tileSourceKey in usedTiles)) {
      usedTiles[tileSourceKey] = {};
    }

    usedTiles[tileSourceKey][tile.getKey()] = true;
  };
  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to 'preload' levels.
   * @param {function(import("../../Tile.js").default)=} opt_tileCallback Tile callback.
   * @protected
   */


  CanvasTileLayerRenderer.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {
    var tileSourceKey = (0, _util.getUid)(tileSource);

    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }

    var wantedTiles = frameState.wantedTiles[tileSourceKey];
    var tileQueue = frameState.tileQueue;
    var minZoom = tileGrid.getMinZoom();
    var tile, tileRange, tileResolution, x, y, z;

    for (z = minZoom; z <= currentZ; ++z) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
      tileResolution = tileGrid.getResolution(z);

      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
          if (currentZ - z <= preload) {
            tile = tileSource.getTile(z, x, y, pixelRatio, projection);

            if (tile.getState() == _TileState.default.IDLE) {
              wantedTiles[tile.getKey()] = true;

              if (!tileQueue.isKeyQueued(tile.getKey())) {
                tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);
              }
            }

            if (opt_tileCallback !== undefined) {
              opt_tileCallback(tile);
            }
          } else {
            tileSource.useTile(z, x, y, projection);
          }
        }
      }
    }
  };

  return CanvasTileLayerRenderer;
}(_Layer.default);
/**
 * @function
 * @return {import("../../layer/Tile.js").default|import("../../layer/VectorTile.js").default}
 */


CanvasTileLayerRenderer.prototype.getLayer;
var _default = CanvasTileLayerRenderer;
exports.default = _default;
},{"../../util.js":"node_modules/ol/util.js","../../proj.js":"node_modules/ol/proj.js","../../TileRange.js":"node_modules/ol/TileRange.js","../../TileState.js":"node_modules/ol/TileState.js","../../extent.js":"node_modules/ol/extent.js","./Layer.js":"node_modules/ol/renderer/canvas/Layer.js","../../transform.js":"node_modules/ol/transform.js","../../array.js":"node_modules/ol/array.js","../../render/canvas.js":"node_modules/ol/render/canvas.js"}],"node_modules/ol/layer/Tile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _BaseTile = _interopRequireDefault(require("./BaseTile.js"));

var _TileLayer = _interopRequireDefault(require("../renderer/canvas/TileLayer.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/Tile
 */


/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @api
 */
var TileLayer =
/** @class */
function (_super) {
  __extends(TileLayer, _super);
  /**
   * @param {import("./BaseTile.js").Options=} opt_options Tile layer options.
   */


  function TileLayer(opt_options) {
    return _super.call(this, opt_options) || this;
  }
  /**
   * Create a renderer for this layer.
   * @return {import("../renderer/Layer.js").default} A layer renderer.
   * @protected
   */


  TileLayer.prototype.createRenderer = function () {
    return new _TileLayer.default(this);
  };

  return TileLayer;
}(_BaseTile.default);

var _default = TileLayer;
exports.default = _default;
},{"./BaseTile.js":"node_modules/ol/layer/BaseTile.js","../renderer/canvas/TileLayer.js":"node_modules/ol/renderer/canvas/TileLayer.js"}],"node_modules/ol/source/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_WMS_VERSION = void 0;

/**
 * @module ol/source/common
 */

/**
 * Default WMS version.
 * @type {string}
 */
var DEFAULT_WMS_VERSION = '1.3.0';
exports.DEFAULT_WMS_VERSION = DEFAULT_WMS_VERSION;
},{}],"node_modules/ol/source/WMSServerType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/source/WMSServerType
 */

/**
 * Available server types: `'carmentaserver'`, `'geoserver'`, `'mapserver'`,
 *     `'qgis'`. These are servers that have vendor parameters beyond the WMS
 *     specification that OpenLayers can make use of.
 * @enum {string}
 */
var _default = {
  /**
   * HiDPI support for [Carmenta Server](https://www.carmenta.com/en/products/carmenta-server)
   * @api
   */
  CARMENTA_SERVER: 'carmentaserver',

  /**
   * HiDPI support for [GeoServer](https://geoserver.org/)
   * @api
   */
  GEOSERVER: 'geoserver',

  /**
   * HiDPI support for [MapServer](https://mapserver.org/)
   * @api
   */
  MAPSERVER: 'mapserver',

  /**
   * HiDPI support for [QGIS](https://qgis.org/)
   * @api
   */
  QGIS: 'qgis'
};
exports.default = _default;
},{}],"node_modules/ol/uri.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.appendParams = appendParams;

/**
 * @module ol/uri
 */

/**
 * Appends query parameters to a URI.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {!Object} params An object where keys are URI-encoded parameter keys,
 *     and the values are arbitrary types or arrays.
 * @return {string} The new URI.
 */
function appendParams(uri, params) {
  var keyParams = []; // Skip any null or undefined parameter values

  Object.keys(params).forEach(function (k) {
    if (params[k] !== null && params[k] !== undefined) {
      keyParams.push(k + '=' + encodeURIComponent(params[k]));
    }
  });
  var qs = keyParams.join('&'); // remove any trailing ? or &

  uri = uri.replace(/[?&]$/, ''); // append ? or & depending on whether uri has existing parameters

  uri = uri.indexOf('?') === -1 ? uri + '?' : uri + '&';
  return uri + qs;
}
},{}],"node_modules/ol/source/TileWMS.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _common = require("./common.js");

var _asserts = require("../asserts.js");

var _extent = require("../extent.js");

var _obj = require("../obj.js");

var _math = require("../math.js");

var _proj = require("../proj.js");

var _reproj = require("../reproj.js");

var _size = require("../size.js");

var _TileImage = _interopRequireDefault(require("./TileImage.js"));

var _WMSServerType = _interopRequireDefault(require("./WMSServerType.js"));

var _tilecoord = require("../tilecoord.js");

var _string = require("../string.js");

var _uri = require("../uri.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/TileWMS
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Tile cache size. The default depends on the screen size. Will be ignored if too small.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {Object<string,*>} params WMS request parameters.
 * At least a `LAYERS` param is required. `STYLES` is
 * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`
 * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.
 * @property {number} [gutter=0]
 * The size in pixels of the gutter around image tiles to ignore. By setting
 * this property to a non-zero value, images will be requested that are wider
 * and taller than the tile size by a value of `2 x gutter`.
 * Using a non-zero value allows artifacts of rendering at tile edges to be
 * ignored. If you control the WMS service it is recommended to address
 * "artifacts at tile edges" issues by properly configuring the WMS service. For
 * example, MapServer has a `tile_map_edge_buffer` configuration parameter for
 * this. See http://mapserver.org/output/tile_mode.html.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid. Base this on the resolutions,
 * tilesize and extent supported by the server.
 * If this is not defined, a default grid will be used: if there is a projection
 * extent, the grid will be based on that; if not, a grid based on a global
 * extent with origin at 0,0 will be used..
 * @property {import("./WMSServerType.js").default|string} [serverType]
 * The type of the remote WMS server. Currently only used when `hidpi` is
 * `true`.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] WMS service URL.
 * @property {Array<string>} [urls] WMS service urls.
 * Use this instead of `url` when the WMS supports multiple urls for GetMap requests.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * When set to `false`, only one world
 * will be rendered. When `true`, tiles will be requested for one world only,
 * but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */

/**
 * @classdesc
 * Layer source for tile data from WMS servers.
 * @api
 */
var TileWMS =
/** @class */
function (_super) {
  __extends(TileWMS, _super);
  /**
   * @param {Options=} [opt_options] Tile WMS options.
   */


  function TileWMS(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options :
    /** @type {Options} */
    {};
    var params = options.params || {};
    var transparent = 'TRANSPARENT' in params ? params['TRANSPARENT'] : true;
    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      opaque: !transparent,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tileUrlFunction: tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition
    }) || this;
    /**
     * @private
     * @type {number}
     */

    _this.gutter_ = options.gutter !== undefined ? options.gutter : 0;
    /**
     * @private
     * @type {!Object}
     */

    _this.params_ = params;
    /**
     * @private
     * @type {boolean}
     */

    _this.v13_ = true;
    /**
     * @private
     * @type {import("./WMSServerType.js").default|undefined}
     */

    _this.serverType_ =
    /** @type {import("./WMSServerType.js").default|undefined} */
    options.serverType;
    /**
     * @private
     * @type {boolean}
     */

    _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    _this.tmpExtent_ = (0, _extent.createEmpty)();

    _this.updateV13_();

    _this.setKey(_this.getKeyForParams_());

    return _this;
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */


  TileWMS.prototype.getFeatureInfoUrl = function (coordinate, resolution, projection, params) {
    var projectionObj = (0, _proj.get)(projection);
    var sourceProjectionObj = this.getProjection();
    var tileGrid = this.getTileGrid();

    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projectionObj);
    }

    var z = tileGrid.getZForResolution(resolution, this.zDirection);
    var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);

    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return undefined;
    }

    var tileResolution = tileGrid.getResolution(tileCoord[0]);
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    var tileSize = (0, _size.toSize)(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
    var gutter = this.gutter_;

    if (gutter !== 0) {
      tileSize = (0, _size.buffer)(tileSize, gutter, this.tmpSize);
      tileExtent = (0, _extent.buffer)(tileExtent, tileResolution * gutter, tileExtent);
    }

    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
      tileResolution = (0, _reproj.calculateSourceResolution)(sourceProjectionObj, projectionObj, coordinate, tileResolution);
      tileExtent = (0, _proj.transformExtent)(tileExtent, projectionObj, sourceProjectionObj);
      coordinate = (0, _proj.transform)(coordinate, projectionObj, sourceProjectionObj);
    }

    var baseParams = {
      'SERVICE': 'WMS',
      'VERSION': _common.DEFAULT_WMS_VERSION,
      'REQUEST': 'GetFeatureInfo',
      'FORMAT': 'image/png',
      'TRANSPARENT': true,
      'QUERY_LAYERS': this.params_['LAYERS']
    };
    (0, _obj.assign)(baseParams, this.params_, params);
    var x = Math.floor((coordinate[0] - tileExtent[0]) / tileResolution);
    var y = Math.floor((tileExtent[3] - coordinate[1]) / tileResolution);
    baseParams[this.v13_ ? 'I' : 'X'] = x;
    baseParams[this.v13_ ? 'J' : 'Y'] = y;
    return this.getRequestUrl_(tileCoord, tileSize, tileExtent, 1, sourceProjectionObj || projectionObj, baseParams);
  };
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */


  TileWMS.prototype.getLegendUrl = function (resolution, params) {
    if (this.urls[0] === undefined) {
      return undefined;
    }

    var baseParams = {
      'SERVICE': 'WMS',
      'VERSION': _common.DEFAULT_WMS_VERSION,
      'REQUEST': 'GetLegendGraphic',
      'FORMAT': 'image/png'
    };

    if (params === undefined || params['LAYER'] === undefined) {
      var layers = this.params_.LAYERS;
      var isSingleLayer = !Array.isArray(layers) || layers.length === 1;

      if (!isSingleLayer) {
        return undefined;
      }

      baseParams['LAYER'] = layers;
    }

    if (resolution !== undefined) {
      var mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
      var dpi = 25.4 / 0.28;
      var inchesPerMeter = 39.37;
      baseParams['SCALE'] = resolution * mpu * inchesPerMeter * dpi;
    }

    (0, _obj.assign)(baseParams, params);
    return (0, _uri.appendParams)(
    /** @type {string} */
    this.urls[0], baseParams);
  };
  /**
   * @inheritDoc
   */


  TileWMS.prototype.getGutter = function () {
    return this.gutter_;
  };
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */


  TileWMS.prototype.getParams = function () {
    return this.params_;
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../size.js").Size} tileSize Tile size.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */


  TileWMS.prototype.getRequestUrl_ = function (tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {
    var urls = this.urls;

    if (!urls) {
      return undefined;
    }

    params['WIDTH'] = tileSize[0];
    params['HEIGHT'] = tileSize[1];
    params[this.v13_ ? 'CRS' : 'SRS'] = projection.getCode();

    if (!('STYLES' in this.params_)) {
      params['STYLES'] = '';
    }

    if (pixelRatio != 1) {
      switch (this.serverType_) {
        case _WMSServerType.default.GEOSERVER:
          var dpi = 90 * pixelRatio + 0.5 | 0;

          if ('FORMAT_OPTIONS' in params) {
            params['FORMAT_OPTIONS'] += ';dpi:' + dpi;
          } else {
            params['FORMAT_OPTIONS'] = 'dpi:' + dpi;
          }

          break;

        case _WMSServerType.default.MAPSERVER:
          params['MAP_RESOLUTION'] = 90 * pixelRatio;
          break;

        case _WMSServerType.default.CARMENTA_SERVER:
        case _WMSServerType.default.QGIS:
          params['DPI'] = 90 * pixelRatio;
          break;

        default:
          (0, _asserts.assert)(false, 52); // Unknown `serverType` configured

          break;
      }
    }

    var axisOrientation = projection.getAxisOrientation();
    var bbox = tileExtent;

    if (this.v13_ && axisOrientation.substr(0, 2) == 'ne') {
      var tmp = void 0;
      tmp = tileExtent[0];
      bbox[0] = tileExtent[1];
      bbox[1] = tmp;
      tmp = tileExtent[2];
      bbox[2] = tileExtent[3];
      bbox[3] = tmp;
    }

    params['BBOX'] = bbox.join(',');
    var url;

    if (urls.length == 1) {
      url = urls[0];
    } else {
      var index = (0, _math.modulo)((0, _tilecoord.hash)(tileCoord), urls.length);
      url = urls[index];
    }

    return (0, _uri.appendParams)(url, params);
  };
  /**
   * @inheritDoc
   */


  TileWMS.prototype.getTilePixelRatio = function (pixelRatio) {
    return !this.hidpi_ || this.serverType_ === undefined ? 1 :
    /** @type {number} */
    pixelRatio;
  };
  /**
   * @private
   * @return {string} The key for the current params.
   */


  TileWMS.prototype.getKeyForParams_ = function () {
    var i = 0;
    var res = [];

    for (var key in this.params_) {
      res[i++] = key + '-' + this.params_[key];
    }

    return res.join('/');
  };
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */


  TileWMS.prototype.updateParams = function (params) {
    (0, _obj.assign)(this.params_, params);
    this.updateV13_();
    this.setKey(this.getKeyForParams_());
  };
  /**
   * @private
   */


  TileWMS.prototype.updateV13_ = function () {
    var version = this.params_['VERSION'] || _common.DEFAULT_WMS_VERSION;
    this.v13_ = (0, _string.compareVersions)(version, '1.3') >= 0;
  };

  return TileWMS;
}(_TileImage.default);
/**
 * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
 * @param {number} pixelRatio The pixel ratio
 * @param {import("../proj/Projection.js").default} projection The projection
 * @return {string|undefined} The tile URL
 * @this {TileWMS}
 */


function tileUrlFunction(tileCoord, pixelRatio, projection) {
  var tileGrid = this.getTileGrid();

  if (!tileGrid) {
    tileGrid = this.getTileGridForProjection(projection);
  }

  if (tileGrid.getResolutions().length <= tileCoord[0]) {
    return undefined;
  }

  if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {
    pixelRatio = 1;
  }

  var tileResolution = tileGrid.getResolution(tileCoord[0]);
  var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
  var tileSize = (0, _size.toSize)(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
  var gutter = this.gutter_;

  if (gutter !== 0) {
    tileSize = (0, _size.buffer)(tileSize, gutter, this.tmpSize);
    tileExtent = (0, _extent.buffer)(tileExtent, tileResolution * gutter, tileExtent);
  }

  if (pixelRatio != 1) {
    tileSize = (0, _size.scale)(tileSize, pixelRatio, this.tmpSize);
  }

  var baseParams = {
    'SERVICE': 'WMS',
    'VERSION': _common.DEFAULT_WMS_VERSION,
    'REQUEST': 'GetMap',
    'FORMAT': 'image/png',
    'TRANSPARENT': true
  };
  (0, _obj.assign)(baseParams, this.params_);
  return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
}

var _default = TileWMS;
exports.default = _default;
},{"./common.js":"node_modules/ol/source/common.js","../asserts.js":"node_modules/ol/asserts.js","../extent.js":"node_modules/ol/extent.js","../obj.js":"node_modules/ol/obj.js","../math.js":"node_modules/ol/math.js","../proj.js":"node_modules/ol/proj.js","../reproj.js":"node_modules/ol/reproj.js","../size.js":"node_modules/ol/size.js","./TileImage.js":"node_modules/ol/source/TileImage.js","./WMSServerType.js":"node_modules/ol/source/WMSServerType.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../string.js":"node_modules/ol/string.js","../uri.js":"node_modules/ol/uri.js"}],"node_modules/ol/webgl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContext = getContext;
exports.getSupportedExtensions = getSupportedExtensions;
exports.FLOAT = exports.UNSIGNED_INT = exports.UNSIGNED_SHORT = exports.UNSIGNED_BYTE = exports.DYNAMIC_DRAW = exports.STATIC_DRAW = exports.STREAM_DRAW = exports.ELEMENT_ARRAY_BUFFER = exports.ARRAY_BUFFER = void 0;

/**
 * @module ol/webgl
 */

/**
 * Constants taken from goog.webgl
 */

/**
 * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing vertices data, such as
 * position, color, texture coordinate, etc. These vertices are then referenced by an index buffer
 * to be drawn on screen (see {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER}).
 * @const
 * @type {number}
 * @api
 */
var ARRAY_BUFFER = 0x8892;
/**
 * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing indices data.
 * Index buffers are essentially lists of references to vertices defined in a vertex buffer
 * (see {@link module:ol/webgl.ARRAY_BUFFER}), and define the primitives (triangles) to be drawn.
 * @const
 * @type {number}
 * @api
 */

exports.ARRAY_BUFFER = ARRAY_BUFFER;
var ELEMENT_ARRAY_BUFFER = 0x8893;
/**
 * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.
 * @const
 * @type {number}
 * @api
 */

exports.ELEMENT_ARRAY_BUFFER = ELEMENT_ARRAY_BUFFER;
var STREAM_DRAW = 0x88E0;
/**
 * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.
 * @const
 * @type {number}
 * @api
 */

exports.STREAM_DRAW = STREAM_DRAW;
var STATIC_DRAW = 0x88E4;
/**
 * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.
 * @const
 * @type {number}
 * @api
 */

exports.STATIC_DRAW = STATIC_DRAW;
var DYNAMIC_DRAW = 0x88E8;
/**
 * @const
 * @type {number}
 */

exports.DYNAMIC_DRAW = DYNAMIC_DRAW;
var UNSIGNED_BYTE = 0x1401;
/**
 * @const
 * @type {number}
 */

exports.UNSIGNED_BYTE = UNSIGNED_BYTE;
var UNSIGNED_SHORT = 0x1403;
/**
 * @const
 * @type {number}
 */

exports.UNSIGNED_SHORT = UNSIGNED_SHORT;
var UNSIGNED_INT = 0x1405;
/**
 * @const
 * @type {number}
 */

exports.UNSIGNED_INT = UNSIGNED_INT;
var FLOAT = 0x1406;
/** end of goog.webgl constants
 */

/**
 * @const
 * @type {Array<string>}
 */

exports.FLOAT = FLOAT;
var CONTEXT_IDS = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];
/**
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {Object=} opt_attributes Attributes.
 * @return {WebGLRenderingContext} WebGL rendering context.
 */

function getContext(canvas, opt_attributes) {
  var ii = CONTEXT_IDS.length;

  for (var i = 0; i < ii; ++i) {
    try {
      var context = canvas.getContext(CONTEXT_IDS[i], opt_attributes);

      if (context) {
        return (
          /** @type {!WebGLRenderingContext} */
          context
        );
      }
    } catch (e) {// pass
    }
  }

  return null;
}
/**
 * @type {Array<string>}
 */


var supportedExtensions;
/**
 * @return {Array<string>} List of supported WebGL extensions.
 */

function getSupportedExtensions() {
  if (!supportedExtensions) {
    var canvas = document.createElement('canvas');
    var gl = getContext(canvas);

    if (gl) {
      supportedExtensions = gl.getSupportedExtensions();
    }
  }

  return supportedExtensions;
}
},{}],"node_modules/ol/webgl/Buffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getArrayClassForType = getArrayClassForType;
exports.default = exports.BufferUsage = void 0;

var _webgl = require("../webgl.js");

var _asserts = require("../asserts.js");

/**
 * @module ol/webgl/Buffer
 */

/**
 * Used to describe the intended usage for the data: `STATIC_DRAW`, `STREAM_DRAW`
 * or `DYNAMIC_DRAW`.
 * @enum {number}
 */
var BufferUsage = {
  STATIC_DRAW: _webgl.STATIC_DRAW,
  STREAM_DRAW: _webgl.STREAM_DRAW,
  DYNAMIC_DRAW: _webgl.DYNAMIC_DRAW
};
/**
 * @classdesc
 * Object used to store an array of data as well as usage information for that data.
 * Stores typed arrays internally, either Float32Array or Uint16/32Array depending on
 * the buffer type (ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER) and available extensions.
 *
 * To populate the array, you can either use:
 * * A size using `#ofSize(buffer)`
 * * An `ArrayBuffer` object using `#fromArrayBuffer(buffer)`
 * * A plain array using `#fromArray(array)`
 *
 * Note:
 * See the documentation of [WebGLRenderingContext.bufferData](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData)
 * for more info on buffer usage.
 * @api
 */

exports.BufferUsage = BufferUsage;

var WebGLArrayBuffer =
/** @class */
function () {
  /**
   * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
   * @param {number=} opt_usage Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.
   * Default is `DYNAMIC_DRAW`.
   */
  function WebGLArrayBuffer(type, opt_usage) {
    /**
     * @private
     * @type {Float32Array|Uint32Array}
     */
    this.array = null;
    /**
     * @private
     * @type {number}
     */

    this.type = type;
    (0, _asserts.assert)(type === _webgl.ARRAY_BUFFER || type === _webgl.ELEMENT_ARRAY_BUFFER, 62);
    /**
     * @private
     * @type {number}
     */

    this.usage = opt_usage !== undefined ? opt_usage : BufferUsage.STATIC_DRAW;
  }
  /**
   * Populates the buffer with an array of the given size (all values will be zeroes).
   * @param {number} size Array size
   */


  WebGLArrayBuffer.prototype.ofSize = function (size) {
    this.array = new (getArrayClassForType(this.type))(size);
  };
  /**
   * Populates the buffer with an array of the given size (all values will be zeroes).
   * @param {Array<number>} array Numerical array
   */


  WebGLArrayBuffer.prototype.fromArray = function (array) {
    this.array = getArrayClassForType(this.type).from(array);
  };
  /**
   * Populates the buffer with a raw binary array buffer.
   * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been
   * initialized for the same typed array class.
   */


  WebGLArrayBuffer.prototype.fromArrayBuffer = function (buffer) {
    this.array = new (getArrayClassForType(this.type))(buffer);
  };
  /**
   * @return {number} Buffer type.
   */


  WebGLArrayBuffer.prototype.getType = function () {
    return this.type;
  };
  /**
   * Will return null if the buffer was not initialized
   * @return {Float32Array|Uint32Array} Array.
   */


  WebGLArrayBuffer.prototype.getArray = function () {
    return this.array;
  };
  /**
   * @return {number} Usage.
   */


  WebGLArrayBuffer.prototype.getUsage = function () {
    return this.usage;
  };
  /**
   * Will return 0 if the buffer is not initialized
   * @return {number} Array size
   */


  WebGLArrayBuffer.prototype.getSize = function () {
    return this.array ? this.array.length : 0;
  };

  return WebGLArrayBuffer;
}();
/**
 * Returns a typed array constructor based on the given buffer type
 * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
 * @returns {Float32ArrayConstructor|Uint32ArrayConstructor} The typed array class to use for this buffer.
 */


function getArrayClassForType(type) {
  switch (type) {
    case _webgl.ARRAY_BUFFER:
      return Float32Array;

    case _webgl.ELEMENT_ARRAY_BUFFER:
      return Uint32Array;

    default:
      return Float32Array;
  }
}

var _default = WebGLArrayBuffer;
exports.default = _default;
},{"../webgl.js":"node_modules/ol/webgl.js","../asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/webgl/ContextEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/webgl/ContextEventType
 */

/**
 * @enum {string}
 */
var _default = {
  LOST: 'webglcontextlost',
  RESTORED: 'webglcontextrestored'
};
exports.default = _default;
},{}],"node_modules/ol/vec/mat4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.fromTransform = fromTransform;

/**
 * @module ol/vec/mat4
 */

/**
 * @return {Array<number>} "4x4 matrix representing a 3D identity transform."
 */
function create() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
/**
 * @param {Array<number>} mat4 Flattened 4x4 matrix receiving the result.
 * @param {import("../transform.js").Transform} transform Transformation matrix.
 * @return {Array<number>} "2D transformation matrix as flattened 4x4 matrix."
 */


function fromTransform(mat4, transform) {
  mat4[0] = transform[0];
  mat4[1] = transform[1];
  mat4[4] = transform[2];
  mat4[5] = transform[3];
  mat4[12] = transform[4];
  mat4[13] = transform[5];
  return mat4;
}
},{}],"node_modules/ol/webgl/PostProcessingPass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/webgl/PostProcessingPass
 */
var DEFAULT_VERTEX_SHADER = "\n  precision mediump float;\n  \n  attribute vec2 a_position;\n  varying vec2 v_texCoord;\n  varying vec2 v_screenCoord;\n  \n  uniform vec2 u_screenSize;\n   \n  void main() {\n    v_texCoord = a_position * 0.5 + 0.5;\n    v_screenCoord = v_texCoord * u_screenSize;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n  }\n";
var DEFAULT_FRAGMENT_SHADER = "\n  precision mediump float;\n   \n  uniform sampler2D u_image;\n   \n  varying vec2 v_texCoord;\n   \n  void main() {\n    gl_FragColor = texture2D(u_image, v_texCoord);\n  }\n";
/**
 * @typedef {Object} Options
 * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas that will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object.<string,import("./Helper").UniformValue>} [uniforms] Uniform definitions for the post process step
 */

/**
 * @typedef {Object} UniformInternalDescription
 * @property {import("./Helper").UniformValue} value Value
 * @property {number} location Location
 * @property {WebGLTexture} [texture] Texture
 * @private
 */

/**
 * @classdesc
 * This class is used to define Post Processing passes with custom shaders and uniforms.
 * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.
 *
 * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that
 * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).
 * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.
 *
 * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be
 * premultiplied.
 *
 * Default shaders are shown hereafter:
 *
 * * Vertex shader:
 *
 *   ```
 *   precision mediump float;
 *
 *   attribute vec2 a_position;
 *   varying vec2 v_texCoord;
 *   varying vec2 v_screenCoord;
 *
 *   uniform vec2 u_screenSize;
 *
 *   void main() {
 *     v_texCoord = a_position * 0.5 + 0.5;
 *     v_screenCoord = v_texCoord * u_screenSize;
 *     gl_Position = vec4(a_position, 0.0, 1.0);
 *   }
 *   ```
 *
 * * Fragment shader:
 *
 *   ```
 *   precision mediump float;
 *
 *   uniform sampler2D u_image;
 *
 *   varying vec2 v_texCoord;
 *
 *   void main() {
 *     gl_FragColor = texture2D(u_image, v_texCoord);
 *   }
 *   ```
 *
 * @api
 */

var WebGLPostProcessingPass =
/** @class */
function () {
  /**
   * @param {Options} options Options.
   */
  function WebGLPostProcessingPass(options) {
    this.gl_ = options.webGlContext;
    var gl = this.gl_;
    this.scaleRatio_ = options.scaleRatio || 1;
    this.renderTargetTexture_ = gl.createTexture();
    this.renderTargetTextureSize_ = null;
    this.frameBuffer_ = gl.createFramebuffer(); // compile the program for the frame buffer
    // TODO: make compilation errors show up

    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);
    gl.compileShader(vertexShader);
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);
    gl.compileShader(fragmentShader);
    this.renderTargetProgram_ = gl.createProgram();
    gl.attachShader(this.renderTargetProgram_, vertexShader);
    gl.attachShader(this.renderTargetProgram_, fragmentShader);
    gl.linkProgram(this.renderTargetProgram_); // bind the vertices buffer for the frame buffer

    this.renderTargetVerticesBuffer_ = gl.createBuffer();
    var verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);
    this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, 'a_position');
    this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_screenSize');
    this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_image');
    /**
     * Holds info about custom uniforms used in the post processing pass
     * @type {Array<UniformInternalDescription>}
     * @private
     */

    this.uniforms_ = [];
    options.uniforms && Object.keys(options.uniforms).forEach(function (name) {
      this.uniforms_.push({
        value: options.uniforms[name],
        location: gl.getUniformLocation(this.renderTargetProgram_, name)
      });
    }.bind(this));
  }
  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   * @api
   */


  WebGLPostProcessingPass.prototype.getGL = function () {
    return this.gl_;
  };
  /**
   * Initialize the render target texture of the post process, make sure it is at the
   * right size and bind it as a render target for the next draw calls.
   * The last step to be initialized will be the one where the primitives are rendered.
   * @param {import("../PluggableMap.js").FrameState} frameState current frame state
   * @api
   */


  WebGLPostProcessingPass.prototype.init = function (frameState) {
    var gl = this.getGL();
    var textureSize = [gl.drawingBufferWidth * this.scaleRatio_, gl.drawingBufferHeight * this.scaleRatio_]; // rendering goes to my buffer

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());
    gl.viewport(0, 0, textureSize[0], textureSize[1]); // if size has changed: adjust canvas & render target texture

    if (!this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== textureSize[0] || this.renderTargetTextureSize_[1] !== textureSize[1]) {
      this.renderTargetTextureSize_ = textureSize; // create a new texture

      var level = 0;
      var internalFormat = gl.RGBA;
      var border = 0;
      var format = gl.RGBA;
      var type = gl.UNSIGNED_BYTE;
      var data = null;
      gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format, type, data);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); // bind the texture to the framebuffer

      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);
    }
  };
  /**
   * Render to the next postprocessing pass (or to the canvas if final pass).
   * @param {import("../PluggableMap.js").FrameState} frameState current frame state
   * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional
   * @api
   */


  WebGLPostProcessingPass.prototype.apply = function (frameState, nextPass) {
    var gl = this.getGL();
    var size = frameState.size;
    gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_); // render the frame buffer to the canvas

    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
    gl.useProgram(this.renderTargetProgram_);
    gl.enableVertexAttribArray(this.renderTargetAttribLocation_);
    gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);
    gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);
    gl.uniform1i(this.renderTargetTextureLocation_, 0);
    this.applyUniforms(frameState);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  };
  /**
   * @returns {WebGLFramebuffer} Frame buffer
   * @api
   */


  WebGLPostProcessingPass.prototype.getFrameBuffer = function () {
    return this.frameBuffer_;
  };
  /**
   * Sets the custom uniforms based on what was given in the constructor.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @private
   */


  WebGLPostProcessingPass.prototype.applyUniforms = function (frameState) {
    var gl = this.getGL();
    var value;
    var textureSlot = 1;
    this.uniforms_.forEach(function (uniform) {
      value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value; // apply value based on type

      if (value instanceof HTMLCanvasElement || value instanceof ImageData) {
        // create a texture & put data
        if (!uniform.texture) {
          uniform.texture = gl.createTexture();
        }

        gl.activeTexture(gl["TEXTURE" + textureSlot]);
        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        if (value instanceof ImageData) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
        } // fill texture slots


        gl.uniform1i(uniform.location, textureSlot++);
      } else if (Array.isArray(value)) {
        switch (value.length) {
          case 2:
            gl.uniform2f(uniform.location, value[0], value[1]);
            return;

          case 3:
            gl.uniform3f(uniform.location, value[0], value[1], value[2]);
            return;

          case 4:
            gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);
            return;

          default:
            return;
        }
      } else if (typeof value === 'number') {
        gl.uniform1f(uniform.location, value);
      }
    });
  };

  return WebGLPostProcessingPass;
}();

var _default = WebGLPostProcessingPass;
exports.default = _default;
},{}],"node_modules/ol/webgl/Helper.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.computeAttributesStride = computeAttributesStride;
exports.default = exports.AttributeType = exports.DefaultUniform = exports.ShaderType = void 0;

var _util = require("../util.js");

var _Disposable = _interopRequireDefault(require("../Disposable.js"));

var _obj = require("../obj.js");

var _ContextEventType = _interopRequireDefault(require("../webgl/ContextEventType.js"));

var _transform = require("../transform.js");

var _mat = require("../vec/mat4.js");

var _PostProcessingPass = _interopRequireDefault(require("./PostProcessingPass.js"));

var _webgl = require("../webgl.js");

var _array = require("../array.js");

var _asserts = require("../asserts.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/webgl/Helper
 */


/**
 * @typedef {Object} BufferCacheEntry
 * @property {import("./Buffer.js").default} buffer
 * @property {WebGLBuffer} webGlBuffer
 */

/**
 * Shader types, either `FRAGMENT_SHADER` or `VERTEX_SHADER`.
 * @enum {number}
 */
var ShaderType = {
  FRAGMENT_SHADER: 0x8B30,
  VERTEX_SHADER: 0x8B31
};
/**
 * Uniform names used in the default shaders: `PROJECTION_MATRIX`, `OFFSET_SCALE_MATRIX`.
 * and `OFFSET_ROTATION_MATRIX`.
 * @enum {string}
 */

exports.ShaderType = ShaderType;
var DefaultUniform = {
  PROJECTION_MATRIX: 'u_projectionMatrix',
  OFFSET_SCALE_MATRIX: 'u_offsetScaleMatrix',
  OFFSET_ROTATION_MATRIX: 'u_offsetRotateMatrix',
  TIME: 'u_time',
  ZOOM: 'u_zoom',
  RESOLUTION: 'u_resolution'
};
/**
 * Attribute types, either `UNSIGNED_BYTE`, `UNSIGNED_SHORT`, `UNSIGNED_INT` or `FLOAT`
 * Note: an attribute stored in a `Float32Array` should be of type `FLOAT`.
 * @enum {number}
 */

exports.DefaultUniform = DefaultUniform;
var AttributeType = {
  UNSIGNED_BYTE: _webgl.UNSIGNED_BYTE,
  UNSIGNED_SHORT: _webgl.UNSIGNED_SHORT,
  UNSIGNED_INT: _webgl.UNSIGNED_INT,
  FLOAT: _webgl.FLOAT
};
/**
 * Description of an attribute in a buffer
 * @typedef {Object} AttributeDescription
 * @property {string} name Attribute name to use in shaders
 * @property {number} size Number of components per attributes
 * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is
 * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).
 * Default is `FLOAT`.
 */

/**
 * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|import("../transform").Transform} UniformLiteralValue
 */

/**
 * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning
 * one of the previous types.
 * @typedef {UniformLiteralValue|function(import("../PluggableMap.js").FrameState):UniformLiteralValue} UniformValue
 */

/**
 * @typedef {Object} PostProcessesOptions
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas which will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object.<string,UniformValue>} [uniforms] Uniform definitions for the post process step
 */

/**
 * @typedef {Object} Options
 * @property {Object.<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform
 * names in the provided or default shaders.
 * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions
 */

/**
 * @typedef {Object} UniformInternalDescription
 * @property {string} name Name
 * @property {UniformValue=} value Value
 * @property {WebGLTexture} [texture] Texture
 * @private
 */

/**
 * @classdesc
 * This class is intended to provide low-level functions related to WebGL rendering, so that accessing
 * directly the WebGL API should not be required anymore.
 *
 * Several operations are handled by the `WebGLHelper` class:
 *
 * ### Define custom shaders and uniforms
 *
 *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:
 *
 *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).
 *   Outputs are:
 *
 *   * `gl_Position`: position of the vertex in screen space
 *
 *   * Varyings usually prefixed with `v_` are passed on to the fragment shader
 *
 *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.
 *
 *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that
 *   can be changed at every frame and can be of type float, arrays of float or images.
 *
 *   Shaders must be compiled and assembled into a program like so:
 *   ```js
 *   // here we simply create two shaders and assemble them in a program which is then used
 *   // for subsequent rendering calls
 *   const vertexShader = new WebGLVertex(VERTEX_SHADER);
 *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);
 *   const program = this.context.getProgram(fragmentShader, vertexShader);
 *   helper.useProgram(this.program);
 *   ```
 *
 *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.
 *   You can also change their value along the way like so:
 *   ```js
 *   helper.setUniformFloatValue('u_value', valueAsNumber);
 *   ```
 *
 * ### Defining post processing passes
 *
 *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas
 *   while applying special effects in screen space.
 *   Typical uses are: blurring, color manipulation, depth of field, filtering...
 *
 *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.
 *   A post process step accepts the following options:
 *
 *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.
 *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.
 *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.
 *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.
 *
 *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.
 *
 * ### Binding WebGL buffers and flushing data into them
 *
 *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.
 *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.
 *   This is done using {@link bindBuffer}.
 *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using
 *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.
 *
 *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}
 *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).
 *
 *   Examples below:
 *   ```js
 *   // at initialization phase
 *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);
 *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);
 *
 *   // when array values have changed
 *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);
 *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
 *
 *   // at rendering phase
 *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);
 *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
 *   ```
 *
 * ### Specifying attributes
 *
 *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).
 *   Attributes are used to specify these uses. Use {@link enableAttributeArray_} and either
 *   the default attribute names in {@link module:ol/webgl/Helper.DefaultAttrib} or custom ones.
 *
 *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.
 *   ```js
 *   // here we indicate that the data array has the following structure:
 *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]
 *   helper.enableAttributes([
 *     {
 *        name: 'a_position',
 *        size: 2
 *     },
 *     {
 *       name: 'a_offset',
 *       size: 2
 *     },
 *     {
 *       name: 'a_texCoord',
 *       size: 2
 *     }
 *   ])
 *   ```
 *
 * ### Rendering primitives
 *
 *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.
 *   ```js
 *   // frame preparation step
 *   helper.prepareDraw(frameState);
 *
 *   // call this for every data array that has to be rendered on screen
 *   helper.drawElements(0, this.indicesBuffer.getArray().length);
 *
 *   // finalize the rendering by applying post processes
 *   helper.finalizeDraw(frameState);
 *   ```
 *
 * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.
 *
 *
 * @api
 */

exports.AttributeType = AttributeType;

var WebGLHelper =
/** @class */
function (_super) {
  __extends(WebGLHelper, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function WebGLHelper(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options || {};
    /** @private */

    _this.boundHandleWebGLContextLost_ = _this.handleWebGLContextLost.bind(_this);
    /** @private */

    _this.boundHandleWebGLContextRestored_ = _this.handleWebGLContextRestored.bind(_this);
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.canvas_ = document.createElement('canvas');
    _this.canvas_.style.position = 'absolute';
    _this.canvas_.style.left = '0';
    /**
     * @private
     * @type {WebGLRenderingContext}
     */

    _this.gl_ = (0, _webgl.getContext)(_this.canvas_);

    var gl = _this.getGL();
    /**
     * @private
     * @type {!Object<string, BufferCacheEntry>}
     */


    _this.bufferCache_ = {};
    /**
     * @private
     * @type {WebGLProgram}
     */

    _this.currentProgram_ = null;
    (0, _asserts.assert)((0, _array.includes)((0, _webgl.getSupportedExtensions)(), 'OES_element_index_uint'), 63);
    gl.getExtension('OES_element_index_uint');

    _this.canvas_.addEventListener(_ContextEventType.default.LOST, _this.boundHandleWebGLContextLost_);

    _this.canvas_.addEventListener(_ContextEventType.default.RESTORED, _this.boundHandleWebGLContextRestored_);
    /**
     * @private
     * @type {import("../transform.js").Transform}
     */


    _this.offsetRotateMatrix_ = (0, _transform.create)();
    /**
     * @private
     * @type {import("../transform.js").Transform}
     */

    _this.offsetScaleMatrix_ = (0, _transform.create)();
    /**
     * @private
     * @type {Array<number>}
     */

    _this.tmpMat4_ = (0, _mat.create)();
    /**
     * @private
     * @type {Object.<string, WebGLUniformLocation>}
     */

    _this.uniformLocations_ = {};
    /**
     * @private
     * @type {Object.<string, number>}
     */

    _this.attribLocations_ = {};
    /**
     * Holds info about custom uniforms used in the post processing pass.
     * If the uniform is a texture, the WebGL Texture object will be stored here.
     * @type {Array<UniformInternalDescription>}
     * @private
     */

    _this.uniforms_ = [];

    if (options.uniforms) {
      for (var name_1 in options.uniforms) {
        _this.uniforms_.push({
          name: name_1,
          value: options.uniforms[name_1]
        });
      }
    }
    /**
     * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the
     * options. If no post process was given, a default one is used (so as not to have to make an exception to
     * the frame buffer logic).
     * @type {Array<WebGLPostProcessingPass>}
     * @private
     */


    _this.postProcessPasses_ = options.postProcesses ? options.postProcesses.map(function (options) {
      return new _PostProcessingPass.default({
        webGlContext: gl,
        scaleRatio: options.scaleRatio,
        vertexShader: options.vertexShader,
        fragmentShader: options.fragmentShader,
        uniforms: options.uniforms
      });
    }) : [new _PostProcessingPass.default({
      webGlContext: gl
    })];
    /**
     * @type {string|null}
     * @private
     */

    _this.shaderCompileErrors_ = null;
    /**
     * @type {number}
     * @private
     */

    _this.startTime_ = Date.now();
    return _this;
  }
  /**
   * Just bind the buffer if it's in the cache. Otherwise create
   * the WebGL buffer, bind it, populate it, and add an entry to
   * the cache.
   * @param {import("./Buffer").default} buffer Buffer.
   * @api
   */


  WebGLHelper.prototype.bindBuffer = function (buffer) {
    var gl = this.getGL();
    var bufferKey = (0, _util.getUid)(buffer);
    var bufferCache = this.bufferCache_[bufferKey];

    if (!bufferCache) {
      var webGlBuffer = gl.createBuffer();
      bufferCache = {
        buffer: buffer,
        webGlBuffer: webGlBuffer
      };
      this.bufferCache_[bufferKey] = bufferCache;
    }

    gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);
  };
  /**
   * Update the data contained in the buffer array; this is required for the
   * new data to be rendered
   * @param {import("./Buffer").default} buffer Buffer.
   * @api
   */


  WebGLHelper.prototype.flushBufferData = function (buffer) {
    var gl = this.getGL();
    this.bindBuffer(buffer);
    gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());
  };
  /**
   * @param {import("./Buffer.js").default} buf Buffer.
   */


  WebGLHelper.prototype.deleteBuffer = function (buf) {
    var gl = this.getGL();
    var bufferKey = (0, _util.getUid)(buf);
    var bufferCacheEntry = this.bufferCache_[bufferKey];

    if (!gl.isContextLost()) {
      gl.deleteBuffer(bufferCacheEntry.buffer);
    }

    delete this.bufferCache_[bufferKey];
  };
  /**
   * @inheritDoc
   */


  WebGLHelper.prototype.disposeInternal = function () {
    this.canvas_.removeEventListener(_ContextEventType.default.LOST, this.boundHandleWebGLContextLost_);
    this.canvas_.removeEventListener(_ContextEventType.default.RESTORED, this.boundHandleWebGLContextRestored_);
  };
  /**
   * Clear the buffer & set the viewport to draw.
   * Post process passes will be initialized here, the first one being bound as a render target for
   * subsequent draw calls.
   * @param {import("../PluggableMap.js").FrameState} frameState current frame state
   * @api
   */


  WebGLHelper.prototype.prepareDraw = function (frameState) {
    var gl = this.getGL();
    var canvas = this.getCanvas();
    var size = frameState.size;
    var pixelRatio = frameState.pixelRatio;
    canvas.width = size[0] * pixelRatio;
    canvas.height = size[1] * pixelRatio;
    canvas.style.width = size[0] + 'px';
    canvas.style.height = size[1] + 'px';
    gl.useProgram(this.currentProgram_); // loop backwards in post processes list

    for (var i = this.postProcessPasses_.length - 1; i >= 0; i--) {
      this.postProcessPasses_[i].init(frameState);
    }

    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.useProgram(this.currentProgram_);
    this.applyFrameState(frameState);
    this.applyUniforms(frameState);
  };
  /**
   * Clear the render target & bind it for future draw operations.
   * This is similar to `prepareDraw`, only post processes will not be applied.
   * Note: the whole viewport will be drawn to the render target, regardless of its size.
   * @param {import("../PluggableMap.js").FrameState} frameState current frame state
   * @param {import("./RenderTarget.js").default} renderTarget Render target to draw to
   * @param {boolean} [opt_disableAlphaBlend] If true, no alpha blending will happen.
   */


  WebGLHelper.prototype.prepareDrawToRenderTarget = function (frameState, renderTarget, opt_disableAlphaBlend) {
    var gl = this.getGL();
    var size = renderTarget.getSize();
    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());
    gl.viewport(0, 0, size[0], size[1]);
    gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());
    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
    gl.useProgram(this.currentProgram_);
    this.applyFrameState(frameState);
    this.applyUniforms(frameState);
  };
  /**
   * Execute a draw call based on the currently bound program, texture, buffers, attributes.
   * @param {number} start Start index.
   * @param {number} end End index.
   * @api
   */


  WebGLHelper.prototype.drawElements = function (start, end) {
    var gl = this.getGL();
    var elementType = gl.UNSIGNED_INT;
    var elementSize = 4;
    var numItems = end - start;
    var offsetInBytes = start * elementSize;
    gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);
  };
  /**
   * Apply the successive post process passes which will eventually render to the actual canvas.
   * @param {import("../PluggableMap.js").FrameState} frameState current frame state
   * @api
   */


  WebGLHelper.prototype.finalizeDraw = function (frameState) {
    // apply post processes using the next one as target
    for (var i = 0; i < this.postProcessPasses_.length; i++) {
      this.postProcessPasses_[i].apply(frameState, this.postProcessPasses_[i + 1] || null);
    }
  };
  /**
   * @return {HTMLCanvasElement} Canvas.
   * @api
   */


  WebGLHelper.prototype.getCanvas = function () {
    return this.canvas_;
  };
  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   * @api
   */


  WebGLHelper.prototype.getGL = function () {
    return this.gl_;
  };
  /**
   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @private
   */


  WebGLHelper.prototype.applyFrameState = function (frameState) {
    var size = frameState.size;
    var rotation = frameState.viewState.rotation;
    var offsetScaleMatrix = (0, _transform.reset)(this.offsetScaleMatrix_);
    (0, _transform.scale)(offsetScaleMatrix, 2 / size[0], 2 / size[1]);
    var offsetRotateMatrix = (0, _transform.reset)(this.offsetRotateMatrix_);

    if (rotation !== 0) {
      (0, _transform.rotate)(offsetRotateMatrix, -rotation);
    }

    this.setUniformMatrixValue(DefaultUniform.OFFSET_SCALE_MATRIX, (0, _mat.fromTransform)(this.tmpMat4_, offsetScaleMatrix));
    this.setUniformMatrixValue(DefaultUniform.OFFSET_ROTATION_MATRIX, (0, _mat.fromTransform)(this.tmpMat4_, offsetRotateMatrix));
    this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * 0.001);
    this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);
    this.setUniformFloatValue(DefaultUniform.RESOLUTION, frameState.viewState.resolution);
  };
  /**
   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @private
   */


  WebGLHelper.prototype.applyUniforms = function (frameState) {
    var gl = this.getGL();
    var value;
    var textureSlot = 0;
    this.uniforms_.forEach(function (uniform) {
      value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value; // apply value based on type

      if (value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof ImageData) {
        // create a texture & put data
        if (!uniform.texture) {
          uniform.prevValue = undefined;
          uniform.texture = gl.createTexture();
        }

        gl.activeTexture(gl["TEXTURE" + textureSlot]);
        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        var imageReady = !(value instanceof HTMLImageElement) ||
        /** @type {HTMLImageElement} */
        value.complete;

        if (imageReady && uniform.prevValue !== value) {
          uniform.prevValue = value;
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
        } // fill texture slots by increasing index


        gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);
      } else if (Array.isArray(value) && value.length === 6) {
        this.setUniformMatrixValue(uniform.name, (0, _mat.fromTransform)(this.tmpMat4_, value));
      } else if (Array.isArray(value) && value.length <= 4) {
        switch (value.length) {
          case 2:
            gl.uniform2f(this.getUniformLocation(uniform.name), value[0], value[1]);
            return;

          case 3:
            gl.uniform3f(this.getUniformLocation(uniform.name), value[0], value[1], value[2]);
            return;

          case 4:
            gl.uniform4f(this.getUniformLocation(uniform.name), value[0], value[1], value[2], value[3]);
            return;

          default:
            return;
        }
      } else if (typeof value === 'number') {
        gl.uniform1f(this.getUniformLocation(uniform.name), value);
      }
    }.bind(this));
  };
  /**
   * Use a program.  If the program is already in use, this will return `false`.
   * @param {WebGLProgram} program Program.
   * @return {boolean} Changed.
   * @api
   */


  WebGLHelper.prototype.useProgram = function (program) {
    if (program == this.currentProgram_) {
      return false;
    } else {
      var gl = this.getGL();
      gl.useProgram(program);
      this.currentProgram_ = program;
      this.uniformLocations_ = {};
      this.attribLocations_ = {};
      return true;
    }
  };
  /**
   * Will attempt to compile a vertex or fragment shader based on source
   * On error, the shader will be returned but
   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`
   * Use `gl.getShaderInfoLog(shader)` to have details
   * @param {string} source Shader source
   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER
   * @return {WebGLShader} Shader object
   */


  WebGLHelper.prototype.compileShader = function (source, type) {
    var gl = this.getGL();
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
  };
  /**
   * Create a program for a vertex and fragment shader. The shaders compilation may have failed:
   * use `WebGLHelper.getShaderCompileErrors()`to have details if any.
   * @param {string} fragmentShaderSource Fragment shader source.
   * @param {string} vertexShaderSource Vertex shader source.
   * @return {WebGLProgram} Program
   * @api
   */


  WebGLHelper.prototype.getProgram = function (fragmentShaderSource, vertexShaderSource) {
    var gl = this.getGL();
    var fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
    var vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);
    this.shaderCompileErrors_ = null;

    if (gl.getShaderInfoLog(fragmentShader)) {
      this.shaderCompileErrors_ = "Fragment shader compilation failed:\n" + gl.getShaderInfoLog(fragmentShader);
    }

    if (gl.getShaderInfoLog(vertexShader)) {
      this.shaderCompileErrors_ = (this.shaderCompileErrors_ || '') + ("Vertex shader compilation failed:\n" + gl.getShaderInfoLog(vertexShader));
    }

    var program = gl.createProgram();
    gl.attachShader(program, fragmentShader);
    gl.attachShader(program, vertexShader);
    gl.linkProgram(program);
    return program;
  };
  /**
   * Will return the last shader compilation errors. If no error happened, will return null;
   * @return {string|null} Errors description, or null if last compilation was successful
   * @api
   */


  WebGLHelper.prototype.getShaderCompileErrors = function () {
    return this.shaderCompileErrors_;
  };
  /**
   * Will get the location from the shader or the cache
   * @param {string} name Uniform name
   * @return {WebGLUniformLocation} uniformLocation
   * @api
   */


  WebGLHelper.prototype.getUniformLocation = function (name) {
    if (this.uniformLocations_[name] === undefined) {
      this.uniformLocations_[name] = this.getGL().getUniformLocation(this.currentProgram_, name);
    }

    return this.uniformLocations_[name];
  };
  /**
   * Will get the location from the shader or the cache
   * @param {string} name Attribute name
   * @return {number} attribLocation
   * @api
   */


  WebGLHelper.prototype.getAttributeLocation = function (name) {
    if (this.attribLocations_[name] === undefined) {
      this.attribLocations_[name] = this.getGL().getAttribLocation(this.currentProgram_, name);
    }

    return this.attribLocations_[name];
  };
  /**
   * Modifies the given transform to apply the rotation/translation/scaling of the given frame state.
   * The resulting transform can be used to convert world space coordinates to view coordinates.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../transform").Transform} transform Transform to update.
   * @return {import("../transform").Transform} The updated transform object.
   * @api
   */


  WebGLHelper.prototype.makeProjectionTransform = function (frameState, transform) {
    var size = frameState.size;
    var rotation = frameState.viewState.rotation;
    var resolution = frameState.viewState.resolution;
    var center = frameState.viewState.center;
    (0, _transform.reset)(transform);
    (0, _transform.compose)(transform, 0, 0, 2 / (resolution * size[0]), 2 / (resolution * size[1]), -rotation, -center[0], -center[1]);
    return transform;
  };
  /**
   * Give a value for a standard float uniform
   * @param {string} uniform Uniform name
   * @param {number} value Value
   * @api
   */


  WebGLHelper.prototype.setUniformFloatValue = function (uniform, value) {
    this.getGL().uniform1f(this.getUniformLocation(uniform), value);
  };
  /**
   * Give a value for a standard matrix4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Matrix value
   * @api
   */


  WebGLHelper.prototype.setUniformMatrixValue = function (uniform, value) {
    this.getGL().uniformMatrix4fv(this.getUniformLocation(uniform), false, value);
  };
  /**
   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`
   * internally.
   * @param {string} attribName Attribute name
   * @param {number} size Number of components per attributes
   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT
   * @param {number} stride Stride in bytes (0 means attribs are packed)
   * @param {number} offset Offset in bytes
   * @private
   */


  WebGLHelper.prototype.enableAttributeArray_ = function (attribName, size, type, stride, offset) {
    var location = this.getAttributeLocation(attribName); // the attribute has not been found in the shaders; do not enable it

    if (location < 0) {
      return;
    }

    this.getGL().enableVertexAttribArray(location);
    this.getGL().vertexAttribPointer(location, size, type, false, stride, offset);
  };
  /**
   * Will enable the following attributes to be read from the currently bound buffer,
   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the
   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.
   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer
   * @api
   */


  WebGLHelper.prototype.enableAttributes = function (attributes) {
    var stride = computeAttributesStride(attributes);
    var offset = 0;

    for (var i = 0; i < attributes.length; i++) {
      var attr = attributes[i];
      this.enableAttributeArray_(attr.name, attr.size, attr.type || _webgl.FLOAT, stride, offset);
      offset += attr.size * getByteSizeFromType(attr.type);
    }
  };
  /**
   * WebGL context was lost
   * @private
   */


  WebGLHelper.prototype.handleWebGLContextLost = function () {
    (0, _obj.clear)(this.bufferCache_);
    this.currentProgram_ = null;
  };
  /**
   * WebGL context was restored
   * @private
   */


  WebGLHelper.prototype.handleWebGLContextRestored = function () {};
  /**
   * Will create or reuse a given webgl texture and apply the given size. If no image data
   * specified, the texture will be empty, otherwise image data will be used and the `size`
   * parameter will be ignored.
   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.
   * @param {Array<number>} size Expected size of the texture
   * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [opt_data] Image data/object to bind to the texture
   * @param {WebGLTexture} [opt_texture] Existing texture to reuse
   * @return {WebGLTexture} The generated texture
   * @api
   */


  WebGLHelper.prototype.createTexture = function (size, opt_data, opt_texture) {
    var gl = this.getGL();
    var texture = opt_texture || gl.createTexture(); // set params & size

    var level = 0;
    var internalFormat = gl.RGBA;
    var border = 0;
    var format = gl.RGBA;
    var type = gl.UNSIGNED_BYTE;
    gl.bindTexture(gl.TEXTURE_2D, texture);

    if (opt_data) {
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, opt_data);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, size[0], size[1], border, format, type, null);
    }

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    return texture;
  };

  return WebGLHelper;
}(_Disposable.default);
/**
 * Compute a stride in bytes based on a list of attributes
 * @param {Array<AttributeDescription>} attributes Ordered list of attributes
 * @returns {number} Stride, ie amount of values for each vertex in the vertex buffer
 * @api
 */


function computeAttributesStride(attributes) {
  var stride = 0;

  for (var i = 0; i < attributes.length; i++) {
    var attr = attributes[i];
    stride += attr.size * getByteSizeFromType(attr.type);
  }

  return stride;
}
/**
 * Computes the size in byte of an attribute type.
 * @param {AttributeType} type Attribute type
 * @returns {number} The size in bytes
 */


function getByteSizeFromType(type) {
  switch (type) {
    case AttributeType.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;

    case AttributeType.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;

    case AttributeType.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;

    case AttributeType.FLOAT:
    default:
      return Float32Array.BYTES_PER_ELEMENT;
  }
}

var _default = WebGLHelper;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","../Disposable.js":"node_modules/ol/Disposable.js","../obj.js":"node_modules/ol/obj.js","../webgl/ContextEventType.js":"node_modules/ol/webgl/ContextEventType.js","../transform.js":"node_modules/ol/transform.js","../vec/mat4.js":"node_modules/ol/vec/mat4.js","./PostProcessingPass.js":"node_modules/ol/webgl/PostProcessingPass.js","../webgl.js":"node_modules/ol/webgl.js","../array.js":"node_modules/ol/array.js","../asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/renderer/webgl/Layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.writePointFeatureToBuffers = writePointFeatureToBuffers;
exports.getBlankImageData = getBlankImageData;
exports.colorEncodeId = colorEncodeId;
exports.colorDecodeId = colorDecodeId;
exports.default = exports.WebGLWorkerMessageType = void 0;

var _Layer = _interopRequireDefault(require("../Layer.js"));

var _Helper = _interopRequireDefault(require("../../webgl/Helper.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/webgl/Layer
 */


/**
 * @enum {string}
 */
var WebGLWorkerMessageType = {
  GENERATE_BUFFERS: 'GENERATE_BUFFERS'
};
/**
 * @typedef {Object} WebGLWorkerGenerateBuffersMessage
 * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.
 * When the buffers are generated, the worked will send a message of the same type to the main thread, with
 * the generated buffers in it.
 * Note that any addition properties present in the message *will* be sent back to the main thread.
 * @property {WebGLWorkerMessageType} type Message type
 * @property {ArrayBuffer} renderInstructions Render instructions raw binary buffer.
 * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).
 * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).
 * @property {number} [customAttributesCount] Amount of custom attributes count in the render instructions.
 */

/**
 * @typedef {Object} PostProcessesOptions
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas that will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object.<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process step
 */

/**
 * @typedef {Object} Options
 * @property {Object.<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process steps
 * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions
 */

/**
 * @classdesc
 * Base WebGL renderer class.
 * Holds all logic related to data manipulation & some common rendering logic
 * @template {import("../../layer/Layer.js").default} LayerType
 */

exports.WebGLWorkerMessageType = WebGLWorkerMessageType;

var WebGLLayerRenderer =
/** @class */
function (_super) {
  __extends(WebGLLayerRenderer, _super);
  /**
   * @param {LayerType} layer Layer.
   * @param {Options=} [opt_options] Options.
   */


  function WebGLLayerRenderer(layer, opt_options) {
    var _this = _super.call(this, layer) || this;

    var options = opt_options || {};
    /**
     * @type {WebGLHelper}
     * @protected
     */

    _this.helper = new _Helper.default({
      postProcesses: options.postProcesses,
      uniforms: options.uniforms
    });
    return _this;
  }
  /**
   * @inheritDoc
   */


  WebGLLayerRenderer.prototype.disposeInternal = function () {
    this.helper.dispose();

    _super.prototype.disposeInternal.call(this);
  };
  /**
   * Will return the last shader compilation errors. If no error happened, will return null;
   * @return {string|null} Errors, or null if last compilation was successful
   * @api
   */


  WebGLLayerRenderer.prototype.getShaderCompileErrors = function () {
    return this.helper.getShaderCompileErrors();
  };

  return WebGLLayerRenderer;
}(_Layer.default);

var tmpArray_ = [];
var bufferPositions_ = {
  vertexPosition: 0,
  indexPosition: 0
};

function writePointVertex(buffer, pos, x, y, index) {
  buffer[pos + 0] = x;
  buffer[pos + 1] = y;
  buffer[pos + 2] = index;
}
/**
 * An object holding positions both in an index and a vertex buffer.
 * @typedef {Object} BufferPositions
 * @property {number} vertexPosition Position in the vertex buffer
 * @property {number} indexPosition Position in the index buffer
 */

/**
 * Pushes a quad (two triangles) based on a point geometry
 * @param {Float32Array} instructions Array of render instructions for points.
 * @param {number} elementIndex Index from which render instructions will be read.
 * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.
 * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.
 * @param {number} customAttributesCount Amount of custom attributes for each element.
 * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.
 * @return {BufferPositions} New buffer positions where to write next
 * @property {number} vertexPosition New position in the vertex buffer where future writes should start.
 * @property {number} indexPosition New position in the index buffer where future writes should start.
 * @private
 */


function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {
  // This is for x, y and index
  var baseVertexAttrsCount = 3;
  var baseInstructionsCount = 2;
  var stride = baseVertexAttrsCount + customAttributesCount;
  var x = instructions[elementIndex + 0];
  var y = instructions[elementIndex + 1]; // read custom numerical attributes on the feature

  var customAttrs = tmpArray_;
  customAttrs.length = customAttributesCount;

  for (var i = 0; i < customAttrs.length; i++) {
    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];
  }

  var vPos = bufferPositions ? bufferPositions.vertexPosition : 0;
  var iPos = bufferPositions ? bufferPositions.indexPosition : 0;
  var baseIndex = vPos / stride; // push vertices for each of the four quad corners (first standard then custom attributes)

  writePointVertex(vertexBuffer, vPos, x, y, 0);
  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;
  writePointVertex(vertexBuffer, vPos, x, y, 1);
  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;
  writePointVertex(vertexBuffer, vPos, x, y, 2);
  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;
  writePointVertex(vertexBuffer, vPos, x, y, 3);
  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
  vPos += stride;
  indexBuffer[iPos++] = baseIndex;
  indexBuffer[iPos++] = baseIndex + 1;
  indexBuffer[iPos++] = baseIndex + 3;
  indexBuffer[iPos++] = baseIndex + 1;
  indexBuffer[iPos++] = baseIndex + 2;
  indexBuffer[iPos++] = baseIndex + 3;
  bufferPositions_.vertexPosition = vPos;
  bufferPositions_.indexPosition = iPos;
  return bufferPositions_;
}
/**
 * Returns a texture of 1x1 pixel, white
 * @private
 * @return {ImageData} Image data.
 */


function getBlankImageData() {
  var canvas = document.createElement('canvas');
  var image = canvas.getContext('2d').createImageData(1, 1);
  image.data[0] = 255;
  image.data[1] = 255;
  image.data[2] = 255;
  image.data[3] = 255;
  return image;
}
/**
 * Generates a color array based on a numerical id
 * Note: the range for each component is 0 to 1 with 256 steps
 * @param {number} id Id
 * @param {Array<number>} [opt_array] Reusable array
 * @return {Array<number>} Color array containing the encoded id
 */


function colorEncodeId(id, opt_array) {
  var array = opt_array || [];
  var radix = 256;
  var divide = radix - 1;
  array[0] = Math.floor(id / radix / radix / radix) / divide;
  array[1] = Math.floor(id / radix / radix) % radix / divide;
  array[2] = Math.floor(id / radix) % radix / divide;
  array[3] = id % radix / divide;
  return array;
}
/**
 * Reads an id from a color-encoded array
 * Note: the expected range for each component is 0 to 1 with 256 steps.
 * @param {Array<number>} color Color array containing the encoded id
 * @return {number} Decoded id
 */


function colorDecodeId(color) {
  var id = 0;
  var radix = 256;
  var mult = radix - 1;
  id += Math.round(color[0] * radix * radix * radix * mult);
  id += Math.round(color[1] * radix * radix * mult);
  id += Math.round(color[2] * radix * mult);
  id += Math.round(color[3] * mult);
  return id;
}

var _default = WebGLLayerRenderer;
exports.default = _default;
},{"../Layer.js":"node_modules/ol/renderer/Layer.js","../../webgl/Helper.js":"node_modules/ol/webgl/Helper.js"}],"node_modules/ol/worker/webgl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
var source = "var e=\"function\"==typeof Object.assign?Object.assign:function(e,n){if(null==e)throw new TypeError(\"Cannot convert undefined or null to object\");for(var t=Object(e),r=1,o=arguments.length;r<o;++r){var i=arguments[r];if(null!=i)for(var f in i)i.hasOwnProperty(f)&&(t[f]=i[f])}return t},n=\"GENERATE_BUFFERS\",t=[],r={vertexPosition:0,indexPosition:0};function o(e,n,t,r,o){e[n+0]=t,e[n+1]=r,e[n+2]=o}function i(e,n,i,f,s,u){var a=3+s,l=e[n+0],v=e[n+1],c=t;c.length=s;for(var g=0;g<c.length;g++)c[g]=e[n+2+g];var b=u?u.vertexPosition:0,h=u?u.indexPosition:0,d=b/a;return o(i,b,l,v,0),c.length&&i.set(c,b+3),o(i,b+=a,l,v,1),c.length&&i.set(c,b+3),o(i,b+=a,l,v,2),c.length&&i.set(c,b+3),o(i,b+=a,l,v,3),c.length&&i.set(c,b+3),b+=a,f[h++]=d,f[h++]=d+1,f[h++]=d+3,f[h++]=d+1,f[h++]=d+2,f[h++]=d+3,r.vertexPosition=b,r.indexPosition=h,r}var f=self;f.onmessage=function(t){var r=t.data;if(r.type===n){for(var o=r.customAttributesCount,s=2+o,u=new Float32Array(r.renderInstructions),a=u.length/s,l=4*a*(o+3),v=new Uint32Array(6*a),c=new Float32Array(l),g=null,b=0;b<u.length;b+=s)g=i(u,b,c,v,o,g);var h=e({vertexBuffer:c.buffer,indexBuffer:v.buffer,renderInstructions:u.buffer},r);f.postMessage(h,[c.buffer,v.buffer,u.buffer])}};";
var blob = new Blob([source], {
  type: 'application/javascript'
});
var url = URL.createObjectURL(blob);

function create() {
  return new Worker(url);
}
},{}],"node_modules/ol/webgl/RenderTarget.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _array = require("../array.js");

/**
 * A wrapper class to simplify rendering to a texture instead of the final canvas
 * @module ol/webgl/RenderTarget
 */
// for pixel color reading
var tmpArray4 = new Uint8Array(4);
/**
 * @classdesc
 * This class is a wrapper around the association of both a `WebGLTexture` and a `WebGLFramebuffer` instances,
 * simplifying initialization and binding for rendering.
 * @api
 */

var WebGLRenderTarget =
/** @class */
function () {
  /**
   * @param {import("./Helper.js").default} helper WebGL helper; mandatory.
   * @param {Array<number>} [opt_size] Expected size of the render target texture; note: this can be changed later on.
   */
  function WebGLRenderTarget(helper, opt_size) {
    /**
     * @private
     * @type {import("./Helper.js").default}
     */
    this.helper_ = helper;
    var gl = helper.getGL();
    /**
     * @private
     * @type {WebGLTexture}
     */

    this.texture_ = gl.createTexture();
    /**
     * @private
     * @type {WebGLFramebuffer}
     */

    this.framebuffer_ = gl.createFramebuffer();
    /**
     * @type {Array<number>}
     * @private
     */

    this.size_ = opt_size || [1, 1];
    /**
     * @type {Uint8Array}
     * @private
     */

    this.data_ = new Uint8Array(0);
    /**
     * @type {boolean}
     * @private
     */

    this.dataCacheDirty_ = true;
    this.updateSize_();
  }
  /**
   * Changes the size of the render target texture. Note: will do nothing if the size
   * is already the same.
   * @param {Array<number>} size Expected size of the render target texture
   * @api
   */


  WebGLRenderTarget.prototype.setSize = function (size) {
    if ((0, _array.equals)(size, this.size_)) {
      return;
    }

    this.size_[0] = size[0];
    this.size_[1] = size[1];
    this.updateSize_();
  };
  /**
   * Returns the size of the render target texture
   * @return {Array<number>} Size of the render target texture
   * @api
   */


  WebGLRenderTarget.prototype.getSize = function () {
    return this.size_;
  };
  /**
   * This will cause following calls to `#readAll` or `#readPixel` to download the content of the
   * render target into memory, which is an expensive operation.
   * This content will be kept in cache but should be cleared after each new render.
   * @api
   */


  WebGLRenderTarget.prototype.clearCachedData = function () {
    this.dataCacheDirty_ = true;
  };
  /**
   * Returns the full content of the frame buffer as a series of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * @return {Uint8Array} Integer array of color values
   * @api
   */


  WebGLRenderTarget.prototype.readAll = function () {
    if (this.dataCacheDirty_) {
      var size = this.size_;
      var gl = this.helper_.getGL();
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);
      gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.UNSIGNED_BYTE, this.data_);
      this.dataCacheDirty_ = false;
    }

    return this.data_;
  };
  /**
   * Reads one pixel of the frame buffer as an array of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * If x and/or y are outside of existing data, an array filled with 0 is returned.
   * @param {number} x Pixel coordinate
   * @param {number} y Pixel coordinate
   * @returns {Uint8Array} Integer array with one color value (4 components)
   * @api
   */


  WebGLRenderTarget.prototype.readPixel = function (x, y) {
    if (x < 0 || y < 0 || x > this.size_[0] || y >= this.size_[1]) {
      tmpArray4[0] = 0;
      tmpArray4[1] = 0;
      tmpArray4[2] = 0;
      tmpArray4[3] = 0;
      return tmpArray4;
    }

    this.readAll();
    var index = Math.floor(x) + (this.size_[1] - Math.floor(y) - 1) * this.size_[0];
    tmpArray4[0] = this.data_[index * 4];
    tmpArray4[1] = this.data_[index * 4 + 1];
    tmpArray4[2] = this.data_[index * 4 + 2];
    tmpArray4[3] = this.data_[index * 4 + 3];
    return tmpArray4;
  };
  /**
   * @return {WebGLTexture} Texture to render to
   */


  WebGLRenderTarget.prototype.getTexture = function () {
    return this.texture_;
  };
  /**
   * @return {WebGLFramebuffer} Frame buffer of the render target
   */


  WebGLRenderTarget.prototype.getFramebuffer = function () {
    return this.framebuffer_;
  };
  /**
   * @private
   */


  WebGLRenderTarget.prototype.updateSize_ = function () {
    var size = this.size_;
    var gl = this.helper_.getGL();
    this.texture_ = this.helper_.createTexture(size, null, this.texture_);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);
    gl.viewport(0, 0, size[0], size[1]);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture_, 0);
    this.data_ = new Uint8Array(size[0] * size[1] * 4);
  };

  return WebGLRenderTarget;
}();

var _default = WebGLRenderTarget;
exports.default = _default;
},{"../array.js":"node_modules/ol/array.js"}],"node_modules/ol/renderer/webgl/PointsLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Buffer = _interopRequireDefault(require("../../webgl/Buffer.js"));

var _webgl = require("../../webgl.js");

var _Helper = require("../../webgl/Helper.js");

var _GeometryType = _interopRequireDefault(require("../../geom/GeometryType.js"));

var _Layer = _interopRequireWildcard(require("./Layer.js"));

var _ViewHint = _interopRequireDefault(require("../../ViewHint.js"));

var _extent = require("../../extent.js");

var _transform = require("../../transform.js");

var _webgl2 = require("../../worker/webgl.js");

var _util = require("../../util.js");

var _RenderTarget = _interopRequireDefault(require("../../webgl/RenderTarget.js"));

var _asserts = require("../../asserts.js");

var _BaseVector = _interopRequireDefault(require("../../layer/BaseVector.js"));

var _events = require("../../events.js");

var _VectorEventType = _interopRequireDefault(require("../../source/VectorEventType.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/webgl/PointsLayer
 */


/**
 * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different
 * for each feature.
 * @property {string} name Attribute name.
 * @property {function(import("../../Feature").default, Object<string, *>):number} callback This callback computes the numerical value of the
 * attribute for a given feature (properties are available as 2nd arg for quicker access).
 */

/**
 * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize
 * rebuildBuffers by accessing these objects quicker.
 * @property {import("../../Feature").default} feature Feature
 * @property {Object<string, *>} properties Feature properties
 * @property {import("../../geom").Geometry} geometry Feature geometry
 */

/**
 * @typedef {Object} Options
 * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then
 * passed to the GPU. The `name` property of each attribute will serve as its identifier:
 *  * In the vertex shader as an `attribute` by prefixing it with `a_`
 *  * In the fragment shader as a `varying` by prefixing it with `v_`
 * Please note that these can only be numerical values.
 * @property {string} vertexShader Vertex shader source, mandatory.
 * @property {string} fragmentShader Fragment shader source, mandatory.
 * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.
 * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.
 * @property {Object.<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process steps
 * Please note that `u_texture` is reserved for the main texture slot.
 * @property {Array<import("./Layer").PostProcessesOptions>} [postProcesses] Post-processes definitions
 */

/**
 * @classdesc
 * WebGL vector renderer optimized for points.
 * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU
 * every time the vector source changes.
 *
 * You need to provide vertex and fragment shaders for rendering. This can be done using
 * {@link module:ol/webgl/ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute
 * containing the screen-space projected center of the quad, as well as a `a_index` attribute
 * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).
 *
 * To include variable attributes in the shaders, you need to declare them using the `attributes` property of
 * the options object like so:
 * ```js
 * new WebGLPointsLayerRenderer(layer, {
 *   attributes: [
 *     {
 *       name: 'size',
 *       callback: function(feature) {
 *         // compute something with the feature
 *       }
 *     },
 *     {
 *       name: 'weight',
 *       callback: function(feature) {
 *         // compute something with the feature
 *       }
 *     },
 *   ],
 *   vertexShader:
 *     // shader using attribute a_weight and a_size
 *   fragmentShader:
 *     // shader using varying v_weight and v_size
 * ```
 *
 * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`
 * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain
 * the final color that will have to be output for hit detection to work.
 *
 * The following uniform is used for the main texture: `u_texture`.
 *
 * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.
 *
 * Points are rendered as quads with the following structure:
 *
 * ```
 *   (u0, v1)      (u1, v1)
 *  [3]----------[2]
 *   |`           |
 *   |  `         |
 *   |    `       |
 *   |      `     |
 *   |        `   |
 *   |          ` |
 *  [0]----------[1]
 *   (u0, v0)      (u1, v0)
 *  ```
 *
 * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.
 *
 * @api
 */
var WebGLPointsLayerRenderer =
/** @class */
function (_super) {
  __extends(WebGLPointsLayerRenderer, _super);
  /**
   * @param {import("../../layer/Layer.js").default} layer Layer.
   * @param {Options} options Options.
   */


  function WebGLPointsLayerRenderer(layer, options) {
    var _this = this;

    var uniforms = options.uniforms || {};
    var projectionMatrixTransform = (0, _transform.create)();
    uniforms[_Helper.DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;
    _this = _super.call(this, layer, {
      uniforms: uniforms,
      postProcesses: options.postProcesses
    }) || this;
    _this.sourceRevision_ = -1;
    _this.verticesBuffer_ = new _Buffer.default(_webgl.ARRAY_BUFFER, _webgl.DYNAMIC_DRAW);
    _this.hitVerticesBuffer_ = new _Buffer.default(_webgl.ARRAY_BUFFER, _webgl.DYNAMIC_DRAW);
    _this.indicesBuffer_ = new _Buffer.default(_webgl.ELEMENT_ARRAY_BUFFER, _webgl.DYNAMIC_DRAW);
    _this.program_ = _this.helper.getProgram(options.fragmentShader, options.vertexShader);
    /**
     * @type {boolean}
     * @private
     */

    _this.hitDetectionEnabled_ = options.hitFragmentShader && options.hitVertexShader ? true : false;
    _this.hitProgram_ = _this.hitDetectionEnabled_ && _this.helper.getProgram(options.hitFragmentShader, options.hitVertexShader);
    var customAttributes = options.attributes ? options.attributes.map(function (attribute) {
      return {
        name: 'a_' + attribute.name,
        size: 1,
        type: _Helper.AttributeType.FLOAT
      };
    }) : [];
    /**
     * A list of attributes used by the renderer. By default only the position and
     * index of the vertex (0 to 3) are required.
     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}
     */

    _this.attributes = [{
      name: 'a_position',
      size: 2,
      type: _Helper.AttributeType.FLOAT
    }, {
      name: 'a_index',
      size: 1,
      type: _Helper.AttributeType.FLOAT
    }].concat(customAttributes);
    /**
     * A list of attributes used for hit detection.
     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}
     */

    _this.hitDetectionAttributes = [{
      name: 'a_position',
      size: 2,
      type: _Helper.AttributeType.FLOAT
    }, {
      name: 'a_index',
      size: 1,
      type: _Helper.AttributeType.FLOAT
    }, {
      name: 'a_hitColor',
      size: 4,
      type: _Helper.AttributeType.FLOAT
    }, {
      name: 'a_featureUid',
      size: 1,
      type: _Helper.AttributeType.FLOAT
    }].concat(customAttributes);
    _this.customAttributes = options.attributes ? options.attributes : [];
    _this.previousExtent_ = (0, _extent.createEmpty)();
    /**
     * This transform is updated on every frame and is the composition of:
     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)
     * - current world->screen transform
     * @type {import("../../transform.js").Transform}
     * @private
     */

    _this.currentTransform_ = projectionMatrixTransform;
    /**
     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space
     * @type {import("../../transform.js").Transform}
     * @private
     */

    _this.renderTransform_ = (0, _transform.create)();
    /**
     * @type {import("../../transform.js").Transform}
     * @private
     */

    _this.invertRenderTransform_ = (0, _transform.create)();
    /**
     * @type {Float32Array}
     * @private
     */

    _this.renderInstructions_ = new Float32Array(0);
    /**
     * These instructions are used for hit detection
     * @type {Float32Array}
     * @private
     */

    _this.hitRenderInstructions_ = new Float32Array(0);
    /**
     * @type {WebGLRenderTarget}
     * @private
     */

    _this.hitRenderTarget_ = _this.hitDetectionEnabled_ && new _RenderTarget.default(_this.helper);
    _this.worker_ = (0, _webgl2.create)();

    _this.worker_.addEventListener('message', function (event) {
      var received = event.data;

      if (received.type === _Layer.WebGLWorkerMessageType.GENERATE_BUFFERS) {
        var projectionTransform = received.projectionTransform;

        if (received.hitDetection) {
          this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);
          this.helper.flushBufferData(this.hitVerticesBuffer_);
        } else {
          this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);
          this.helper.flushBufferData(this.verticesBuffer_);
        }

        this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);
        this.helper.flushBufferData(this.indicesBuffer_);
        this.renderTransform_ = projectionTransform;
        (0, _transform.makeInverse)(this.invertRenderTransform_, this.renderTransform_);

        if (received.hitDetection) {
          this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);
        } else {
          this.renderInstructions_ = new Float32Array(event.data.renderInstructions);
        }

        this.getLayer().changed();
      }
    }.bind(_this));
    /**
     * This object will be updated when the source changes. Key is uid.
     * @type {Object<string, FeatureCacheItem>}
     * @private
     */


    _this.featureCache_ = {};
    /**
     * Amount of features in the cache.
     * @type {number}
     * @private
     */

    _this.featureCount_ = 0;

    var source = _this.getLayer().getSource();

    _this.sourceListenKeys_ = [(0, _events.listen)(source, _VectorEventType.default.ADDFEATURE, _this.handleSourceFeatureAdded_, _this), (0, _events.listen)(source, _VectorEventType.default.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this), (0, _events.listen)(source, _VectorEventType.default.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this), (0, _events.listen)(source, _VectorEventType.default.CLEAR, _this.handleSourceFeatureClear_, _this)];
    source.forEachFeature(function (feature) {
      this.featureCache_[(0, _util.getUid)(feature)] = {
        feature: feature,
        properties: feature.getProperties(),
        geometry: feature.getGeometry()
      };
      this.featureCount_++;
    }.bind(_this));
    return _this;
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */


  WebGLPointsLayerRenderer.prototype.handleSourceFeatureAdded_ = function (event) {
    var feature = event.feature;
    this.featureCache_[(0, _util.getUid)(feature)] = {
      feature: feature,
      properties: feature.getProperties(),
      geometry: feature.getGeometry()
    };
    this.featureCount_++;
  };
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */


  WebGLPointsLayerRenderer.prototype.handleSourceFeatureChanged_ = function (event) {
    var feature = event.feature;
    this.featureCache_[(0, _util.getUid)(feature)] = {
      feature: feature,
      properties: feature.getProperties(),
      geometry: feature.getGeometry()
    };
  };
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */


  WebGLPointsLayerRenderer.prototype.handleSourceFeatureDelete_ = function (event) {
    var feature = event.feature;
    delete this.featureCache_[(0, _util.getUid)(feature)];
    this.featureCount_--;
  };
  /**
   * @private
   */


  WebGLPointsLayerRenderer.prototype.handleSourceFeatureClear_ = function () {
    this.featureCache_ = {};
    this.featureCount_ = 0;
  };
  /**
   * @inheritDoc
   */


  WebGLPointsLayerRenderer.prototype.renderFrame = function (frameState) {
    var renderCount = this.indicesBuffer_.getSize();
    this.helper.drawElements(0, renderCount);
    this.helper.finalizeDraw(frameState);
    var canvas = this.helper.getCanvas();
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var opacity = layerState.opacity;

    if (opacity !== parseFloat(canvas.style.opacity)) {
      canvas.style.opacity = opacity;
    }

    if (this.hitDetectionEnabled_) {
      this.renderHitDetection(frameState);
      this.hitRenderTarget_.clearCachedData();
    }

    return canvas;
  };
  /**
   * @inheritDoc
   */


  WebGLPointsLayerRenderer.prototype.prepareFrame = function (frameState) {
    var layer = this.getLayer();
    var vectorSource = layer.getSource();
    var viewState = frameState.viewState;
    var viewNotMoving = !frameState.viewHints[_ViewHint.default.ANIMATING] && !frameState.viewHints[_ViewHint.default.INTERACTING];
    var extentChanged = !(0, _extent.equals)(this.previousExtent_, frameState.extent);
    var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();

    if (sourceChanged) {
      this.sourceRevision_ = vectorSource.getRevision();
    }

    if (viewNotMoving && (extentChanged || sourceChanged)) {
      var projection = viewState.projection;
      var resolution = viewState.resolution;
      var renderBuffer = layer instanceof _BaseVector.default ? layer.getRenderBuffer() : 0;
      var extent = (0, _extent.buffer)(frameState.extent, renderBuffer * resolution);
      vectorSource.loadFeatures(extent, resolution, projection);
      this.rebuildBuffers_(frameState);
      this.previousExtent_ = frameState.extent.slice();
    } // apply the current projection transform with the invert of the one used to fill buffers


    this.helper.makeProjectionTransform(frameState, this.currentTransform_);
    (0, _transform.multiply)(this.currentTransform_, this.invertRenderTransform_);
    this.helper.useProgram(this.program_);
    this.helper.prepareDraw(frameState); // write new data

    this.helper.bindBuffer(this.verticesBuffer_);
    this.helper.bindBuffer(this.indicesBuffer_);
    this.helper.enableAttributes(this.attributes);
    return true;
  };
  /**
   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much
   * @param {import("../../PluggableMap").FrameState} frameState Frame state.
   * @private
   */


  WebGLPointsLayerRenderer.prototype.rebuildBuffers_ = function (frameState) {
    // saves the projection transform for the current frame state
    var projectionTransform = (0, _transform.create)();
    this.helper.makeProjectionTransform(frameState, projectionTransform); // here we anticipate the amount of render instructions that we well generate
    // this can be done since we know that for normal render we only have x, y as base instructions,
    // and x, y, r, g, b, a and featureUid for hit render instructions
    // and we also know the amount of custom attributes to append to these

    var totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;

    if (!this.renderInstructions_ || this.renderInstructions_.length !== totalInstructionsCount) {
      this.renderInstructions_ = new Float32Array(totalInstructionsCount);
    }

    if (this.hitDetectionEnabled_) {
      var totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;

      if (!this.hitRenderInstructions_ || this.hitRenderInstructions_.length !== totalHitInstructionsCount) {
        this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);
      }
    } // loop on features to fill the buffer


    var featureCache, geometry;
    var tmpCoords = [];
    var tmpColor = [];
    var renderIndex = 0;
    var hitIndex = 0;
    var hitColor;

    for (var featureUid in this.featureCache_) {
      featureCache = this.featureCache_[featureUid];
      geometry =
      /** @type {import("../../geom").Point} */
      featureCache.geometry;

      if (!geometry || geometry.getType() !== _GeometryType.default.POINT) {
        continue;
      }

      tmpCoords[0] = geometry.getFlatCoordinates()[0];
      tmpCoords[1] = geometry.getFlatCoordinates()[1];
      (0, _transform.apply)(projectionTransform, tmpCoords);
      hitColor = (0, _Layer.colorEncodeId)(hitIndex + 6, tmpColor);
      this.renderInstructions_[renderIndex++] = tmpCoords[0];
      this.renderInstructions_[renderIndex++] = tmpCoords[1]; // for hit detection, the feature uid is saved in the opacity value
      // and the index of the opacity value is encoded in the color values

      if (this.hitDetectionEnabled_) {
        this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];
        this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];
        this.hitRenderInstructions_[hitIndex++] = hitColor[0];
        this.hitRenderInstructions_[hitIndex++] = hitColor[1];
        this.hitRenderInstructions_[hitIndex++] = hitColor[2];
        this.hitRenderInstructions_[hitIndex++] = hitColor[3];
        this.hitRenderInstructions_[hitIndex++] = Number(featureUid);
      } // pushing custom attributes


      var value = void 0;

      for (var j = 0; j < this.customAttributes.length; j++) {
        value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);
        this.renderInstructions_[renderIndex++] = value;

        if (this.hitDetectionEnabled_) {
          this.hitRenderInstructions_[hitIndex++] = value;
        }
      }
    }
    /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */


    var message = {
      type: _Layer.WebGLWorkerMessageType.GENERATE_BUFFERS,
      renderInstructions: this.renderInstructions_.buffer,
      customAttributesCount: this.customAttributes.length
    }; // additional properties will be sent back as-is by the worker

    message['projectionTransform'] = projectionTransform;
    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);
    this.renderInstructions_ = null;
    /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */

    if (this.hitDetectionEnabled_) {
      var hitMessage = {
        type: _Layer.WebGLWorkerMessageType.GENERATE_BUFFERS,
        renderInstructions: this.hitRenderInstructions_.buffer,
        customAttributesCount: 5 + this.customAttributes.length
      };
      hitMessage['projectionTransform'] = projectionTransform;
      hitMessage['hitDetection'] = true;
      this.worker_.postMessage(hitMessage, [this.hitRenderInstructions_.buffer]);
      this.hitRenderInstructions_ = null;
    }
  };
  /**
   * @inheritDoc
   */


  WebGLPointsLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, declutteredFeatures) {
    (0, _asserts.assert)(this.hitDetectionEnabled_, 66);

    if (!this.hitRenderInstructions_) {
      return;
    }

    var pixel = (0, _transform.apply)(frameState.coordinateToPixelTransform, coordinate.slice());
    var data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);
    var color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];
    var index = (0, _Layer.colorDecodeId)(color);
    var opacity = this.hitRenderInstructions_[index];
    var uid = Math.floor(opacity).toString();
    var source = this.getLayer().getSource();
    var feature = source.getFeatureByUid(uid);

    if (feature) {
      return callback(feature, this.getLayer());
    }
  };
  /**
   * Render the hit detection data to the corresponding render target
   * @param {import("../../PluggableMap.js").FrameState} frameState current frame state
   */


  WebGLPointsLayerRenderer.prototype.renderHitDetection = function (frameState) {
    // skip render entirely if vertex buffers not ready/generated yet
    if (!this.hitVerticesBuffer_.getSize()) {
      return;
    }

    this.hitRenderTarget_.setSize([Math.floor(frameState.size[0] / 2), Math.floor(frameState.size[1] / 2)]);
    this.helper.useProgram(this.hitProgram_);
    this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);
    this.helper.bindBuffer(this.hitVerticesBuffer_);
    this.helper.bindBuffer(this.indicesBuffer_);
    this.helper.enableAttributes(this.hitDetectionAttributes);
    var renderCount = this.indicesBuffer_.getSize();
    this.helper.drawElements(0, renderCount);
  };
  /**
   * @inheritDoc
   */


  WebGLPointsLayerRenderer.prototype.disposeInternal = function () {
    this.worker_.terminate();
    this.layer_ = null;
    this.sourceListenKeys_.forEach(function (key) {
      (0, _events.unlistenByKey)(key);
    });
    this.sourceListenKeys_ = null;

    _super.prototype.disposeInternal.call(this);
  };

  return WebGLPointsLayerRenderer;
}(_Layer.default);

var _default = WebGLPointsLayerRenderer;
exports.default = _default;
},{"../../webgl/Buffer.js":"node_modules/ol/webgl/Buffer.js","../../webgl.js":"node_modules/ol/webgl.js","../../webgl/Helper.js":"node_modules/ol/webgl/Helper.js","../../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","./Layer.js":"node_modules/ol/renderer/webgl/Layer.js","../../ViewHint.js":"node_modules/ol/ViewHint.js","../../extent.js":"node_modules/ol/extent.js","../../transform.js":"node_modules/ol/transform.js","../../worker/webgl.js":"node_modules/ol/worker/webgl.js","../../util.js":"node_modules/ol/util.js","../../webgl/RenderTarget.js":"node_modules/ol/webgl/RenderTarget.js","../../asserts.js":"node_modules/ol/asserts.js","../../layer/BaseVector.js":"node_modules/ol/layer/BaseVector.js","../../events.js":"node_modules/ol/events.js","../../source/VectorEventType.js":"node_modules/ol/source/VectorEventType.js"}],"node_modules/ol/layer/Heatmap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Object = require("../Object.js");

var _dom = require("../dom.js");

var _Vector = _interopRequireDefault(require("./Vector.js"));

var _math = require("../math.js");

var _obj = require("../obj.js");

var _PointsLayer = _interopRequireDefault(require("../renderer/webgl/PointsLayer.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/Heatmap
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {Array<string>} [gradient=['#00f', '#0ff', '#0f0', '#ff0', '#f00']] The color gradient
 * of the heatmap, specified as an array of CSS color strings.
 * @property {number} [radius=8] Radius size in pixels.
 * @property {number} [blur=15] Blur size in pixels.
 * @property {string|function(import("../Feature.js").default):number} [weight='weight'] The feature
 * attribute to use for the weight or a function that returns a weight from a feature. Weight values
 * should range from 0 to 1 (and values outside will be clamped to that range).
 * @property {import("../source/Vector.js").default} [source] Source.
 */

/**
 * @enum {string}
 * @private
 */
var Property = {
  BLUR: 'blur',
  GRADIENT: 'gradient',
  RADIUS: 'radius'
};
/**
 * @const
 * @type {Array<string>}
 */

var DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];
/**
 * @classdesc
 * Layer for rendering vector data as a heatmap.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @fires import("../render/Event.js").RenderEvent
 * @api
 */

var Heatmap =
/** @class */
function (_super) {
  __extends(Heatmap, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function Heatmap(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var baseOptions = (0, _obj.assign)({}, options);
    delete baseOptions.gradient;
    delete baseOptions.radius;
    delete baseOptions.blur;
    delete baseOptions.weight;
    _this = _super.call(this, baseOptions) || this;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.gradient_ = null;

    _this.addEventListener((0, _Object.getChangeEventType)(Property.GRADIENT), _this.handleGradientChanged_);

    _this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);

    _this.setBlur(options.blur !== undefined ? options.blur : 15);

    _this.setRadius(options.radius !== undefined ? options.radius : 8);

    var weight = options.weight ? options.weight : 'weight';

    if (typeof weight === 'string') {
      _this.weightFunction_ = function (feature) {
        return feature.get(weight);
      };
    } else {
      _this.weightFunction_ = weight;
    } // For performance reasons, don't sort the features before rendering.
    // The render order is not relevant for a heatmap representation.


    _this.setRenderOrder(null);

    return _this;
  }
  /**
   * Return the blur size in pixels.
   * @return {number} Blur size in pixels.
   * @api
   * @observable
   */


  Heatmap.prototype.getBlur = function () {
    return (
      /** @type {number} */
      this.get(Property.BLUR)
    );
  };
  /**
   * Return the gradient colors as array of strings.
   * @return {Array<string>} Colors.
   * @api
   * @observable
   */


  Heatmap.prototype.getGradient = function () {
    return (
      /** @type {Array<string>} */
      this.get(Property.GRADIENT)
    );
  };
  /**
   * Return the size of the radius in pixels.
   * @return {number} Radius size in pixel.
   * @api
   * @observable
   */


  Heatmap.prototype.getRadius = function () {
    return (
      /** @type {number} */
      this.get(Property.RADIUS)
    );
  };
  /**
   * @private
   */


  Heatmap.prototype.handleGradientChanged_ = function () {
    this.gradient_ = createGradient(this.getGradient());
  };
  /**
   * Set the blur size in pixels.
   * @param {number} blur Blur size in pixels.
   * @api
   * @observable
   */


  Heatmap.prototype.setBlur = function (blur) {
    this.set(Property.BLUR, blur);
  };
  /**
   * Set the gradient colors as array of strings.
   * @param {Array<string>} colors Gradient.
   * @api
   * @observable
   */


  Heatmap.prototype.setGradient = function (colors) {
    this.set(Property.GRADIENT, colors);
  };
  /**
   * Set the size of the radius in pixels.
   * @param {number} radius Radius size in pixel.
   * @api
   * @observable
   */


  Heatmap.prototype.setRadius = function (radius) {
    this.set(Property.RADIUS, radius);
  };
  /**
   * @inheritDoc
   */


  Heatmap.prototype.createRenderer = function () {
    return new _PointsLayer.default(this, {
      attributes: [{
        name: 'weight',
        callback: function (feature) {
          var weight = this.weightFunction_(feature);
          return weight !== undefined ? (0, _math.clamp)(weight, 0, 1) : 1;
        }.bind(this)
      }],
      vertexShader: "\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_weight = a_weight;\n        }",
      fragmentShader: "\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          gl_FragColor = vec4(alpha, alpha, alpha, alpha);\n        }",
      hitVertexShader: "\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n        attribute vec4 a_hitColor;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_hitColor = a_hitColor;\n          v_weight = a_weight;\n        }",
      hitFragmentShader: "\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          if (alpha < 0.05) {\n            discard;\n          }\n\n          gl_FragColor = v_hitColor;\n        }",
      uniforms: {
        u_size: function () {
          return (this.get(Property.RADIUS) + this.get(Property.BLUR)) * 2;
        }.bind(this),
        u_blurSlope: function () {
          return this.get(Property.RADIUS) / Math.max(1, this.get(Property.BLUR));
        }.bind(this)
      },
      postProcesses: [{
        fragmentShader: "\n            precision mediump float;\n\n            uniform sampler2D u_image;\n            uniform sampler2D u_gradientTexture;\n\n            varying vec2 v_texCoord;\n\n            void main() {\n              vec4 color = texture2D(u_image, v_texCoord);\n              gl_FragColor.a = color.a;\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\n              gl_FragColor.rgb *= gl_FragColor.a;\n            }",
        uniforms: {
          u_gradientTexture: function () {
            return this.gradient_;
          }.bind(this)
        }
      }]
    });
  };

  return Heatmap;
}(_Vector.default);
/**
 * @param {Array<string>} colors A list of colored.
 * @return {HTMLCanvasElement} canvas with gradient texture.
 */


function createGradient(colors) {
  var width = 1;
  var height = 256;
  var context = (0, _dom.createCanvasContext2D)(width, height);
  var gradient = context.createLinearGradient(0, 0, width, height);
  var step = 1 / (colors.length - 1);

  for (var i = 0, ii = colors.length; i < ii; ++i) {
    gradient.addColorStop(i * step, colors[i]);
  }

  context.fillStyle = gradient;
  context.fillRect(0, 0, width, height);
  return context.canvas;
}

var _default = Heatmap;
exports.default = _default;
},{"../Object.js":"node_modules/ol/Object.js","../dom.js":"node_modules/ol/dom.js","./Vector.js":"node_modules/ol/layer/Vector.js","../math.js":"node_modules/ol/math.js","../obj.js":"node_modules/ol/obj.js","../renderer/webgl/PointsLayer.js":"node_modules/ol/renderer/webgl/PointsLayer.js"}],"node_modules/ol/layer/BaseImage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Layer = _interopRequireDefault(require("./Layer.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/BaseImage
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {import("../source/Image.js").default} [source] Source for this layer.
 */

/**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @extends {Layer<import("../source/Image.js").default>}
 * @api
 */
var BaseImageLayer =
/** @class */
function (_super) {
  __extends(BaseImageLayer, _super);
  /**
   * @param {Options=} opt_options Layer options.
   */


  function BaseImageLayer(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, options) || this;
    return _this;
  }

  return BaseImageLayer;
}(_Layer.default);

var _default = BaseImageLayer;
exports.default = _default;
},{"./Layer.js":"node_modules/ol/layer/Layer.js"}],"node_modules/ol/renderer/canvas/ImageLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _common = require("../../reproj/common.js");

var _ViewHint = _interopRequireDefault(require("../../ViewHint.js"));

var _extent = require("../../extent.js");

var _proj = require("../../proj.js");

var _Layer = _interopRequireDefault(require("./Layer.js"));

var _transform = require("../../transform.js");

var _canvas = require("../../render/canvas.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/canvas/ImageLayer
 */


/**
 * @classdesc
 * Canvas renderer for image layers.
 * @api
 */
var CanvasImageLayerRenderer =
/** @class */
function (_super) {
  __extends(CanvasImageLayerRenderer, _super);
  /**
   * @param {import("../../layer/Image.js").default} imageLayer Image layer.
   */


  function CanvasImageLayerRenderer(imageLayer) {
    var _this = _super.call(this, imageLayer) || this;
    /**
     * @protected
     * @type {?import("../../ImageBase.js").default}
     */


    _this.image_ = null;
    return _this;
  }
  /**
   * @inheritDoc
   */


  CanvasImageLayerRenderer.prototype.getImage = function () {
    return !this.image_ ? null : this.image_.getImage();
  };
  /**
   * @inheritDoc
   */


  CanvasImageLayerRenderer.prototype.prepareFrame = function (frameState) {
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var viewResolution = viewState.resolution;
    var imageSource = this.getLayer().getSource();
    var hints = frameState.viewHints;
    var renderedExtent = frameState.extent;

    if (layerState.extent !== undefined) {
      renderedExtent = (0, _extent.getIntersection)(renderedExtent, (0, _proj.fromUserExtent)(layerState.extent, viewState.projection));
    }

    if (!hints[_ViewHint.default.ANIMATING] && !hints[_ViewHint.default.INTERACTING] && !(0, _extent.isEmpty)(renderedExtent)) {
      if (imageSource) {
        var projection = viewState.projection;

        if (!_common.ENABLE_RASTER_REPROJECTION) {
          var sourceProjection = imageSource.getProjection();

          if (sourceProjection) {
            projection = sourceProjection;
          }
        }

        var image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);

        if (image && this.loadImage(image)) {
          this.image_ = image;
        }
      } else {
        this.image_ = null;
      }
    }

    return !!this.image_;
  };
  /**
   * @inheritDoc
   */


  CanvasImageLayerRenderer.prototype.renderFrame = function (frameState, target) {
    var image = this.image_;
    var imageExtent = image.getExtent();
    var imageResolution = image.getResolution();
    var imagePixelRatio = image.getPixelRatio();
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var viewCenter = viewState.center;
    var viewResolution = viewState.resolution;
    var size = frameState.size;
    var scale = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);
    var width = Math.round(size[0] * pixelRatio);
    var height = Math.round(size[1] * pixelRatio);
    var rotation = viewState.rotation;

    if (rotation) {
      var size_1 = Math.round(Math.sqrt(width * width + height * height));
      width = size_1;
      height = size_1;
    } // set forward and inverse pixel transforms


    (0, _transform.compose)(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
    (0, _transform.makeInverse)(this.inversePixelTransform, this.pixelTransform);
    var canvasTransform = (0, _canvas.createTransformString)(this.pixelTransform);
    this.useContainer(target, canvasTransform, layerState.opacity);
    var context = this.context;
    var canvas = context.canvas;

    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    } // clipped rendering if layer extent is set


    var clipped = false;

    if (layerState.extent) {
      var layerExtent = (0, _proj.fromUserExtent)(layerState.extent, viewState.projection);
      clipped = !(0, _extent.containsExtent)(layerExtent, frameState.extent) && (0, _extent.intersects)(layerExtent, frameState.extent);

      if (clipped) {
        this.clipUnrotated(context, frameState, layerExtent);
      }
    }

    var img = image.getImage();
    var transform = (0, _transform.compose)(this.tempTransform_, width / 2, height / 2, scale, scale, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);
    this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
    var dx = transform[4];
    var dy = transform[5];
    var dw = img.width * transform[0];
    var dh = img.height * transform[3];
    this.preRender(context, frameState);

    if (dw >= 0.5 && dh >= 0.5) {
      var opacity = layerState.opacity;
      var previousAlpha = void 0;

      if (opacity !== 1) {
        previousAlpha = this.context.globalAlpha;
        this.context.globalAlpha = opacity;
      }

      this.context.drawImage(img, 0, 0, +img.width, +img.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));

      if (opacity !== 1) {
        this.context.globalAlpha = previousAlpha;
      }
    }

    this.postRender(context, frameState);

    if (clipped) {
      context.restore();
    }

    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }

    return this.container;
  };

  return CanvasImageLayerRenderer;
}(_Layer.default);

var _default = CanvasImageLayerRenderer;
exports.default = _default;
},{"../../reproj/common.js":"node_modules/ol/reproj/common.js","../../ViewHint.js":"node_modules/ol/ViewHint.js","../../extent.js":"node_modules/ol/extent.js","../../proj.js":"node_modules/ol/proj.js","./Layer.js":"node_modules/ol/renderer/canvas/Layer.js","../../transform.js":"node_modules/ol/transform.js","../../render/canvas.js":"node_modules/ol/render/canvas.js"}],"node_modules/ol/layer/Image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _BaseImage = _interopRequireDefault(require("./BaseImage.js"));

var _ImageLayer = _interopRequireDefault(require("../renderer/canvas/ImageLayer.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/Image
 */


/**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @api
 */
var ImageLayer =
/** @class */
function (_super) {
  __extends(ImageLayer, _super);
  /**
   * @param {import("./BaseImage.js").Options=} opt_options Layer options.
   */


  function ImageLayer(opt_options) {
    return _super.call(this, opt_options) || this;
  }
  /**
   * Create a renderer for this layer.
   * @return {import("../renderer/Layer.js").default} A layer renderer.
   * @protected
   */


  ImageLayer.prototype.createRenderer = function () {
    return new _ImageLayer.default(this);
  };

  return ImageLayer;
}(_BaseImage.default);

var _default = ImageLayer;
exports.default = _default;
},{"./BaseImage.js":"node_modules/ol/layer/BaseImage.js","../renderer/canvas/ImageLayer.js":"node_modules/ol/renderer/canvas/ImageLayer.js"}],"node_modules/ol/ImageCanvas.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ImageBase = _interopRequireDefault(require("./ImageBase.js"));

var _ImageState = _interopRequireDefault(require("./ImageState.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/ImageCanvas
 */


/**
 * A function that is called to trigger asynchronous canvas drawing.  It is
 * called with a "done" callback that should be called when drawing is done.
 * If any error occurs during drawing, the "done" callback should be called with
 * that error.
 *
 * @typedef {function(function(Error=): void): void} Loader
 */
var ImageCanvas =
/** @class */
function (_super) {
  __extends(ImageCanvas, _super);
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {HTMLCanvasElement} canvas Canvas.
   * @param {Loader=} opt_loader Optional loader function to
   *     support asynchronous canvas drawing.
   */


  function ImageCanvas(extent, resolution, pixelRatio, canvas, opt_loader) {
    var _this = this;

    var state = opt_loader !== undefined ? _ImageState.default.IDLE : _ImageState.default.LOADED;
    _this = _super.call(this, extent, resolution, pixelRatio, state) || this;
    /**
     * Optional canvas loader function.
     * @type {?Loader}
     * @private
     */

    _this.loader_ = opt_loader !== undefined ? opt_loader : null;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.canvas_ = canvas;
    /**
     * @private
     * @type {?Error}
     */

    _this.error_ = null;
    return _this;
  }
  /**
   * Get any error associated with asynchronous rendering.
   * @return {?Error} Any error that occurred during rendering.
   */


  ImageCanvas.prototype.getError = function () {
    return this.error_;
  };
  /**
   * Handle async drawing complete.
   * @param {Error=} err Any error during drawing.
   * @private
   */


  ImageCanvas.prototype.handleLoad_ = function (err) {
    if (err) {
      this.error_ = err;
      this.state = _ImageState.default.ERROR;
    } else {
      this.state = _ImageState.default.LOADED;
    }

    this.changed();
  };
  /**
   * @inheritDoc
   */


  ImageCanvas.prototype.load = function () {
    if (this.state == _ImageState.default.IDLE) {
      this.state = _ImageState.default.LOADING;
      this.changed();
      this.loader_(this.handleLoad_.bind(this));
    }
  };
  /**
   * @return {HTMLCanvasElement} Canvas element.
   */


  ImageCanvas.prototype.getImage = function () {
    return this.canvas_;
  };

  return ImageCanvas;
}(_ImageBase.default);

var _default = ImageCanvas;
exports.default = _default;
},{"./ImageBase.js":"node_modules/ol/ImageBase.js","./ImageState.js":"node_modules/ol/ImageState.js"}],"node_modules/ol/renderer/canvas/VectorImageLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ImageCanvas = _interopRequireDefault(require("../../ImageCanvas.js"));

var _ViewHint = _interopRequireDefault(require("../../ViewHint.js"));

var _extent = require("../../extent.js");

var _obj = require("../../obj.js");

var _ImageLayer = _interopRequireDefault(require("./ImageLayer.js"));

var _VectorLayer = _interopRequireDefault(require("./VectorLayer.js"));

var _EventType = _interopRequireDefault(require("../../events/EventType.js"));

var _ImageState = _interopRequireDefault(require("../../ImageState.js"));

var _render = require("../../render.js");

var _transform = require("../../transform.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/canvas/VectorImageLayer
 */


/**
 * @classdesc
 * Canvas renderer for image layers.
 * @api
 */
var CanvasVectorImageLayerRenderer =
/** @class */
function (_super) {
  __extends(CanvasVectorImageLayerRenderer, _super);
  /**
   * @param {import("../../layer/VectorImage.js").default} layer Vector image layer.
   */


  function CanvasVectorImageLayerRenderer(layer) {
    var _this = _super.call(this, layer) || this;
    /**
     * @private
     * @type {import("./VectorLayer.js").default}
     */


    _this.vectorRenderer_ = new _VectorLayer.default(layer);
    /**
     * @private
     * @type {number}
     */

    _this.layerImageRatio_ = layer.getImageRatio();
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    _this.coordinateToVectorPixelTransform_ = (0, _transform.create)();
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    _this.renderedPixelToCoordinateTransform_ = null;
    return _this;
  }
  /**
   * @inheritDoc
   */


  CanvasVectorImageLayerRenderer.prototype.disposeInternal = function () {
    this.vectorRenderer_.dispose();

    _super.prototype.disposeInternal.call(this);
  };
  /**
   * @inheritDoc
   */


  CanvasVectorImageLayerRenderer.prototype.getFeatures = function (pixel) {
    if (this.vectorRenderer_) {
      var vectorPixel = (0, _transform.apply)(this.coordinateToVectorPixelTransform_, (0, _transform.apply)(this.renderedPixelToCoordinateTransform_, pixel.slice()));
      return this.vectorRenderer_.getFeatures(vectorPixel);
    } else {
      var promise = new Promise(function (resolve, reject) {
        resolve([]);
      });
      return promise;
    }
  };
  /**
   * @inheritDoc
   */


  CanvasVectorImageLayerRenderer.prototype.handleFontsChanged = function () {
    this.vectorRenderer_.handleFontsChanged();
  };
  /**
   * @inheritDoc
   */


  CanvasVectorImageLayerRenderer.prototype.prepareFrame = function (frameState) {
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var viewResolution = viewState.resolution;
    var hints = frameState.viewHints;
    var vectorRenderer = this.vectorRenderer_;
    var renderedExtent = frameState.extent;

    if (this.layerImageRatio_ !== 1) {
      renderedExtent = renderedExtent.slice(0);
      (0, _extent.scaleFromCenter)(renderedExtent, this.layerImageRatio_);
    }

    var width = (0, _extent.getWidth)(renderedExtent) / viewResolution;
    var height = (0, _extent.getHeight)(renderedExtent) / viewResolution;

    if (!hints[_ViewHint.default.ANIMATING] && !hints[_ViewHint.default.INTERACTING] && !(0, _extent.isEmpty)(renderedExtent)) {
      vectorRenderer.useContainer(null, null, 1);
      var context = vectorRenderer.context;
      var imageFrameState_1 =
      /** @type {import("../../PluggableMap.js").FrameState} */
      (0, _obj.assign)({}, frameState, {
        declutterItems: [],
        extent: renderedExtent,
        size: [width, height],
        viewState:
        /** @type {import("../../View.js").State} */
        (0, _obj.assign)({}, frameState.viewState, {
          rotation: 0
        })
      });
      var image_1 = new _ImageCanvas.default(renderedExtent, viewResolution, pixelRatio, context.canvas, function (callback) {
        if (vectorRenderer.prepareFrame(imageFrameState_1) && vectorRenderer.replayGroupChanged) {
          vectorRenderer.renderFrame(imageFrameState_1, null);
          (0, _render.renderDeclutterItems)(imageFrameState_1, null);
          callback();
        }
      });
      image_1.addEventListener(_EventType.default.CHANGE, function () {
        if (image_1.getState() === _ImageState.default.LOADED) {
          this.image_ = image_1;
        }
      }.bind(this));
      image_1.load();
    }

    if (this.image_) {
      var image = this.image_;
      var imageResolution = image.getResolution();
      var imagePixelRatio = image.getPixelRatio();
      var renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
      this.renderedResolution = renderedResolution;
      this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();
      this.coordinateToVectorPixelTransform_ = (0, _transform.compose)(this.coordinateToVectorPixelTransform_, width / 2, height / 2, 1 / renderedResolution, -1 / renderedResolution, 0, -viewState.center[0], -viewState.center[1]);
    }

    return !!this.image_;
  };
  /**
   * @override
   */


  CanvasVectorImageLayerRenderer.prototype.preRender = function () {};
  /**
   * @override
   */


  CanvasVectorImageLayerRenderer.prototype.postRender = function () {};
  /**
   * @inheritDoc
   */


  CanvasVectorImageLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, declutteredFeatures) {
    if (this.vectorRenderer_) {
      return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, declutteredFeatures);
    } else {
      return _super.prototype.forEachFeatureAtCoordinate.call(this, coordinate, frameState, hitTolerance, callback, declutteredFeatures);
    }
  };

  return CanvasVectorImageLayerRenderer;
}(_ImageLayer.default);

var _default = CanvasVectorImageLayerRenderer;
exports.default = _default;
},{"../../ImageCanvas.js":"node_modules/ol/ImageCanvas.js","../../ViewHint.js":"node_modules/ol/ViewHint.js","../../extent.js":"node_modules/ol/extent.js","../../obj.js":"node_modules/ol/obj.js","./ImageLayer.js":"node_modules/ol/renderer/canvas/ImageLayer.js","./VectorLayer.js":"node_modules/ol/renderer/canvas/VectorLayer.js","../../events/EventType.js":"node_modules/ol/events/EventType.js","../../ImageState.js":"node_modules/ol/ImageState.js","../../render.js":"node_modules/ol/render.js","../../transform.js":"node_modules/ol/transform.js"}],"node_modules/ol/layer/VectorImage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _BaseVector = _interopRequireDefault(require("./BaseVector.js"));

var _obj = require("../obj.js");

var _VectorImageLayer = _interopRequireDefault(require("../renderer/canvas/VectorImageLayer.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/VectorImage
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {import("../source/Vector.js").default} [source] Source.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text on this layer. The priority is defined
 * by the `zIndex` of the style and the render order of features. Higher z-index means higher priority.
 * Within the same z-index, a feature rendered before another has higher priority.
 * @property {import("../style/Style.js").StyleLike} [style] Layer style. See
 * {@link module:ol/style} for default style which will be used if this is not defined.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
 * be recreated during animations. This means that no vectors will be shown clipped, but the
 * setting will have a performance impact for large amounts of vector data. When set to `false`,
 * batches will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
 * be recreated during interactions. See also `updateWhileAnimating`.
 * @property {number} [imageRatio=1] Ratio by which the rendered extent should be larger than the
 * viewport extent. A larger ratio avoids cut images during panning, but will cause a decrease in performance.
 */

/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @api
 */
var VectorImageLayer =
/** @class */
function (_super) {
  __extends(VectorImageLayer, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function VectorImageLayer(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var baseOptions = (0, _obj.assign)({}, options);
    delete baseOptions.imageRatio;
    _this = _super.call(this, baseOptions) || this;
    /**
     * @type {number}
     * @private
     */

    _this.imageRatio_ = options.imageRatio !== undefined ? options.imageRatio : 1;
    return _this;
  }
  /**
   * @return {number} Ratio between rendered extent size and viewport extent size.
   */


  VectorImageLayer.prototype.getImageRatio = function () {
    return this.imageRatio_;
  };
  /**
   * Create a renderer for this layer.
   * @return {import("../renderer/Layer.js").default} A layer renderer.
   * @protected
   */


  VectorImageLayer.prototype.createRenderer = function () {
    return new _VectorImageLayer.default(this);
  };

  return VectorImageLayer;
}(_BaseVector.default);

var _default = VectorImageLayer;
exports.default = _default;
},{"./BaseVector.js":"node_modules/ol/layer/BaseVector.js","../obj.js":"node_modules/ol/obj.js","../renderer/canvas/VectorImageLayer.js":"node_modules/ol/renderer/canvas/VectorImageLayer.js"}],"node_modules/ol/layer/VectorTileRenderType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/layer/VectorTileRenderType
 */

/**
 * @enum {string}
 * Render mode for vector tiles:
 *  * `'image'`: Vector tiles are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels
 *    are scaled during zoom animations. Point symbols and texts are accurately
 *    rendered as vectors and can stay upright on rotated views.
 *  * `'vector'`: Everything is rendered as vectors. Use this mode for improved
 *    performance on vector tile layers with only a few rendered features (e.g.
 *    for highlighting a subset of features of another layer with the same
 *    source).
 * @api
 */
var _default = {
  IMAGE: 'image',
  HYBRID: 'hybrid',
  VECTOR: 'vector'
};
exports.default = _default;
},{}],"node_modules/ol/renderer/canvas/VectorTileLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("../../util.js");

var _TileState = _interopRequireDefault(require("../../TileState.js"));

var _ViewHint = _interopRequireDefault(require("../../ViewHint.js"));

var _events = require("../../events.js");

var _EventType = _interopRequireDefault(require("../../events/EventType.js"));

var _extent = require("../../extent.js");

var _VectorTileRenderType = _interopRequireDefault(require("../../layer/VectorTileRenderType.js"));

var _BuilderType = _interopRequireDefault(require("../../render/canvas/BuilderType.js"));

var _BuilderGroup = _interopRequireDefault(require("../../render/canvas/BuilderGroup.js"));

var _TileLayer = _interopRequireDefault(require("./TileLayer.js"));

var _size = require("../../size.js");

var _vector = require("../vector.js");

var _transform = require("../../transform.js");

var _ExecutorGroup = _interopRequireWildcard(require("../../render/canvas/ExecutorGroup.js"));

var _obj = require("../../obj.js");

var _hitdetect = require("../../render/canvas/hitdetect.js");

var _coordinate = require("../../coordinate.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/canvas/VectorTileLayer
 */


/**
 * @type {!Object<string, Array<import("../../render/canvas/BuilderType.js").default>>}
 */
var IMAGE_REPLAYS = {
  'image': [_BuilderType.default.POLYGON, _BuilderType.default.CIRCLE, _BuilderType.default.LINE_STRING, _BuilderType.default.IMAGE, _BuilderType.default.TEXT],
  'hybrid': [_BuilderType.default.POLYGON, _BuilderType.default.LINE_STRING],
  'vector': []
};
/**
 * @type {!Object<string, Array<import("../../render/canvas/BuilderType.js").default>>}
 */

var VECTOR_REPLAYS = {
  'image': [_BuilderType.default.DEFAULT],
  'hybrid': [_BuilderType.default.IMAGE, _BuilderType.default.TEXT, _BuilderType.default.DEFAULT],
  'vector': [_BuilderType.default.POLYGON, _BuilderType.default.CIRCLE, _BuilderType.default.LINE_STRING, _BuilderType.default.IMAGE, _BuilderType.default.TEXT, _BuilderType.default.DEFAULT]
};
/**
 * @classdesc
 * Canvas renderer for vector tile layers.
 * @api
 */

var CanvasVectorTileLayerRenderer =
/** @class */
function (_super) {
  __extends(CanvasVectorTileLayerRenderer, _super);
  /**
   * @param {import("../../layer/VectorTile.js").default} layer VectorTile layer.
   */


  function CanvasVectorTileLayerRenderer(layer) {
    var _this = _super.call(this, layer) || this;
    /** @private */


    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
    /**
     * @private
     * @type {boolean}
     */

    _this.dirty_ = false;
    /**
     * @private
     * @type {number}
     */

    _this.renderedLayerRevision_;
    /**
     * @private
     * @type {import("../../transform").Transform}
     */

    _this.renderedPixelToCoordinateTransform_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.renderedRotation_;
    /**
     * @private
     * @type {!Object<string, import("../../VectorRenderTile.js").default>}
     */

    _this.renderTileImageQueue_ = {};
    /**
     * @type {Object<string, import("../../events.js").EventsKey>}
     */

    _this.tileListenerKeys_ = {};
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    _this.tmpTransform_ = (0, _transform.create)();
    return _this;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection").default} projection Projection.
   * @param {boolean} queue Queue tile for rendering.
   * @return {boolean|undefined} Tile needs to be rendered.
   */


  CanvasVectorTileLayerRenderer.prototype.prepareTile = function (tile, pixelRatio, projection, queue) {
    var render;
    var tileUid = (0, _util.getUid)(tile);
    var state = tile.getState();

    if ((state === _TileState.default.LOADED && tile.hifi || state === _TileState.default.ERROR) && tileUid in this.tileListenerKeys_) {
      (0, _events.unlistenByKey)(this.tileListenerKeys_[tileUid]);
      delete this.tileListenerKeys_[tileUid];
    }

    if (state === _TileState.default.LOADED || state === _TileState.default.ERROR) {
      this.updateExecutorGroup_(tile, pixelRatio, projection);

      if (this.tileImageNeedsRender_(tile, pixelRatio, projection)) {
        render = true;

        if (queue) {
          this.renderTileImageQueue_[tileUid] = tile;
        }
      }
    }

    return render;
  };
  /**
   * @inheritDoc
   */


  CanvasVectorTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var resolution = viewState.resolution;
    var projection = viewState.projection;
    var layer = this.getLayer();
    var tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);

    if (tile.getState() < _TileState.default.LOADED) {
      tile.wantedResolution = resolution;
      var tileUid = (0, _util.getUid)(tile);

      if (!(tileUid in this.tileListenerKeys_)) {
        var listenerKey = (0, _events.listen)(tile, _EventType.default.CHANGE, this.prepareTile.bind(this, tile, pixelRatio, projection, true));
        this.tileListenerKeys_[tileUid] = listenerKey;
      }
    } else {
      var viewHints = frameState.viewHints;
      var hifi = !(viewHints[_ViewHint.default.ANIMATING] || viewHints[_ViewHint.default.INTERACTING]);

      if (hifi || !tile.wantedResolution) {
        tile.wantedResolution = resolution;
      }

      var render = this.prepareTile(tile, pixelRatio, projection, false);

      if (render && layer.getRenderMode() !== _VectorTileRenderType.default.VECTOR) {
        this.renderTileImage_(tile, frameState);
      }
    }

    return _super.prototype.getTile.call(this, z, x, y, frameState);
  };
  /**
   * @inheritdoc
   */


  CanvasVectorTileLayerRenderer.prototype.isDrawableTile = function (tile) {
    var layer = this.getLayer();
    return _super.prototype.isDrawableTile.call(this, tile) && layer.getRenderMode() === _VectorTileRenderType.default.VECTOR || tile.hasContext(layer);
  };
  /**
   * @inheritDoc
   */


  CanvasVectorTileLayerRenderer.prototype.getTileImage = function (tile) {
    return tile.getImage(this.getLayer());
  };
  /**
   * @inheritDoc
   */


  CanvasVectorTileLayerRenderer.prototype.prepareFrame = function (frameState) {
    var layerRevision = this.getLayer().getRevision();

    if (this.renderedLayerRevision_ != layerRevision) {
      this.renderedTiles.length = 0;
    }

    this.renderedLayerRevision_ = layerRevision;
    return _super.prototype.prepareFrame.call(this, frameState);
  };
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @private
   */


  CanvasVectorTileLayerRenderer.prototype.updateExecutorGroup_ = function (tile, pixelRatio, projection) {
    var layer =
    /** @type {import("../../layer/VectorTile.js").default} */
    this.getLayer();
    var revision = layer.getRevision();
    var renderOrder = layer.getRenderOrder() || null;
    var resolution = tile.wantedResolution;
    var builderState = tile.getReplayState(layer);

    if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder && builderState.renderedZ === tile.sourceZ) {
      return;
    }

    var source = layer.getSource();
    var sourceTileGrid = source.getTileGrid();
    var tileGrid = source.getTileGridForProjection(projection);
    var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
    var sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);
    var layerUid = (0, _util.getUid)(layer);
    delete tile.hitDetectionImageData[layerUid];
    tile.executorGroups[layerUid] = [];

    var _loop_1 = function (t, tt) {
      var sourceTile = sourceTiles[t];

      if (sourceTile.getState() != _TileState.default.LOADED) {
        return "continue";
      }

      var sourceTileCoord = sourceTile.tileCoord;
      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
      var sharedExtent = (0, _extent.getIntersection)(tileExtent, sourceTileExtent);
      var bufferedExtent = (0, _extent.equals)(sourceTileExtent, sharedExtent) ? null : (0, _extent.buffer)(sharedExtent, layer.getRenderBuffer() * resolution, this_1.tmpExtent);
      builderState.dirty = false;
      var builderGroup = new _BuilderGroup.default(0, sharedExtent, resolution, pixelRatio, layer.getDeclutter());
      var squaredTolerance = (0, _vector.getSquaredTolerance)(resolution, pixelRatio);
      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @this {CanvasVectorTileLayerRenderer}
       */

      var render = function (feature) {
        var styles;
        var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();

        if (styleFunction) {
          styles = styleFunction(feature, resolution);
        }

        if (styles) {
          var dirty = this.renderFeature(feature, squaredTolerance, styles, builderGroup);
          this.dirty_ = this.dirty_ || dirty;
          builderState.dirty = builderState.dirty || dirty;
        }
      };

      var features = sourceTile.getFeatures();

      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {
        features.sort(renderOrder);
      }

      for (var i = 0, ii = features.length; i < ii; ++i) {
        var feature = features[i];

        if (!bufferedExtent || (0, _extent.intersects)(bufferedExtent, feature.getGeometry().getExtent())) {
          render.call(this_1, feature);
        }
      }

      var executorGroupInstructions = builderGroup.finish(); // no need to clip when the render tile is covered by a single source tile

      var replayExtent = layer.getRenderMode() !== _VectorTileRenderType.default.VECTOR && layer.getDeclutter() && sourceTiles.length === 1 ? null : sharedExtent;
      var renderingReplayGroup = new _ExecutorGroup.default(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());
      tile.executorGroups[layerUid].push(renderingReplayGroup);
    };

    var this_1 = this;

    for (var t = 0, tt = sourceTiles.length; t < tt; ++t) {
      _loop_1(t, tt);
    }

    builderState.renderedRevision = revision;
    builderState.renderedZ = tile.sourceZ;
    builderState.renderedRenderOrder = renderOrder;
    builderState.renderedResolution = resolution;
  };
  /**
   * @inheritDoc
   */


  CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, declutteredFeatures) {
    var resolution = frameState.viewState.resolution;
    var rotation = frameState.viewState.rotation;
    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;
    var layer =
    /** @type {import("../../layer/VectorTile.js").default} */
    this.getLayer();
    var declutter = layer.getDeclutter();
    var source = layer.getSource();
    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
    /** @type {!Object<string, boolean>} */

    var features = {};
    var renderedTiles =
    /** @type {Array<import("../../VectorRenderTile.js").default>} */
    this.renderedTiles;
    var found;
    var i, ii;

    var _loop_2 = function () {
      var tile = renderedTiles[i];
      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
      var tileContainsCoordinate = (0, _extent.containsCoordinate)(tileExtent, coordinate);

      if (!declutter) {
        // When not decluttering, we only need to consider the tile that contains the given
        // coordinate, because each feature will be rendered for each tile that contains it.
        if (!tileContainsCoordinate) {
          return "continue";
        }
      }

      var executorGroups = tile.executorGroups[(0, _util.getUid)(layer)];

      for (var t = 0, tt = executorGroups.length; t < tt; ++t) {
        var executorGroup = executorGroups[t];
        found = found || executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance,
        /**
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         * @return {?} Callback result.
         */
        function (feature) {
          if (tileContainsCoordinate || declutteredFeatures && declutteredFeatures.indexOf(feature) !== -1) {
            var key = feature.getId();

            if (key === undefined) {
              key = (0, _util.getUid)(feature);
            }

            if (!(key in features)) {
              features[key] = true;
              return callback(feature, layer);
            }
          }
        }, layer.getDeclutter() ? declutteredFeatures : null);
      }
    };

    for (i = 0, ii = renderedTiles.length; i < ii; ++i) {
      _loop_2();
    }

    return found;
  };
  /**
   * @inheritDoc
   */


  CanvasVectorTileLayerRenderer.prototype.getFeatures = function (pixel) {
    return new Promise(function (resolve, reject) {
      var layer =
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer();
      var layerUid = (0, _util.getUid)(layer);
      var source = layer.getSource();
      var projection = this.renderedProjection;
      var projectionExtent = projection.getExtent();
      var resolution = this.renderedResolution;
      var tileGrid = source.getTileGridForProjection(projection);
      var coordinate = (0, _transform.apply)(this.renderedPixelToCoordinateTransform_, pixel.slice());
      var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);
      var tile;

      for (var i = 0, ii = this.renderedTiles.length; i < ii; ++i) {
        if (tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()) {
          tile = this.renderedTiles[i];

          if (tile.getState() === _TileState.default.LOADED && tile.hifi) {
            var extent_1 = tileGrid.getTileCoordExtent(tile.tileCoord);

            if (source.getWrapX() && projection.canWrapX() && !(0, _extent.containsExtent)(projectionExtent, extent_1)) {
              (0, _coordinate.wrapX)(coordinate, projection);
            }

            break;
          }

          tile = undefined;
        }
      }

      if (!tile || tile.loadingSourceTiles > 0) {
        resolve([]);
        return;
      }

      var extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
      var corner = (0, _extent.getTopLeft)(extent);
      var tilePixel = [(coordinate[0] - corner[0]) / resolution, (corner[1] - coordinate[1]) / resolution];
      var features = tile.getSourceTiles().reduce(function (accumulator, sourceTile) {
        return accumulator.concat(sourceTile.getFeatures());
      }, []);
      var hitDetectionImageData = tile.hitDetectionImageData[layerUid];

      if (!hitDetectionImageData && !this.animatingOrInteracting_) {
        var tileSize = (0, _size.toSize)(tileGrid.getTileSize(tileGrid.getZForResolution(resolution)));
        var size = [tileSize[0] / 2, tileSize[1] / 2];
        var rotation = this.renderedRotation_;
        var transforms = [this.getRenderTransform(tileGrid.getTileCoordCenter(tile.wrappedTileCoord), resolution, 0, 0.5, size[0], size[1], 0)];
        hitDetectionImageData = (0, _hitdetect.createHitDetectionImageData)(tileSize, transforms, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile.wrappedTileCoord), tile.getReplayState(layer).renderedResolution, rotation);
        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;
      }

      resolve((0, _hitdetect.hitDetect)(tilePixel, features, hitDetectionImageData));
    }.bind(this));
  };
  /**
   * @inheritDoc
   */


  CanvasVectorTileLayerRenderer.prototype.handleFontsChanged = function () {
    (0, _obj.clear)(this.renderTileImageQueue_);
    var layer = this.getLayer();

    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {
      layer.changed();
    }
  };
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */


  CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function (event) {
    this.renderIfReadyAndVisible();
  };
  /**
   * @inheritDoc
   */


  CanvasVectorTileLayerRenderer.prototype.renderFrame = function (frameState, target) {
    var viewHints = frameState.viewHints;
    var hifi = !(viewHints[_ViewHint.default.ANIMATING] || viewHints[_ViewHint.default.INTERACTING]);
    this.renderQueuedTileImages_(hifi, frameState);

    _super.prototype.renderFrame.call(this, frameState, target);

    this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();
    this.renderedRotation_ = frameState.viewState.rotation;
    var layer =
    /** @type {import("../../layer/VectorTile.js").default} */
    this.getLayer();
    var renderMode = layer.getRenderMode();

    if (renderMode === _VectorTileRenderType.default.IMAGE) {
      return this.container;
    }

    var source = layer.getSource(); // Unqueue tiles from the image queue when we don't need any more

    var usedTiles = frameState.usedTiles[(0, _util.getUid)(source)];

    for (var tileUid in this.renderTileImageQueue_) {
      if (!usedTiles || !(tileUid in usedTiles)) {
        delete this.renderTileImageQueue_[tileUid];
      }
    }

    var context = this.context;
    var declutterReplays = layer.getDeclutter() ? {} : null;
    var replayTypes = VECTOR_REPLAYS[renderMode];
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var center = viewState.center;
    var resolution = viewState.resolution;
    var rotation = viewState.rotation;
    var size = frameState.size;
    var width = Math.round(size[0] * pixelRatio);
    var height = Math.round(size[1] * pixelRatio);
    var tiles = this.renderedTiles;
    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
    var clips = [];
    var clipZs = [];

    for (var i = tiles.length - 1; i >= 0; --i) {
      var tile =
      /** @type {import("../../VectorRenderTile.js").default} */
      tiles[i];
      var tileCoord = tile.tileCoord;
      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
      var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];
      var transform = (0, _transform.multiply)((0, _transform.scale)(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));
      var executorGroups = tile.executorGroups[(0, _util.getUid)(layer)];
      var clipped = false;

      for (var t = 0, tt = executorGroups.length; t < tt; ++t) {
        var executorGroup = executorGroups[t];

        if (!executorGroup.hasExecutors(replayTypes)) {
          // sourceTile has no instructions of the types we want to render
          continue;
        }

        var currentZ = tile.tileCoord[0];
        var currentClip = void 0;

        if (!declutterReplays && !clipped) {
          currentClip = executorGroup.getClipCoords(transform);
          context.save(); // Create a clip mask for regions in this low resolution tile that are
          // already filled by a higher resolution tile

          for (var j = 0, jj = clips.length; j < jj; ++j) {
            var clip = clips[j];

            if (currentZ < clipZs[j]) {
              context.beginPath(); // counter-clockwise (outer ring) for current tile

              context.moveTo(currentClip[0], currentClip[1]);
              context.lineTo(currentClip[2], currentClip[3]);
              context.lineTo(currentClip[4], currentClip[5]);
              context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher resolution tile

              context.moveTo(clip[6], clip[7]);
              context.lineTo(clip[4], clip[5]);
              context.lineTo(clip[2], clip[3]);
              context.lineTo(clip[0], clip[1]);
              context.clip();
            }
          }
        }

        executorGroup.execute(context, transform, rotation, hifi, replayTypes, declutterReplays);

        if (!declutterReplays && !clipped) {
          context.restore();
          clips.push(currentClip);
          clipZs.push(currentZ);
          clipped = true;
        }
      }
    }

    if (declutterReplays) {
      var layerState = frameState.layerStatesArray[frameState.layerIndex];
      (0, _ExecutorGroup.replayDeclutter)(declutterReplays, context, rotation, layerState.opacity, hifi, frameState.declutterItems);
    }

    return this.container;
  };
  /**
   * @param {boolean} hifi We have time to render a high fidelity map image.
   * @param {import('../../PluggableMap.js').FrameState} frameState Frame state.
   */


  CanvasVectorTileLayerRenderer.prototype.renderQueuedTileImages_ = function (hifi, frameState) {
    // When we don't have time to render hifi, only render tiles until we have used up
    // half of the frame budget of 16 ms
    for (var uid in this.renderTileImageQueue_) {
      if (!hifi && Date.now() - frameState.time > 8) {
        frameState.animate = true;
        break;
      }

      var tile = this.renderTileImageQueue_[uid];
      delete this.renderTileImageQueue_[uid];
      this.renderTileImage_(tile, frameState);
    }
  };
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} executorGroup Replay group.
   * @return {boolean} `true` if an image is loading.
   */


  CanvasVectorTileLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, executorGroup) {
    if (!styles) {
      return false;
    }

    var loading = false;

    if (Array.isArray(styles)) {
      for (var i = 0, ii = styles.length; i < ii; ++i) {
        loading = (0, _vector.renderFeature)(executorGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_) || loading;
      }
    } else {
      loading = (0, _vector.renderFeature)(executorGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_);
    }

    return loading;
  };
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @return {boolean} A new tile image was rendered.
   * @private
   */


  CanvasVectorTileLayerRenderer.prototype.tileImageNeedsRender_ = function (tile, pixelRatio, projection) {
    var layer =
    /** @type {import("../../layer/VectorTile.js").default} */
    this.getLayer();
    var replayState = tile.getReplayState(layer);
    var revision = layer.getRevision();
    var sourceZ = tile.sourceZ;
    var resolution = tile.wantedResolution;
    return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision || replayState.renderedTileZ !== sourceZ;
  };
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {import("../../PluggableMap").FrameState} frameState Frame state.
   * @private
   */


  CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function (tile, frameState) {
    var layer =
    /** @type {import("../../layer/VectorTile.js").default} */
    this.getLayer();
    var replayState = tile.getReplayState(layer);
    var revision = layer.getRevision();
    var executorGroups = tile.executorGroups[(0, _util.getUid)(layer)];
    replayState.renderedTileRevision = revision;
    replayState.renderedTileZ = tile.sourceZ;
    var tileCoord = tile.wrappedTileCoord;
    var z = tileCoord[0];
    var source = layer.getSource();
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var tileGrid = source.getTileGridForProjection(projection);
    var tileResolution = tileGrid.getResolution(tile.tileCoord[0]);
    var renderPixelRatio = frameState.pixelRatio / tile.wantedResolution * tileResolution;
    var resolution = tileGrid.getResolution(z);
    var context = tile.getContext(layer); // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles

    pixelRatio = Math.max(pixelRatio, renderPixelRatio / pixelRatio);
    var size = source.getTilePixelSize(z, pixelRatio, projection);
    context.canvas.width = size[0];
    context.canvas.height = size[1];
    var renderScale = pixelRatio / renderPixelRatio;

    if (renderScale !== 1) {
      var canvasTransform = (0, _transform.reset)(this.tmpTransform_);
      (0, _transform.scale)(canvasTransform, renderScale, renderScale);
      context.setTransform.apply(context, canvasTransform);
    }

    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
    var pixelScale = renderPixelRatio / resolution;
    var transform = (0, _transform.reset)(this.tmpTransform_);
    (0, _transform.scale)(transform, pixelScale, -pixelScale);
    (0, _transform.translate)(transform, -tileExtent[0], -tileExtent[3]);

    for (var i = 0, ii = executorGroups.length; i < ii; ++i) {
      var executorGroup = executorGroups[i];
      executorGroup.execute(context, transform, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);
    }

    replayState.renderedTileResolution = tile.wantedResolution;
  };

  return CanvasVectorTileLayerRenderer;
}(_TileLayer.default);

var _default = CanvasVectorTileLayerRenderer;
exports.default = _default;
},{"../../util.js":"node_modules/ol/util.js","../../TileState.js":"node_modules/ol/TileState.js","../../ViewHint.js":"node_modules/ol/ViewHint.js","../../events.js":"node_modules/ol/events.js","../../events/EventType.js":"node_modules/ol/events/EventType.js","../../extent.js":"node_modules/ol/extent.js","../../layer/VectorTileRenderType.js":"node_modules/ol/layer/VectorTileRenderType.js","../../render/canvas/BuilderType.js":"node_modules/ol/render/canvas/BuilderType.js","../../render/canvas/BuilderGroup.js":"node_modules/ol/render/canvas/BuilderGroup.js","./TileLayer.js":"node_modules/ol/renderer/canvas/TileLayer.js","../../size.js":"node_modules/ol/size.js","../vector.js":"node_modules/ol/renderer/vector.js","../../transform.js":"node_modules/ol/transform.js","../../render/canvas/ExecutorGroup.js":"node_modules/ol/render/canvas/ExecutorGroup.js","../../obj.js":"node_modules/ol/obj.js","../../render/canvas/hitdetect.js":"node_modules/ol/render/canvas/hitdetect.js","../../coordinate.js":"node_modules/ol/coordinate.js"}],"node_modules/ol/layer/VectorTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _asserts = require("../asserts.js");

var _TileProperty = _interopRequireDefault(require("./TileProperty.js"));

var _BaseVector = _interopRequireDefault(require("./BaseVector.js"));

var _VectorTileRenderType = _interopRequireDefault(require("./VectorTileRenderType.js"));

var _VectorTileLayer = _interopRequireDefault(require("../renderer/canvas/VectorTileLayer.js"));

var _obj = require("../obj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/VectorTile
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the
 * renderer when getting features from the vector tile for the rendering or hit-detection.
 * Recommended value: Vector tiles are usually generated with a buffer, so this value should match
 * the largest possible buffer of the used tiles. It should be at least the size of the largest
 * point symbol or line width.
 * @property {import("./VectorTileRenderType.js").default|string} [renderMode='hybrid'] Render mode for vector tiles:
 *  * `'image'`: Vector tiles are rendered as images. Great performance, but point symbols and texts
 *    are always rotated with the view and pixels are scaled during zoom animations. When `declutter`
 *    is set to `true`, the decluttering is done per tile resulting in labels and point symbols getting
 *    cut off at tile boundaries.
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom
 *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on
 *    rotated views.
 *  * `'vector'`: Everything is rendered as vectors. Use this mode for improved performance on vector
 *    tile layers with only a few rendered features (e.g. for highlighting a subset of features of
 *    another layer with the same source).
 * @property {import("../source/VectorTile.js").default} [source] Source.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 * @property {import("../style/Style.js").StyleLike} [style] Layer style. See
 * {@link module:ol/style} for default style which will be used if this is not defined.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be
 * recreated during animations. This means that no vectors will be shown clipped, but the setting
 * will have a performance impact for large amounts of vector data. When set to `false`, batches
 * will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be
 * recreated during interactions. See also `updateWhileAnimating`.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 */

/**
 * @classdesc
 * Layer for vector tile data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @param {Options=} opt_options Options.
 * @extends {BaseVectorLayer<import("../source/VectorTile.js").default>}
 * @api
 */
var VectorTileLayer =
/** @class */
function (_super) {
  __extends(VectorTileLayer, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function VectorTileLayer(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var baseOptions =
    /** @type {Object} */
    (0, _obj.assign)({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    _this = _super.call(this,
    /** @type {import("./BaseVector.js").Options} */
    baseOptions) || this;
    var renderMode = options.renderMode || _VectorTileRenderType.default.HYBRID;
    (0, _asserts.assert)(renderMode == undefined || renderMode == _VectorTileRenderType.default.IMAGE || renderMode == _VectorTileRenderType.default.HYBRID || renderMode == _VectorTileRenderType.default.VECTOR, 28); // `renderMode` must be `'image'`, `'hybrid'` or `'vector'`.

    /**
     * @private
     * @type {VectorTileRenderType}
     */

    _this.renderMode_ = renderMode;

    _this.setPreload(options.preload ? options.preload : 0);

    _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);

    return _this;
  }
  /**
   * Create a renderer for this layer.
   * @return {import("../renderer/Layer.js").default} A layer renderer.
   * @protected
   */


  VectorTileLayer.prototype.createRenderer = function () {
    return new _VectorTileLayer.default(this);
  };
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in {@link import("../PluggableMap.js").default#getFeaturesAtPixel}: Text
   * is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
   * @api
   */


  VectorTileLayer.prototype.getFeatures = function (pixel) {
    return _super.prototype.getFeatures.call(this, pixel);
  };
  /**
   * @return {VectorTileRenderType} The render mode.
   */


  VectorTileLayer.prototype.getRenderMode = function () {
    return this.renderMode_;
  };
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */


  VectorTileLayer.prototype.getPreload = function () {
    return (
      /** @type {number} */
      this.get(_TileProperty.default.PRELOAD)
    );
  };
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */


  VectorTileLayer.prototype.getUseInterimTilesOnError = function () {
    return (
      /** @type {boolean} */
      this.get(_TileProperty.default.USE_INTERIM_TILES_ON_ERROR)
    );
  };
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */


  VectorTileLayer.prototype.setPreload = function (preload) {
    this.set(_TileProperty.default.PRELOAD, preload);
  };
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */


  VectorTileLayer.prototype.setUseInterimTilesOnError = function (useInterimTilesOnError) {
    this.set(_TileProperty.default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  };

  return VectorTileLayer;
}(_BaseVector.default);

var _default = VectorTileLayer;
exports.default = _default;
},{"../asserts.js":"node_modules/ol/asserts.js","./TileProperty.js":"node_modules/ol/layer/TileProperty.js","./BaseVector.js":"node_modules/ol/layer/BaseVector.js","./VectorTileRenderType.js":"node_modules/ol/layer/VectorTileRenderType.js","../renderer/canvas/VectorTileLayer.js":"node_modules/ol/renderer/canvas/VectorTileLayer.js","../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Group", {
  enumerable: true,
  get: function () {
    return _Group.default;
  }
});
Object.defineProperty(exports, "Heatmap", {
  enumerable: true,
  get: function () {
    return _Heatmap.default;
  }
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function () {
    return _Image.default;
  }
});
Object.defineProperty(exports, "Layer", {
  enumerable: true,
  get: function () {
    return _Layer.default;
  }
});
Object.defineProperty(exports, "Tile", {
  enumerable: true,
  get: function () {
    return _Tile.default;
  }
});
Object.defineProperty(exports, "Vector", {
  enumerable: true,
  get: function () {
    return _Vector.default;
  }
});
Object.defineProperty(exports, "VectorImage", {
  enumerable: true,
  get: function () {
    return _VectorImage.default;
  }
});
Object.defineProperty(exports, "VectorTile", {
  enumerable: true,
  get: function () {
    return _VectorTile.default;
  }
});

var _Group = _interopRequireDefault(require("./layer/Group.js"));

var _Heatmap = _interopRequireDefault(require("./layer/Heatmap.js"));

var _Image = _interopRequireDefault(require("./layer/Image.js"));

var _Layer = _interopRequireDefault(require("./layer/Layer.js"));

var _Tile = _interopRequireDefault(require("./layer/Tile.js"));

var _Vector = _interopRequireDefault(require("./layer/Vector.js"));

var _VectorImage = _interopRequireDefault(require("./layer/VectorImage.js"));

var _VectorTile = _interopRequireDefault(require("./layer/VectorTile.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./layer/Group.js":"node_modules/ol/layer/Group.js","./layer/Heatmap.js":"node_modules/ol/layer/Heatmap.js","./layer/Image.js":"node_modules/ol/layer/Image.js","./layer/Layer.js":"node_modules/ol/layer/Layer.js","./layer/Tile.js":"node_modules/ol/layer/Tile.js","./layer/Vector.js":"node_modules/ol/layer/Vector.js","./layer/VectorImage.js":"node_modules/ol/layer/VectorImage.js","./layer/VectorTile.js":"node_modules/ol/layer/VectorTile.js"}],"node_modules/jsts/dist/jsts.min.js":[function(require,module,exports) {
var define;
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e678) { throw _e678; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e679) { didErr = true; err = _e679; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * JSTS. See https://github.com/bjornharrtell/jsts
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
 * @license
 */
!function (t, e) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).jsts = {});
}(this, function (t) {
  "use strict";

  var e = /*#__PURE__*/function () {
    function e() {
      _classCallCheck(this, e);
    }

    _createClass(e, null, [{
      key: "equalsWithTolerance",
      value: function equalsWithTolerance(t, e, n) {
        return Math.abs(t - e) <= n;
      }
    }]);

    return e;
  }();

  var n = /*#__PURE__*/function () {
    function n(t) {
      _classCallCheck(this, n);

      this.message = t;
    }

    _createClass(n, [{
      key: "toString",
      value: function toString() {
        return this.message;
      }
    }]);

    return n;
  }();

  var s = /*#__PURE__*/function (_n2) {
    _inherits(s, _n2);

    var _super = _createSuper(s);

    function s() {
      _classCallCheck(this, s);

      return _super.apply(this, arguments);
    }

    return s;
  }(n);

  var i = /*#__PURE__*/function () {
    function i(t, e) {
      _classCallCheck(this, i);

      this.low = e || 0, this.high = t || 0;
    }

    _createClass(i, null, [{
      key: "toBinaryString",
      value: function toBinaryString(t) {
        var e,
            n = "";

        for (e = 2147483648; e > 0; e >>>= 1) {
          n += (t.high & e) === e ? "1" : "0";
        }

        for (e = 2147483648; e > 0; e >>>= 1) {
          n += (t.low & e) === e ? "1" : "0";
        }

        return n;
      }
    }]);

    return i;
  }();

  function r() {}

  function o() {}

  function l() {}

  function a() {}

  function c() {}

  r.NaN = NaN, r.isNaN = function (t) {
    return Number.isNaN(t);
  }, r.isInfinite = function (t) {
    return !Number.isFinite(t);
  }, r.MAX_VALUE = Number.MAX_VALUE, "function" == typeof Float64Array && "function" == typeof Int32Array ? function () {
    var t = new Float64Array(1),
        e = new Int32Array(t.buffer);
    r.doubleToLongBits = function (n) {
      t[0] = n;
      var s = 0 | e[0],
          r = 0 | e[1];
      return 2146435072 == (2146435072 & r) && 0 != (1048575 & r) && 0 !== s && (s = 0, r = 2146959360), new i(r, s);
    }, r.longBitsToDouble = function (n) {
      return e[0] = n.low, e[1] = n.high, t[0];
    };
  }() : function () {
    var t = Math.log2,
        e = Math.floor,
        n = Math.pow,
        s = function () {
      for (var _s2 = 53; _s2 > 0; _s2--) {
        var _i2 = n(2, _s2) - 1;

        if (e(t(_i2)) + 1 === _s2) return _i2;
      }

      return 0;
    }();

    r.doubleToLongBits = function (r) {
      var o, l, a, c, h, u, g, d, _;

      if (r < 0 || 1 / r === Number.NEGATIVE_INFINITY ? (u = 1 << 31, r = -r) : u = 0, 0 === r) return _ = 0, d = u, new i(d, _);
      if (r === 1 / 0) return _ = 0, d = 2146435072 | u, new i(d, _);
      if (r != r) return _ = 0, d = 2146959360, new i(d, _);
      if (c = 0, _ = 0, o = e(r), o > 1) if (o <= s) c = e(t(o)), c <= 20 ? (_ = 0, d = o << 20 - c & 1048575) : (a = c - 20, l = n(2, a), _ = o % l << 32 - a, d = o / l & 1048575);else for (a = o, _ = 0; l = a / 2, a = e(l), 0 !== a;) {
        c++, _ >>>= 1, _ |= (1 & d) << 31, d >>>= 1, l !== a && (d |= 524288);
      }
      if (g = c + 1023, h = 0 === o, o = r - o, c < 52 && 0 !== o) for (a = 0;;) {
        if (l = 2 * o, l >= 1 ? (o = l - 1, h ? (g--, h = !1) : (a <<= 1, a |= 1, c++)) : (o = l, h ? 0 == --g && (c++, h = !1) : (a <<= 1, c++)), 20 === c) d |= a, a = 0;else if (52 === c) {
          _ |= a;
          break;
        }

        if (1 === l) {
          c < 20 ? d |= a << 20 - c : c < 52 && (_ |= a << 52 - c);
          break;
        }
      }
      return d |= g << 20, d |= u, new i(d, _);
    }, r.longBitsToDouble = function (t) {
      var e, s, i, r;
      var o = t.high,
          l = t.low,
          a = o & 1 << 31 ? -1 : 1;

      for (i = ((2146435072 & o) >> 20) - 1023, r = 0, s = 1 << 19, e = 1; e <= 20; e++) {
        o & s && (r += n(2, -e)), s >>>= 1;
      }

      for (s = 1 << 31, e = 21; e <= 52; e++) {
        l & s && (r += n(2, -e)), s >>>= 1;
      }

      if (-1023 === i) {
        if (0 === r) return 0 * a;
        i = -1022;
      } else {
        if (1024 === i) return 0 === r ? a / 0 : NaN;
        r += 1;
      }

      return a * r * n(2, i);
    };
  }();

  var h = /*#__PURE__*/function (_n3) {
    _inherits(h, _n3);

    var _super2 = _createSuper(h);

    function h() {
      _classCallCheck(this, h);

      return _super2.apply(this, arguments);
    }

    return h;
  }(n);

  var u = /*#__PURE__*/function (_h) {
    _inherits(u, _h);

    var _super3 = _createSuper(u);

    function u() {
      var _this;

      _classCallCheck(this, u);

      _this = _super3.call(this), u.constructor_.apply(_assertThisInitialized(_this), arguments);
      return _this;
    }

    _createClass(u, null, [{
      key: "constructor_",
      value: function constructor_() {
        if (0 === arguments.length) h.constructor_.call(this);else if (1 === arguments.length) {
          var _t2 = arguments[0];
          h.constructor_.call(this, _t2);
        }
      }
    }]);

    return u;
  }(h);

  var g = /*#__PURE__*/function () {
    function g() {
      _classCallCheck(this, g);
    }

    _createClass(g, null, [{
      key: "shouldNeverReachHere",
      value: function shouldNeverReachHere() {
        if (0 === arguments.length) g.shouldNeverReachHere(null);else if (1 === arguments.length) {
          var _t3 = arguments[0];
          throw new u("Should never reach here" + (null !== _t3 ? ": " + _t3 : ""));
        }
      }
    }, {
      key: "isTrue",
      value: function isTrue() {
        if (1 === arguments.length) {
          var _t4 = arguments[0];
          g.isTrue(_t4, null);
        } else if (2 === arguments.length) {
          var _t5 = arguments[1];
          if (!arguments[0]) throw null === _t5 ? new u() : new u(_t5);
        }
      }
    }, {
      key: "equals",
      value: function equals() {
        if (2 === arguments.length) {
          var _t6 = arguments[0],
              _e2 = arguments[1];
          g.equals(_t6, _e2, null);
        } else if (3 === arguments.length) {
          var _t7 = arguments[0],
              _e3 = arguments[1],
              _n4 = arguments[2];
          if (!_e3.equals(_t7)) throw new u("Expected " + _t7 + " but encountered " + _e3 + (null !== _n4 ? ": " + _n4 : ""));
        }
      }
    }]);

    return g;
  }();

  var d = new ArrayBuffer(8),
      _ = new Float64Array(d),
      p = new Int32Array(d);

  var m = /*#__PURE__*/function () {
    function m() {
      _classCallCheck(this, m);

      m.constructor_.apply(this, arguments);
    }

    _createClass(m, [{
      key: "getM",
      value: function getM() {
        return r.NaN;
      }
    }, {
      key: "setOrdinate",
      value: function setOrdinate(t, e) {
        switch (t) {
          case m.X:
            this.x = e;
            break;

          case m.Y:
            this.y = e;
            break;

          case m.Z:
            this.setZ(e);
            break;

          default:
            throw new s("Invalid ordinate index: " + t);
        }
      }
    }, {
      key: "equals2D",
      value: function equals2D() {
        if (1 === arguments.length) {
          var _t8 = arguments[0];
          return this.x === _t8.x && this.y === _t8.y;
        }

        if (2 === arguments.length) {
          var _t9 = arguments[0],
              _n5 = arguments[1];
          return !!e.equalsWithTolerance(this.x, _t9.x, _n5) && !!e.equalsWithTolerance(this.y, _t9.y, _n5);
        }
      }
    }, {
      key: "setM",
      value: function setM(t) {
        throw new s("Invalid ordinate index: " + m.M);
      }
    }, {
      key: "getZ",
      value: function getZ() {
        return this.z;
      }
    }, {
      key: "getOrdinate",
      value: function getOrdinate(t) {
        switch (t) {
          case m.X:
            return this.x;

          case m.Y:
            return this.y;

          case m.Z:
            return this.getZ();
        }

        throw new s("Invalid ordinate index: " + t);
      }
    }, {
      key: "equals3D",
      value: function equals3D(t) {
        return this.x === t.x && this.y === t.y && (this.getZ() === t.getZ() || r.isNaN(this.getZ()) && r.isNaN(t.getZ()));
      }
    }, {
      key: "equals",
      value: function equals(t) {
        return t instanceof m && this.equals2D(t);
      }
    }, {
      key: "equalInZ",
      value: function equalInZ(t, n) {
        return e.equalsWithTolerance(this.getZ(), t.getZ(), n);
      }
    }, {
      key: "setX",
      value: function setX(t) {
        this.x = t;
      }
    }, {
      key: "compareTo",
      value: function compareTo(t) {
        var e = t;
        return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0;
      }
    }, {
      key: "getX",
      value: function getX() {
        return this.x;
      }
    }, {
      key: "setZ",
      value: function setZ(t) {
        this.z = t;
      }
    }, {
      key: "clone",
      value: function clone() {
        try {
          return null;
        } catch (t) {
          if (t instanceof CloneNotSupportedException) return g.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null;
          throw t;
        }
      }
    }, {
      key: "copy",
      value: function copy() {
        return new m(this);
      }
    }, {
      key: "toString",
      value: function toString() {
        return "(" + this.x + ", " + this.y + ", " + this.getZ() + ")";
      }
    }, {
      key: "distance3D",
      value: function distance3D(t) {
        var e = this.x - t.x,
            n = this.y - t.y,
            s = this.getZ() - t.getZ();
        return Math.sqrt(e * e + n * n + s * s);
      }
    }, {
      key: "getY",
      value: function getY() {
        return this.y;
      }
    }, {
      key: "setY",
      value: function setY(t) {
        this.y = t;
      }
    }, {
      key: "distance",
      value: function distance(t) {
        var e = this.x - t.x,
            n = this.y - t.y;
        return Math.sqrt(e * e + n * n);
      }
    }, {
      key: "hashCode",
      value: function hashCode() {
        var t = 17;
        return t = 37 * t + m.hashCode(this.x), t = 37 * t + m.hashCode(this.y), t;
      }
    }, {
      key: "setCoordinate",
      value: function setCoordinate(t) {
        this.x = t.x, this.y = t.y, this.z = t.getZ();
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [o, l, c];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) m.constructor_.call(this, 0, 0);else if (1 === arguments.length) {
          var _t10 = arguments[0];
          m.constructor_.call(this, _t10.x, _t10.y, _t10.getZ());
        } else if (2 === arguments.length) {
          var _t11 = arguments[0],
              _e4 = arguments[1];
          m.constructor_.call(this, _t11, _e4, m.NULL_ORDINATE);
        } else if (3 === arguments.length) {
          var _t12 = arguments[0],
              _e5 = arguments[1],
              _n6 = arguments[2];
          this.x = _t12, this.y = _e5, this.z = _n6;
        }
      }
    }, {
      key: "hashCode",
      value: function hashCode(t) {
        return _[0] = t, p[0] ^ p[1];
      }
    }]);

    return m;
  }();

  var f = /*#__PURE__*/function () {
    function f() {
      _classCallCheck(this, f);

      f.constructor_.apply(this, arguments);
    }

    _createClass(f, [{
      key: "compare",
      value: function compare(t, e) {
        var n = f.compare(t.x, e.x);
        if (0 !== n) return n;
        var s = f.compare(t.y, e.y);
        if (0 !== s) return s;
        if (this._dimensionsToTest <= 2) return 0;
        return f.compare(t.getZ(), e.getZ());
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [a];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._dimensionsToTest = 2, 0 === arguments.length) f.constructor_.call(this, 2);else if (1 === arguments.length) {
          var _t13 = arguments[0];
          if (2 !== _t13 && 3 !== _t13) throw new s("only 2 or 3 dimensions may be specified");
          this._dimensionsToTest = _t13;
        }
      }
    }, {
      key: "compare",
      value: function compare(t, e) {
        return t < e ? -1 : t > e ? 1 : r.isNaN(t) ? r.isNaN(e) ? 0 : -1 : r.isNaN(e) ? 1 : 0;
      }
    }]);

    return f;
  }();

  function y(t, e) {
    return t.interfaces_ && t.interfaces_.indexOf(e) > -1;
  }

  m.DimensionalComparator = f, m.NULL_ORDINATE = r.NaN, m.X = 0, m.Y = 1, m.Z = 2, m.M = 3;

  var x = /*#__PURE__*/function () {
    function x() {
      _classCallCheck(this, x);
    }

    _createClass(x, [{
      key: "add",
      value: function add() {}
    }, {
      key: "addAll",
      value: function addAll() {}
    }, {
      key: "isEmpty",
      value: function isEmpty() {}
    }, {
      key: "iterator",
      value: function iterator() {}
    }, {
      key: "size",
      value: function size() {}
    }, {
      key: "toArray",
      value: function toArray() {}
    }, {
      key: "remove",
      value: function remove() {}
    }]);

    return x;
  }();

  var E = /*#__PURE__*/function (_n7) {
    _inherits(E, _n7);

    var _super4 = _createSuper(E);

    function E() {
      _classCallCheck(this, E);

      return _super4.apply(this, arguments);
    }

    return E;
  }(n);

  var I = /*#__PURE__*/function (_x) {
    _inherits(I, _x);

    var _super5 = _createSuper(I);

    function I() {
      _classCallCheck(this, I);

      return _super5.apply(this, arguments);
    }

    _createClass(I, [{
      key: "get",
      value: function get() {}
    }, {
      key: "set",
      value: function set() {}
    }, {
      key: "isEmpty",
      value: function isEmpty() {}
    }]);

    return I;
  }(x);

  var N = /*#__PURE__*/function (_n8) {
    _inherits(N, _n8);

    var _super6 = _createSuper(N);

    function N() {
      _classCallCheck(this, N);

      return _super6.apply(this, arguments);
    }

    return N;
  }(n);

  var S = /*#__PURE__*/function (_I) {
    _inherits(S, _I);

    var _super7 = _createSuper(S);

    function S(t) {
      var _this2;

      _classCallCheck(this, S);

      _this2 = _super7.call(this), _this2.array = [], t instanceof x && _this2.addAll(t);
      return _this2;
    }

    _createClass(S, [{
      key: "ensureCapacity",
      value: function ensureCapacity() {}
    }, {
      key: "add",
      value: function add(t) {
        return 1 === arguments.length ? this.array.push(t) : this.array.splice(arguments[0], 0, arguments[1]), !0;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.array = [];
      }
    }, {
      key: "addAll",
      value: function addAll(t) {
        var _iterator = _createForOfIteratorHelper(t),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _e6 = _step.value;
            this.array.push(_e6);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }, {
      key: "set",
      value: function set(t, e) {
        var n = this.array[t];
        return this.array[t] = e, n;
      }
    }, {
      key: "iterator",
      value: function iterator() {
        return new w(this);
      }
    }, {
      key: "get",
      value: function get(t) {
        if (t < 0 || t >= this.size()) throw new E();
        return this.array[t];
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return 0 === this.array.length;
      }
    }, {
      key: "sort",
      value: function sort(t) {
        t ? this.array.sort(function (e, n) {
          return t.compare(e, n);
        }) : this.array.sort();
      }
    }, {
      key: "size",
      value: function size() {
        return this.array.length;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        return this.array.slice();
      }
    }, {
      key: "remove",
      value: function remove(t) {
        for (var _e7 = 0, _n9 = this.array.length; _e7 < _n9; _e7++) {
          if (this.array[_e7] === t) return !!this.array.splice(_e7, 1);
        }

        return !1;
      }
    }, {
      key: Symbol.iterator,
      value: function value() {
        return this.array.values();
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [I, x];
      }
    }]);

    return S;
  }(I);

  var w = /*#__PURE__*/function () {
    function w(t) {
      _classCallCheck(this, w);

      this.arrayList = t, this.position = 0;
    }

    _createClass(w, [{
      key: "next",
      value: function next() {
        if (this.position === this.arrayList.size()) throw new N();
        return this.arrayList.get(this.position++);
      }
    }, {
      key: "hasNext",
      value: function hasNext() {
        return this.position < this.arrayList.size();
      }
    }, {
      key: "set",
      value: function set(t) {
        return this.arrayList.set(this.position - 1, t);
      }
    }, {
      key: "remove",
      value: function remove() {
        this.arrayList.remove(this.arrayList.get(this.position));
      }
    }]);

    return w;
  }();

  var C = /*#__PURE__*/function (_S) {
    _inherits(C, _S);

    var _super8 = _createSuper(C);

    function C() {
      var _this3;

      _classCallCheck(this, C);

      _this3 = _super8.call(this), C.constructor_.apply(_assertThisInitialized(_this3), arguments);
      return _this3;
    }

    _createClass(C, [{
      key: "getCoordinate",
      value: function getCoordinate(t) {
        return this.get(t);
      }
    }, {
      key: "addAll",
      value: function addAll() {
        if (2 === arguments.length && "boolean" == typeof arguments[1] && y(arguments[0], x)) {
          var _t14 = arguments[1];

          var _e8 = !1;

          for (var _n10 = arguments[0].iterator(); _n10.hasNext();) {
            this.add(_n10.next(), _t14), _e8 = !0;
          }

          return _e8;
        }

        return _get(_getPrototypeOf(C.prototype), "addAll", this).apply(this, arguments);
      }
    }, {
      key: "clone",
      value: function clone() {
        var t = _get(_getPrototypeOf(C.prototype), "clone", this).call(this);

        for (var _e9 = 0; _e9 < this.size(); _e9++) {
          t.add(_e9, this.get(_e9).clone());
        }

        return t;
      }
    }, {
      key: "toCoordinateArray",
      value: function toCoordinateArray() {
        if (0 === arguments.length) return this.toArray(C.coordArrayType);

        if (1 === arguments.length) {
          if (arguments[0]) return this.toArray(C.coordArrayType);

          var _t15 = this.size(),
              _e10 = new Array(_t15).fill(null);

          for (var _n11 = 0; _n11 < _t15; _n11++) {
            _e10[_n11] = this.get(_t15 - _n11 - 1);
          }

          return _e10;
        }
      }
    }, {
      key: "add",
      value: function add() {
        if (1 === arguments.length) {
          var _t16 = arguments[0];
          return _get(_getPrototypeOf(C.prototype), "add", this).call(this, _t16);
        }

        if (2 === arguments.length) {
          if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
            var _t17 = arguments[0],
                _e11 = arguments[1];
            return this.add(_t17, _e11, !0), !0;
          }

          if (arguments[0] instanceof m && "boolean" == typeof arguments[1]) {
            var _t18 = arguments[0];

            if (!arguments[1] && this.size() >= 1) {
              if (this.get(this.size() - 1).equals2D(_t18)) return null;
            }

            _get(_getPrototypeOf(C.prototype), "add", this).call(this, _t18);
          } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
            var _t19 = arguments[0],
                _e12 = arguments[1];
            return this.add(_t19, _e12), !0;
          }
        } else if (3 === arguments.length) {
          if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
            var _t20 = arguments[0],
                _e13 = arguments[1];
            if (arguments[2]) for (var _n12 = 0; _n12 < _t20.length; _n12++) {
              this.add(_t20[_n12], _e13);
            } else for (var _n13 = _t20.length - 1; _n13 >= 0; _n13--) {
              this.add(_t20[_n13], _e13);
            }
            return !0;
          }

          if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof m) {
            var _t21 = arguments[0],
                _e14 = arguments[1];

            if (!arguments[2]) {
              var _n14 = this.size();

              if (_n14 > 0) {
                if (_t21 > 0) {
                  if (this.get(_t21 - 1).equals2D(_e14)) return null;
                }

                if (_t21 < _n14) {
                  if (this.get(_t21).equals2D(_e14)) return null;
                }
              }
            }

            _get(_getPrototypeOf(C.prototype), "add", this).call(this, _t21, _e14);
          }
        } else if (4 === arguments.length) {
          var _t22 = arguments[0],
              _e15 = arguments[1],
              _n15 = arguments[2],
              _s3 = arguments[3];
          var _i3 = 1;
          _n15 > _s3 && (_i3 = -1);

          for (var _r2 = _n15; _r2 !== _s3; _r2 += _i3) {
            this.add(_t22[_r2], _e15);
          }

          return !0;
        }
      }
    }, {
      key: "closeRing",
      value: function closeRing() {
        if (this.size() > 0) {
          var _t23 = this.get(0).copy();

          this.add(_t23, !1);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (0 === arguments.length) ;else if (1 === arguments.length) {
          var _t24 = arguments[0];
          this.ensureCapacity(_t24.length), this.add(_t24, !0);
        } else if (2 === arguments.length) {
          var _t25 = arguments[0],
              _e16 = arguments[1];
          this.ensureCapacity(_t25.length), this.add(_t25, _e16);
        }
      }
    }]);

    return C;
  }(S);

  C.coordArrayType = new Array(0).fill(null);

  var L = /*#__PURE__*/function () {
    function L() {
      _classCallCheck(this, L);
    }

    _createClass(L, [{
      key: "filter",
      value: function filter(t, e) {}
    }, {
      key: "isDone",
      value: function isDone() {}
    }, {
      key: "isGeometryChanged",
      value: function isGeometryChanged() {}
    }]);

    return L;
  }();

  var T = /*#__PURE__*/function () {
    function T() {
      _classCallCheck(this, T);

      T.constructor_.apply(this, arguments);
    }

    _createClass(T, [{
      key: "getArea",
      value: function getArea() {
        return this.getWidth() * this.getHeight();
      }
    }, {
      key: "equals",
      value: function equals(t) {
        if (!(t instanceof T)) return !1;
        var e = t;
        return this.isNull() ? e.isNull() : this._maxx === e.getMaxX() && this._maxy === e.getMaxY() && this._minx === e.getMinX() && this._miny === e.getMinY();
      }
    }, {
      key: "intersection",
      value: function intersection(t) {
        if (this.isNull() || t.isNull() || !this.intersects(t)) return new T();
        var e = this._minx > t._minx ? this._minx : t._minx,
            n = this._miny > t._miny ? this._miny : t._miny,
            s = this._maxx < t._maxx ? this._maxx : t._maxx,
            i = this._maxy < t._maxy ? this._maxy : t._maxy;
        return new T(e, s, n, i);
      }
    }, {
      key: "isNull",
      value: function isNull() {
        return this._maxx < this._minx;
      }
    }, {
      key: "getMaxX",
      value: function getMaxX() {
        return this._maxx;
      }
    }, {
      key: "covers",
      value: function covers() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof m) {
            var _t26 = arguments[0];
            return this.covers(_t26.x, _t26.y);
          }

          if (arguments[0] instanceof T) {
            var _t27 = arguments[0];
            return !this.isNull() && !_t27.isNull() && _t27.getMinX() >= this._minx && _t27.getMaxX() <= this._maxx && _t27.getMinY() >= this._miny && _t27.getMaxY() <= this._maxy;
          }
        } else if (2 === arguments.length) {
          var _t28 = arguments[0],
              _e17 = arguments[1];
          return !this.isNull() && _t28 >= this._minx && _t28 <= this._maxx && _e17 >= this._miny && _e17 <= this._maxy;
        }
      }
    }, {
      key: "intersects",
      value: function intersects() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof T) {
            var _t29 = arguments[0];
            return !this.isNull() && !_t29.isNull() && !(_t29._minx > this._maxx || _t29._maxx < this._minx || _t29._miny > this._maxy || _t29._maxy < this._miny);
          }

          if (arguments[0] instanceof m) {
            var _t30 = arguments[0];
            return this.intersects(_t30.x, _t30.y);
          }
        } else if (2 === arguments.length) {
          if (arguments[0] instanceof m && arguments[1] instanceof m) {
            var _t31 = arguments[0],
                _e18 = arguments[1];
            if (this.isNull()) return !1;
            if ((_t31.x < _e18.x ? _t31.x : _e18.x) > this._maxx) return !1;
            if ((_t31.x > _e18.x ? _t31.x : _e18.x) < this._minx) return !1;
            if ((_t31.y < _e18.y ? _t31.y : _e18.y) > this._maxy) return !1;
            return !((_t31.y > _e18.y ? _t31.y : _e18.y) < this._miny);
          }

          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var _t32 = arguments[0],
                _e19 = arguments[1];
            return !this.isNull() && !(_t32 > this._maxx || _t32 < this._minx || _e19 > this._maxy || _e19 < this._miny);
          }
        }
      }
    }, {
      key: "getMinY",
      value: function getMinY() {
        return this._miny;
      }
    }, {
      key: "getDiameter",
      value: function getDiameter() {
        if (this.isNull()) return 0;
        var t = this.getWidth(),
            e = this.getHeight();
        return Math.sqrt(t * t + e * e);
      }
    }, {
      key: "getMinX",
      value: function getMinX() {
        return this._minx;
      }
    }, {
      key: "expandToInclude",
      value: function expandToInclude() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof m) {
            var _t33 = arguments[0];
            this.expandToInclude(_t33.x, _t33.y);
          } else if (arguments[0] instanceof T) {
            var _t34 = arguments[0];
            if (_t34.isNull()) return null;
            this.isNull() ? (this._minx = _t34.getMinX(), this._maxx = _t34.getMaxX(), this._miny = _t34.getMinY(), this._maxy = _t34.getMaxY()) : (_t34._minx < this._minx && (this._minx = _t34._minx), _t34._maxx > this._maxx && (this._maxx = _t34._maxx), _t34._miny < this._miny && (this._miny = _t34._miny), _t34._maxy > this._maxy && (this._maxy = _t34._maxy));
          }
        } else if (2 === arguments.length) {
          var _t35 = arguments[0],
              _e20 = arguments[1];
          this.isNull() ? (this._minx = _t35, this._maxx = _t35, this._miny = _e20, this._maxy = _e20) : (_t35 < this._minx && (this._minx = _t35), _t35 > this._maxx && (this._maxx = _t35), _e20 < this._miny && (this._miny = _e20), _e20 > this._maxy && (this._maxy = _e20));
        }
      }
    }, {
      key: "minExtent",
      value: function minExtent() {
        if (this.isNull()) return 0;
        var t = this.getWidth(),
            e = this.getHeight();
        return t < e ? t : e;
      }
    }, {
      key: "getWidth",
      value: function getWidth() {
        return this.isNull() ? 0 : this._maxx - this._minx;
      }
    }, {
      key: "compareTo",
      value: function compareTo(t) {
        var e = t;
        return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this._minx < e._minx ? -1 : this._minx > e._minx ? 1 : this._miny < e._miny ? -1 : this._miny > e._miny ? 1 : this._maxx < e._maxx ? -1 : this._maxx > e._maxx ? 1 : this._maxy < e._maxy ? -1 : this._maxy > e._maxy ? 1 : 0;
      }
    }, {
      key: "translate",
      value: function translate(t, e) {
        if (this.isNull()) return null;
        this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e);
      }
    }, {
      key: "copy",
      value: function copy() {
        return new T(this);
      }
    }, {
      key: "toString",
      value: function toString() {
        return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
      }
    }, {
      key: "setToNull",
      value: function setToNull() {
        this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
      }
    }, {
      key: "disjoint",
      value: function disjoint(t) {
        return !(!this.isNull() && !t.isNull()) || t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny;
      }
    }, {
      key: "getHeight",
      value: function getHeight() {
        return this.isNull() ? 0 : this._maxy - this._miny;
      }
    }, {
      key: "maxExtent",
      value: function maxExtent() {
        if (this.isNull()) return 0;
        var t = this.getWidth(),
            e = this.getHeight();
        return t > e ? t : e;
      }
    }, {
      key: "expandBy",
      value: function expandBy() {
        if (1 === arguments.length) {
          var _t36 = arguments[0];
          this.expandBy(_t36, _t36);
        } else if (2 === arguments.length) {
          var _t37 = arguments[0],
              _e21 = arguments[1];
          if (this.isNull()) return null;
          this._minx -= _t37, this._maxx += _t37, this._miny -= _e21, this._maxy += _e21, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
        }
      }
    }, {
      key: "contains",
      value: function contains() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof T) {
            var _t38 = arguments[0];
            return this.covers(_t38);
          }

          if (arguments[0] instanceof m) {
            var _t39 = arguments[0];
            return this.covers(_t39);
          }
        } else if (2 === arguments.length) {
          var _t40 = arguments[0],
              _e22 = arguments[1];
          return this.covers(_t40, _e22);
        }
      }
    }, {
      key: "centre",
      value: function centre() {
        return this.isNull() ? null : new m((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
      }
    }, {
      key: "init",
      value: function init() {
        if (0 === arguments.length) this.setToNull();else if (1 === arguments.length) {
          if (arguments[0] instanceof m) {
            var _t41 = arguments[0];
            this.init(_t41.x, _t41.x, _t41.y, _t41.y);
          } else if (arguments[0] instanceof T) {
            var _t42 = arguments[0];
            this._minx = _t42._minx, this._maxx = _t42._maxx, this._miny = _t42._miny, this._maxy = _t42._maxy;
          }
        } else if (2 === arguments.length) {
          var _t43 = arguments[0],
              _e23 = arguments[1];
          this.init(_t43.x, _e23.x, _t43.y, _e23.y);
        } else if (4 === arguments.length) {
          var _t44 = arguments[0],
              _e24 = arguments[1],
              _n16 = arguments[2],
              _s4 = arguments[3];
          _t44 < _e24 ? (this._minx = _t44, this._maxx = _e24) : (this._minx = _e24, this._maxx = _t44), _n16 < _s4 ? (this._miny = _n16, this._maxy = _s4) : (this._miny = _s4, this._maxy = _n16);
        }
      }
    }, {
      key: "getMaxY",
      value: function getMaxY() {
        return this._maxy;
      }
    }, {
      key: "distance",
      value: function distance(t) {
        if (this.intersects(t)) return 0;
        var e = 0;
        this._maxx < t._minx ? e = t._minx - this._maxx : this._minx > t._maxx && (e = this._minx - t._maxx);
        var n = 0;
        return this._maxy < t._miny ? n = t._miny - this._maxy : this._miny > t._maxy && (n = this._miny - t._maxy), 0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n);
      }
    }, {
      key: "hashCode",
      value: function hashCode() {
        var t = 17;
        return t = 37 * t + m.hashCode(this._minx), t = 37 * t + m.hashCode(this._maxx), t = 37 * t + m.hashCode(this._miny), t = 37 * t + m.hashCode(this._maxy), t;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [o, c];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length) this.init();else if (1 === arguments.length) {
          if (arguments[0] instanceof m) {
            var _t45 = arguments[0];
            this.init(_t45.x, _t45.x, _t45.y, _t45.y);
          } else if (arguments[0] instanceof T) {
            var _t46 = arguments[0];
            this.init(_t46);
          }
        } else if (2 === arguments.length) {
          var _t47 = arguments[0],
              _e25 = arguments[1];
          this.init(_t47.x, _e25.x, _t47.y, _e25.y);
        } else if (4 === arguments.length) {
          var _t48 = arguments[0],
              _e26 = arguments[1],
              _n17 = arguments[2],
              _s5 = arguments[3];
          this.init(_t48, _e26, _n17, _s5);
        }
      }
    }, {
      key: "intersects",
      value: function intersects() {
        if (3 === arguments.length) {
          var _t49 = arguments[0],
              _e27 = arguments[1],
              _n18 = arguments[2];
          return _n18.x >= (_t49.x < _e27.x ? _t49.x : _e27.x) && _n18.x <= (_t49.x > _e27.x ? _t49.x : _e27.x) && _n18.y >= (_t49.y < _e27.y ? _t49.y : _e27.y) && _n18.y <= (_t49.y > _e27.y ? _t49.y : _e27.y);
        }

        if (4 === arguments.length) {
          var _t50 = arguments[0],
              _e28 = arguments[1],
              _n19 = arguments[2],
              _s6 = arguments[3];

          var _i4 = Math.min(_n19.x, _s6.x),
              _r3 = Math.max(_n19.x, _s6.x),
              _o2 = Math.min(_t50.x, _e28.x),
              _l2 = Math.max(_t50.x, _e28.x);

          return !(_o2 > _r3) && !(_l2 < _i4) && (_i4 = Math.min(_n19.y, _s6.y), _r3 = Math.max(_n19.y, _s6.y), _o2 = Math.min(_t50.y, _e28.y), _l2 = Math.max(_t50.y, _e28.y), !(_o2 > _r3) && !(_l2 < _i4));
        }
      }
    }]);

    return T;
  }();

  var R = /*#__PURE__*/function () {
    function R(t) {
      _classCallCheck(this, R);

      this.str = t;
    }

    _createClass(R, [{
      key: "append",
      value: function append(t) {
        this.str += t;
      }
    }, {
      key: "setCharAt",
      value: function setCharAt(t, e) {
        this.str = this.str.substr(0, t) + e + this.str.substr(t + 1);
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.str;
      }
    }]);

    return R;
  }();

  var P = /*#__PURE__*/function () {
    function P(t) {
      _classCallCheck(this, P);

      this.value = t;
    }

    _createClass(P, [{
      key: "intValue",
      value: function intValue() {
        return this.value;
      }
    }, {
      key: "compareTo",
      value: function compareTo(t) {
        return this.value < t ? -1 : this.value > t ? 1 : 0;
      }
    }], [{
      key: "compare",
      value: function compare(t, e) {
        return t < e ? -1 : t > e ? 1 : 0;
      }
    }, {
      key: "isNan",
      value: function isNan(t) {
        return Number.isNaN(t);
      }
    }, {
      key: "valueOf",
      value: function valueOf(t) {
        return new P(t);
      }
    }]);

    return P;
  }();

  var O = /*#__PURE__*/function () {
    function O() {
      _classCallCheck(this, O);
    }

    _createClass(O, null, [{
      key: "isWhitespace",
      value: function isWhitespace(t) {
        return t <= 32 && t >= 0 || 127 === t;
      }
    }, {
      key: "toUpperCase",
      value: function toUpperCase(t) {
        return t.toUpperCase();
      }
    }]);

    return O;
  }();

  var v = /*#__PURE__*/function () {
    function v() {
      _classCallCheck(this, v);

      v.constructor_.apply(this, arguments);
    }

    _createClass(v, [{
      key: "le",
      value: function le(t) {
        return this._hi < t._hi || this._hi === t._hi && this._lo <= t._lo;
      }
    }, {
      key: "extractSignificantDigits",
      value: function extractSignificantDigits(t, e) {
        var n = this.abs(),
            s = v.magnitude(n._hi);
        var i = v.TEN.pow(s);
        n = n.divide(i), n.gt(v.TEN) ? (n = n.divide(v.TEN), s += 1) : n.lt(v.ONE) && (n = n.multiply(v.TEN), s -= 1);
        var r = s + 1,
            o = new R(),
            l = v.MAX_PRINT_DIGITS - 1;

        for (var _e29 = 0; _e29 <= l; _e29++) {
          t && _e29 === r && o.append(".");

          var _s7 = Math.trunc(n._hi);

          if (_s7 < 0) break;

          var _i5 = !1,
              _a = 0;

          _s7 > 9 ? (_i5 = !0, _a = "9") : _a = "0" + _s7, o.append(_a), n = n.subtract(v.valueOf(_s7)).multiply(v.TEN), _i5 && n.selfAdd(v.TEN);

          var _c = !0;

          var _h2 = v.magnitude(n._hi);

          if (_h2 < 0 && Math.abs(_h2) >= l - _e29 && (_c = !1), !_c) break;
        }

        return e[0] = s, o.toString();
      }
    }, {
      key: "sqr",
      value: function sqr() {
        return this.multiply(this);
      }
    }, {
      key: "doubleValue",
      value: function doubleValue() {
        return this._hi + this._lo;
      }
    }, {
      key: "subtract",
      value: function subtract() {
        if (arguments[0] instanceof v) {
          var _t51 = arguments[0];
          return this.add(_t51.negate());
        }

        if ("number" == typeof arguments[0]) {
          var _t52 = arguments[0];
          return this.add(-_t52);
        }
      }
    }, {
      key: "equals",
      value: function equals() {
        if (1 === arguments.length && arguments[0] instanceof v) {
          var _t53 = arguments[0];
          return this._hi === _t53._hi && this._lo === _t53._lo;
        }
      }
    }, {
      key: "isZero",
      value: function isZero() {
        return 0 === this._hi && 0 === this._lo;
      }
    }, {
      key: "selfSubtract",
      value: function selfSubtract() {
        if (arguments[0] instanceof v) {
          var _t54 = arguments[0];
          return this.isNaN() ? this : this.selfAdd(-_t54._hi, -_t54._lo);
        }

        if ("number" == typeof arguments[0]) {
          var _t55 = arguments[0];
          return this.isNaN() ? this : this.selfAdd(-_t55, 0);
        }
      }
    }, {
      key: "getSpecialNumberString",
      value: function getSpecialNumberString() {
        return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
      }
    }, {
      key: "min",
      value: function min(t) {
        return this.le(t) ? this : t;
      }
    }, {
      key: "selfDivide",
      value: function selfDivide() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof v) {
            var _t56 = arguments[0];
            return this.selfDivide(_t56._hi, _t56._lo);
          }

          if ("number" == typeof arguments[0]) {
            var _t57 = arguments[0];
            return this.selfDivide(_t57, 0);
          }
        } else if (2 === arguments.length) {
          var _t58 = arguments[0],
              _e30 = arguments[1];
          var _n20 = null,
              _s8 = null,
              _i6 = null,
              _r4 = null,
              _o3 = null,
              _l3 = null,
              _a2 = null,
              _c2 = null;
          return _o3 = this._hi / _t58, _l3 = v.SPLIT * _o3, _n20 = _l3 - _o3, _c2 = v.SPLIT * _t58, _n20 = _l3 - _n20, _s8 = _o3 - _n20, _i6 = _c2 - _t58, _a2 = _o3 * _t58, _i6 = _c2 - _i6, _r4 = _t58 - _i6, _c2 = _n20 * _i6 - _a2 + _n20 * _r4 + _s8 * _i6 + _s8 * _r4, _l3 = (this._hi - _a2 - _c2 + this._lo - _o3 * _e30) / _t58, _c2 = _o3 + _l3, this._hi = _c2, this._lo = _o3 - _c2 + _l3, this;
        }
      }
    }, {
      key: "dump",
      value: function dump() {
        return "DD<" + this._hi + ", " + this._lo + ">";
      }
    }, {
      key: "divide",
      value: function divide() {
        if (arguments[0] instanceof v) {
          var _t59 = arguments[0];
          var _e31 = null,
              _n21 = null,
              _s9 = null,
              _i7 = null,
              _r5 = null,
              _o4 = null,
              _l4 = null,
              _a3 = null;
          _r5 = this._hi / _t59._hi, _o4 = v.SPLIT * _r5, _e31 = _o4 - _r5, _a3 = v.SPLIT * _t59._hi, _e31 = _o4 - _e31, _n21 = _r5 - _e31, _s9 = _a3 - _t59._hi, _l4 = _r5 * _t59._hi, _s9 = _a3 - _s9, _i7 = _t59._hi - _s9, _a3 = _e31 * _s9 - _l4 + _e31 * _i7 + _n21 * _s9 + _n21 * _i7, _o4 = (this._hi - _l4 - _a3 + this._lo - _r5 * _t59._lo) / _t59._hi, _a3 = _r5 + _o4;
          return new v(_a3, _r5 - _a3 + _o4);
        }

        if ("number" == typeof arguments[0]) {
          var _t60 = arguments[0];
          return r.isNaN(_t60) ? v.createNaN() : v.copy(this).selfDivide(_t60, 0);
        }
      }
    }, {
      key: "ge",
      value: function ge(t) {
        return this._hi > t._hi || this._hi === t._hi && this._lo >= t._lo;
      }
    }, {
      key: "pow",
      value: function pow(t) {
        if (0 === t) return v.valueOf(1);
        var e = new v(this),
            n = v.valueOf(1),
            s = Math.abs(t);
        if (s > 1) for (; s > 0;) {
          s % 2 == 1 && n.selfMultiply(e), s /= 2, s > 0 && (e = e.sqr());
        } else n = e;
        return t < 0 ? n.reciprocal() : n;
      }
    }, {
      key: "ceil",
      value: function ceil() {
        if (this.isNaN()) return v.NaN;
        var t = Math.ceil(this._hi);
        var e = 0;
        return t === this._hi && (e = Math.ceil(this._lo)), new v(t, e);
      }
    }, {
      key: "compareTo",
      value: function compareTo(t) {
        var e = t;
        return this._hi < e._hi ? -1 : this._hi > e._hi ? 1 : this._lo < e._lo ? -1 : this._lo > e._lo ? 1 : 0;
      }
    }, {
      key: "rint",
      value: function rint() {
        if (this.isNaN()) return this;
        return this.add(.5).floor();
      }
    }, {
      key: "setValue",
      value: function setValue() {
        if (arguments[0] instanceof v) {
          var _t61 = arguments[0];
          return this.init(_t61), this;
        }

        if ("number" == typeof arguments[0]) {
          var _t62 = arguments[0];
          return this.init(_t62), this;
        }
      }
    }, {
      key: "max",
      value: function max(t) {
        return this.ge(t) ? this : t;
      }
    }, {
      key: "sqrt",
      value: function sqrt() {
        if (this.isZero()) return v.valueOf(0);
        if (this.isNegative()) return v.NaN;
        var t = 1 / Math.sqrt(this._hi),
            e = this._hi * t,
            n = v.valueOf(e),
            s = this.subtract(n.sqr())._hi * (.5 * t);
        return n.add(s);
      }
    }, {
      key: "selfAdd",
      value: function selfAdd() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof v) {
            var _t63 = arguments[0];
            return this.selfAdd(_t63._hi, _t63._lo);
          }

          if ("number" == typeof arguments[0]) {
            var _t64 = arguments[0];
            var _e32 = null,
                _n22 = null,
                _s10 = null,
                _i8 = null,
                _r6 = null,
                _o5 = null;
            return _s10 = this._hi + _t64, _r6 = _s10 - this._hi, _i8 = _s10 - _r6, _i8 = _t64 - _r6 + (this._hi - _i8), _o5 = _i8 + this._lo, _e32 = _s10 + _o5, _n22 = _o5 + (_s10 - _e32), this._hi = _e32 + _n22, this._lo = _n22 + (_e32 - this._hi), this;
          }
        } else if (2 === arguments.length) {
          var _t65 = arguments[0],
              _e33 = arguments[1];
          var _n23 = null,
              _s11 = null,
              _i9 = null,
              _r7 = null,
              _o6 = null,
              _l5 = null,
              _a4 = null,
              _c3 = null;
          _o6 = this._hi + _t65, _i9 = this._lo + _e33, _a4 = _o6 - this._hi, _c3 = _i9 - this._lo, _l5 = _o6 - _a4, _r7 = _i9 - _c3, _l5 = _t65 - _a4 + (this._hi - _l5), _r7 = _e33 - _c3 + (this._lo - _r7), _a4 = _l5 + _i9, _n23 = _o6 + _a4, _s11 = _a4 + (_o6 - _n23), _a4 = _r7 + _s11;

          var _h3 = _n23 + _a4,
              _u = _a4 + (_n23 - _h3);

          return this._hi = _h3, this._lo = _u, this;
        }
      }
    }, {
      key: "selfMultiply",
      value: function selfMultiply() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof v) {
            var _t66 = arguments[0];
            return this.selfMultiply(_t66._hi, _t66._lo);
          }

          if ("number" == typeof arguments[0]) {
            var _t67 = arguments[0];
            return this.selfMultiply(_t67, 0);
          }
        } else if (2 === arguments.length) {
          var _t68 = arguments[0],
              _e34 = arguments[1];
          var _n24 = null,
              _s12 = null,
              _i10 = null,
              _r8 = null,
              _o7 = null,
              _l6 = null;
          _o7 = v.SPLIT * this._hi, _n24 = _o7 - this._hi, _l6 = v.SPLIT * _t68, _n24 = _o7 - _n24, _s12 = this._hi - _n24, _i10 = _l6 - _t68, _o7 = this._hi * _t68, _i10 = _l6 - _i10, _r8 = _t68 - _i10, _l6 = _n24 * _i10 - _o7 + _n24 * _r8 + _s12 * _i10 + _s12 * _r8 + (this._hi * _e34 + this._lo * _t68);

          var _a5 = _o7 + _l6;

          _n24 = _o7 - _a5;

          var _c4 = _l6 + _n24;

          return this._hi = _a5, this._lo = _c4, this;
        }
      }
    }, {
      key: "selfSqr",
      value: function selfSqr() {
        return this.selfMultiply(this);
      }
    }, {
      key: "floor",
      value: function floor() {
        if (this.isNaN()) return v.NaN;
        var t = Math.floor(this._hi);
        var e = 0;
        return t === this._hi && (e = Math.floor(this._lo)), new v(t, e);
      }
    }, {
      key: "negate",
      value: function negate() {
        return this.isNaN() ? this : new v(-this._hi, -this._lo);
      }
    }, {
      key: "clone",
      value: function clone() {
        try {
          return null;
        } catch (t) {
          if (t instanceof CloneNotSupportedException) return null;
          throw t;
        }
      }
    }, {
      key: "multiply",
      value: function multiply() {
        if (arguments[0] instanceof v) {
          var _t69 = arguments[0];
          return _t69.isNaN() ? v.createNaN() : v.copy(this).selfMultiply(_t69);
        }

        if ("number" == typeof arguments[0]) {
          var _t70 = arguments[0];
          return r.isNaN(_t70) ? v.createNaN() : v.copy(this).selfMultiply(_t70, 0);
        }
      }
    }, {
      key: "isNaN",
      value: function isNaN() {
        return r.isNaN(this._hi);
      }
    }, {
      key: "intValue",
      value: function intValue() {
        return Math.trunc(this._hi);
      }
    }, {
      key: "toString",
      value: function toString() {
        var t = v.magnitude(this._hi);
        return t >= -3 && t <= 20 ? this.toStandardNotation() : this.toSciNotation();
      }
    }, {
      key: "toStandardNotation",
      value: function toStandardNotation() {
        var t = this.getSpecialNumberString();
        if (null !== t) return t;
        var e = new Array(1).fill(null),
            n = this.extractSignificantDigits(!0, e),
            s = e[0] + 1;
        var i = n;
        if ("." === n.charAt(0)) i = "0" + n;else if (s < 0) i = "0." + v.stringOfChar("0", -s) + n;else if (-1 === n.indexOf(".")) {
          var _t71 = s - n.length;

          i = n + v.stringOfChar("0", _t71) + ".0";
        }
        return this.isNegative() ? "-" + i : i;
      }
    }, {
      key: "reciprocal",
      value: function reciprocal() {
        var t = null,
            e = null,
            n = null,
            s = null,
            i = null,
            r = null,
            o = null,
            l = null;
        i = 1 / this._hi, r = v.SPLIT * i, t = r - i, l = v.SPLIT * this._hi, t = r - t, e = i - t, n = l - this._hi, o = i * this._hi, n = l - n, s = this._hi - n, l = t * n - o + t * s + e * n + e * s, r = (1 - o - l - i * this._lo) / this._hi;
        var a = i + r;
        return new v(a, i - a + r);
      }
    }, {
      key: "toSciNotation",
      value: function toSciNotation() {
        if (this.isZero()) return v.SCI_NOT_ZERO;
        var t = this.getSpecialNumberString();
        if (null !== t) return t;
        var e = new Array(1).fill(null),
            n = this.extractSignificantDigits(!1, e),
            s = v.SCI_NOT_EXPONENT_CHAR + e[0];
        if ("0" === n.charAt(0)) throw new IllegalStateException("Found leading zero: " + n);
        var i = "";
        n.length > 1 && (i = n.substring(1));
        var r = n.charAt(0) + "." + i;
        return this.isNegative() ? "-" + r + s : r + s;
      }
    }, {
      key: "abs",
      value: function abs() {
        return this.isNaN() ? v.NaN : this.isNegative() ? this.negate() : new v(this);
      }
    }, {
      key: "isPositive",
      value: function isPositive() {
        return this._hi > 0 || 0 === this._hi && this._lo > 0;
      }
    }, {
      key: "lt",
      value: function lt(t) {
        return this._hi < t._hi || this._hi === t._hi && this._lo < t._lo;
      }
    }, {
      key: "add",
      value: function add() {
        if (arguments[0] instanceof v) {
          var _t72 = arguments[0];
          return v.copy(this).selfAdd(_t72);
        }

        if ("number" == typeof arguments[0]) {
          var _t73 = arguments[0];
          return v.copy(this).selfAdd(_t73);
        }
      }
    }, {
      key: "init",
      value: function init() {
        if (1 === arguments.length) {
          if ("number" == typeof arguments[0]) {
            var _t74 = arguments[0];
            this._hi = _t74, this._lo = 0;
          } else if (arguments[0] instanceof v) {
            var _t75 = arguments[0];
            this._hi = _t75._hi, this._lo = _t75._lo;
          }
        } else if (2 === arguments.length) {
          var _t76 = arguments[0],
              _e35 = arguments[1];
          this._hi = _t76, this._lo = _e35;
        }
      }
    }, {
      key: "gt",
      value: function gt(t) {
        return this._hi > t._hi || this._hi === t._hi && this._lo > t._lo;
      }
    }, {
      key: "isNegative",
      value: function isNegative() {
        return this._hi < 0 || 0 === this._hi && this._lo < 0;
      }
    }, {
      key: "trunc",
      value: function trunc() {
        return this.isNaN() ? v.NaN : this.isPositive() ? this.floor() : this.ceil();
      }
    }, {
      key: "signum",
      value: function signum() {
        return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [c, o, l];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._hi = 0, this._lo = 0, 0 === arguments.length) this.init(0);else if (1 === arguments.length) {
          if ("number" == typeof arguments[0]) {
            var _t77 = arguments[0];
            this.init(_t77);
          } else if (arguments[0] instanceof v) {
            var _t78 = arguments[0];
            this.init(_t78);
          } else if ("string" == typeof arguments[0]) {
            var _t79 = arguments[0];
            v.constructor_.call(this, v.parse(_t79));
          }
        } else if (2 === arguments.length) {
          var _t80 = arguments[0],
              _e36 = arguments[1];
          this.init(_t80, _e36);
        }
      }
    }, {
      key: "determinant",
      value: function determinant() {
        if ("number" == typeof arguments[3] && "number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
          var _t81 = arguments[0],
              _e37 = arguments[1],
              _n25 = arguments[2],
              _s13 = arguments[3];
          return v.determinant(v.valueOf(_t81), v.valueOf(_e37), v.valueOf(_n25), v.valueOf(_s13));
        }

        if (arguments[3] instanceof v && arguments[2] instanceof v && arguments[0] instanceof v && arguments[1] instanceof v) {
          var _t82 = arguments[1],
              _e38 = arguments[2],
              _n26 = arguments[3];
          return arguments[0].multiply(_n26).selfSubtract(_t82.multiply(_e38));
        }
      }
    }, {
      key: "sqr",
      value: function sqr(t) {
        return v.valueOf(t).selfMultiply(t);
      }
    }, {
      key: "valueOf",
      value: function valueOf() {
        if ("string" == typeof arguments[0]) {
          var _t83 = arguments[0];
          return v.parse(_t83);
        }

        if ("number" == typeof arguments[0]) {
          return new v(arguments[0]);
        }
      }
    }, {
      key: "sqrt",
      value: function sqrt(t) {
        return v.valueOf(t).sqrt();
      }
    }, {
      key: "parse",
      value: function parse(t) {
        var e = 0;
        var n = t.length;

        for (; O.isWhitespace(t.charAt(e));) {
          e++;
        }

        var s = !1;

        if (e < n) {
          var _n27 = t.charAt(e);

          "-" !== _n27 && "+" !== _n27 || (e++, "-" === _n27 && (s = !0));
        }

        var i = new v();
        var r = 0,
            o = 0,
            l = 0,
            a = !1;

        for (; !(e >= n);) {
          var _n28 = t.charAt(e);

          if (e++, O.isDigit(_n28)) {
            var _t84 = _n28 - "0";

            i.selfMultiply(v.TEN), i.selfAdd(_t84), r++;
          } else {
            if ("." !== _n28) {
              if ("e" === _n28 || "E" === _n28) {
                var _n29 = t.substring(e);

                try {
                  l = P.parseInt(_n29);
                } catch (e) {
                  throw e instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + _n29 + " in string " + t) : e;
                }

                break;
              }

              throw new NumberFormatException("Unexpected character '" + _n28 + "' at position " + e + " in string " + t);
            }

            o = r, a = !0;
          }
        }

        var c = i;
        a || (o = r);
        var h = r - o - l;
        if (0 === h) c = i;else if (h > 0) {
          var _t85 = v.TEN.pow(h);

          c = i.divide(_t85);
        } else if (h < 0) {
          var _t86 = v.TEN.pow(-h);

          c = i.multiply(_t86);
        }
        return s ? c.negate() : c;
      }
    }, {
      key: "createNaN",
      value: function createNaN() {
        return new v(r.NaN, r.NaN);
      }
    }, {
      key: "copy",
      value: function copy(t) {
        return new v(t);
      }
    }, {
      key: "magnitude",
      value: function magnitude(t) {
        var e = Math.abs(t),
            n = Math.log(e) / Math.log(10);
        var s = Math.trunc(Math.floor(n));
        return 10 * Math.pow(10, s) <= e && (s += 1), s;
      }
    }, {
      key: "stringOfChar",
      value: function stringOfChar(t, e) {
        var n = new R();

        for (var _s14 = 0; _s14 < e; _s14++) {
          n.append(t);
        }

        return n.toString();
      }
    }]);

    return v;
  }();

  v.PI = new v(3.141592653589793, 12246467991473532e-32), v.TWO_PI = new v(6.283185307179586, 24492935982947064e-32), v.PI_2 = new v(1.5707963267948966, 6123233995736766e-32), v.E = new v(2.718281828459045, 14456468917292502e-32), v.NaN = new v(r.NaN, r.NaN), v.EPS = 123259516440783e-46, v.SPLIT = 134217729, v.MAX_PRINT_DIGITS = 32, v.TEN = v.valueOf(10), v.ONE = v.valueOf(1), v.SCI_NOT_EXPONENT_CHAR = "E", v.SCI_NOT_ZERO = "0.0E0";

  var M = /*#__PURE__*/function () {
    function M() {
      _classCallCheck(this, M);
    }

    _createClass(M, null, [{
      key: "orientationIndex",
      value: function orientationIndex(t, e, n) {
        var s = M.orientationIndexFilter(t, e, n);
        if (s <= 1) return s;
        var i = v.valueOf(e.x).selfAdd(-t.x),
            r = v.valueOf(e.y).selfAdd(-t.y),
            o = v.valueOf(n.x).selfAdd(-e.x),
            l = v.valueOf(n.y).selfAdd(-e.y);
        return i.selfMultiply(l).selfSubtract(r.selfMultiply(o)).signum();
      }
    }, {
      key: "signOfDet2x2",
      value: function signOfDet2x2() {
        if (arguments[3] instanceof v && arguments[2] instanceof v && arguments[0] instanceof v && arguments[1] instanceof v) {
          var _t87 = arguments[1],
              _e39 = arguments[2],
              _n30 = arguments[3];
          return arguments[0].multiply(_n30).selfSubtract(_t87.multiply(_e39)).signum();
        }

        if ("number" == typeof arguments[3] && "number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
          var _t88 = arguments[0],
              _e40 = arguments[1],
              _n31 = arguments[2],
              _s15 = arguments[3],
              _i11 = v.valueOf(_t88),
              _r9 = v.valueOf(_e40),
              _o8 = v.valueOf(_n31),
              _l7 = v.valueOf(_s15);

          return _i11.multiply(_l7).selfSubtract(_r9.multiply(_o8)).signum();
        }
      }
    }, {
      key: "intersection",
      value: function intersection(t, e, n, s) {
        var i = new v(t.y).selfSubtract(e.y),
            o = new v(e.x).selfSubtract(t.x),
            l = new v(t.x).selfMultiply(e.y).selfSubtract(new v(e.x).selfMultiply(t.y)),
            a = new v(n.y).selfSubtract(s.y),
            c = new v(s.x).selfSubtract(n.x),
            h = new v(n.x).selfMultiply(s.y).selfSubtract(new v(s.x).selfMultiply(n.y)),
            u = o.multiply(h).selfSubtract(c.multiply(l)),
            g = a.multiply(l).selfSubtract(i.multiply(h)),
            d = i.multiply(c).selfSubtract(a.multiply(o)),
            _ = u.selfDivide(d).doubleValue(),
            p = g.selfDivide(d).doubleValue();

        return r.isNaN(_) || r.isInfinite(_) || r.isNaN(p) || r.isInfinite(p) ? null : new m(_, p);
      }
    }, {
      key: "orientationIndexFilter",
      value: function orientationIndexFilter(t, e, n) {
        var s = null;
        var i = (t.x - n.x) * (e.y - n.y),
            r = (t.y - n.y) * (e.x - n.x),
            o = i - r;

        if (i > 0) {
          if (r <= 0) return M.signum(o);
          s = i + r;
        } else {
          if (!(i < 0)) return M.signum(o);
          if (r >= 0) return M.signum(o);
          s = -i - r;
        }

        var l = M.DP_SAFE_EPSILON * s;
        return o >= l || -o >= l ? M.signum(o) : 2;
      }
    }, {
      key: "signum",
      value: function signum(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0;
      }
    }]);

    return M;
  }();

  M.DP_SAFE_EPSILON = 1e-15;

  var b = /*#__PURE__*/function () {
    function b() {
      _classCallCheck(this, b);
    }

    _createClass(b, [{
      key: "getM",
      value: function getM(t) {
        if (this.hasM()) {
          var _e41 = this.getDimension() - this.getMeasures();

          return this.getOrdinate(t, _e41);
        }

        return r.NaN;
      }
    }, {
      key: "setOrdinate",
      value: function setOrdinate(t, e, n) {}
    }, {
      key: "getZ",
      value: function getZ(t) {
        return this.hasZ() ? this.getOrdinate(t, 2) : r.NaN;
      }
    }, {
      key: "size",
      value: function size() {}
    }, {
      key: "getOrdinate",
      value: function getOrdinate(t, e) {}
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {}
    }, {
      key: "getCoordinateCopy",
      value: function getCoordinateCopy(t) {}
    }, {
      key: "createCoordinate",
      value: function createCoordinate() {}
    }, {
      key: "getDimension",
      value: function getDimension() {}
    }, {
      key: "hasM",
      value: function hasM() {
        return this.getMeasures() > 0;
      }
    }, {
      key: "getX",
      value: function getX(t) {}
    }, {
      key: "hasZ",
      value: function hasZ() {
        return this.getDimension() - this.getMeasures() > 2;
      }
    }, {
      key: "getMeasures",
      value: function getMeasures() {
        return 0;
      }
    }, {
      key: "expandEnvelope",
      value: function expandEnvelope(t) {}
    }, {
      key: "copy",
      value: function copy() {}
    }, {
      key: "getY",
      value: function getY(t) {}
    }, {
      key: "toCoordinateArray",
      value: function toCoordinateArray() {}
    }, {
      key: "interfaces_",
      get: function get() {
        return [l];
      }
    }]);

    return b;
  }();

  b.X = 0, b.Y = 1, b.Z = 2, b.M = 3;

  var D = /*#__PURE__*/function () {
    function D() {
      _classCallCheck(this, D);
    }

    _createClass(D, null, [{
      key: "index",
      value: function index(t, e, n) {
        return M.orientationIndex(t, e, n);
      }
    }, {
      key: "isCCW",
      value: function isCCW() {
        if (arguments[0] instanceof Array) {
          var _t89 = arguments[0],
              _e42 = _t89.length - 1;

          if (_e42 < 3) throw new s("Ring has fewer than 4 points, so orientation cannot be determined");
          var _n32 = _t89[0],
              _i12 = 0;

          for (var _s16 = 1; _s16 <= _e42; _s16++) {
            var _e43 = _t89[_s16];
            _e43.y > _n32.y && (_n32 = _e43, _i12 = _s16);
          }

          var _r10 = _i12;

          do {
            _r10 -= 1, _r10 < 0 && (_r10 = _e42);
          } while (_t89[_r10].equals2D(_n32) && _r10 !== _i12);

          var _o9 = _i12;

          do {
            _o9 = (_o9 + 1) % _e42;
          } while (_t89[_o9].equals2D(_n32) && _o9 !== _i12);

          var _l8 = _t89[_r10],
              _a6 = _t89[_o9];
          if (_l8.equals2D(_n32) || _a6.equals2D(_n32) || _l8.equals2D(_a6)) return !1;

          var _c5 = D.index(_l8, _n32, _a6);

          var _h4 = null;
          return _h4 = 0 === _c5 ? _l8.x > _a6.x : _c5 > 0, _h4;
        }

        if (y(arguments[0], b)) {
          var _t90 = arguments[0],
              _e44 = _t90.size() - 1;

          if (_e44 < 3) throw new s("Ring has fewer than 4 points, so orientation cannot be determined");

          var _n33 = _t90.getCoordinate(0),
              _i13 = 0;

          for (var _s17 = 1; _s17 <= _e44; _s17++) {
            var _e45 = _t90.getCoordinate(_s17);

            _e45.y > _n33.y && (_n33 = _e45, _i13 = _s17);
          }

          var _r11 = null,
              _o10 = _i13;

          do {
            _o10 -= 1, _o10 < 0 && (_o10 = _e44), _r11 = _t90.getCoordinate(_o10);
          } while (_r11.equals2D(_n33) && _o10 !== _i13);

          var _l9 = null,
              _a7 = _i13;

          do {
            _a7 = (_a7 + 1) % _e44, _l9 = _t90.getCoordinate(_a7);
          } while (_l9.equals2D(_n33) && _a7 !== _i13);

          if (_r11.equals2D(_n33) || _l9.equals2D(_n33) || _r11.equals2D(_l9)) return !1;

          var _c6 = D.index(_r11, _n33, _l9);

          var _h5 = null;
          return _h5 = 0 === _c6 ? _r11.x > _l9.x : _c6 > 0, _h5;
        }
      }
    }]);

    return D;
  }();

  D.CLOCKWISE = -1, D.RIGHT = D.CLOCKWISE, D.COUNTERCLOCKWISE = 1, D.LEFT = D.COUNTERCLOCKWISE, D.COLLINEAR = 0, D.STRAIGHT = D.COLLINEAR;

  var A = /*#__PURE__*/function () {
    function A() {
      _classCallCheck(this, A);
    }

    _createClass(A, null, [{
      key: "intersection",
      value: function intersection(t, e, n, s) {
        var i = t.x < e.x ? t.x : e.x,
            o = t.y < e.y ? t.y : e.y,
            l = t.x > e.x ? t.x : e.x,
            a = t.y > e.y ? t.y : e.y,
            c = n.x < s.x ? n.x : s.x,
            h = n.y < s.y ? n.y : s.y,
            u = n.x > s.x ? n.x : s.x,
            g = n.y > s.y ? n.y : s.y,
            d = ((i > c ? i : c) + (l < u ? l : u)) / 2,
            _ = ((o > h ? o : h) + (a < g ? a : g)) / 2,
            p = t.x - d,
            f = t.y - _,
            y = e.x - d,
            x = e.y - _,
            E = n.x - d,
            I = n.y - _,
            N = s.x - d,
            S = s.y - _,
            w = f - x,
            C = y - p,
            L = p * x - y * f,
            T = I - S,
            R = N - E,
            P = E * S - N * I,
            O = w * R - T * C,
            v = (C * P - R * L) / O,
            M = (T * L - w * P) / O;

        return r.isNaN(v) || r.isInfinite(v) || r.isNaN(M) || r.isInfinite(M) ? null : new m(v + d, M + _);
      }
    }]);

    return A;
  }();

  var F = /*#__PURE__*/function () {
    function F() {
      _classCallCheck(this, F);
    }

    _createClass(F, null, [{
      key: "arraycopy",
      value: function arraycopy(t, e, n, s, i) {
        var r = 0;

        for (var _o11 = e; _o11 < e + i; _o11++) {
          n[s + r] = t[_o11], r++;
        }
      }
    }, {
      key: "getProperty",
      value: function getProperty(t) {
        return {
          "line.separator": "\n"
        }[t];
      }
    }]);

    return F;
  }();

  var G = /*#__PURE__*/function () {
    function G() {
      _classCallCheck(this, G);
    }

    _createClass(G, null, [{
      key: "log10",
      value: function log10(t) {
        var e = Math.log(t);
        return r.isInfinite(e) || r.isNaN(e) ? e : e / G.LOG_10;
      }
    }, {
      key: "min",
      value: function min(t, e, n, s) {
        var i = t;
        return e < i && (i = e), n < i && (i = n), s < i && (i = s), i;
      }
    }, {
      key: "clamp",
      value: function clamp() {
        if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
          var _t91 = arguments[0],
              _e46 = arguments[1],
              _n34 = arguments[2];
          return _t91 < _e46 ? _e46 : _t91 > _n34 ? _n34 : _t91;
        }

        if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
          var _t92 = arguments[0],
              _e47 = arguments[1],
              _n35 = arguments[2];
          return _t92 < _e47 ? _e47 : _t92 > _n35 ? _n35 : _t92;
        }
      }
    }, {
      key: "wrap",
      value: function wrap(t, e) {
        return t < 0 ? e - -t % e : t % e;
      }
    }, {
      key: "max",
      value: function max() {
        if (3 === arguments.length) {
          var _t93 = arguments[1],
              _e48 = arguments[2];
          var _n36 = arguments[0];
          return _t93 > _n36 && (_n36 = _t93), _e48 > _n36 && (_n36 = _e48), _n36;
        }

        if (4 === arguments.length) {
          var _t94 = arguments[1],
              _e49 = arguments[2],
              _n37 = arguments[3];
          var _s18 = arguments[0];
          return _t94 > _s18 && (_s18 = _t94), _e49 > _s18 && (_s18 = _e49), _n37 > _s18 && (_s18 = _n37), _s18;
        }
      }
    }, {
      key: "average",
      value: function average(t, e) {
        return (t + e) / 2;
      }
    }]);

    return G;
  }();

  G.LOG_10 = Math.log(10);

  var q = /*#__PURE__*/function () {
    function q() {
      _classCallCheck(this, q);
    }

    _createClass(q, null, [{
      key: "segmentToSegment",
      value: function segmentToSegment(t, e, n, s) {
        if (t.equals(e)) return q.pointToSegment(t, n, s);
        if (n.equals(s)) return q.pointToSegment(s, t, e);
        var i = !1;

        if (T.intersects(t, e, n, s)) {
          var _r12 = (e.x - t.x) * (s.y - n.y) - (e.y - t.y) * (s.x - n.x);

          if (0 === _r12) i = !0;else {
            var _o12 = (t.y - n.y) * (s.x - n.x) - (t.x - n.x) * (s.y - n.y),
                _l10 = ((t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y)) / _r12,
                _a8 = _o12 / _r12;

            (_a8 < 0 || _a8 > 1 || _l10 < 0 || _l10 > 1) && (i = !0);
          }
        } else i = !0;

        return i ? G.min(q.pointToSegment(t, n, s), q.pointToSegment(e, n, s), q.pointToSegment(n, t, e), q.pointToSegment(s, t, e)) : 0;
      }
    }, {
      key: "pointToSegment",
      value: function pointToSegment(t, e, n) {
        if (e.x === n.x && e.y === n.y) return t.distance(e);
        var s = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),
            i = ((t.x - e.x) * (n.x - e.x) + (t.y - e.y) * (n.y - e.y)) / s;
        if (i <= 0) return t.distance(e);
        if (i >= 1) return t.distance(n);
        var r = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / s;
        return Math.abs(r) * Math.sqrt(s);
      }
    }, {
      key: "pointToLinePerpendicular",
      value: function pointToLinePerpendicular(t, e, n) {
        var s = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),
            i = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / s;
        return Math.abs(i) * Math.sqrt(s);
      }
    }, {
      key: "pointToSegmentString",
      value: function pointToSegmentString(t, e) {
        if (0 === e.length) throw new s("Line array must contain at least one vertex");
        var n = t.distance(e[0]);

        for (var _s19 = 0; _s19 < e.length - 1; _s19++) {
          var _i14 = q.pointToSegment(t, e[_s19], e[_s19 + 1]);

          _i14 < n && (n = _i14);
        }

        return n;
      }
    }]);

    return q;
  }();

  var B = /*#__PURE__*/function () {
    function B() {
      _classCallCheck(this, B);
    }

    _createClass(B, [{
      key: "create",
      value: function create() {
        if (1 === arguments.length) arguments[0] instanceof Array || y(arguments[0], b);else if (2 === arguments.length) ;else if (3 === arguments.length) {
          var _t95 = arguments[0],
              _e50 = arguments[1];
          return this.create(_t95, _e50);
        }
      }
    }]);

    return B;
  }();

  var Y = /*#__PURE__*/function () {
    function Y() {
      _classCallCheck(this, Y);
    }

    _createClass(Y, [{
      key: "filter",
      value: function filter(t) {}
    }]);

    return Y;
  }();

  var V = /*#__PURE__*/function () {
    function V() {
      _classCallCheck(this, V);

      V.constructor_.apply(this, arguments);
    }

    _createClass(V, [{
      key: "isGeometryCollection",
      value: function isGeometryCollection() {
        return this.getTypeCode() === V.TYPECODE_GEOMETRYCOLLECTION;
      }
    }, {
      key: "getFactory",
      value: function getFactory() {
        return this._factory;
      }
    }, {
      key: "getGeometryN",
      value: function getGeometryN(t) {
        return this;
      }
    }, {
      key: "getArea",
      value: function getArea() {
        return 0;
      }
    }, {
      key: "isRectangle",
      value: function isRectangle() {
        return !1;
      }
    }, {
      key: "equalsExact",
      value: function equalsExact(t) {
        return this === t || this.equalsExact(t, 0);
      }
    }, {
      key: "geometryChanged",
      value: function geometryChanged() {
        this.apply(V.geometryChangedFilter);
      }
    }, {
      key: "geometryChangedAction",
      value: function geometryChangedAction() {
        this._envelope = null;
      }
    }, {
      key: "equalsNorm",
      value: function equalsNorm(t) {
        return null !== t && this.norm().equalsExact(t.norm());
      }
    }, {
      key: "getLength",
      value: function getLength() {
        return 0;
      }
    }, {
      key: "getNumGeometries",
      value: function getNumGeometries() {
        return 1;
      }
    }, {
      key: "compareTo",
      value: function compareTo() {
        var t;

        if (1 === arguments.length) {
          var _e51 = arguments[0];
          return t = _e51, this.getTypeCode() !== t.getTypeCode() ? this.getTypeCode() - t.getTypeCode() : this.isEmpty() && t.isEmpty() ? 0 : this.isEmpty() ? -1 : t.isEmpty() ? 1 : this.compareToSameClass(_e51);
        }

        if (2 === arguments.length) {
          var _e52 = arguments[0],
              _n38 = arguments[1];
          return t = _e52, this.getTypeCode() !== t.getTypeCode() ? this.getTypeCode() - t.getTypeCode() : this.isEmpty() && t.isEmpty() ? 0 : this.isEmpty() ? -1 : t.isEmpty() ? 1 : this.compareToSameClass(_e52, _n38);
        }
      }
    }, {
      key: "getUserData",
      value: function getUserData() {
        return this._userData;
      }
    }, {
      key: "getSRID",
      value: function getSRID() {
        return this._SRID;
      }
    }, {
      key: "getEnvelope",
      value: function getEnvelope() {
        return this.getFactory().toGeometry(this.getEnvelopeInternal());
      }
    }, {
      key: "checkNotGeometryCollection",
      value: function checkNotGeometryCollection(t) {
        if (t.getTypeCode() === V.TYPECODE_GEOMETRYCOLLECTION) throw new s("This method does not support GeometryCollection arguments");
      }
    }, {
      key: "equal",
      value: function equal(t, e, n) {
        return 0 === n ? t.equals(e) : t.distance(e) <= n;
      }
    }, {
      key: "norm",
      value: function norm() {
        var t = this.copy();
        return t.normalize(), t;
      }
    }, {
      key: "reverse",
      value: function reverse() {
        var t = this.reverseInternal();
        return null != this.envelope && (t.envelope = this.envelope.copy()), t.setSRID(this.getSRID()), t;
      }
    }, {
      key: "copy",
      value: function copy() {
        var t = this.copyInternal();
        return t.envelope = null == this._envelope ? null : this._envelope.copy(), t._SRID = this._SRID, t._userData = this._userData, t;
      }
    }, {
      key: "getPrecisionModel",
      value: function getPrecisionModel() {
        return this._factory.getPrecisionModel();
      }
    }, {
      key: "getEnvelopeInternal",
      value: function getEnvelopeInternal() {
        return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new T(this._envelope);
      }
    }, {
      key: "setSRID",
      value: function setSRID(t) {
        this._SRID = t;
      }
    }, {
      key: "setUserData",
      value: function setUserData(t) {
        this._userData = t;
      }
    }, {
      key: "compare",
      value: function compare(t, e) {
        var n = t.iterator(),
            s = e.iterator();

        for (; n.hasNext() && s.hasNext();) {
          var _t96 = n.next(),
              _e53 = s.next(),
              _i15 = _t96.compareTo(_e53);

          if (0 !== _i15) return _i15;
        }

        return n.hasNext() ? 1 : s.hasNext() ? -1 : 0;
      }
    }, {
      key: "hashCode",
      value: function hashCode() {
        return this.getEnvelopeInternal().hashCode();
      }
    }, {
      key: "isEquivalentClass",
      value: function isEquivalentClass(t) {
        return this.getClass() === t.getClass();
      }
    }, {
      key: "isGeometryCollectionOrDerived",
      value: function isGeometryCollectionOrDerived() {
        return this.getTypeCode() === V.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === V.TYPECODE_MULTIPOINT || this.getTypeCode() === V.TYPECODE_MULTILINESTRING || this.getTypeCode() === V.TYPECODE_MULTIPOLYGON;
      }
    }, {
      key: "getClass",
      value: function getClass() {
        return V;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [l, o, c];
      }
    }], [{
      key: "hasNonEmptyElements",
      value: function hasNonEmptyElements(t) {
        for (var _e54 = 0; _e54 < t.length; _e54++) {
          if (!t[_e54].isEmpty()) return !0;
        }

        return !1;
      }
    }, {
      key: "hasNullElements",
      value: function hasNullElements(t) {
        for (var _e55 = 0; _e55 < t.length; _e55++) {
          if (null === t[_e55]) return !0;
        }

        return !1;
      }
    }]);

    return V;
  }();

  V.constructor_ = function (t) {
    t && (this._envelope = null, this._userData = null, this._factory = t, this._SRID = t.getSRID());
  }, V.TYPECODE_POINT = 0, V.TYPECODE_MULTIPOINT = 1, V.TYPECODE_LINESTRING = 2, V.TYPECODE_LINEARRING = 3, V.TYPECODE_MULTILINESTRING = 4, V.TYPECODE_POLYGON = 5, V.TYPECODE_MULTIPOLYGON = 6, V.TYPECODE_GEOMETRYCOLLECTION = 7, V.TYPENAME_POINT = "Point", V.TYPENAME_MULTIPOINT = "MultiPoint", V.TYPENAME_LINESTRING = "LineString", V.TYPENAME_LINEARRING = "LinearRing", V.TYPENAME_MULTILINESTRING = "MultiLineString", V.TYPENAME_POLYGON = "Polygon", V.TYPENAME_MULTIPOLYGON = "MultiPolygon", V.TYPENAME_GEOMETRYCOLLECTION = "GeometryCollection", V.geometryChangedFilter = {
    get interfaces_() {
      return [Y];
    },

    filter: function filter(t) {
      t.geometryChangedAction();
    }
  };

  var z = /*#__PURE__*/function () {
    function z() {
      _classCallCheck(this, z);
    }

    _createClass(z, [{
      key: "filter",
      value: function filter(t) {}
    }]);

    return z;
  }();

  var X = /*#__PURE__*/function () {
    function X() {
      _classCallCheck(this, X);
    }

    _createClass(X, null, [{
      key: "ofLine",
      value: function ofLine(t) {
        var e = t.size();
        if (e <= 1) return 0;
        var n = 0;
        var s = new m();
        t.getCoordinate(0, s);
        var i = s.x,
            r = s.y;

        for (var _o13 = 1; _o13 < e; _o13++) {
          t.getCoordinate(_o13, s);

          var _e56 = s.x,
              _l11 = s.y,
              _a9 = _e56 - i,
              _c7 = _l11 - r;

          n += Math.sqrt(_a9 * _a9 + _c7 * _c7), i = _e56, r = _l11;
        }

        return n;
      }
    }]);

    return X;
  }();

  var k = function k() {
    _classCallCheck(this, k);
  };

  var U = /*#__PURE__*/function () {
    function U() {
      _classCallCheck(this, U);
    }

    _createClass(U, null, [{
      key: "copyCoord",
      value: function copyCoord(t, e, n, s) {
        var i = Math.min(t.getDimension(), n.getDimension());

        for (var _r13 = 0; _r13 < i; _r13++) {
          n.setOrdinate(s, _r13, t.getOrdinate(e, _r13));
        }
      }
    }, {
      key: "isRing",
      value: function isRing(t) {
        var e = t.size();
        return 0 === e || !(e <= 3) && t.getOrdinate(0, b.X) === t.getOrdinate(e - 1, b.X) && t.getOrdinate(0, b.Y) === t.getOrdinate(e - 1, b.Y);
      }
    }, {
      key: "scroll",
      value: function scroll() {
        if (2 === arguments.length) {
          if (y(arguments[0], b) && Number.isInteger(arguments[1])) {
            var _t97 = arguments[0],
                _e57 = arguments[1];
            U.scroll(_t97, _e57, U.isRing(_t97));
          } else if (y(arguments[0], b) && arguments[1] instanceof m) {
            var _t98 = arguments[0],
                _e58 = arguments[1],
                _n39 = U.indexOf(_e58, _t98);

            if (_n39 <= 0) return null;
            U.scroll(_t98, _n39);
          }
        } else if (3 === arguments.length) {
          var _t99 = arguments[0],
              _e59 = arguments[1],
              _n40 = arguments[2];
          if (_e59 <= 0) return null;

          var _s20 = _t99.copy(),
              _i16 = _n40 ? _t99.size() - 1 : _t99.size();

          for (var _n41 = 0; _n41 < _i16; _n41++) {
            for (var _r14 = 0; _r14 < _t99.getDimension(); _r14++) {
              _t99.setOrdinate(_n41, _r14, _s20.getOrdinate((_e59 + _n41) % _i16, _r14));
            }
          }

          if (_n40) for (var _e60 = 0; _e60 < _t99.getDimension(); _e60++) {
            _t99.setOrdinate(_i16, _e60, _t99.getOrdinate(0, _e60));
          }
        }
      }
    }, {
      key: "isEqual",
      value: function isEqual(t, e) {
        var n = t.size();
        if (n !== e.size()) return !1;
        var s = Math.min(t.getDimension(), e.getDimension());

        for (var _i17 = 0; _i17 < n; _i17++) {
          for (var _n42 = 0; _n42 < s; _n42++) {
            var _s21 = t.getOrdinate(_i17, _n42),
                _o14 = e.getOrdinate(_i17, _n42);

            if (t.getOrdinate(_i17, _n42) !== e.getOrdinate(_i17, _n42) && (!r.isNaN(_s21) || !r.isNaN(_o14))) return !1;
          }
        }

        return !0;
      }
    }, {
      key: "minCoordinateIndex",
      value: function minCoordinateIndex() {
        if (1 === arguments.length) {
          var _t100 = arguments[0];
          return U.minCoordinateIndex(_t100, 0, _t100.size() - 1);
        }

        if (3 === arguments.length) {
          var _t101 = arguments[0],
              _e61 = arguments[2];

          var _n43 = -1,
              _s22 = null;

          for (var _i18 = arguments[1]; _i18 <= _e61; _i18++) {
            var _e62 = _t101.getCoordinate(_i18);

            (null === _s22 || _s22.compareTo(_e62) > 0) && (_s22 = _e62, _n43 = _i18);
          }

          return _n43;
        }
      }
    }, {
      key: "extend",
      value: function extend(t, e, n) {
        var s = t.create(n, e.getDimension()),
            i = e.size();
        if (U.copy(e, 0, s, 0, i), i > 0) for (var _t102 = i; _t102 < n; _t102++) {
          U.copy(e, i - 1, s, _t102, 1);
        }
        return s;
      }
    }, {
      key: "reverse",
      value: function reverse(t) {
        var e = t.size() - 1,
            n = Math.trunc(e / 2);

        for (var _s23 = 0; _s23 <= n; _s23++) {
          U.swap(t, _s23, e - _s23);
        }
      }
    }, {
      key: "swap",
      value: function swap(t, e, n) {
        if (e === n) return null;

        for (var _s24 = 0; _s24 < t.getDimension(); _s24++) {
          var _i19 = t.getOrdinate(e, _s24);

          t.setOrdinate(e, _s24, t.getOrdinate(n, _s24)), t.setOrdinate(n, _s24, _i19);
        }
      }
    }, {
      key: "copy",
      value: function copy(t, e, n, s, i) {
        for (var _r15 = 0; _r15 < i; _r15++) {
          U.copyCoord(t, e + _r15, n, s + _r15);
        }
      }
    }, {
      key: "ensureValidRing",
      value: function ensureValidRing(t, e) {
        var n = e.size();
        if (0 === n) return e;
        if (n <= 3) return U.createClosedRing(t, e, 4);
        return e.getOrdinate(0, b.X) === e.getOrdinate(n - 1, b.X) && e.getOrdinate(0, b.Y) === e.getOrdinate(n - 1, b.Y) ? e : U.createClosedRing(t, e, n + 1);
      }
    }, {
      key: "indexOf",
      value: function indexOf(t, e) {
        for (var _n44 = 0; _n44 < e.size(); _n44++) {
          if (t.x === e.getOrdinate(_n44, b.X) && t.y === e.getOrdinate(_n44, b.Y)) return _n44;
        }

        return -1;
      }
    }, {
      key: "createClosedRing",
      value: function createClosedRing(t, e, n) {
        var s = t.create(n, e.getDimension()),
            i = e.size();
        U.copy(e, 0, s, 0, i);

        for (var _t103 = i; _t103 < n; _t103++) {
          U.copy(e, 0, s, _t103, 1);
        }

        return s;
      }
    }, {
      key: "minCoordinate",
      value: function minCoordinate(t) {
        var e = null;

        for (var _n45 = 0; _n45 < t.size(); _n45++) {
          var _s25 = t.getCoordinate(_n45);

          (null === e || e.compareTo(_s25) > 0) && (e = _s25);
        }

        return e;
      }
    }]);

    return U;
  }();

  var H = /*#__PURE__*/function (_n46) {
    _inherits(H, _n46);

    var _super9 = _createSuper(H);

    function H() {
      _classCallCheck(this, H);

      return _super9.apply(this, arguments);
    }

    return H;
  }(n);

  var W = /*#__PURE__*/function () {
    function W() {
      _classCallCheck(this, W);
    }

    _createClass(W, null, [{
      key: "toDimensionSymbol",
      value: function toDimensionSymbol(t) {
        switch (t) {
          case W.FALSE:
            return W.SYM_FALSE;

          case W.TRUE:
            return W.SYM_TRUE;

          case W.DONTCARE:
            return W.SYM_DONTCARE;

          case W.P:
            return W.SYM_P;

          case W.L:
            return W.SYM_L;

          case W.A:
            return W.SYM_A;
        }

        throw new s("Unknown dimension value: " + t);
      }
    }, {
      key: "toDimensionValue",
      value: function toDimensionValue(t) {
        switch (O.toUpperCase(t)) {
          case W.SYM_FALSE:
            return W.FALSE;

          case W.SYM_TRUE:
            return W.TRUE;

          case W.SYM_DONTCARE:
            return W.DONTCARE;

          case W.SYM_P:
            return W.P;

          case W.SYM_L:
            return W.L;

          case W.SYM_A:
            return W.A;
        }

        throw new s("Unknown dimension symbol: " + t);
      }
    }]);

    return W;
  }();

  W.P = 0, W.L = 1, W.A = 2, W.FALSE = -1, W.TRUE = -2, W.DONTCARE = -3, W.SYM_FALSE = "F", W.SYM_TRUE = "T", W.SYM_DONTCARE = "*", W.SYM_P = "0", W.SYM_L = "1", W.SYM_A = "2";

  var Z = /*#__PURE__*/function () {
    function Z() {
      _classCallCheck(this, Z);
    }

    _createClass(Z, [{
      key: "filter",
      value: function filter(t) {}
    }]);

    return Z;
  }();

  var j = /*#__PURE__*/function (_V) {
    _inherits(j, _V);

    var _super10 = _createSuper(j);

    function j() {
      var _this4;

      _classCallCheck(this, j);

      _this4 = _super10.call(this), j.constructor_.apply(_assertThisInitialized(_this4), arguments);
      return _this4;
    }

    _createClass(j, [{
      key: "computeEnvelopeInternal",
      value: function computeEnvelopeInternal() {
        return this.isEmpty() ? new T() : this._points.expandEnvelope(new T());
      }
    }, {
      key: "isRing",
      value: function isRing() {
        return this.isClosed() && this.isSimple();
      }
    }, {
      key: "getCoordinates",
      value: function getCoordinates() {
        return this._points.toCoordinateArray();
      }
    }, {
      key: "copyInternal",
      value: function copyInternal() {
        return new j(this._points.copy(), this._factory);
      }
    }, {
      key: "equalsExact",
      value: function equalsExact() {
        if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
          var _t104 = arguments[0],
              _e63 = arguments[1];
          if (!this.isEquivalentClass(_t104)) return !1;
          var _n47 = _t104;
          if (this._points.size() !== _n47._points.size()) return !1;

          for (var _t105 = 0; _t105 < this._points.size(); _t105++) {
            if (!this.equal(this._points.getCoordinate(_t105), _n47._points.getCoordinate(_t105), _e63)) return !1;
          }

          return !0;
        }

        return _get(_getPrototypeOf(j.prototype), "equalsExact", this).apply(this, arguments);
      }
    }, {
      key: "normalize",
      value: function normalize() {
        for (var _t106 = 0; _t106 < Math.trunc(this._points.size() / 2); _t106++) {
          var _e64 = this._points.size() - 1 - _t106;

          if (!this._points.getCoordinate(_t106).equals(this._points.getCoordinate(_e64))) {
            if (this._points.getCoordinate(_t106).compareTo(this._points.getCoordinate(_e64)) > 0) {
              var _t107 = this._points.copy();

              U.reverse(_t107), this._points = _t107;
            }

            return null;
          }
        }
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        return this.isEmpty() ? null : this._points.getCoordinate(0);
      }
    }, {
      key: "getBoundaryDimension",
      value: function getBoundaryDimension() {
        return this.isClosed() ? W.FALSE : 0;
      }
    }, {
      key: "isClosed",
      value: function isClosed() {
        return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
      }
    }, {
      key: "reverseInternal",
      value: function reverseInternal() {
        var t = this._points.copy();

        return U.reverse(t), this.getFactory().createLineString(t);
      }
    }, {
      key: "getEndPoint",
      value: function getEndPoint() {
        return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
      }
    }, {
      key: "getTypeCode",
      value: function getTypeCode() {
        return V.TYPECODE_LINESTRING;
      }
    }, {
      key: "getDimension",
      value: function getDimension() {
        return 1;
      }
    }, {
      key: "getLength",
      value: function getLength() {
        return X.ofLine(this._points);
      }
    }, {
      key: "getNumPoints",
      value: function getNumPoints() {
        return this._points.size();
      }
    }, {
      key: "compareToSameClass",
      value: function compareToSameClass() {
        if (1 === arguments.length) {
          var _t108 = arguments[0];
          var _e65 = 0,
              _n48 = 0;

          for (; _e65 < this._points.size() && _n48 < _t108._points.size();) {
            var _s26 = this._points.getCoordinate(_e65).compareTo(_t108._points.getCoordinate(_n48));

            if (0 !== _s26) return _s26;
            _e65++, _n48++;
          }

          return _e65 < this._points.size() ? 1 : _n48 < _t108._points.size() ? -1 : 0;
        }

        if (2 === arguments.length) {
          var _t109 = arguments[0];
          return arguments[1].compare(this._points, _t109._points);
        }
      }
    }, {
      key: "apply",
      value: function apply() {
        if (y(arguments[0], z)) {
          var _t110 = arguments[0];

          for (var _e66 = 0; _e66 < this._points.size(); _e66++) {
            _t110.filter(this._points.getCoordinate(_e66));
          }
        } else if (y(arguments[0], L)) {
          var _t111 = arguments[0];
          if (0 === this._points.size()) return null;

          for (var _e67 = 0; _e67 < this._points.size() && (_t111.filter(this._points, _e67), !_t111.isDone()); _e67++) {
            ;
          }

          _t111.isGeometryChanged() && this.geometryChanged();
        } else if (y(arguments[0], Z)) {
          arguments[0].filter(this);
        } else if (y(arguments[0], Y)) {
          arguments[0].filter(this);
        }
      }
    }, {
      key: "getBoundary",
      value: function getBoundary() {
        throw new H();
      }
    }, {
      key: "isEquivalentClass",
      value: function isEquivalentClass(t) {
        return t instanceof j;
      }
    }, {
      key: "getCoordinateN",
      value: function getCoordinateN(t) {
        return this._points.getCoordinate(t);
      }
    }, {
      key: "getGeometryType",
      value: function getGeometryType() {
        return V.TYPENAME_LINESTRING;
      }
    }, {
      key: "getCoordinateSequence",
      value: function getCoordinateSequence() {
        return this._points;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return 0 === this._points.size();
      }
    }, {
      key: "init",
      value: function init(t) {
        if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size()) throw new s("Invalid number of points in LineString (found " + t.size() + " - must be 0 or >= 2)");
        this._points = t;
      }
    }, {
      key: "isCoordinate",
      value: function isCoordinate(t) {
        for (var _e68 = 0; _e68 < this._points.size(); _e68++) {
          if (this._points.getCoordinate(_e68).equals(t)) return !0;
        }

        return !1;
      }
    }, {
      key: "getStartPoint",
      value: function getStartPoint() {
        return this.isEmpty() ? null : this.getPointN(0);
      }
    }, {
      key: "getPointN",
      value: function getPointN(t) {
        return this.getFactory().createPoint(this._points.getCoordinate(t));
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [k];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._points = null, 0 === arguments.length) ;else if (2 === arguments.length) {
          var _t112 = arguments[0],
              _e69 = arguments[1];
          V.constructor_.call(this, _e69), this.init(_t112);
        }
      }
    }]);

    return j;
  }(V);

  var K = function K() {
    _classCallCheck(this, K);
  };

  var Q = /*#__PURE__*/function (_V2) {
    _inherits(Q, _V2);

    var _super11 = _createSuper(Q);

    function Q() {
      var _this5;

      _classCallCheck(this, Q);

      _this5 = _super11.call(this), Q.constructor_.apply(_assertThisInitialized(_this5), arguments);
      return _this5;
    }

    _createClass(Q, [{
      key: "computeEnvelopeInternal",
      value: function computeEnvelopeInternal() {
        if (this.isEmpty()) return new T();
        var t = new T();
        return t.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t;
      }
    }, {
      key: "getCoordinates",
      value: function getCoordinates() {
        return this.isEmpty() ? [] : [this.getCoordinate()];
      }
    }, {
      key: "copyInternal",
      value: function copyInternal() {
        return new Q(this._coordinates.copy(), this._factory);
      }
    }, {
      key: "equalsExact",
      value: function equalsExact() {
        if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
          var _t113 = arguments[0],
              _e70 = arguments[1];
          return !!this.isEquivalentClass(_t113) && (!(!this.isEmpty() || !_t113.isEmpty()) || this.isEmpty() === _t113.isEmpty() && this.equal(_t113.getCoordinate(), this.getCoordinate(), _e70));
        }

        return _get(_getPrototypeOf(Q.prototype), "equalsExact", this).apply(this, arguments);
      }
    }, {
      key: "normalize",
      value: function normalize() {}
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null;
      }
    }, {
      key: "getBoundaryDimension",
      value: function getBoundaryDimension() {
        return W.FALSE;
      }
    }, {
      key: "reverseInternal",
      value: function reverseInternal() {
        return this.getFactory().createPoint(this._coordinates.copy());
      }
    }, {
      key: "getTypeCode",
      value: function getTypeCode() {
        return V.TYPECODE_POINT;
      }
    }, {
      key: "getDimension",
      value: function getDimension() {
        return 0;
      }
    }, {
      key: "getNumPoints",
      value: function getNumPoints() {
        return this.isEmpty() ? 0 : 1;
      }
    }, {
      key: "getX",
      value: function getX() {
        if (null === this.getCoordinate()) throw new IllegalStateException("getX called on empty Point");
        return this.getCoordinate().x;
      }
    }, {
      key: "compareToSameClass",
      value: function compareToSameClass() {
        if (1 === arguments.length) {
          var _t114 = arguments[0];
          return this.getCoordinate().compareTo(_t114.getCoordinate());
        }

        if (2 === arguments.length) {
          var _t115 = arguments[0];
          return arguments[1].compare(this._coordinates, _t115._coordinates);
        }
      }
    }, {
      key: "apply",
      value: function apply() {
        if (y(arguments[0], z)) {
          var _t116 = arguments[0];
          if (this.isEmpty()) return null;

          _t116.filter(this.getCoordinate());
        } else if (y(arguments[0], L)) {
          var _t117 = arguments[0];
          if (this.isEmpty()) return null;
          _t117.filter(this._coordinates, 0), _t117.isGeometryChanged() && this.geometryChanged();
        } else if (y(arguments[0], Z)) {
          arguments[0].filter(this);
        } else if (y(arguments[0], Y)) {
          arguments[0].filter(this);
        }
      }
    }, {
      key: "getBoundary",
      value: function getBoundary() {
        return this.getFactory().createGeometryCollection();
      }
    }, {
      key: "getGeometryType",
      value: function getGeometryType() {
        return V.TYPENAME_POINT;
      }
    }, {
      key: "getCoordinateSequence",
      value: function getCoordinateSequence() {
        return this._coordinates;
      }
    }, {
      key: "getY",
      value: function getY() {
        if (null === this.getCoordinate()) throw new IllegalStateException("getY called on empty Point");
        return this.getCoordinate().y;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return 0 === this._coordinates.size();
      }
    }, {
      key: "init",
      value: function init(t) {
        null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), g.isTrue(t.size() <= 1), this._coordinates = t;
      }
    }, {
      key: "isSimple",
      value: function isSimple() {
        return !0;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [K];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._coordinates = null;
        var t = arguments[0],
            e = arguments[1];
        V.constructor_.call(this, e), this.init(t);
      }
    }]);

    return Q;
  }(V);

  var J = /*#__PURE__*/function () {
    function J() {
      _classCallCheck(this, J);
    }

    _createClass(J, null, [{
      key: "ofRing",
      value: function ofRing() {
        if (arguments[0] instanceof Array) {
          var _t118 = arguments[0];
          return Math.abs(J.ofRingSigned(_t118));
        }

        if (y(arguments[0], b)) {
          var _t119 = arguments[0];
          return Math.abs(J.ofRingSigned(_t119));
        }
      }
    }, {
      key: "ofRingSigned",
      value: function ofRingSigned() {
        if (arguments[0] instanceof Array) {
          var _t120 = arguments[0];
          if (_t120.length < 3) return 0;
          var _e71 = 0;
          var _n49 = _t120[0].x;

          for (var _s27 = 1; _s27 < _t120.length - 1; _s27++) {
            var _i20 = _t120[_s27].x - _n49,
                _r16 = _t120[_s27 + 1].y;

            _e71 += _i20 * (_t120[_s27 - 1].y - _r16);
          }

          return _e71 / 2;
        }

        if (y(arguments[0], b)) {
          var _t121 = arguments[0],
              _e72 = _t121.size();

          if (_e72 < 3) return 0;

          var _n50 = new m(),
              _s28 = new m(),
              _i21 = new m();

          _t121.getCoordinate(0, _s28), _t121.getCoordinate(1, _i21);
          var _r17 = _s28.x;
          _i21.x -= _r17;
          var _o15 = 0;

          for (var _l12 = 1; _l12 < _e72 - 1; _l12++) {
            _n50.y = _s28.y, _s28.x = _i21.x, _s28.y = _i21.y, _t121.getCoordinate(_l12 + 1, _i21), _i21.x -= _r17, _o15 += _s28.x * (_n50.y - _i21.y);
          }

          return _o15 / 2;
        }
      }
    }]);

    return J;
  }();

  var $ = /*#__PURE__*/function () {
    function $() {
      _classCallCheck(this, $);
    }

    _createClass($, null, [{
      key: "sort",
      value: function sort() {
        var _arguments = arguments;
        var t = arguments[0];
        if (1 === arguments.length) t.sort(function (t, e) {
          return t.compareTo(e);
        });else if (2 === arguments.length) t.sort(function (t, e) {
          return _arguments[1].compare(t, e);
        });else if (3 === arguments.length) {
          var _e73 = t.slice(arguments[1], arguments[2]);

          _e73.sort();

          var _n51 = t.slice(0, arguments[1]).concat(_e73, t.slice(arguments[2], t.length));

          t.splice(0, t.length);

          var _iterator2 = _createForOfIteratorHelper(_n51),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _e74 = _step2.value;
              t.push(_e74);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        } else if (4 === arguments.length) {
          var _e75 = t.slice(arguments[1], arguments[2]);

          _e75.sort(function (t, e) {
            return _arguments[3].compare(t, e);
          });

          var _n52 = t.slice(0, arguments[1]).concat(_e75, t.slice(arguments[2], t.length));

          t.splice(0, t.length);

          var _iterator3 = _createForOfIteratorHelper(_n52),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var _e76 = _step3.value;
              t.push(_e76);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      }
    }, {
      key: "asList",
      value: function asList(t) {
        var e = new S();

        var _iterator4 = _createForOfIteratorHelper(t),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var _n53 = _step4.value;
            e.add(_n53);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        return e;
      }
    }, {
      key: "copyOf",
      value: function copyOf(t, e) {
        return t.slice(0, e);
      }
    }]);

    return $;
  }();

  var tt = function tt() {
    _classCallCheck(this, tt);
  };

  var et = /*#__PURE__*/function (_V3) {
    _inherits(et, _V3);

    var _super12 = _createSuper(et);

    function et() {
      var _this6;

      _classCallCheck(this, et);

      _this6 = _super12.call(this), et.constructor_.apply(_assertThisInitialized(_this6), arguments);
      return _this6;
    }

    _createClass(et, [{
      key: "computeEnvelopeInternal",
      value: function computeEnvelopeInternal() {
        return this._shell.getEnvelopeInternal();
      }
    }, {
      key: "getCoordinates",
      value: function getCoordinates() {
        if (this.isEmpty()) return [];
        var t = new Array(this.getNumPoints()).fill(null);
        var e = -1;

        var n = this._shell.getCoordinates();

        for (var _s29 = 0; _s29 < n.length; _s29++) {
          e++, t[e] = n[_s29];
        }

        for (var _n54 = 0; _n54 < this._holes.length; _n54++) {
          var _s30 = this._holes[_n54].getCoordinates();

          for (var _n55 = 0; _n55 < _s30.length; _n55++) {
            e++, t[e] = _s30[_n55];
          }
        }

        return t;
      }
    }, {
      key: "getArea",
      value: function getArea() {
        var t = 0;
        t += J.ofRing(this._shell.getCoordinateSequence());

        for (var _e77 = 0; _e77 < this._holes.length; _e77++) {
          t -= J.ofRing(this._holes[_e77].getCoordinateSequence());
        }

        return t;
      }
    }, {
      key: "copyInternal",
      value: function copyInternal() {
        var t = this._shell.copy(),
            e = new Array(this._holes.length).fill(null);

        for (var _t122 = 0; _t122 < this._holes.length; _t122++) {
          e[_t122] = this._holes[_t122].copy();
        }

        return new et(t, e, this._factory);
      }
    }, {
      key: "isRectangle",
      value: function isRectangle() {
        if (0 !== this.getNumInteriorRing()) return !1;
        if (null === this._shell) return !1;
        if (5 !== this._shell.getNumPoints()) return !1;

        var t = this._shell.getCoordinateSequence(),
            e = this.getEnvelopeInternal();

        for (var _n56 = 0; _n56 < 5; _n56++) {
          var _s31 = t.getX(_n56);

          if (_s31 !== e.getMinX() && _s31 !== e.getMaxX()) return !1;

          var _i22 = t.getY(_n56);

          if (_i22 !== e.getMinY() && _i22 !== e.getMaxY()) return !1;
        }

        var n = t.getX(0),
            s = t.getY(0);

        for (var _e78 = 1; _e78 <= 4; _e78++) {
          var _i23 = t.getX(_e78),
              _r18 = t.getY(_e78);

          if (_i23 !== n === (_r18 !== s)) return !1;
          n = _i23, s = _r18;
        }

        return !0;
      }
    }, {
      key: "equalsExact",
      value: function equalsExact() {
        if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
          var _t123 = arguments[0],
              _e79 = arguments[1];
          if (!this.isEquivalentClass(_t123)) return !1;
          var _n57 = _t123,
              _s32 = this._shell,
              _i24 = _n57._shell;
          if (!_s32.equalsExact(_i24, _e79)) return !1;
          if (this._holes.length !== _n57._holes.length) return !1;

          for (var _t124 = 0; _t124 < this._holes.length; _t124++) {
            if (!this._holes[_t124].equalsExact(_n57._holes[_t124], _e79)) return !1;
          }

          return !0;
        }

        return _get(_getPrototypeOf(et.prototype), "equalsExact", this).apply(this, arguments);
      }
    }, {
      key: "normalize",
      value: function normalize() {
        if (0 === arguments.length) {
          this._shell = this.normalized(this._shell, !0);

          for (var _t125 = 0; _t125 < this._holes.length; _t125++) {
            this._holes[_t125] = this.normalized(this._holes[_t125], !1);
          }

          $.sort(this._holes);
        } else if (2 === arguments.length) {
          var _t126 = arguments[0],
              _e80 = arguments[1];
          if (_t126.isEmpty()) return null;

          var _n58 = _t126.getCoordinateSequence(),
              _s33 = U.minCoordinateIndex(_n58, 0, _n58.size() - 2);

          U.scroll(_n58, _s33, !0), D.isCCW(_n58) === _e80 && U.reverse(_n58);
        }
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        return this._shell.getCoordinate();
      }
    }, {
      key: "getNumInteriorRing",
      value: function getNumInteriorRing() {
        return this._holes.length;
      }
    }, {
      key: "getBoundaryDimension",
      value: function getBoundaryDimension() {
        return 1;
      }
    }, {
      key: "reverseInternal",
      value: function reverseInternal() {
        var t = this.getExteriorRing().reverse(),
            e = new Array(this.getNumInteriorRing()).fill(null);

        for (var _t127 = 0; _t127 < e.length; _t127++) {
          e[_t127] = this.getInteriorRingN(_t127).reverse();
        }

        return this.getFactory().createPolygon(t, e);
      }
    }, {
      key: "getTypeCode",
      value: function getTypeCode() {
        return V.TYPECODE_POLYGON;
      }
    }, {
      key: "getDimension",
      value: function getDimension() {
        return 2;
      }
    }, {
      key: "getLength",
      value: function getLength() {
        var t = 0;
        t += this._shell.getLength();

        for (var _e81 = 0; _e81 < this._holes.length; _e81++) {
          t += this._holes[_e81].getLength();
        }

        return t;
      }
    }, {
      key: "getNumPoints",
      value: function getNumPoints() {
        var t = this._shell.getNumPoints();

        for (var _e82 = 0; _e82 < this._holes.length; _e82++) {
          t += this._holes[_e82].getNumPoints();
        }

        return t;
      }
    }, {
      key: "convexHull",
      value: function convexHull() {
        return this.getExteriorRing().convexHull();
      }
    }, {
      key: "normalized",
      value: function normalized(t, e) {
        var n = t.copy();
        return this.normalize(n, e), n;
      }
    }, {
      key: "compareToSameClass",
      value: function compareToSameClass() {
        if (1 === arguments.length) {
          var _t128 = arguments[0],
              _e83 = this._shell,
              _n59 = _t128._shell;
          return _e83.compareToSameClass(_n59);
        }

        if (2 === arguments.length) {
          var _t129 = arguments[1],
              _e84 = arguments[0],
              _n60 = this._shell,
              _s34 = _e84._shell,
              _i25 = _n60.compareToSameClass(_s34, _t129);

          if (0 !== _i25) return _i25;

          var _r19 = this.getNumInteriorRing(),
              _o16 = _e84.getNumInteriorRing();

          var _l13 = 0;

          for (; _l13 < _r19 && _l13 < _o16;) {
            var _n61 = this.getInteriorRingN(_l13),
                _s35 = _e84.getInteriorRingN(_l13),
                _i26 = _n61.compareToSameClass(_s35, _t129);

            if (0 !== _i26) return _i26;
            _l13++;
          }

          return _l13 < _r19 ? 1 : _l13 < _o16 ? -1 : 0;
        }
      }
    }, {
      key: "apply",
      value: function apply() {
        if (y(arguments[0], z)) {
          var _t130 = arguments[0];

          this._shell.apply(_t130);

          for (var _e85 = 0; _e85 < this._holes.length; _e85++) {
            this._holes[_e85].apply(_t130);
          }
        } else if (y(arguments[0], L)) {
          var _t131 = arguments[0];
          if (this._shell.apply(_t131), !_t131.isDone()) for (var _e86 = 0; _e86 < this._holes.length && (this._holes[_e86].apply(_t131), !_t131.isDone()); _e86++) {
            ;
          }
          _t131.isGeometryChanged() && this.geometryChanged();
        } else if (y(arguments[0], Z)) {
          arguments[0].filter(this);
        } else if (y(arguments[0], Y)) {
          var _t132 = arguments[0];
          _t132.filter(this), this._shell.apply(_t132);

          for (var _e87 = 0; _e87 < this._holes.length; _e87++) {
            this._holes[_e87].apply(_t132);
          }
        }
      }
    }, {
      key: "getBoundary",
      value: function getBoundary() {
        if (this.isEmpty()) return this.getFactory().createMultiLineString();
        var t = new Array(this._holes.length + 1).fill(null);
        t[0] = this._shell;

        for (var _e88 = 0; _e88 < this._holes.length; _e88++) {
          t[_e88 + 1] = this._holes[_e88];
        }

        return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t);
      }
    }, {
      key: "getGeometryType",
      value: function getGeometryType() {
        return V.TYPENAME_POLYGON;
      }
    }, {
      key: "getExteriorRing",
      value: function getExteriorRing() {
        return this._shell;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return this._shell.isEmpty();
      }
    }, {
      key: "getInteriorRingN",
      value: function getInteriorRingN(t) {
        return this._holes[t];
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [tt];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._shell = null, this._holes = null;
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2];
        if (V.constructor_.call(this, n), null === t && (t = this.getFactory().createLinearRing()), null === e && (e = []), V.hasNullElements(e)) throw new s("holes must not contain null elements");
        if (t.isEmpty() && V.hasNonEmptyElements(e)) throw new s("shell is empty but holes are not");
        this._shell = t, this._holes = e;
      }
    }]);

    return et;
  }(V);

  var nt = /*#__PURE__*/function (_x2) {
    _inherits(nt, _x2);

    var _super13 = _createSuper(nt);

    function nt() {
      _classCallCheck(this, nt);

      return _super13.apply(this, arguments);
    }

    _createClass(nt, [{
      key: "contains",
      value: function contains() {}
    }]);

    return nt;
  }(x);

  var st = /*#__PURE__*/function (_nt) {
    _inherits(st, _nt);

    var _super14 = _createSuper(st);

    function st() {
      _classCallCheck(this, st);

      return _super14.apply(this, arguments);
    }

    return st;
  }(nt);

  var it = /*#__PURE__*/function (_st) {
    _inherits(it, _st);

    var _super15 = _createSuper(it);

    function it(t) {
      var _this7;

      _classCallCheck(this, it);

      _this7 = _super15.call(this), _this7.array = [], t instanceof x && _this7.addAll(t);
      return _this7;
    }

    _createClass(it, [{
      key: "contains",
      value: function contains(t) {
        var _iterator5 = _createForOfIteratorHelper(this.array),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _e89 = _step5.value;
            if (0 === _e89.compareTo(t)) return !0;
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        return !1;
      }
    }, {
      key: "add",
      value: function add(t) {
        if (this.contains(t)) return !1;

        for (var _e90 = 0, _n62 = this.array.length; _e90 < _n62; _e90++) {
          if (1 === this.array[_e90].compareTo(t)) return !!this.array.splice(_e90, 0, t);
        }

        return this.array.push(t), !0;
      }
    }, {
      key: "addAll",
      value: function addAll(t) {
        var _iterator6 = _createForOfIteratorHelper(t),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var _e91 = _step6.value;
            this.add(_e91);
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        return !0;
      }
    }, {
      key: "remove",
      value: function remove() {
        throw new H();
      }
    }, {
      key: "size",
      value: function size() {
        return this.array.length;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return 0 === this.array.length;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        return this.array.slice();
      }
    }, {
      key: "iterator",
      value: function iterator() {
        return new rt(this.array);
      }
    }]);

    return it;
  }(st);

  var rt = /*#__PURE__*/function () {
    function rt(t) {
      _classCallCheck(this, rt);

      this.array = t, this.position = 0;
    }

    _createClass(rt, [{
      key: "next",
      value: function next() {
        if (this.position === this.array.length) throw new N();
        return this.array[this.position++];
      }
    }, {
      key: "hasNext",
      value: function hasNext() {
        return this.position < this.array.length;
      }
    }, {
      key: "remove",
      value: function remove() {
        throw new H();
      }
    }]);

    return rt;
  }();

  var ot = /*#__PURE__*/function (_V4) {
    _inherits(ot, _V4);

    var _super16 = _createSuper(ot);

    function ot() {
      var _this8;

      _classCallCheck(this, ot);

      _this8 = _super16.call(this), ot.constructor_.apply(_assertThisInitialized(_this8), arguments);
      return _this8;
    }

    _createClass(ot, [{
      key: "computeEnvelopeInternal",
      value: function computeEnvelopeInternal() {
        var t = new T();

        for (var _e92 = 0; _e92 < this._geometries.length; _e92++) {
          t.expandToInclude(this._geometries[_e92].getEnvelopeInternal());
        }

        return t;
      }
    }, {
      key: "getGeometryN",
      value: function getGeometryN(t) {
        return this._geometries[t];
      }
    }, {
      key: "getCoordinates",
      value: function getCoordinates() {
        var t = new Array(this.getNumPoints()).fill(null);
        var e = -1;

        for (var _n63 = 0; _n63 < this._geometries.length; _n63++) {
          var _s36 = this._geometries[_n63].getCoordinates();

          for (var _n64 = 0; _n64 < _s36.length; _n64++) {
            e++, t[e] = _s36[_n64];
          }
        }

        return t;
      }
    }, {
      key: "getArea",
      value: function getArea() {
        var t = 0;

        for (var _e93 = 0; _e93 < this._geometries.length; _e93++) {
          t += this._geometries[_e93].getArea();
        }

        return t;
      }
    }, {
      key: "copyInternal",
      value: function copyInternal() {
        var t = new Array(this._geometries.length).fill(null);

        for (var _e94 = 0; _e94 < t.length; _e94++) {
          t[_e94] = this._geometries[_e94].copy();
        }

        return new ot(t, this._factory);
      }
    }, {
      key: "equalsExact",
      value: function equalsExact() {
        if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
          var _t133 = arguments[0],
              _e95 = arguments[1];
          if (!this.isEquivalentClass(_t133)) return !1;
          var _n65 = _t133;
          if (this._geometries.length !== _n65._geometries.length) return !1;

          for (var _t134 = 0; _t134 < this._geometries.length; _t134++) {
            if (!this._geometries[_t134].equalsExact(_n65._geometries[_t134], _e95)) return !1;
          }

          return !0;
        }

        return _get(_getPrototypeOf(ot.prototype), "equalsExact", this).apply(this, arguments);
      }
    }, {
      key: "normalize",
      value: function normalize() {
        for (var _t135 = 0; _t135 < this._geometries.length; _t135++) {
          this._geometries[_t135].normalize();
        }

        $.sort(this._geometries);
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        return this.isEmpty() ? null : this._geometries[0].getCoordinate();
      }
    }, {
      key: "getBoundaryDimension",
      value: function getBoundaryDimension() {
        var t = W.FALSE;

        for (var _e96 = 0; _e96 < this._geometries.length; _e96++) {
          t = Math.max(t, this._geometries[_e96].getBoundaryDimension());
        }

        return t;
      }
    }, {
      key: "reverseInternal",
      value: function reverseInternal() {
        var t = this._geometries.length,
            e = new S(t);

        for (var _n66 = 0; _n66 < t; _n66++) {
          e.add(this._geometries[_n66].reverse());
        }

        return this.getFactory().buildGeometry(e);
      }
    }, {
      key: "getTypeCode",
      value: function getTypeCode() {
        return V.TYPECODE_GEOMETRYCOLLECTION;
      }
    }, {
      key: "getDimension",
      value: function getDimension() {
        var t = W.FALSE;

        for (var _e97 = 0; _e97 < this._geometries.length; _e97++) {
          t = Math.max(t, this._geometries[_e97].getDimension());
        }

        return t;
      }
    }, {
      key: "getLength",
      value: function getLength() {
        var t = 0;

        for (var _e98 = 0; _e98 < this._geometries.length; _e98++) {
          t += this._geometries[_e98].getLength();
        }

        return t;
      }
    }, {
      key: "getNumPoints",
      value: function getNumPoints() {
        var t = 0;

        for (var _e99 = 0; _e99 < this._geometries.length; _e99++) {
          t += this._geometries[_e99].getNumPoints();
        }

        return t;
      }
    }, {
      key: "getNumGeometries",
      value: function getNumGeometries() {
        return this._geometries.length;
      }
    }, {
      key: "compareToSameClass",
      value: function compareToSameClass() {
        if (1 === arguments.length) {
          var _t136 = arguments[0],
              _e100 = new it($.asList(this._geometries)),
              _n67 = new it($.asList(_t136._geometries));

          return this.compare(_e100, _n67);
        }

        if (2 === arguments.length) {
          var _t137 = arguments[1],
              _e101 = arguments[0],
              _n68 = this.getNumGeometries(),
              _s37 = _e101.getNumGeometries();

          var _i27 = 0;

          for (; _i27 < _n68 && _i27 < _s37;) {
            var _n69 = this.getGeometryN(_i27),
                _s38 = _e101.getGeometryN(_i27),
                _r20 = _n69.compareToSameClass(_s38, _t137);

            if (0 !== _r20) return _r20;
            _i27++;
          }

          return _i27 < _n68 ? 1 : _i27 < _s37 ? -1 : 0;
        }
      }
    }, {
      key: "apply",
      value: function apply() {
        if (y(arguments[0], z)) {
          var _t138 = arguments[0];

          for (var _e102 = 0; _e102 < this._geometries.length; _e102++) {
            this._geometries[_e102].apply(_t138);
          }
        } else if (y(arguments[0], L)) {
          var _t139 = arguments[0];
          if (0 === this._geometries.length) return null;

          for (var _e103 = 0; _e103 < this._geometries.length && (this._geometries[_e103].apply(_t139), !_t139.isDone()); _e103++) {
            ;
          }

          _t139.isGeometryChanged() && this.geometryChanged();
        } else if (y(arguments[0], Z)) {
          var _t140 = arguments[0];

          _t140.filter(this);

          for (var _e104 = 0; _e104 < this._geometries.length; _e104++) {
            this._geometries[_e104].apply(_t140);
          }
        } else if (y(arguments[0], Y)) {
          var _t141 = arguments[0];

          _t141.filter(this);

          for (var _e105 = 0; _e105 < this._geometries.length; _e105++) {
            this._geometries[_e105].apply(_t141);
          }
        }
      }
    }, {
      key: "getBoundary",
      value: function getBoundary() {
        return V.checkNotGeometryCollection(this), g.shouldNeverReachHere(), null;
      }
    }, {
      key: "getGeometryType",
      value: function getGeometryType() {
        return V.TYPENAME_GEOMETRYCOLLECTION;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        for (var _t142 = 0; _t142 < this._geometries.length; _t142++) {
          if (!this._geometries[_t142].isEmpty()) return !1;
        }

        return !0;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._geometries = null, 0 === arguments.length) ;else if (2 === arguments.length) {
          var _t143 = arguments[0],
              _e106 = arguments[1];
          if (V.constructor_.call(this, _e106), null === _t143 && (_t143 = []), V.hasNullElements(_t143)) throw new s("geometries must not contain null elements");
          this._geometries = _t143;
        }
      }
    }]);

    return ot;
  }(V);

  var lt = /*#__PURE__*/function (_ot) {
    _inherits(lt, _ot);

    var _super17 = _createSuper(lt);

    function lt() {
      var _this9;

      _classCallCheck(this, lt);

      _this9 = _super17.call(this), lt.constructor_.apply(_assertThisInitialized(_this9), arguments);
      return _this9;
    }

    _createClass(lt, [{
      key: "copyInternal",
      value: function copyInternal() {
        var t = new Array(this._geometries.length).fill(null);

        for (var _e107 = 0; _e107 < t.length; _e107++) {
          t[_e107] = this._geometries[_e107].copy();
        }

        return new lt(t, this._factory);
      }
    }, {
      key: "isValid",
      value: function isValid() {
        return !0;
      }
    }, {
      key: "equalsExact",
      value: function equalsExact() {
        if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
          var _t144 = arguments[0],
              _e108 = arguments[1];
          return !!this.isEquivalentClass(_t144) && _get(_getPrototypeOf(lt.prototype), "equalsExact", this).call(this, _t144, _e108);
        }

        return _get(_getPrototypeOf(lt.prototype), "equalsExact", this).apply(this, arguments);
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        if (1 === arguments.length && Number.isInteger(arguments[0])) {
          var _t145 = arguments[0];
          return this._geometries[_t145].getCoordinate();
        }

        return _get(_getPrototypeOf(lt.prototype), "getCoordinate", this).apply(this, arguments);
      }
    }, {
      key: "getBoundaryDimension",
      value: function getBoundaryDimension() {
        return W.FALSE;
      }
    }, {
      key: "getTypeCode",
      value: function getTypeCode() {
        return V.TYPECODE_MULTIPOINT;
      }
    }, {
      key: "getDimension",
      value: function getDimension() {
        return 0;
      }
    }, {
      key: "getBoundary",
      value: function getBoundary() {
        return this.getFactory().createGeometryCollection();
      }
    }, {
      key: "getGeometryType",
      value: function getGeometryType() {
        return V.TYPENAME_MULTIPOINT;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [K];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        var t = arguments[0],
            e = arguments[1];
        ot.constructor_.call(this, t, e);
      }
    }]);

    return lt;
  }(ot);

  var at = /*#__PURE__*/function (_j) {
    _inherits(at, _j);

    var _super18 = _createSuper(at);

    function at() {
      var _this10;

      _classCallCheck(this, at);

      _this10 = _super18.call(this), at.constructor_.apply(_assertThisInitialized(_this10), arguments);
      return _this10;
    }

    _createClass(at, [{
      key: "copyInternal",
      value: function copyInternal() {
        return new at(this._points.copy(), this._factory);
      }
    }, {
      key: "getBoundaryDimension",
      value: function getBoundaryDimension() {
        return W.FALSE;
      }
    }, {
      key: "isClosed",
      value: function isClosed() {
        return !!this.isEmpty() || _get(_getPrototypeOf(at.prototype), "isClosed", this).call(this);
      }
    }, {
      key: "reverseInternal",
      value: function reverseInternal() {
        var t = this._points.copy();

        return U.reverse(t), this.getFactory().createLinearRing(t);
      }
    }, {
      key: "getTypeCode",
      value: function getTypeCode() {
        return V.TYPECODE_LINEARRING;
      }
    }, {
      key: "validateConstruction",
      value: function validateConstruction() {
        if (!this.isEmpty() && !_get(_getPrototypeOf(at.prototype), "isClosed", this).call(this)) throw new s("Points of LinearRing do not form a closed linestring");
        if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < at.MINIMUM_VALID_SIZE) throw new s("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
      }
    }, {
      key: "getGeometryType",
      value: function getGeometryType() {
        return V.TYPENAME_LINEARRING;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        var t = arguments[0],
            e = arguments[1];
        j.constructor_.call(this, t, e), this.validateConstruction();
      }
    }]);

    return at;
  }(j);

  at.MINIMUM_VALID_SIZE = 4;

  var ct = /*#__PURE__*/function (_m) {
    _inherits(ct, _m);

    var _super19 = _createSuper(ct);

    function ct() {
      var _this11;

      _classCallCheck(this, ct);

      _this11 = _super19.call(this), ct.constructor_.apply(_assertThisInitialized(_this11), arguments);
      return _this11;
    }

    _createClass(ct, [{
      key: "setOrdinate",
      value: function setOrdinate(t, e) {
        switch (t) {
          case ct.X:
            this.x = e;
            break;

          case ct.Y:
            this.y = e;
            break;

          default:
            throw new s("Invalid ordinate index: " + t);
        }
      }
    }, {
      key: "getZ",
      value: function getZ() {
        return m.NULL_ORDINATE;
      }
    }, {
      key: "getOrdinate",
      value: function getOrdinate(t) {
        switch (t) {
          case ct.X:
            return this.x;

          case ct.Y:
            return this.y;
        }

        throw new s("Invalid ordinate index: " + t);
      }
    }, {
      key: "setZ",
      value: function setZ(t) {
        throw new s("CoordinateXY dimension 2 does not support z-ordinate");
      }
    }, {
      key: "copy",
      value: function copy() {
        return new ct(this);
      }
    }, {
      key: "toString",
      value: function toString() {
        return "(" + this.x + ", " + this.y + ")";
      }
    }, {
      key: "setCoordinate",
      value: function setCoordinate(t) {
        this.x = t.x, this.y = t.y, this.z = t.getZ();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (0 === arguments.length) m.constructor_.call(this);else if (1 === arguments.length) {
          if (arguments[0] instanceof ct) {
            var _t146 = arguments[0];
            m.constructor_.call(this, _t146.x, _t146.y);
          } else if (arguments[0] instanceof m) {
            var _t147 = arguments[0];
            m.constructor_.call(this, _t147.x, _t147.y);
          }
        } else if (2 === arguments.length) {
          var _t148 = arguments[0],
              _e109 = arguments[1];
          m.constructor_.call(this, _t148, _e109, m.NULL_ORDINATE);
        }
      }
    }]);

    return ct;
  }(m);

  ct.X = 0, ct.Y = 1, ct.Z = -1, ct.M = -1;

  var ht = /*#__PURE__*/function (_m2) {
    _inherits(ht, _m2);

    var _super20 = _createSuper(ht);

    function ht() {
      var _this12;

      _classCallCheck(this, ht);

      _this12 = _super20.call(this), ht.constructor_.apply(_assertThisInitialized(_this12), arguments);
      return _this12;
    }

    _createClass(ht, [{
      key: "getM",
      value: function getM() {
        return this._m;
      }
    }, {
      key: "setOrdinate",
      value: function setOrdinate(t, e) {
        switch (t) {
          case ht.X:
            this.x = e;
            break;

          case ht.Y:
            this.y = e;
            break;

          case ht.M:
            this._m = e;
            break;

          default:
            throw new s("Invalid ordinate index: " + t);
        }
      }
    }, {
      key: "setM",
      value: function setM(t) {
        this._m = t;
      }
    }, {
      key: "getZ",
      value: function getZ() {
        return m.NULL_ORDINATE;
      }
    }, {
      key: "getOrdinate",
      value: function getOrdinate(t) {
        switch (t) {
          case ht.X:
            return this.x;

          case ht.Y:
            return this.y;

          case ht.M:
            return this._m;
        }

        throw new s("Invalid ordinate index: " + t);
      }
    }, {
      key: "setZ",
      value: function setZ(t) {
        throw new s("CoordinateXY dimension 2 does not support z-ordinate");
      }
    }, {
      key: "copy",
      value: function copy() {
        return new ht(this);
      }
    }, {
      key: "toString",
      value: function toString() {
        return "(" + this.x + ", " + this.y + " m=" + this.getM() + ")";
      }
    }, {
      key: "setCoordinate",
      value: function setCoordinate(t) {
        this.x = t.x, this.y = t.y, this.z = t.getZ(), this._m = t.getM();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._m = null, 0 === arguments.length) m.constructor_.call(this), this._m = 0;else if (1 === arguments.length) {
          if (arguments[0] instanceof ht) {
            var _t149 = arguments[0];
            m.constructor_.call(this, _t149.x, _t149.y), this._m = _t149._m;
          } else if (arguments[0] instanceof m) {
            var _t150 = arguments[0];
            m.constructor_.call(this, _t150.x, _t150.y), this._m = this.getM();
          }
        } else if (3 === arguments.length) {
          var _t151 = arguments[0],
              _e110 = arguments[1],
              _n70 = arguments[2];
          m.constructor_.call(this, _t151, _e110, m.NULL_ORDINATE), this._m = _n70;
        }
      }
    }]);

    return ht;
  }(m);

  ht.X = 0, ht.Y = 1, ht.Z = -1, ht.M = 2;

  var ut = /*#__PURE__*/function (_m3) {
    _inherits(ut, _m3);

    var _super21 = _createSuper(ut);

    function ut() {
      var _this13;

      _classCallCheck(this, ut);

      _this13 = _super21.call(this), ut.constructor_.apply(_assertThisInitialized(_this13), arguments);
      return _this13;
    }

    _createClass(ut, [{
      key: "getM",
      value: function getM() {
        return this._m;
      }
    }, {
      key: "setOrdinate",
      value: function setOrdinate(t, e) {
        switch (t) {
          case m.X:
            this.x = e;
            break;

          case m.Y:
            this.y = e;
            break;

          case m.Z:
            this.z = e;
            break;

          case m.M:
            this._m = e;
            break;

          default:
            throw new s("Invalid ordinate index: " + t);
        }
      }
    }, {
      key: "setM",
      value: function setM(t) {
        this._m = t;
      }
    }, {
      key: "getOrdinate",
      value: function getOrdinate(t) {
        switch (t) {
          case m.X:
            return this.x;

          case m.Y:
            return this.y;

          case m.Z:
            return this.getZ();

          case m.M:
            return this.getM();
        }

        throw new s("Invalid ordinate index: " + t);
      }
    }, {
      key: "copy",
      value: function copy() {
        return new ut(this);
      }
    }, {
      key: "toString",
      value: function toString() {
        return "(" + this.x + ", " + this.y + ", " + this.getZ() + " m=" + this.getM() + ")";
      }
    }, {
      key: "setCoordinate",
      value: function setCoordinate(t) {
        this.x = t.x, this.y = t.y, this.z = t.getZ(), this._m = t.getM();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._m = null, 0 === arguments.length) m.constructor_.call(this), this._m = 0;else if (1 === arguments.length) {
          if (arguments[0] instanceof ut) {
            var _t152 = arguments[0];
            m.constructor_.call(this, _t152), this._m = _t152._m;
          } else if (arguments[0] instanceof m) {
            var _t153 = arguments[0];
            m.constructor_.call(this, _t153), this._m = this.getM();
          }
        } else if (4 === arguments.length) {
          var _t154 = arguments[0],
              _e111 = arguments[1],
              _n71 = arguments[2],
              _s39 = arguments[3];
          m.constructor_.call(this, _t154, _e111, _n71), this._m = _s39;
        }
      }
    }]);

    return ut;
  }(m);

  var gt = /*#__PURE__*/function () {
    function gt() {
      _classCallCheck(this, gt);
    }

    _createClass(gt, null, [{
      key: "measures",
      value: function measures(t) {
        return t instanceof ct ? 0 : t instanceof ht || t instanceof ut ? 1 : 0;
      }
    }, {
      key: "dimension",
      value: function dimension(t) {
        return t instanceof ct ? 2 : t instanceof ht ? 3 : t instanceof ut ? 4 : 3;
      }
    }, {
      key: "create",
      value: function create() {
        if (1 === arguments.length) {
          var _t155 = arguments[0];
          return gt.create(_t155, 0);
        }

        if (2 === arguments.length) {
          var _t156 = arguments[0],
              _e112 = arguments[1];
          return 2 === _t156 ? new ct() : 3 === _t156 && 0 === _e112 ? new m() : 3 === _t156 && 1 === _e112 ? new ht() : 4 === _t156 && 1 === _e112 ? new ut() : new m();
        }
      }
    }]);

    return gt;
  }();

  var dt = /*#__PURE__*/function () {
    function dt() {
      _classCallCheck(this, dt);
    }

    _createClass(dt, null, [{
      key: "isRing",
      value: function isRing(t) {
        return !(t.length < 4) && !!t[0].equals2D(t[t.length - 1]);
      }
    }, {
      key: "ptNotInList",
      value: function ptNotInList(t, e) {
        for (var _n72 = 0; _n72 < t.length; _n72++) {
          var _s40 = t[_n72];
          if (dt.indexOf(_s40, e) < 0) return _s40;
        }

        return null;
      }
    }, {
      key: "scroll",
      value: function scroll(t, e) {
        var n = dt.indexOf(e, t);
        if (n < 0) return null;
        var s = new Array(t.length).fill(null);
        F.arraycopy(t, n, s, 0, t.length - n), F.arraycopy(t, 0, s, t.length - n, n), F.arraycopy(s, 0, t, 0, t.length);
      }
    }, {
      key: "equals",
      value: function equals() {
        if (2 === arguments.length) {
          var _t157 = arguments[0],
              _e113 = arguments[1];
          if (_t157 === _e113) return !0;
          if (null === _t157 || null === _e113) return !1;
          if (_t157.length !== _e113.length) return !1;

          for (var _n73 = 0; _n73 < _t157.length; _n73++) {
            if (!_t157[_n73].equals(_e113[_n73])) return !1;
          }

          return !0;
        }

        if (3 === arguments.length) {
          var _t158 = arguments[0],
              _e114 = arguments[1],
              _n74 = arguments[2];
          if (_t158 === _e114) return !0;
          if (null === _t158 || null === _e114) return !1;
          if (_t158.length !== _e114.length) return !1;

          for (var _s41 = 0; _s41 < _t158.length; _s41++) {
            if (0 !== _n74.compare(_t158[_s41], _e114[_s41])) return !1;
          }

          return !0;
        }
      }
    }, {
      key: "intersection",
      value: function intersection(t, e) {
        var n = new C();

        for (var _s42 = 0; _s42 < t.length; _s42++) {
          e.intersects(t[_s42]) && n.add(t[_s42], !0);
        }

        return n.toCoordinateArray();
      }
    }, {
      key: "measures",
      value: function measures(t) {
        if (null === t || 0 === t.length) return 0;
        var e = 0;

        var _iterator7 = _createForOfIteratorHelper(t),
            _step7;

        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var _n75 = _step7.value;
            e = Math.max(e, gt.measures(_n75));
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }

        return e;
      }
    }, {
      key: "hasRepeatedPoints",
      value: function hasRepeatedPoints(t) {
        for (var _e115 = 1; _e115 < t.length; _e115++) {
          if (t[_e115 - 1].equals(t[_e115])) return !0;
        }

        return !1;
      }
    }, {
      key: "removeRepeatedPoints",
      value: function removeRepeatedPoints(t) {
        if (!dt.hasRepeatedPoints(t)) return t;
        return new C(t, !1).toCoordinateArray();
      }
    }, {
      key: "reverse",
      value: function reverse(t) {
        var e = t.length - 1,
            n = Math.trunc(e / 2);

        for (var _s43 = 0; _s43 <= n; _s43++) {
          var _n76 = t[_s43];
          t[_s43] = t[e - _s43], t[e - _s43] = _n76;
        }
      }
    }, {
      key: "removeNull",
      value: function removeNull(t) {
        var e = 0;

        for (var _n77 = 0; _n77 < t.length; _n77++) {
          null !== t[_n77] && e++;
        }

        var n = new Array(e).fill(null);
        if (0 === e) return n;
        var s = 0;

        for (var _e116 = 0; _e116 < t.length; _e116++) {
          null !== t[_e116] && (n[s++] = t[_e116]);
        }

        return n;
      }
    }, {
      key: "copyDeep",
      value: function copyDeep() {
        if (1 === arguments.length) {
          var _t159 = arguments[0],
              _e117 = new Array(_t159.length).fill(null);

          for (var _n78 = 0; _n78 < _t159.length; _n78++) {
            _e117[_n78] = _t159[_n78].copy();
          }

          return _e117;
        }

        if (5 === arguments.length) {
          var _t160 = arguments[0],
              _e118 = arguments[1],
              _n79 = arguments[2],
              _s44 = arguments[3],
              _i28 = arguments[4];

          for (var _r21 = 0; _r21 < _i28; _r21++) {
            _n79[_s44 + _r21] = _t160[_e118 + _r21].copy();
          }
        }
      }
    }, {
      key: "isEqualReversed",
      value: function isEqualReversed(t, e) {
        for (var _n80 = 0; _n80 < t.length; _n80++) {
          var _s45 = t[_n80],
              _i29 = e[t.length - _n80 - 1];
          if (0 !== _s45.compareTo(_i29)) return !1;
        }

        return !0;
      }
    }, {
      key: "envelope",
      value: function envelope(t) {
        var e = new T();

        for (var _n81 = 0; _n81 < t.length; _n81++) {
          e.expandToInclude(t[_n81]);
        }

        return e;
      }
    }, {
      key: "toCoordinateArray",
      value: function toCoordinateArray(t) {
        return t.toArray(dt.coordArrayType);
      }
    }, {
      key: "dimension",
      value: function dimension(t) {
        if (null === t || 0 === t.length) return 3;
        var e = 0;

        var _iterator8 = _createForOfIteratorHelper(t),
            _step8;

        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var _n82 = _step8.value;
            e = Math.max(e, gt.dimension(_n82));
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }

        return e;
      }
    }, {
      key: "atLeastNCoordinatesOrNothing",
      value: function atLeastNCoordinatesOrNothing(t, e) {
        return e.length >= t ? e : [];
      }
    }, {
      key: "indexOf",
      value: function indexOf(t, e) {
        for (var _n83 = 0; _n83 < e.length; _n83++) {
          if (t.equals(e[_n83])) return _n83;
        }

        return -1;
      }
    }, {
      key: "increasingDirection",
      value: function increasingDirection(t) {
        for (var _e119 = 0; _e119 < Math.trunc(t.length / 2); _e119++) {
          var _n84 = t.length - 1 - _e119,
              _s46 = t[_e119].compareTo(t[_n84]);

          if (0 !== _s46) return _s46;
        }

        return 1;
      }
    }, {
      key: "compare",
      value: function compare(t, e) {
        var n = 0;

        for (; n < t.length && n < e.length;) {
          var _s47 = t[n].compareTo(e[n]);

          if (0 !== _s47) return _s47;
          n++;
        }

        return n < e.length ? -1 : n < t.length ? 1 : 0;
      }
    }, {
      key: "minCoordinate",
      value: function minCoordinate(t) {
        var e = null;

        for (var _n85 = 0; _n85 < t.length; _n85++) {
          (null === e || e.compareTo(t[_n85]) > 0) && (e = t[_n85]);
        }

        return e;
      }
    }, {
      key: "extract",
      value: function extract(t, e, n) {
        e = G.clamp(e, 0, t.length);
        var s = (n = G.clamp(n, -1, t.length)) - e + 1;
        n < 0 && (s = 0), e >= t.length && (s = 0), n < e && (s = 0);
        var i = new Array(s).fill(null);
        if (0 === s) return i;
        var r = 0;

        for (var _s48 = e; _s48 <= n; _s48++) {
          i[r++] = t[_s48];
        }

        return i;
      }
    }]);

    return dt;
  }();

  dt.ForwardComparator = /*#__PURE__*/function () {
    function _class() {
      _classCallCheck(this, _class);
    }

    _createClass(_class, [{
      key: "compare",
      value: function compare(t, e) {
        var n = t,
            s = e;
        return dt.compare(n, s);
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [a];
      }
    }]);

    return _class;
  }(), dt.BidirectionalComparator = /*#__PURE__*/function () {
    function _class2() {
      _classCallCheck(this, _class2);
    }

    _createClass(_class2, [{
      key: "compare",
      value: function compare(t, e) {
        var n = t,
            s = e;
        if (n.length < s.length) return -1;
        if (n.length > s.length) return 1;
        if (0 === n.length) return 0;
        var i = dt.compare(n, s);
        return dt.isEqualReversed(n, s) ? 0 : i;
      }
    }, {
      key: "OLDcompare",
      value: function OLDcompare(t, e) {
        var n = t,
            s = e;
        if (n.length < s.length) return -1;
        if (n.length > s.length) return 1;
        if (0 === n.length) return 0;
        var i = dt.increasingDirection(n),
            r = dt.increasingDirection(s);
        var o = i > 0 ? 0 : n.length - 1,
            l = r > 0 ? 0 : n.length - 1;

        for (var _t161 = 0; _t161 < n.length; _t161++) {
          var _t162 = n[o].compareTo(s[l]);

          if (0 !== _t162) return _t162;
          o += i, l += r;
        }

        return 0;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [a];
      }
    }]);

    return _class2;
  }(), dt.coordArrayType = new Array(0).fill(null);

  var _t = /*#__PURE__*/function () {
    function _t(t) {
      _classCallCheck(this, _t);

      this.str = t;
    }

    _createClass(_t, [{
      key: "append",
      value: function append(t) {
        this.str += t;
      }
    }, {
      key: "setCharAt",
      value: function setCharAt(t, e) {
        this.str = this.str.substr(0, t) + e + this.str.substr(t + 1);
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.str;
      }
    }]);

    return _t;
  }();

  var pt = /*#__PURE__*/function () {
    function pt() {
      _classCallCheck(this, pt);

      pt.constructor_.apply(this, arguments);
    }

    _createClass(pt, [{
      key: "getM",
      value: function getM(t) {
        return this.hasM() ? this._coordinates[t].getM() : r.NaN;
      }
    }, {
      key: "setOrdinate",
      value: function setOrdinate(t, e, n) {
        switch (e) {
          case b.X:
            this._coordinates[t].x = n;
            break;

          case b.Y:
            this._coordinates[t].y = n;
            break;

          default:
            this._coordinates[t].setOrdinate(e, n);

        }
      }
    }, {
      key: "getZ",
      value: function getZ(t) {
        return this.hasZ() ? this._coordinates[t].getZ() : r.NaN;
      }
    }, {
      key: "size",
      value: function size() {
        return this._coordinates.length;
      }
    }, {
      key: "getOrdinate",
      value: function getOrdinate(t, e) {
        switch (e) {
          case b.X:
            return this._coordinates[t].x;

          case b.Y:
            return this._coordinates[t].y;

          default:
            return this._coordinates[t].getOrdinate(e);
        }
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        if (1 === arguments.length) {
          var _t163 = arguments[0];
          return this._coordinates[_t163];
        }

        if (2 === arguments.length) {
          var _t164 = arguments[0];
          arguments[1].setCoordinate(this._coordinates[_t164]);
        }
      }
    }, {
      key: "getCoordinateCopy",
      value: function getCoordinateCopy(t) {
        var e = this.createCoordinate();
        return e.setCoordinate(this._coordinates[t]), e;
      }
    }, {
      key: "createCoordinate",
      value: function createCoordinate() {
        return gt.create(this.getDimension(), this.getMeasures());
      }
    }, {
      key: "getDimension",
      value: function getDimension() {
        return this._dimension;
      }
    }, {
      key: "getX",
      value: function getX(t) {
        return this._coordinates[t].x;
      }
    }, {
      key: "getMeasures",
      value: function getMeasures() {
        return this._measures;
      }
    }, {
      key: "expandEnvelope",
      value: function expandEnvelope(t) {
        for (var _e120 = 0; _e120 < this._coordinates.length; _e120++) {
          t.expandToInclude(this._coordinates[_e120]);
        }

        return t;
      }
    }, {
      key: "copy",
      value: function copy() {
        var t = new Array(this.size()).fill(null);

        for (var _e121 = 0; _e121 < this._coordinates.length; _e121++) {
          var _n86 = this.createCoordinate();

          _n86.setCoordinate(this._coordinates[_e121]), t[_e121] = _n86;
        }

        return new pt(t, this._dimension, this._measures);
      }
    }, {
      key: "toString",
      value: function toString() {
        if (this._coordinates.length > 0) {
          var _t165 = new _t(17 * this._coordinates.length);

          _t165.append("("), _t165.append(this._coordinates[0]);

          for (var _e122 = 1; _e122 < this._coordinates.length; _e122++) {
            _t165.append(", "), _t165.append(this._coordinates[_e122]);
          }

          return _t165.append(")"), _t165.toString();
        }

        return "()";
      }
    }, {
      key: "getY",
      value: function getY(t) {
        return this._coordinates[t].y;
      }
    }, {
      key: "toCoordinateArray",
      value: function toCoordinateArray() {
        return this._coordinates;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [b, c];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._dimension = 3, this._measures = 0, this._coordinates = null, 1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            var _t166 = arguments[0];
            pt.constructor_.call(this, _t166, dt.dimension(_t166), dt.measures(_t166));
          } else if (Number.isInteger(arguments[0])) {
            var _t167 = arguments[0];
            this._coordinates = new Array(_t167).fill(null);

            for (var _e123 = 0; _e123 < _t167; _e123++) {
              this._coordinates[_e123] = new m();
            }
          } else if (y(arguments[0], b)) {
            var _t168 = arguments[0];
            if (null === _t168) return this._coordinates = new Array(0).fill(null), null;
            this._dimension = _t168.getDimension(), this._measures = _t168.getMeasures(), this._coordinates = new Array(_t168.size()).fill(null);

            for (var _e124 = 0; _e124 < this._coordinates.length; _e124++) {
              this._coordinates[_e124] = _t168.getCoordinateCopy(_e124);
            }
          }
        } else if (2 === arguments.length) {
          if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
            var _t169 = arguments[0],
                _e125 = arguments[1];
            pt.constructor_.call(this, _t169, _e125, dt.measures(_t169));
          } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var _t170 = arguments[0],
                _e126 = arguments[1];
            this._coordinates = new Array(_t170).fill(null), this._dimension = _e126;

            for (var _n87 = 0; _n87 < _t170; _n87++) {
              this._coordinates[_n87] = gt.create(_e126);
            }
          }
        } else if (3 === arguments.length) if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
          var _t171 = arguments[0],
              _e127 = arguments[1],
              _n88 = arguments[2];
          this._dimension = _e127, this._measures = _n88, this._coordinates = null === _t171 ? new Array(0).fill(null) : _t171;
        } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
          var _t172 = arguments[0],
              _e128 = arguments[1],
              _n89 = arguments[2];
          this._coordinates = new Array(_t172).fill(null), this._dimension = _e128, this._measures = _n89;

          for (var _e129 = 0; _e129 < _t172; _e129++) {
            this._coordinates[_e129] = this.createCoordinate();
          }
        }
      }
    }]);

    return pt;
  }();

  var mt = /*#__PURE__*/function () {
    function mt() {
      _classCallCheck(this, mt);
    }

    _createClass(mt, [{
      key: "readResolve",
      value: function readResolve() {
        return mt.instance();
      }
    }, {
      key: "create",
      value: function create() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            return new pt(arguments[0]);
          }

          if (y(arguments[0], b)) {
            return new pt(arguments[0]);
          }
        } else {
          if (2 === arguments.length) {
            var _t173 = arguments[1];
            return _t173 > 3 && (_t173 = 3), _t173 < 2 && (_t173 = 2), new pt(arguments[0], _t173);
          }

          if (3 === arguments.length) {
            var _t174 = arguments[2],
                _e130 = arguments[1] - _t174;

            return _t174 > 1 && (_t174 = 1), _e130 > 3 && (_e130 = 3), _e130 < 2 && (_e130 = 2), new pt(arguments[0], _e130 + _t174, _t174);
          }
        }
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [B, c];
      }
    }], [{
      key: "instance",
      value: function instance() {
        return mt.instanceObject;
      }
    }]);

    return mt;
  }();

  mt.instanceObject = new mt();

  var ft = /*#__PURE__*/function (_ot2) {
    _inherits(ft, _ot2);

    var _super22 = _createSuper(ft);

    function ft() {
      var _this14;

      _classCallCheck(this, ft);

      _this14 = _super22.call(this), ft.constructor_.apply(_assertThisInitialized(_this14), arguments);
      return _this14;
    }

    _createClass(ft, [{
      key: "copyInternal",
      value: function copyInternal() {
        var t = new Array(this._geometries.length).fill(null);

        for (var _e131 = 0; _e131 < t.length; _e131++) {
          t[_e131] = this._geometries[_e131].copy();
        }

        return new ft(t, this._factory);
      }
    }, {
      key: "equalsExact",
      value: function equalsExact() {
        if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
          var _t175 = arguments[0],
              _e132 = arguments[1];
          return !!this.isEquivalentClass(_t175) && _get(_getPrototypeOf(ft.prototype), "equalsExact", this).call(this, _t175, _e132);
        }

        return _get(_getPrototypeOf(ft.prototype), "equalsExact", this).apply(this, arguments);
      }
    }, {
      key: "getBoundaryDimension",
      value: function getBoundaryDimension() {
        return 1;
      }
    }, {
      key: "getTypeCode",
      value: function getTypeCode() {
        return V.TYPECODE_MULTIPOLYGON;
      }
    }, {
      key: "getDimension",
      value: function getDimension() {
        return 2;
      }
    }, {
      key: "getBoundary",
      value: function getBoundary() {
        if (this.isEmpty()) return this.getFactory().createMultiLineString();
        var t = new S();

        for (var _e133 = 0; _e133 < this._geometries.length; _e133++) {
          var _n90 = this._geometries[_e133].getBoundary();

          for (var _e134 = 0; _e134 < _n90.getNumGeometries(); _e134++) {
            t.add(_n90.getGeometryN(_e134));
          }
        }

        var e = new Array(t.size()).fill(null);
        return this.getFactory().createMultiLineString(t.toArray(e));
      }
    }, {
      key: "getGeometryType",
      value: function getGeometryType() {
        return V.TYPENAME_MULTIPOLYGON;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [tt];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        var t = arguments[0],
            e = arguments[1];
        ot.constructor_.call(this, t, e);
      }
    }]);

    return ft;
  }(ot);

  var yt = /*#__PURE__*/function () {
    function yt() {
      _classCallCheck(this, yt);
    }

    _createClass(yt, [{
      key: "get",
      value: function get() {}
    }, {
      key: "put",
      value: function put() {}
    }, {
      key: "size",
      value: function size() {}
    }, {
      key: "values",
      value: function values() {}
    }, {
      key: "entrySet",
      value: function entrySet() {}
    }]);

    return yt;
  }();

  var xt = /*#__PURE__*/function (_nt2) {
    _inherits(xt, _nt2);

    var _super23 = _createSuper(xt);

    function xt(t) {
      var _this15;

      _classCallCheck(this, xt);

      _this15 = _super23.call(this), _this15.map = new Map(), t instanceof x && _this15.addAll(t);
      return _this15;
    }

    _createClass(xt, [{
      key: "contains",
      value: function contains(t) {
        var e = t.hashCode ? t.hashCode() : t;
        return !!this.map.has(e);
      }
    }, {
      key: "add",
      value: function add(t) {
        var e = t.hashCode ? t.hashCode() : t;
        return !this.map.has(e) && !!this.map.set(e, t);
      }
    }, {
      key: "addAll",
      value: function addAll(t) {
        var _iterator9 = _createForOfIteratorHelper(t),
            _step9;

        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var _e135 = _step9.value;
            this.add(_e135);
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }

        return !0;
      }
    }, {
      key: "remove",
      value: function remove() {
        throw new H();
      }
    }, {
      key: "size",
      value: function size() {
        return this.map.size;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return 0 === this.map.size;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        return Array.from(this.map.values());
      }
    }, {
      key: "iterator",
      value: function iterator() {
        return new Et(this.map);
      }
    }, {
      key: Symbol.iterator,
      value: function value() {
        return this.map;
      }
    }]);

    return xt;
  }(nt);

  var Et = /*#__PURE__*/function () {
    function Et(t) {
      _classCallCheck(this, Et);

      this.iterator = t.values();

      var _this$iterator$next = this.iterator.next(),
          e = _this$iterator$next.done,
          n = _this$iterator$next.value;

      this.done = e, this.value = n;
    }

    _createClass(Et, [{
      key: "next",
      value: function next() {
        if (this.done) throw new N();

        var t = this.value,
            _this$iterator$next2 = this.iterator.next(),
            e = _this$iterator$next2.done,
            n = _this$iterator$next2.value;

        return this.done = e, this.value = n, t;
      }
    }, {
      key: "hasNext",
      value: function hasNext() {
        return !this.done;
      }
    }, {
      key: "remove",
      value: function remove() {
        throw new H();
      }
    }]);

    return Et;
  }();

  var It = /*#__PURE__*/function (_yt) {
    _inherits(It, _yt);

    var _super24 = _createSuper(It);

    function It() {
      var _this16;

      _classCallCheck(this, It);

      _this16 = _super24.call(this), _this16.map = new Map();
      return _this16;
    }

    _createClass(It, [{
      key: "get",
      value: function get(t) {
        return this.map.get(t) || null;
      }
    }, {
      key: "put",
      value: function put(t, e) {
        return this.map.set(t, e), e;
      }
    }, {
      key: "values",
      value: function values() {
        var t = new S(),
            e = this.map.values();
        var n = e.next();

        for (; !n.done;) {
          t.add(n.value), n = e.next();
        }

        return t;
      }
    }, {
      key: "entrySet",
      value: function entrySet() {
        var t = new xt();
        return this.map.entries().forEach(function (e) {
          return t.add(e);
        }), t;
      }
    }, {
      key: "size",
      value: function size() {
        return this.map.size();
      }
    }]);

    return It;
  }(yt);

  var Nt = /*#__PURE__*/function () {
    function Nt() {
      _classCallCheck(this, Nt);

      Nt.constructor_.apply(this, arguments);
    }

    _createClass(Nt, [{
      key: "equals",
      value: function equals(t) {
        if (!(t instanceof Nt)) return !1;
        var e = t;
        return this._modelType === e._modelType && this._scale === e._scale;
      }
    }, {
      key: "compareTo",
      value: function compareTo(t) {
        var e = t,
            n = this.getMaximumSignificantDigits(),
            s = e.getMaximumSignificantDigits();
        return P.compare(n, s);
      }
    }, {
      key: "getScale",
      value: function getScale() {
        return this._scale;
      }
    }, {
      key: "isFloating",
      value: function isFloating() {
        return this._modelType === Nt.FLOATING || this._modelType === Nt.FLOATING_SINGLE;
      }
    }, {
      key: "getType",
      value: function getType() {
        return this._modelType;
      }
    }, {
      key: "toString",
      value: function toString() {
        var t = "UNKNOWN";
        return this._modelType === Nt.FLOATING ? t = "Floating" : this._modelType === Nt.FLOATING_SINGLE ? t = "Floating-Single" : this._modelType === Nt.FIXED && (t = "Fixed (Scale=" + this.getScale() + ")"), t;
      }
    }, {
      key: "makePrecise",
      value: function makePrecise() {
        if ("number" == typeof arguments[0]) {
          var _t176 = arguments[0];
          if (r.isNaN(_t176)) return _t176;

          if (this._modelType === Nt.FLOATING_SINGLE) {
            return _t176;
          }

          return this._modelType === Nt.FIXED ? Math.round(_t176 * this._scale) / this._scale : _t176;
        }

        if (arguments[0] instanceof m) {
          var _t177 = arguments[0];
          if (this._modelType === Nt.FLOATING) return null;
          _t177.x = this.makePrecise(_t177.x), _t177.y = this.makePrecise(_t177.y);
        }
      }
    }, {
      key: "getMaximumSignificantDigits",
      value: function getMaximumSignificantDigits() {
        var t = 16;
        return this._modelType === Nt.FLOATING ? t = 16 : this._modelType === Nt.FLOATING_SINGLE ? t = 6 : this._modelType === Nt.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t;
      }
    }, {
      key: "setScale",
      value: function setScale(t) {
        this._scale = Math.abs(t);
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [c, o];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._modelType = null, this._scale = null, 0 === arguments.length) this._modelType = Nt.FLOATING;else if (1 === arguments.length) if (arguments[0] instanceof St) {
          var _t178 = arguments[0];
          this._modelType = _t178, _t178 === Nt.FIXED && this.setScale(1);
        } else if ("number" == typeof arguments[0]) {
          var _t179 = arguments[0];
          this._modelType = Nt.FIXED, this.setScale(_t179);
        } else if (arguments[0] instanceof Nt) {
          var _t180 = arguments[0];
          this._modelType = _t180._modelType, this._scale = _t180._scale;
        }
      }
    }, {
      key: "mostPrecise",
      value: function mostPrecise(t, e) {
        return t.compareTo(e) >= 0 ? t : e;
      }
    }]);

    return Nt;
  }();

  var St = /*#__PURE__*/function () {
    function St() {
      _classCallCheck(this, St);

      St.constructor_.apply(this, arguments);
    }

    _createClass(St, [{
      key: "readResolve",
      value: function readResolve() {
        return St.nameToTypeMap.get(this._name);
      }
    }, {
      key: "toString",
      value: function toString() {
        return this._name;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [c];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._name = null;
        var t = arguments[0];
        this._name = t, St.nameToTypeMap.put(t, this);
      }
    }]);

    return St;
  }();

  St.nameToTypeMap = new It(), Nt.Type = St, Nt.FIXED = new St("FIXED"), Nt.FLOATING = new St("FLOATING"), Nt.FLOATING_SINGLE = new St("FLOATING SINGLE"), Nt.maximumPreciseValue = 9007199254740992;

  var wt = /*#__PURE__*/function (_ot3) {
    _inherits(wt, _ot3);

    var _super25 = _createSuper(wt);

    function wt() {
      var _this17;

      _classCallCheck(this, wt);

      _this17 = _super25.call(this), wt.constructor_.apply(_assertThisInitialized(_this17), arguments);
      return _this17;
    }

    _createClass(wt, [{
      key: "copyInternal",
      value: function copyInternal() {
        var t = new Array(this._geometries.length).fill(null);

        for (var _e136 = 0; _e136 < t.length; _e136++) {
          t[_e136] = this._geometries[_e136].copy();
        }

        return new wt(t, this._factory);
      }
    }, {
      key: "equalsExact",
      value: function equalsExact() {
        if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
          var _t181 = arguments[0],
              _e137 = arguments[1];
          return !!this.isEquivalentClass(_t181) && _get(_getPrototypeOf(wt.prototype), "equalsExact", this).call(this, _t181, _e137);
        }

        return _get(_getPrototypeOf(wt.prototype), "equalsExact", this).apply(this, arguments);
      }
    }, {
      key: "getBoundaryDimension",
      value: function getBoundaryDimension() {
        return this.isClosed() ? W.FALSE : 0;
      }
    }, {
      key: "isClosed",
      value: function isClosed() {
        if (this.isEmpty()) return !1;

        for (var _t182 = 0; _t182 < this._geometries.length; _t182++) {
          if (!this._geometries[_t182].isClosed()) return !1;
        }

        return !0;
      }
    }, {
      key: "getTypeCode",
      value: function getTypeCode() {
        return V.TYPECODE_MULTILINESTRING;
      }
    }, {
      key: "getDimension",
      value: function getDimension() {
        return 1;
      }
    }, {
      key: "getBoundary",
      value: function getBoundary() {
        throw new H();
      }
    }, {
      key: "getGeometryType",
      value: function getGeometryType() {
        return V.TYPENAME_MULTILINESTRING;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [k];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        var t = arguments[0],
            e = arguments[1];
        ot.constructor_.call(this, t, e);
      }
    }]);

    return wt;
  }(ot);

  var Ct = /*#__PURE__*/function () {
    function Ct() {
      _classCallCheck(this, Ct);

      Ct.constructor_.apply(this, arguments);
    }

    _createClass(Ct, [{
      key: "createEmpty",
      value: function createEmpty(t) {
        switch (t) {
          case -1:
            return this.createGeometryCollection();

          case 0:
            return this.createPoint();

          case 1:
            return this.createLineString();

          case 2:
            return this.createPolygon();

          default:
            throw new s("Invalid dimension: " + t);
        }
      }
    }, {
      key: "toGeometry",
      value: function toGeometry(t) {
        return t.isNull() ? this.createPoint() : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new m(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new m(t.getMinX(), t.getMinY()), new m(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new m(t.getMinX(), t.getMinY()), new m(t.getMinX(), t.getMaxY()), new m(t.getMaxX(), t.getMaxY()), new m(t.getMaxX(), t.getMinY()), new m(t.getMinX(), t.getMinY())]), null);
      }
    }, {
      key: "createLineString",
      value: function createLineString() {
        if (0 === arguments.length) return this.createLineString(this.getCoordinateSequenceFactory().create([]));

        if (1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            var _t183 = arguments[0];
            return this.createLineString(null !== _t183 ? this.getCoordinateSequenceFactory().create(_t183) : null);
          }

          if (y(arguments[0], b)) {
            return new j(arguments[0], this);
          }
        }
      }
    }, {
      key: "createMultiLineString",
      value: function createMultiLineString() {
        if (0 === arguments.length) return new wt(null, this);

        if (1 === arguments.length) {
          return new wt(arguments[0], this);
        }
      }
    }, {
      key: "buildGeometry",
      value: function buildGeometry(t) {
        var e = null,
            n = !1,
            s = !1;

        for (var _i30 = t.iterator(); _i30.hasNext();) {
          var _t184 = _i30.next(),
              _r22 = _t184.getTypeCode();

          null === e && (e = _r22), _r22 !== e && (n = !0), _t184 instanceof ot && (s = !0);
        }

        if (null === e) return this.createGeometryCollection();
        if (n || s) return this.createGeometryCollection(Ct.toGeometryArray(t));
        var i = t.iterator().next();

        if (t.size() > 1) {
          if (i instanceof et) return this.createMultiPolygon(Ct.toPolygonArray(t));
          if (i instanceof j) return this.createMultiLineString(Ct.toLineStringArray(t));
          if (i instanceof Q) return this.createMultiPoint(Ct.toPointArray(t));
          g.shouldNeverReachHere("Unhandled geometry type: " + i.getGeometryType());
        }

        return i;
      }
    }, {
      key: "createMultiPointFromCoords",
      value: function createMultiPointFromCoords(t) {
        return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);
      }
    }, {
      key: "createPoint",
      value: function createPoint() {
        if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([]));

        if (1 === arguments.length) {
          if (arguments[0] instanceof m) {
            var _t185 = arguments[0];
            return this.createPoint(null !== _t185 ? this.getCoordinateSequenceFactory().create([_t185]) : null);
          }

          if (y(arguments[0], b)) {
            return new Q(arguments[0], this);
          }
        }
      }
    }, {
      key: "getCoordinateSequenceFactory",
      value: function getCoordinateSequenceFactory() {
        return this._coordinateSequenceFactory;
      }
    }, {
      key: "createPolygon",
      value: function createPolygon() {
        if (0 === arguments.length) return this.createPolygon(null, null);

        if (1 === arguments.length) {
          if (y(arguments[0], b)) {
            var _t186 = arguments[0];
            return this.createPolygon(this.createLinearRing(_t186));
          }

          if (arguments[0] instanceof Array) {
            var _t187 = arguments[0];
            return this.createPolygon(this.createLinearRing(_t187));
          }

          if (arguments[0] instanceof at) {
            var _t188 = arguments[0];
            return this.createPolygon(_t188, null);
          }
        } else if (2 === arguments.length) {
          return new et(arguments[0], arguments[1], this);
        }
      }
    }, {
      key: "getSRID",
      value: function getSRID() {
        return this._SRID;
      }
    }, {
      key: "createGeometryCollection",
      value: function createGeometryCollection() {
        if (0 === arguments.length) return new ot(null, this);

        if (1 === arguments.length) {
          return new ot(arguments[0], this);
        }
      }
    }, {
      key: "getPrecisionModel",
      value: function getPrecisionModel() {
        return this._precisionModel;
      }
    }, {
      key: "createLinearRing",
      value: function createLinearRing() {
        if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));

        if (1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            var _t189 = arguments[0];
            return this.createLinearRing(null !== _t189 ? this.getCoordinateSequenceFactory().create(_t189) : null);
          }

          if (y(arguments[0], b)) {
            return new at(arguments[0], this);
          }
        }
      }
    }, {
      key: "createMultiPolygon",
      value: function createMultiPolygon() {
        if (0 === arguments.length) return new ft(null, this);

        if (1 === arguments.length) {
          return new ft(arguments[0], this);
        }
      }
    }, {
      key: "createMultiPoint",
      value: function createMultiPoint() {
        if (0 === arguments.length) return new lt(null, this);

        if (1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            return new lt(arguments[0], this);
          }

          if (y(arguments[0], b)) {
            var _t190 = arguments[0];
            if (null === _t190) return this.createMultiPoint(new Array(0).fill(null));

            var _e138 = new Array(_t190.size()).fill(null);

            for (var _n91 = 0; _n91 < _t190.size(); _n91++) {
              var _s49 = this.getCoordinateSequenceFactory().create(1, _t190.getDimension(), _t190.getMeasures());

              U.copy(_t190, _n91, _s49, 0, 1), _e138[_n91] = this.createPoint(_s49);
            }

            return this.createMultiPoint(_e138);
          }
        }
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [c];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._precisionModel = null, this._coordinateSequenceFactory = null, this._SRID = null, 0 === arguments.length) Ct.constructor_.call(this, new Nt(), 0);else if (1 === arguments.length) {
          if (y(arguments[0], B)) {
            var _t191 = arguments[0];
            Ct.constructor_.call(this, new Nt(), 0, _t191);
          } else if (arguments[0] instanceof Nt) {
            var _t192 = arguments[0];
            Ct.constructor_.call(this, _t192, 0, Ct.getDefaultCoordinateSequenceFactory());
          }
        } else if (2 === arguments.length) {
          var _t193 = arguments[0],
              _e139 = arguments[1];
          Ct.constructor_.call(this, _t193, _e139, Ct.getDefaultCoordinateSequenceFactory());
        } else if (3 === arguments.length) {
          var _t194 = arguments[0],
              _e140 = arguments[1],
              _n92 = arguments[2];
          this._precisionModel = _t194, this._coordinateSequenceFactory = _n92, this._SRID = _e140;
        }
      }
    }, {
      key: "toMultiPolygonArray",
      value: function toMultiPolygonArray(t) {
        var e = new Array(t.size()).fill(null);
        return t.toArray(e);
      }
    }, {
      key: "toGeometryArray",
      value: function toGeometryArray(t) {
        if (null === t) return null;
        var e = new Array(t.size()).fill(null);
        return t.toArray(e);
      }
    }, {
      key: "getDefaultCoordinateSequenceFactory",
      value: function getDefaultCoordinateSequenceFactory() {
        return mt.instance();
      }
    }, {
      key: "toMultiLineStringArray",
      value: function toMultiLineStringArray(t) {
        var e = new Array(t.size()).fill(null);
        return t.toArray(e);
      }
    }, {
      key: "toLineStringArray",
      value: function toLineStringArray(t) {
        var e = new Array(t.size()).fill(null);
        return t.toArray(e);
      }
    }, {
      key: "toMultiPointArray",
      value: function toMultiPointArray(t) {
        var e = new Array(t.size()).fill(null);
        return t.toArray(e);
      }
    }, {
      key: "toLinearRingArray",
      value: function toLinearRingArray(t) {
        var e = new Array(t.size()).fill(null);
        return t.toArray(e);
      }
    }, {
      key: "toPointArray",
      value: function toPointArray(t) {
        var e = new Array(t.size()).fill(null);
        return t.toArray(e);
      }
    }, {
      key: "toPolygonArray",
      value: function toPolygonArray(t) {
        var e = new Array(t.size()).fill(null);
        return t.toArray(e);
      }
    }, {
      key: "createPointFromInternalCoord",
      value: function createPointFromInternalCoord(t, e) {
        return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t);
      }
    }]);

    return Ct;
  }();

  var Lt = "XY",
      Tt = "XYZ",
      Rt = "XYM",
      Pt = "XYZM",
      Ot = {
    POINT: "Point",
    LINE_STRING: "LineString",
    LINEAR_RING: "LinearRing",
    POLYGON: "Polygon",
    MULTI_POINT: "MultiPoint",
    MULTI_LINE_STRING: "MultiLineString",
    MULTI_POLYGON: "MultiPolygon",
    GEOMETRY_COLLECTION: "GeometryCollection",
    CIRCLE: "Circle"
  },
      vt = 1,
      Mt = 2,
      bt = 3,
      Dt = 4,
      At = 5,
      Ft = 6,
      Gt = {};

  for (var _t195 in Ot) {
    Gt[_t195] = Ot[_t195].toUpperCase();
  }

  var qt = /*#__PURE__*/function () {
    function qt(t) {
      _classCallCheck(this, qt);

      this.wkt = t, this.index_ = -1;
    }

    _createClass(qt, [{
      key: "isAlpha_",
      value: function isAlpha_(t) {
        return t >= "a" && t <= "z" || t >= "A" && t <= "Z";
      }
    }, {
      key: "isNumeric_",
      value: function isNumeric_(t, e) {
        return t >= "0" && t <= "9" || "." == t && !(void 0 !== e && e);
      }
    }, {
      key: "isWhiteSpace_",
      value: function isWhiteSpace_(t) {
        return " " == t || "\t" == t || "\r" == t || "\n" == t;
      }
    }, {
      key: "nextChar_",
      value: function nextChar_() {
        return this.wkt.charAt(++this.index_);
      }
    }, {
      key: "nextToken",
      value: function nextToken() {
        var t = this.nextChar_(),
            e = this.index_;
        var n,
            s = t;
        if ("(" == t) n = Mt;else if ("," == t) n = At;else if (")" == t) n = bt;else if (this.isNumeric_(t) || "-" == t) n = Dt, s = this.readNumber_();else if (this.isAlpha_(t)) n = vt, s = this.readText_();else {
          if (this.isWhiteSpace_(t)) return this.nextToken();
          if ("" !== t) throw new Error("Unexpected character: " + t);
          n = Ft;
        }
        return {
          position: e,
          value: s,
          type: n
        };
      }
    }, {
      key: "readNumber_",
      value: function readNumber_() {
        var t;
        var e = this.index_;
        var n = !1,
            s = !1;

        do {
          "." == t ? n = !0 : "e" != t && "E" != t || (s = !0), t = this.nextChar_();
        } while (this.isNumeric_(t, n) || !s && ("e" == t || "E" == t) || s && ("-" == t || "+" == t));

        return parseFloat(this.wkt.substring(e, this.index_--));
      }
    }, {
      key: "readText_",
      value: function readText_() {
        var t;
        var e = this.index_;

        do {
          t = this.nextChar_();
        } while (this.isAlpha_(t));

        return this.wkt.substring(e, this.index_--).toUpperCase();
      }
    }]);

    return qt;
  }();

  var Bt = /*#__PURE__*/function () {
    function Bt(t, e) {
      _classCallCheck(this, Bt);

      this.lexer_ = t, this.token_, this.layout_ = Lt, this.factory = e;
    }

    _createClass(Bt, [{
      key: "consume_",
      value: function consume_() {
        this.token_ = this.lexer_.nextToken();
      }
    }, {
      key: "isTokenType",
      value: function isTokenType(t) {
        return this.token_.type == t;
      }
    }, {
      key: "match",
      value: function match(t) {
        var e = this.isTokenType(t);
        return e && this.consume_(), e;
      }
    }, {
      key: "parse",
      value: function parse() {
        this.consume_();
        return this.parseGeometry_();
      }
    }, {
      key: "parseGeometryLayout_",
      value: function parseGeometryLayout_() {
        var t = Lt;
        var e = this.token_;

        if (this.isTokenType(vt)) {
          var _n93 = e.value;
          "Z" === _n93 ? t = Tt : "M" === _n93 ? t = Rt : "ZM" === _n93 && (t = Pt), t !== Lt && this.consume_();
        }

        return t;
      }
    }, {
      key: "parseGeometryCollectionText_",
      value: function parseGeometryCollectionText_() {
        if (this.match(Mt)) {
          var _t196 = [];

          do {
            _t196.push(this.parseGeometry_());
          } while (this.match(At));

          if (this.match(bt)) return _t196;
        } else if (this.isEmptyGeometry_()) return [];

        throw new Error(this.formatErrorMessage_());
      }
    }, {
      key: "parsePointText_",
      value: function parsePointText_() {
        if (this.match(Mt)) {
          var _t197 = this.parsePoint_();

          if (this.match(bt)) return _t197;
        } else if (this.isEmptyGeometry_()) return null;

        throw new Error(this.formatErrorMessage_());
      }
    }, {
      key: "parseLineStringText_",
      value: function parseLineStringText_() {
        if (this.match(Mt)) {
          var _t198 = this.parsePointList_();

          if (this.match(bt)) return _t198;
        } else if (this.isEmptyGeometry_()) return [];

        throw new Error(this.formatErrorMessage_());
      }
    }, {
      key: "parsePolygonText_",
      value: function parsePolygonText_() {
        if (this.match(Mt)) {
          var _t199 = this.parseLineStringTextList_();

          if (this.match(bt)) return _t199;
        } else if (this.isEmptyGeometry_()) return [];

        throw new Error(this.formatErrorMessage_());
      }
    }, {
      key: "parseMultiPointText_",
      value: function parseMultiPointText_() {
        if (this.match(Mt)) {
          var _t200;

          if (_t200 = this.token_.type == Mt ? this.parsePointTextList_() : this.parsePointList_(), this.match(bt)) return _t200;
        } else if (this.isEmptyGeometry_()) return [];

        throw new Error(this.formatErrorMessage_());
      }
    }, {
      key: "parseMultiLineStringText_",
      value: function parseMultiLineStringText_() {
        if (this.match(Mt)) {
          var _t201 = this.parseLineStringTextList_();

          if (this.match(bt)) return _t201;
        } else if (this.isEmptyGeometry_()) return [];

        throw new Error(this.formatErrorMessage_());
      }
    }, {
      key: "parseMultiPolygonText_",
      value: function parseMultiPolygonText_() {
        if (this.match(Mt)) {
          var _t202 = this.parsePolygonTextList_();

          if (this.match(bt)) return _t202;
        } else if (this.isEmptyGeometry_()) return [];

        throw new Error(this.formatErrorMessage_());
      }
    }, {
      key: "parsePoint_",
      value: function parsePoint_() {
        var t = [],
            e = this.layout_.length;

        for (var _n94 = 0; _n94 < e; ++_n94) {
          var _e141 = this.token_;
          if (!this.match(Dt)) break;
          t.push(_e141.value);
        }

        if (t.length == e) return t;
        throw new Error(this.formatErrorMessage_());
      }
    }, {
      key: "parsePointList_",
      value: function parsePointList_() {
        var t = [this.parsePoint_()];

        for (; this.match(At);) {
          t.push(this.parsePoint_());
        }

        return t;
      }
    }, {
      key: "parsePointTextList_",
      value: function parsePointTextList_() {
        var t = [this.parsePointText_()];

        for (; this.match(At);) {
          t.push(this.parsePointText_());
        }

        return t;
      }
    }, {
      key: "parseLineStringTextList_",
      value: function parseLineStringTextList_() {
        var t = [this.parseLineStringText_()];

        for (; this.match(At);) {
          t.push(this.parseLineStringText_());
        }

        return t;
      }
    }, {
      key: "parsePolygonTextList_",
      value: function parsePolygonTextList_() {
        var t = [this.parsePolygonText_()];

        for (; this.match(At);) {
          t.push(this.parsePolygonText_());
        }

        return t;
      }
    }, {
      key: "isEmptyGeometry_",
      value: function isEmptyGeometry_() {
        var t = this.isTokenType(vt) && "EMPTY" == this.token_.value;
        return t && this.consume_(), t;
      }
    }, {
      key: "formatErrorMessage_",
      value: function formatErrorMessage_() {
        return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
      }
    }, {
      key: "parseGeometry_",
      value: function parseGeometry_() {
        var t = this.factory,
            e = function e(t) {
          return _construct(m, _toConsumableArray(t));
        },
            n = function n(_n95) {
          var s = _n95.map(function (n) {
            return t.createLinearRing(n.map(e));
          });

          return s.length > 1 ? t.createPolygon(s[0], s.slice(1)) : t.createPolygon(s[0]);
        },
            s = this.token_;

        if (this.match(vt)) {
          var _i31 = s.value;

          if (this.layout_ = this.parseGeometryLayout_(), "GEOMETRYCOLLECTION" == _i31) {
            var _e142 = this.parseGeometryCollectionText_();

            return t.createGeometryCollection(_e142);
          }

          switch (_i31) {
            case "POINT":
              {
                var _e143 = this.parsePointText_();

                return _e143 ? t.createPoint(_construct(m, _toConsumableArray(_e143))) : t.createPoint();
              }

            case "LINESTRING":
              {
                var _n96 = this.parseLineStringText_().map(e);

                return t.createLineString(_n96);
              }

            case "LINEARRING":
              {
                var _n97 = this.parseLineStringText_().map(e);

                return t.createLinearRing(_n97);
              }

            case "POLYGON":
              {
                var _e144 = this.parsePolygonText_();

                return _e144 && 0 !== _e144.length ? n(_e144) : t.createPolygon();
              }

            case "MULTIPOINT":
              {
                var _n98 = this.parseMultiPointText_();

                if (!_n98 || 0 === _n98.length) return t.createMultiPoint();

                var _s50 = _n98.map(e).map(function (e) {
                  return t.createPoint(e);
                });

                return t.createMultiPoint(_s50);
              }

            case "MULTILINESTRING":
              {
                var _n99 = this.parseMultiLineStringText_().map(function (n) {
                  return t.createLineString(n.map(e));
                });

                return t.createMultiLineString(_n99);
              }

            case "MULTIPOLYGON":
              {
                var _e145 = this.parseMultiPolygonText_();

                if (!_e145 || 0 === _e145.length) return t.createMultiPolygon();

                var _s51 = _e145.map(n);

                return t.createMultiPolygon(_s51);
              }

            default:
              throw new Error("Invalid geometry type: " + _i31);
          }
        }

        throw new Error(this.formatErrorMessage_());
      }
    }]);

    return Bt;
  }();

  function Yt(t) {
    if (t.isEmpty()) return "";
    var e = t.getCoordinate(),
        n = [e.x, e.y];
    return e.z && n.push(e.z), e.m && n.push(e.m), n.join(" ");
  }

  function Vt(t) {
    var e = t.getCoordinates().map(function (t) {
      return [t.x, t.y];
    }),
        n = [];

    for (var _t203 = 0, _s52 = e.length; _t203 < _s52; ++_t203) {
      n.push(e[_t203].join(" "));
    }

    return n.join(", ");
  }

  function zt(t) {
    var e = [];
    e.push("(" + Vt(t.getExteriorRing()) + ")");

    for (var _n100 = 0, _s53 = t.getNumInteriorRing(); _n100 < _s53; ++_n100) {
      e.push("(" + Vt(t.getInteriorRingN(_n100)) + ")");
    }

    return e.join(", ");
  }

  var Xt = {
    Point: Yt,
    LineString: Vt,
    LinearRing: Vt,
    Polygon: zt,
    MultiPoint: function MultiPoint(t) {
      var e = [];

      for (var _n101 = 0, _s54 = t.getNumGeometries(); _n101 < _s54; ++_n101) {
        e.push("(" + Yt(t.getGeometryN(_n101)) + ")");
      }

      return e.join(", ");
    },
    MultiLineString: function MultiLineString(t) {
      var e = [];

      for (var _n102 = 0, _s55 = t.getNumGeometries(); _n102 < _s55; ++_n102) {
        e.push("(" + Vt(t.getGeometryN(_n102)) + ")");
      }

      return e.join(", ");
    },
    MultiPolygon: function MultiPolygon(t) {
      var e = [];

      for (var _n103 = 0, _s56 = t.getNumGeometries(); _n103 < _s56; ++_n103) {
        e.push("(" + zt(t.getGeometryN(_n103)) + ")");
      }

      return e.join(", ");
    },
    GeometryCollection: function GeometryCollection(t) {
      var e = [];

      for (var _n104 = 0, _s57 = t.getNumGeometries(); _n104 < _s57; ++_n104) {
        e.push(kt(t.getGeometryN(_n104)));
      }

      return e.join(", ");
    }
  };

  function kt(t) {
    var e = t.getGeometryType();
    var n = Xt[e];
    e = e.toUpperCase();

    var s = function (t) {
      var e = "";
      if (t.isEmpty()) return e;
      var n = t.getCoordinate();
      return n.z && (e += "Z"), n.m && (e += "M"), e;
    }(t);

    if (s.length > 0 && (e += " " + s), t.isEmpty()) return e + " EMPTY";
    return e + " (" + n(t) + ")";
  }

  var Ut = /*#__PURE__*/function () {
    function Ut(t) {
      _classCallCheck(this, Ut);

      this.geometryFactory = t || new Ct(), this.precisionModel = this.geometryFactory.getPrecisionModel();
    }

    _createClass(Ut, [{
      key: "read",
      value: function read(t) {
        var e = new qt(t);
        return new Bt(e, this.geometryFactory).parse();
      }
    }, {
      key: "write",
      value: function write(t) {
        return kt(t);
      }
    }]);

    return Ut;
  }();

  var Ht = /*#__PURE__*/function () {
    function Ht(t) {
      _classCallCheck(this, Ht);

      this.parser = new Ut(t);
    }

    _createClass(Ht, [{
      key: "write",
      value: function write(t) {
        return this.parser.write(t);
      }
    }], [{
      key: "toLineString",
      value: function toLineString(t, e) {
        if (2 !== arguments.length) throw new Error("Not implemented");
        return "LINESTRING ( " + t.x + " " + t.y + ", " + e.x + " " + e.y + " )";
      }
    }]);

    return Ht;
  }();

  var Wt = /*#__PURE__*/function () {
    function Wt() {
      _classCallCheck(this, Wt);

      Wt.constructor_.apply(this, arguments);
    }

    _createClass(Wt, [{
      key: "getIndexAlongSegment",
      value: function getIndexAlongSegment(t, e) {
        return this.computeIntLineIndex(), this._intLineIndex[t][e];
      }
    }, {
      key: "getTopologySummary",
      value: function getTopologySummary() {
        var t = new _t();
        return this.isEndPoint() && t.append(" endpoint"), this._isProper && t.append(" proper"), this.isCollinear() && t.append(" collinear"), t.toString();
      }
    }, {
      key: "computeIntersection",
      value: function computeIntersection(t, e, n, s) {
        this._inputLines[0][0] = t, this._inputLines[0][1] = e, this._inputLines[1][0] = n, this._inputLines[1][1] = s, this._result = this.computeIntersect(t, e, n, s);
      }
    }, {
      key: "getIntersectionNum",
      value: function getIntersectionNum() {
        return this._result;
      }
    }, {
      key: "computeIntLineIndex",
      value: function computeIntLineIndex() {
        if (0 === arguments.length) null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map(function () {
          return Array(2);
        }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));else if (1 === arguments.length) {
          var _t204 = arguments[0];
          this.getEdgeDistance(_t204, 0) > this.getEdgeDistance(_t204, 1) ? (this._intLineIndex[_t204][0] = 0, this._intLineIndex[_t204][1] = 1) : (this._intLineIndex[_t204][0] = 1, this._intLineIndex[_t204][1] = 0);
        }
      }
    }, {
      key: "isProper",
      value: function isProper() {
        return this.hasIntersection() && this._isProper;
      }
    }, {
      key: "setPrecisionModel",
      value: function setPrecisionModel(t) {
        this._precisionModel = t;
      }
    }, {
      key: "isInteriorIntersection",
      value: function isInteriorIntersection() {
        if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);

        if (1 === arguments.length) {
          var _t205 = arguments[0];

          for (var _e146 = 0; _e146 < this._result; _e146++) {
            if (!this._intPt[_e146].equals2D(this._inputLines[_t205][0]) && !this._intPt[_e146].equals2D(this._inputLines[_t205][1])) return !0;
          }

          return !1;
        }
      }
    }, {
      key: "getIntersection",
      value: function getIntersection(t) {
        return this._intPt[t];
      }
    }, {
      key: "isEndPoint",
      value: function isEndPoint() {
        return this.hasIntersection() && !this._isProper;
      }
    }, {
      key: "hasIntersection",
      value: function hasIntersection() {
        return this._result !== Wt.NO_INTERSECTION;
      }
    }, {
      key: "getEdgeDistance",
      value: function getEdgeDistance(t, e) {
        return Wt.computeEdgeDistance(this._intPt[e], this._inputLines[t][0], this._inputLines[t][1]);
      }
    }, {
      key: "isCollinear",
      value: function isCollinear() {
        return this._result === Wt.COLLINEAR_INTERSECTION;
      }
    }, {
      key: "toString",
      value: function toString() {
        return Ht.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Ht.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
      }
    }, {
      key: "getEndpoint",
      value: function getEndpoint(t, e) {
        return this._inputLines[t][e];
      }
    }, {
      key: "isIntersection",
      value: function isIntersection(t) {
        for (var _e147 = 0; _e147 < this._result; _e147++) {
          if (this._intPt[_e147].equals2D(t)) return !0;
        }

        return !1;
      }
    }, {
      key: "getIntersectionAlongSegment",
      value: function getIntersectionAlongSegment(t, e) {
        return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._result = null, this._inputLines = Array(2).fill().map(function () {
          return Array(2);
        }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new m(), this._intPt[1] = new m(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
      }
    }, {
      key: "computeEdgeDistance",
      value: function computeEdgeDistance(t, e, n) {
        var s = Math.abs(n.x - e.x),
            i = Math.abs(n.y - e.y);
        var r = -1;
        if (t.equals(e)) r = 0;else if (t.equals(n)) r = s > i ? s : i;else {
          var _n105 = Math.abs(t.x - e.x),
              _o17 = Math.abs(t.y - e.y);

          r = s > i ? _n105 : _o17, 0 !== r || t.equals(e) || (r = Math.max(_n105, _o17));
        }
        return g.isTrue(!(0 === r && !t.equals(e)), "Bad distance calculation"), r;
      }
    }, {
      key: "nonRobustComputeEdgeDistance",
      value: function nonRobustComputeEdgeDistance(t, e, n) {
        var s = t.x - e.x,
            i = t.y - e.y,
            r = Math.sqrt(s * s + i * i);
        return g.isTrue(!(0 === r && !t.equals(e)), "Invalid distance calculation"), r;
      }
    }]);

    return Wt;
  }();

  Wt.DONT_INTERSECT = 0, Wt.DO_INTERSECT = 1, Wt.COLLINEAR = 2, Wt.NO_INTERSECTION = 0, Wt.POINT_INTERSECTION = 1, Wt.COLLINEAR_INTERSECTION = 2;

  var Zt = /*#__PURE__*/function (_Wt) {
    _inherits(Zt, _Wt);

    var _super26 = _createSuper(Zt);

    function Zt() {
      _classCallCheck(this, Zt);

      return _super26.call(this);
    }

    _createClass(Zt, [{
      key: "isInSegmentEnvelopes",
      value: function isInSegmentEnvelopes(t) {
        var e = new T(this._inputLines[0][0], this._inputLines[0][1]),
            n = new T(this._inputLines[1][0], this._inputLines[1][1]);
        return e.contains(t) && n.contains(t);
      }
    }, {
      key: "computeIntersection",
      value: function computeIntersection() {
        if (3 !== arguments.length) return _get(_getPrototypeOf(Zt.prototype), "computeIntersection", this).apply(this, arguments);
        {
          var _t206 = arguments[0],
              _e148 = arguments[1],
              _n106 = arguments[2];
          if (this._isProper = !1, T.intersects(_e148, _n106, _t206) && 0 === D.index(_e148, _n106, _t206) && 0 === D.index(_n106, _e148, _t206)) return this._isProper = !0, (_t206.equals(_e148) || _t206.equals(_n106)) && (this._isProper = !1), this._result = Wt.POINT_INTERSECTION, null;
          this._result = Wt.NO_INTERSECTION;
        }
      }
    }, {
      key: "intersection",
      value: function intersection(t, e, n, s) {
        var i = this.intersectionSafe(t, e, n, s);
        return this.isInSegmentEnvelopes(i) || (i = new m(Zt.nearestEndpoint(t, e, n, s))), null !== this._precisionModel && this._precisionModel.makePrecise(i), i;
      }
    }, {
      key: "checkDD",
      value: function checkDD(t, e, n, s, i) {
        var r = M.intersection(t, e, n, s),
            o = this.isInSegmentEnvelopes(r);
        F.out.println("DD in env = " + o + "  --------------------- " + r), i.distance(r) > 1e-4 && F.out.println("Distance = " + i.distance(r));
      }
    }, {
      key: "intersectionSafe",
      value: function intersectionSafe(t, e, n, s) {
        var i = A.intersection(t, e, n, s);
        return null === i && (i = Zt.nearestEndpoint(t, e, n, s)), i;
      }
    }, {
      key: "computeCollinearIntersection",
      value: function computeCollinearIntersection(t, e, n, s) {
        var i = T.intersects(t, e, n),
            r = T.intersects(t, e, s),
            o = T.intersects(n, s, t),
            l = T.intersects(n, s, e);
        return i && r ? (this._intPt[0] = n, this._intPt[1] = s, Wt.COLLINEAR_INTERSECTION) : o && l ? (this._intPt[0] = t, this._intPt[1] = e, Wt.COLLINEAR_INTERSECTION) : i && o ? (this._intPt[0] = n, this._intPt[1] = t, !n.equals(t) || r || l ? Wt.COLLINEAR_INTERSECTION : Wt.POINT_INTERSECTION) : i && l ? (this._intPt[0] = n, this._intPt[1] = e, !n.equals(e) || r || o ? Wt.COLLINEAR_INTERSECTION : Wt.POINT_INTERSECTION) : r && o ? (this._intPt[0] = s, this._intPt[1] = t, !s.equals(t) || i || l ? Wt.COLLINEAR_INTERSECTION : Wt.POINT_INTERSECTION) : r && l ? (this._intPt[0] = s, this._intPt[1] = e, !s.equals(e) || i || o ? Wt.COLLINEAR_INTERSECTION : Wt.POINT_INTERSECTION) : Wt.NO_INTERSECTION;
      }
    }, {
      key: "computeIntersect",
      value: function computeIntersect(t, e, n, s) {
        if (this._isProper = !1, !T.intersects(t, e, n, s)) return Wt.NO_INTERSECTION;
        var i = D.index(t, e, n),
            r = D.index(t, e, s);
        if (i > 0 && r > 0 || i < 0 && r < 0) return Wt.NO_INTERSECTION;
        var o = D.index(n, s, t),
            l = D.index(n, s, e);
        if (o > 0 && l > 0 || o < 0 && l < 0) return Wt.NO_INTERSECTION;
        return 0 === i && 0 === r && 0 === o && 0 === l ? this.computeCollinearIntersection(t, e, n, s) : (0 === i || 0 === r || 0 === o || 0 === l ? (this._isProper = !1, t.equals2D(n) || t.equals2D(s) ? this._intPt[0] = t : e.equals2D(n) || e.equals2D(s) ? this._intPt[0] = e : 0 === i ? this._intPt[0] = new m(n) : 0 === r ? this._intPt[0] = new m(s) : 0 === o ? this._intPt[0] = new m(t) : 0 === l && (this._intPt[0] = new m(e))) : (this._isProper = !0, this._intPt[0] = this.intersection(t, e, n, s)), Wt.POINT_INTERSECTION);
      }
    }], [{
      key: "nearestEndpoint",
      value: function nearestEndpoint(t, e, n, s) {
        var i = t,
            r = q.pointToSegment(t, n, s),
            o = q.pointToSegment(e, n, s);
        return o < r && (r = o, i = e), o = q.pointToSegment(n, t, e), o < r && (r = o, i = n), o = q.pointToSegment(s, t, e), o < r && (r = o, i = s), i;
      }
    }]);

    return Zt;
  }(Wt);

  var jt = /*#__PURE__*/function () {
    function jt() {
      _classCallCheck(this, jt);

      jt.constructor_.apply(this, arguments);
    }

    _createClass(jt, [{
      key: "minX",
      value: function minX() {
        return Math.min(this.p0.x, this.p1.x);
      }
    }, {
      key: "orientationIndex",
      value: function orientationIndex() {
        if (arguments[0] instanceof jt) {
          var _t207 = arguments[0],
              _e149 = D.index(this.p0, this.p1, _t207.p0),
              _n107 = D.index(this.p0, this.p1, _t207.p1);

          return _e149 >= 0 && _n107 >= 0 || _e149 <= 0 && _n107 <= 0 ? Math.max(_e149, _n107) : 0;
        }

        if (arguments[0] instanceof m) {
          var _t208 = arguments[0];
          return D.index(this.p0, this.p1, _t208);
        }
      }
    }, {
      key: "toGeometry",
      value: function toGeometry(t) {
        return t.createLineString([this.p0, this.p1]);
      }
    }, {
      key: "isVertical",
      value: function isVertical() {
        return this.p0.x === this.p1.x;
      }
    }, {
      key: "equals",
      value: function equals(t) {
        if (!(t instanceof jt)) return !1;
        var e = t;
        return this.p0.equals(e.p0) && this.p1.equals(e.p1);
      }
    }, {
      key: "intersection",
      value: function intersection(t) {
        var e = new Zt();
        return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null;
      }
    }, {
      key: "project",
      value: function project() {
        if (arguments[0] instanceof m) {
          var _t209 = arguments[0];
          if (_t209.equals(this.p0) || _t209.equals(this.p1)) return new m(_t209);

          var _e150 = this.projectionFactor(_t209),
              _n108 = new m();

          return _n108.x = this.p0.x + _e150 * (this.p1.x - this.p0.x), _n108.y = this.p0.y + _e150 * (this.p1.y - this.p0.y), _n108;
        }

        if (arguments[0] instanceof jt) {
          var _t210 = arguments[0],
              _e151 = this.projectionFactor(_t210.p0),
              _n109 = this.projectionFactor(_t210.p1);

          if (_e151 >= 1 && _n109 >= 1) return null;
          if (_e151 <= 0 && _n109 <= 0) return null;

          var _s58 = this.project(_t210.p0);

          _e151 < 0 && (_s58 = this.p0), _e151 > 1 && (_s58 = this.p1);

          var _i32 = this.project(_t210.p1);

          return _n109 < 0 && (_i32 = this.p0), _n109 > 1 && (_i32 = this.p1), new jt(_s58, _i32);
        }
      }
    }, {
      key: "normalize",
      value: function normalize() {
        this.p1.compareTo(this.p0) < 0 && this.reverse();
      }
    }, {
      key: "angle",
      value: function angle() {
        return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate(t) {
        return 0 === t ? this.p0 : this.p1;
      }
    }, {
      key: "distancePerpendicular",
      value: function distancePerpendicular(t) {
        return q.pointToLinePerpendicular(t, this.p0, this.p1);
      }
    }, {
      key: "minY",
      value: function minY() {
        return Math.min(this.p0.y, this.p1.y);
      }
    }, {
      key: "midPoint",
      value: function midPoint() {
        return jt.midPoint(this.p0, this.p1);
      }
    }, {
      key: "projectionFactor",
      value: function projectionFactor(t) {
        if (t.equals(this.p0)) return 0;
        if (t.equals(this.p1)) return 1;
        var e = this.p1.x - this.p0.x,
            n = this.p1.y - this.p0.y,
            s = e * e + n * n;
        if (s <= 0) return r.NaN;
        return ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / s;
      }
    }, {
      key: "closestPoints",
      value: function closestPoints(t) {
        var e = this.intersection(t);
        if (null !== e) return [e, e];
        var n = new Array(2).fill(null);
        var s = r.MAX_VALUE,
            i = null;
        var o = this.closestPoint(t.p0);
        s = o.distance(t.p0), n[0] = o, n[1] = t.p0;
        var l = this.closestPoint(t.p1);
        i = l.distance(t.p1), i < s && (s = i, n[0] = l, n[1] = t.p1);
        var a = t.closestPoint(this.p0);
        i = a.distance(this.p0), i < s && (s = i, n[0] = this.p0, n[1] = a);
        var c = t.closestPoint(this.p1);
        return i = c.distance(this.p1), i < s && (s = i, n[0] = this.p1, n[1] = c), n;
      }
    }, {
      key: "closestPoint",
      value: function closestPoint(t) {
        var e = this.projectionFactor(t);
        if (e > 0 && e < 1) return this.project(t);
        return this.p0.distance(t) < this.p1.distance(t) ? this.p0 : this.p1;
      }
    }, {
      key: "maxX",
      value: function maxX() {
        return Math.max(this.p0.x, this.p1.x);
      }
    }, {
      key: "getLength",
      value: function getLength() {
        return this.p0.distance(this.p1);
      }
    }, {
      key: "compareTo",
      value: function compareTo(t) {
        var e = t,
            n = this.p0.compareTo(e.p0);
        return 0 !== n ? n : this.p1.compareTo(e.p1);
      }
    }, {
      key: "reverse",
      value: function reverse() {
        var t = this.p0;
        this.p0 = this.p1, this.p1 = t;
      }
    }, {
      key: "equalsTopo",
      value: function equalsTopo(t) {
        return this.p0.equals(t.p0) && this.p1.equals(t.p1) || this.p0.equals(t.p1) && this.p1.equals(t.p0);
      }
    }, {
      key: "lineIntersection",
      value: function lineIntersection(t) {
        return A.intersection(this.p0, this.p1, t.p0, t.p1);
      }
    }, {
      key: "maxY",
      value: function maxY() {
        return Math.max(this.p0.y, this.p1.y);
      }
    }, {
      key: "pointAlongOffset",
      value: function pointAlongOffset(t, e) {
        var n = this.p0.x + t * (this.p1.x - this.p0.x),
            s = this.p0.y + t * (this.p1.y - this.p0.y),
            i = this.p1.x - this.p0.x,
            r = this.p1.y - this.p0.y,
            o = Math.sqrt(i * i + r * r);
        var l = 0,
            a = 0;

        if (0 !== e) {
          if (o <= 0) throw new IllegalStateException("Cannot compute offset from zero-length line segment");
          l = e * i / o, a = e * r / o;
        }

        return new m(n - a, s + l);
      }
    }, {
      key: "setCoordinates",
      value: function setCoordinates() {
        if (1 === arguments.length) {
          var _t211 = arguments[0];
          this.setCoordinates(_t211.p0, _t211.p1);
        } else if (2 === arguments.length) {
          var _t212 = arguments[0],
              _e152 = arguments[1];
          this.p0.x = _t212.x, this.p0.y = _t212.y, this.p1.x = _e152.x, this.p1.y = _e152.y;
        }
      }
    }, {
      key: "segmentFraction",
      value: function segmentFraction(t) {
        var e = this.projectionFactor(t);
        return e < 0 ? e = 0 : (e > 1 || r.isNaN(e)) && (e = 1), e;
      }
    }, {
      key: "toString",
      value: function toString() {
        return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
      }
    }, {
      key: "isHorizontal",
      value: function isHorizontal() {
        return this.p0.y === this.p1.y;
      }
    }, {
      key: "reflect",
      value: function reflect(t) {
        var e = this.p1.getY() - this.p0.getY(),
            n = this.p0.getX() - this.p1.getX(),
            s = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY()),
            i = e * e + n * n,
            r = e * e - n * n,
            o = t.getX(),
            l = t.getY();
        return new m((-r * o - 2 * e * n * l - 2 * e * s) / i, (r * l - 2 * e * n * o - 2 * n * s) / i);
      }
    }, {
      key: "distance",
      value: function distance() {
        if (arguments[0] instanceof jt) {
          var _t213 = arguments[0];
          return q.segmentToSegment(this.p0, this.p1, _t213.p0, _t213.p1);
        }

        if (arguments[0] instanceof m) {
          var _t214 = arguments[0];
          return q.pointToSegment(_t214, this.p0, this.p1);
        }
      }
    }, {
      key: "pointAlong",
      value: function pointAlong(t) {
        var e = new m();
        return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e;
      }
    }, {
      key: "hashCode",
      value: function hashCode() {
        var t = r.doubleToLongBits(this.p0.x);
        t ^= 31 * r.doubleToLongBits(this.p0.y);
        var e = Math.trunc(t) ^ Math.trunc(t >> 32);
        var n = r.doubleToLongBits(this.p1.x);
        n ^= 31 * r.doubleToLongBits(this.p1.y);
        return e ^ (Math.trunc(n) ^ Math.trunc(n >> 32));
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [o, c];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this.p0 = null, this.p1 = null, 0 === arguments.length) jt.constructor_.call(this, new m(), new m());else if (1 === arguments.length) {
          var _t215 = arguments[0];
          jt.constructor_.call(this, _t215.p0, _t215.p1);
        } else if (2 === arguments.length) {
          var _t216 = arguments[0],
              _e153 = arguments[1];
          this.p0 = _t216, this.p1 = _e153;
        } else if (4 === arguments.length) {
          var _t217 = arguments[0],
              _e154 = arguments[1],
              _n110 = arguments[2],
              _s59 = arguments[3];
          jt.constructor_.call(this, new m(_t217, _e154), new m(_n110, _s59));
        }
      }
    }, {
      key: "midPoint",
      value: function midPoint(t, e) {
        return new m((t.x + e.x) / 2, (t.y + e.y) / 2);
      }
    }]);

    return jt;
  }();

  var Kt = /*#__PURE__*/function () {
    function Kt() {
      _classCallCheck(this, Kt);
    }

    _createClass(Kt, null, [{
      key: "toLocationSymbol",
      value: function toLocationSymbol(t) {
        switch (t) {
          case Kt.EXTERIOR:
            return "e";

          case Kt.BOUNDARY:
            return "b";

          case Kt.INTERIOR:
            return "i";

          case Kt.NONE:
            return "-";
        }

        throw new s("Unknown location value: " + t);
      }
    }]);

    return Kt;
  }();

  Kt.INTERIOR = 0, Kt.BOUNDARY = 1, Kt.EXTERIOR = 2, Kt.NONE = -1;

  var Qt = /*#__PURE__*/function () {
    function Qt() {
      _classCallCheck(this, Qt);

      Qt.constructor_.apply(this, arguments);
    }

    _createClass(Qt, [{
      key: "isIntersects",
      value: function isIntersects() {
        return !this.isDisjoint();
      }
    }, {
      key: "isCovers",
      value: function isCovers() {
        return (Qt.isTrue(this._matrix[Kt.INTERIOR][Kt.INTERIOR]) || Qt.isTrue(this._matrix[Kt.INTERIOR][Kt.BOUNDARY]) || Qt.isTrue(this._matrix[Kt.BOUNDARY][Kt.INTERIOR]) || Qt.isTrue(this._matrix[Kt.BOUNDARY][Kt.BOUNDARY])) && this._matrix[Kt.EXTERIOR][Kt.INTERIOR] === W.FALSE && this._matrix[Kt.EXTERIOR][Kt.BOUNDARY] === W.FALSE;
      }
    }, {
      key: "isCoveredBy",
      value: function isCoveredBy() {
        return (Qt.isTrue(this._matrix[Kt.INTERIOR][Kt.INTERIOR]) || Qt.isTrue(this._matrix[Kt.INTERIOR][Kt.BOUNDARY]) || Qt.isTrue(this._matrix[Kt.BOUNDARY][Kt.INTERIOR]) || Qt.isTrue(this._matrix[Kt.BOUNDARY][Kt.BOUNDARY])) && this._matrix[Kt.INTERIOR][Kt.EXTERIOR] === W.FALSE && this._matrix[Kt.BOUNDARY][Kt.EXTERIOR] === W.FALSE;
      }
    }, {
      key: "set",
      value: function set() {
        if (1 === arguments.length) {
          var _t218 = arguments[0];

          for (var _e155 = 0; _e155 < _t218.length; _e155++) {
            var _n111 = Math.trunc(_e155 / 3),
                _s60 = _e155 % 3;

            this._matrix[_n111][_s60] = W.toDimensionValue(_t218.charAt(_e155));
          }
        } else if (3 === arguments.length) {
          var _t219 = arguments[0],
              _e156 = arguments[1],
              _n112 = arguments[2];
          this._matrix[_t219][_e156] = _n112;
        }
      }
    }, {
      key: "isContains",
      value: function isContains() {
        return Qt.isTrue(this._matrix[Kt.INTERIOR][Kt.INTERIOR]) && this._matrix[Kt.EXTERIOR][Kt.INTERIOR] === W.FALSE && this._matrix[Kt.EXTERIOR][Kt.BOUNDARY] === W.FALSE;
      }
    }, {
      key: "setAtLeast",
      value: function setAtLeast() {
        if (1 === arguments.length) {
          var _t220 = arguments[0];

          for (var _e157 = 0; _e157 < _t220.length; _e157++) {
            var _n113 = Math.trunc(_e157 / 3),
                _s61 = _e157 % 3;

            this.setAtLeast(_n113, _s61, W.toDimensionValue(_t220.charAt(_e157)));
          }
        } else if (3 === arguments.length) {
          var _t221 = arguments[0],
              _e158 = arguments[1],
              _n114 = arguments[2];
          this._matrix[_t221][_e158] < _n114 && (this._matrix[_t221][_e158] = _n114);
        }
      }
    }, {
      key: "setAtLeastIfValid",
      value: function setAtLeastIfValid(t, e, n) {
        t >= 0 && e >= 0 && this.setAtLeast(t, e, n);
      }
    }, {
      key: "isWithin",
      value: function isWithin() {
        return Qt.isTrue(this._matrix[Kt.INTERIOR][Kt.INTERIOR]) && this._matrix[Kt.INTERIOR][Kt.EXTERIOR] === W.FALSE && this._matrix[Kt.BOUNDARY][Kt.EXTERIOR] === W.FALSE;
      }
    }, {
      key: "isTouches",
      value: function isTouches(t, e) {
        return t > e ? this.isTouches(e, t) : (t === W.A && e === W.A || t === W.L && e === W.L || t === W.L && e === W.A || t === W.P && e === W.A || t === W.P && e === W.L) && this._matrix[Kt.INTERIOR][Kt.INTERIOR] === W.FALSE && (Qt.isTrue(this._matrix[Kt.INTERIOR][Kt.BOUNDARY]) || Qt.isTrue(this._matrix[Kt.BOUNDARY][Kt.INTERIOR]) || Qt.isTrue(this._matrix[Kt.BOUNDARY][Kt.BOUNDARY]));
      }
    }, {
      key: "isOverlaps",
      value: function isOverlaps(t, e) {
        return t === W.P && e === W.P || t === W.A && e === W.A ? Qt.isTrue(this._matrix[Kt.INTERIOR][Kt.INTERIOR]) && Qt.isTrue(this._matrix[Kt.INTERIOR][Kt.EXTERIOR]) && Qt.isTrue(this._matrix[Kt.EXTERIOR][Kt.INTERIOR]) : t === W.L && e === W.L && 1 === this._matrix[Kt.INTERIOR][Kt.INTERIOR] && Qt.isTrue(this._matrix[Kt.INTERIOR][Kt.EXTERIOR]) && Qt.isTrue(this._matrix[Kt.EXTERIOR][Kt.INTERIOR]);
      }
    }, {
      key: "isEquals",
      value: function isEquals(t, e) {
        return t === e && Qt.isTrue(this._matrix[Kt.INTERIOR][Kt.INTERIOR]) && this._matrix[Kt.INTERIOR][Kt.EXTERIOR] === W.FALSE && this._matrix[Kt.BOUNDARY][Kt.EXTERIOR] === W.FALSE && this._matrix[Kt.EXTERIOR][Kt.INTERIOR] === W.FALSE && this._matrix[Kt.EXTERIOR][Kt.BOUNDARY] === W.FALSE;
      }
    }, {
      key: "toString",
      value: function toString() {
        var t = new _t("123456789");

        for (var _e159 = 0; _e159 < 3; _e159++) {
          for (var _n115 = 0; _n115 < 3; _n115++) {
            t.setCharAt(3 * _e159 + _n115, W.toDimensionSymbol(this._matrix[_e159][_n115]));
          }
        }

        return t.toString();
      }
    }, {
      key: "setAll",
      value: function setAll(t) {
        for (var _e160 = 0; _e160 < 3; _e160++) {
          for (var _n116 = 0; _n116 < 3; _n116++) {
            this._matrix[_e160][_n116] = t;
          }
        }
      }
    }, {
      key: "get",
      value: function get(t, e) {
        return this._matrix[t][e];
      }
    }, {
      key: "transpose",
      value: function transpose() {
        var t = this._matrix[1][0];
        return this._matrix[1][0] = this._matrix[0][1], this._matrix[0][1] = t, t = this._matrix[2][0], this._matrix[2][0] = this._matrix[0][2], this._matrix[0][2] = t, t = this._matrix[2][1], this._matrix[2][1] = this._matrix[1][2], this._matrix[1][2] = t, this;
      }
    }, {
      key: "matches",
      value: function matches(t) {
        if (9 !== t.length) throw new s("Should be length 9: " + t);

        for (var _e161 = 0; _e161 < 3; _e161++) {
          for (var _n117 = 0; _n117 < 3; _n117++) {
            if (!Qt.matches(this._matrix[_e161][_n117], t.charAt(3 * _e161 + _n117))) return !1;
          }
        }

        return !0;
      }
    }, {
      key: "add",
      value: function add(t) {
        for (var _e162 = 0; _e162 < 3; _e162++) {
          for (var _n118 = 0; _n118 < 3; _n118++) {
            this.setAtLeast(_e162, _n118, t.get(_e162, _n118));
          }
        }
      }
    }, {
      key: "isDisjoint",
      value: function isDisjoint() {
        return this._matrix[Kt.INTERIOR][Kt.INTERIOR] === W.FALSE && this._matrix[Kt.INTERIOR][Kt.BOUNDARY] === W.FALSE && this._matrix[Kt.BOUNDARY][Kt.INTERIOR] === W.FALSE && this._matrix[Kt.BOUNDARY][Kt.BOUNDARY] === W.FALSE;
      }
    }, {
      key: "isCrosses",
      value: function isCrosses(t, e) {
        return t === W.P && e === W.L || t === W.P && e === W.A || t === W.L && e === W.A ? Qt.isTrue(this._matrix[Kt.INTERIOR][Kt.INTERIOR]) && Qt.isTrue(this._matrix[Kt.INTERIOR][Kt.EXTERIOR]) : t === W.L && e === W.P || t === W.A && e === W.P || t === W.A && e === W.L ? Qt.isTrue(this._matrix[Kt.INTERIOR][Kt.INTERIOR]) && Qt.isTrue(this._matrix[Kt.EXTERIOR][Kt.INTERIOR]) : t === W.L && e === W.L && 0 === this._matrix[Kt.INTERIOR][Kt.INTERIOR];
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [l];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._matrix = null, 0 === arguments.length) this._matrix = Array(3).fill().map(function () {
          return Array(3);
        }), this.setAll(W.FALSE);else if (1 === arguments.length) if ("string" == typeof arguments[0]) {
          var _t222 = arguments[0];
          Qt.constructor_.call(this), this.set(_t222);
        } else if (arguments[0] instanceof Qt) {
          var _t223 = arguments[0];
          Qt.constructor_.call(this), this._matrix[Kt.INTERIOR][Kt.INTERIOR] = _t223._matrix[Kt.INTERIOR][Kt.INTERIOR], this._matrix[Kt.INTERIOR][Kt.BOUNDARY] = _t223._matrix[Kt.INTERIOR][Kt.BOUNDARY], this._matrix[Kt.INTERIOR][Kt.EXTERIOR] = _t223._matrix[Kt.INTERIOR][Kt.EXTERIOR], this._matrix[Kt.BOUNDARY][Kt.INTERIOR] = _t223._matrix[Kt.BOUNDARY][Kt.INTERIOR], this._matrix[Kt.BOUNDARY][Kt.BOUNDARY] = _t223._matrix[Kt.BOUNDARY][Kt.BOUNDARY], this._matrix[Kt.BOUNDARY][Kt.EXTERIOR] = _t223._matrix[Kt.BOUNDARY][Kt.EXTERIOR], this._matrix[Kt.EXTERIOR][Kt.INTERIOR] = _t223._matrix[Kt.EXTERIOR][Kt.INTERIOR], this._matrix[Kt.EXTERIOR][Kt.BOUNDARY] = _t223._matrix[Kt.EXTERIOR][Kt.BOUNDARY], this._matrix[Kt.EXTERIOR][Kt.EXTERIOR] = _t223._matrix[Kt.EXTERIOR][Kt.EXTERIOR];
        }
      }
    }, {
      key: "matches",
      value: function matches() {
        if (Number.isInteger(arguments[0]) && "string" == typeof arguments[1]) {
          var _t224 = arguments[0],
              _e163 = arguments[1];
          return _e163 === W.SYM_DONTCARE || _e163 === W.SYM_TRUE && (_t224 >= 0 || _t224 === W.TRUE) || _e163 === W.SYM_FALSE && _t224 === W.FALSE || _e163 === W.SYM_P && _t224 === W.P || _e163 === W.SYM_L && _t224 === W.L || _e163 === W.SYM_A && _t224 === W.A;
        }

        if ("string" == typeof arguments[0] && "string" == typeof arguments[1]) {
          var _t225 = arguments[1];
          return new Qt(arguments[0]).matches(_t225);
        }
      }
    }, {
      key: "isTrue",
      value: function isTrue(t) {
        return t >= 0 || t === W.TRUE;
      }
    }]);

    return Qt;
  }();

  var Jt = /*#__PURE__*/function () {
    function Jt() {
      _classCallCheck(this, Jt);
    }

    _createClass(Jt, null, [{
      key: "toDegrees",
      value: function toDegrees(t) {
        return 180 * t / Math.PI;
      }
    }, {
      key: "normalize",
      value: function normalize(t) {
        for (; t > Math.PI;) {
          t -= Jt.PI_TIMES_2;
        }

        for (; t <= -Math.PI;) {
          t += Jt.PI_TIMES_2;
        }

        return t;
      }
    }, {
      key: "angle",
      value: function angle() {
        if (1 === arguments.length) {
          var _t226 = arguments[0];
          return Math.atan2(_t226.y, _t226.x);
        }

        if (2 === arguments.length) {
          var _t227 = arguments[0],
              _e164 = arguments[1],
              _n119 = _e164.x - _t227.x,
              _s62 = _e164.y - _t227.y;

          return Math.atan2(_s62, _n119);
        }
      }
    }, {
      key: "isAcute",
      value: function isAcute(t, e, n) {
        var s = t.x - e.x,
            i = t.y - e.y;
        return s * (n.x - e.x) + i * (n.y - e.y) > 0;
      }
    }, {
      key: "isObtuse",
      value: function isObtuse(t, e, n) {
        var s = t.x - e.x,
            i = t.y - e.y;
        return s * (n.x - e.x) + i * (n.y - e.y) < 0;
      }
    }, {
      key: "interiorAngle",
      value: function interiorAngle(t, e, n) {
        var s = Jt.angle(e, t),
            i = Jt.angle(e, n);
        return Math.abs(i - s);
      }
    }, {
      key: "normalizePositive",
      value: function normalizePositive(t) {
        if (t < 0) {
          for (; t < 0;) {
            t += Jt.PI_TIMES_2;
          }

          t >= Jt.PI_TIMES_2 && (t = 0);
        } else {
          for (; t >= Jt.PI_TIMES_2;) {
            t -= Jt.PI_TIMES_2;
          }

          t < 0 && (t = 0);
        }

        return t;
      }
    }, {
      key: "angleBetween",
      value: function angleBetween(t, e, n) {
        var s = Jt.angle(e, t),
            i = Jt.angle(e, n);
        return Jt.diff(s, i);
      }
    }, {
      key: "diff",
      value: function diff(t, e) {
        var n = null;
        return n = t < e ? e - t : t - e, n > Math.PI && (n = 2 * Math.PI - n), n;
      }
    }, {
      key: "toRadians",
      value: function toRadians(t) {
        return t * Math.PI / 180;
      }
    }, {
      key: "getTurn",
      value: function getTurn(t, e) {
        var n = Math.sin(e - t);
        return n > 0 ? Jt.COUNTERCLOCKWISE : n < 0 ? Jt.CLOCKWISE : Jt.NONE;
      }
    }, {
      key: "angleBetweenOriented",
      value: function angleBetweenOriented(t, e, n) {
        var s = Jt.angle(e, t),
            i = Jt.angle(e, n) - s;
        return i <= -Math.PI ? i + Jt.PI_TIMES_2 : i > Math.PI ? i - Jt.PI_TIMES_2 : i;
      }
    }]);

    return Jt;
  }();

  Jt.PI_TIMES_2 = 2 * Math.PI, Jt.PI_OVER_2 = Math.PI / 2, Jt.PI_OVER_4 = Math.PI / 4, Jt.COUNTERCLOCKWISE = D.COUNTERCLOCKWISE, Jt.CLOCKWISE = D.CLOCKWISE, Jt.NONE = D.COLLINEAR;

  var $t = /*#__PURE__*/function (_n120) {
    _inherits($t, _n120);

    var _super27 = _createSuper($t);

    function $t() {
      var _this18;

      _classCallCheck(this, $t);

      _this18 = _super27.call(this), $t.constructor_.apply(_assertThisInitialized(_this18), arguments);
      return _this18;
    }

    _createClass($t, null, [{
      key: "constructor_",
      value: function constructor_() {
        n.constructor_.call(this, "Projective point not representable on the Cartesian plane.");
      }
    }]);

    return $t;
  }(n);

  var te = /*#__PURE__*/function () {
    function te() {
      _classCallCheck(this, te);

      te.constructor_.apply(this, arguments);
    }

    _createClass(te, [{
      key: "getY",
      value: function getY() {
        var t = this.y / this.w;
        if (r.isNaN(t) || r.isInfinite(t)) throw new $t();
        return t;
      }
    }, {
      key: "getX",
      value: function getX() {
        var t = this.x / this.w;
        if (r.isNaN(t) || r.isInfinite(t)) throw new $t();
        return t;
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        var t = new m();
        return t.x = this.getX(), t.y = this.getY(), t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1;else if (1 === arguments.length) {
          var _t228 = arguments[0];
          this.x = _t228.x, this.y = _t228.y, this.w = 1;
        } else if (2 === arguments.length) {
          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var _t229 = arguments[0],
                _e165 = arguments[1];
            this.x = _t229, this.y = _e165, this.w = 1;
          } else if (arguments[0] instanceof te && arguments[1] instanceof te) {
            var _t230 = arguments[0],
                _e166 = arguments[1];
            this.x = _t230.y * _e166.w - _e166.y * _t230.w, this.y = _e166.x * _t230.w - _t230.x * _e166.w, this.w = _t230.x * _e166.y - _e166.x * _t230.y;
          } else if (arguments[0] instanceof m && arguments[1] instanceof m) {
            var _t231 = arguments[0],
                _e167 = arguments[1];
            this.x = _t231.y - _e167.y, this.y = _e167.x - _t231.x, this.w = _t231.x * _e167.y - _e167.x * _t231.y;
          }
        } else if (3 === arguments.length) {
          var _t232 = arguments[0],
              _e168 = arguments[1],
              _n121 = arguments[2];
          this.x = _t232, this.y = _e168, this.w = _n121;
        } else if (4 === arguments.length) {
          var _t233 = arguments[0],
              _e169 = arguments[1],
              _n122 = arguments[2],
              _s63 = arguments[3],
              _i33 = _t233.y - _e169.y,
              _r23 = _e169.x - _t233.x,
              _o18 = _t233.x * _e169.y - _e169.x * _t233.y,
              _l14 = _n122.y - _s63.y,
              _a10 = _s63.x - _n122.x,
              _c8 = _n122.x * _s63.y - _s63.x * _n122.y;

          this.x = _r23 * _c8 - _a10 * _o18, this.y = _l14 * _o18 - _i33 * _c8, this.w = _i33 * _a10 - _l14 * _r23;
        }
      }
    }]);

    return te;
  }();

  var ee = /*#__PURE__*/function () {
    function ee() {
      _classCallCheck(this, ee);

      ee.constructor_.apply(this, arguments);
    }

    _createClass(ee, [{
      key: "area",
      value: function area() {
        return ee.area(this.p0, this.p1, this.p2);
      }
    }, {
      key: "signedArea",
      value: function signedArea() {
        return ee.signedArea(this.p0, this.p1, this.p2);
      }
    }, {
      key: "interpolateZ",
      value: function interpolateZ(t) {
        if (null === t) throw new s("Supplied point is null.");
        return ee.interpolateZ(t, this.p0, this.p1, this.p2);
      }
    }, {
      key: "longestSideLength",
      value: function longestSideLength() {
        return ee.longestSideLength(this.p0, this.p1, this.p2);
      }
    }, {
      key: "isAcute",
      value: function isAcute() {
        return ee.isAcute(this.p0, this.p1, this.p2);
      }
    }, {
      key: "circumcentre",
      value: function circumcentre() {
        return ee.circumcentre(this.p0, this.p1, this.p2);
      }
    }, {
      key: "area3D",
      value: function area3D() {
        return ee.area3D(this.p0, this.p1, this.p2);
      }
    }, {
      key: "centroid",
      value: function centroid() {
        return ee.centroid(this.p0, this.p1, this.p2);
      }
    }, {
      key: "inCentre",
      value: function inCentre() {
        return ee.inCentre(this.p0, this.p1, this.p2);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this.p0 = null, this.p1 = null, this.p2 = null;
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2];
        this.p0 = t, this.p1 = e, this.p2 = n;
      }
    }, {
      key: "area",
      value: function area(t, e, n) {
        return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2);
      }
    }, {
      key: "signedArea",
      value: function signedArea(t, e, n) {
        return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2;
      }
    }, {
      key: "det",
      value: function det(t, e, n, s) {
        return t * s - e * n;
      }
    }, {
      key: "interpolateZ",
      value: function interpolateZ(t, e, n, s) {
        var i = e.x,
            r = e.y,
            o = n.x - i,
            l = s.x - i,
            a = n.y - r,
            c = s.y - r,
            h = o * c - l * a,
            u = t.x - i,
            g = t.y - r,
            d = (c * u - l * g) / h,
            _ = (-a * u + o * g) / h;

        return e.getZ() + d * (n.getZ() - e.getZ()) + _ * (s.getZ() - e.getZ());
      }
    }, {
      key: "longestSideLength",
      value: function longestSideLength(t, e, n) {
        var s = t.distance(e),
            i = e.distance(n),
            r = n.distance(t);
        var o = s;
        return i > o && (o = i), r > o && (o = r), o;
      }
    }, {
      key: "circumcentreDD",
      value: function circumcentreDD(t, e, n) {
        var s = v.valueOf(t.x).subtract(n.x),
            i = v.valueOf(t.y).subtract(n.y),
            r = v.valueOf(e.x).subtract(n.x),
            o = v.valueOf(e.y).subtract(n.y),
            l = v.determinant(s, i, r, o).multiply(2),
            a = s.sqr().add(i.sqr()),
            c = r.sqr().add(o.sqr()),
            h = v.determinant(i, a, o, c),
            u = v.determinant(s, a, r, c),
            g = v.valueOf(n.x).subtract(h.divide(l)).doubleValue(),
            d = v.valueOf(n.y).add(u.divide(l)).doubleValue();
        return new m(g, d);
      }
    }, {
      key: "isAcute",
      value: function isAcute(t, e, n) {
        return !!Jt.isAcute(t, e, n) && !!Jt.isAcute(e, n, t) && !!Jt.isAcute(n, t, e);
      }
    }, {
      key: "circumcentre",
      value: function circumcentre(t, e, n) {
        var s = n.x,
            i = n.y,
            r = t.x - s,
            o = t.y - i,
            l = e.x - s,
            a = e.y - i,
            c = 2 * ee.det(r, o, l, a),
            h = ee.det(o, r * r + o * o, a, l * l + a * a),
            u = ee.det(r, r * r + o * o, l, l * l + a * a);
        return new m(s - h / c, i + u / c);
      }
    }, {
      key: "perpendicularBisector",
      value: function perpendicularBisector(t, e) {
        var n = e.x - t.x,
            s = e.y - t.y,
            i = new te(t.x + n / 2, t.y + s / 2, 1),
            r = new te(t.x - s + n / 2, t.y + n + s / 2, 1);
        return new te(i, r);
      }
    }, {
      key: "angleBisector",
      value: function angleBisector(t, e, n) {
        var s = e.distance(t),
            i = s / (s + e.distance(n)),
            r = n.x - t.x,
            o = n.y - t.y;
        return new m(t.x + i * r, t.y + i * o);
      }
    }, {
      key: "area3D",
      value: function area3D(t, e, n) {
        var s = e.x - t.x,
            i = e.y - t.y,
            r = e.getZ() - t.getZ(),
            o = n.x - t.x,
            l = n.y - t.y,
            a = n.getZ() - t.getZ(),
            c = i * a - r * l,
            h = r * o - s * a,
            u = s * l - i * o,
            g = c * c + h * h + u * u;
        return Math.sqrt(g) / 2;
      }
    }, {
      key: "centroid",
      value: function centroid(t, e, n) {
        var s = (t.x + e.x + n.x) / 3,
            i = (t.y + e.y + n.y) / 3;
        return new m(s, i);
      }
    }, {
      key: "inCentre",
      value: function inCentre(t, e, n) {
        var s = e.distance(n),
            i = t.distance(n),
            r = t.distance(e),
            o = s + i + r,
            l = (s * t.x + i * e.x + r * n.x) / o,
            a = (s * t.y + i * e.y + r * n.y) / o;
        return new m(l, a);
      }
    }]);

    return ee;
  }();

  var ne = /*#__PURE__*/function (_n123) {
    _inherits(ne, _n123);

    var _super28 = _createSuper(ne);

    function ne() {
      var _this19;

      _classCallCheck(this, ne);

      _this19 = _super28.call(this), ne.constructor_.apply(_assertThisInitialized(_this19), arguments);
      return _this19;
    }

    _createClass(ne, null, [{
      key: "constructor_",
      value: function constructor_() {
        if (0 === arguments.length) n.constructor_.call(this);else if (1 === arguments.length) {
          var _t234 = arguments[0];
          n.constructor_.call(this, _t234);
        }
      }
    }]);

    return ne;
  }(n);

  var se = /*#__PURE__*/function () {
    function se() {
      _classCallCheck(this, se);

      se.constructor_.apply(this, arguments);
    }

    _createClass(se, [{
      key: "setToReflectionBasic",
      value: function setToReflectionBasic(t, e, n, i) {
        if (t === n && e === i) throw new s("Reflection line points must be distinct");
        var r = n - t,
            o = i - e,
            l = Math.sqrt(r * r + o * o),
            a = o / l,
            c = r / l,
            h = 2 * a * c,
            u = c * c - a * a;
        return this._m00 = u, this._m01 = h, this._m02 = 0, this._m10 = h, this._m11 = -u, this._m12 = 0, this;
      }
    }, {
      key: "getInverse",
      value: function getInverse() {
        var t = this.getDeterminant();
        if (0 === t) throw new ne("Transformation is non-invertible");
        var e = this._m11 / t,
            n = -this._m10 / t,
            s = -this._m01 / t,
            i = this._m00 / t,
            r = (this._m01 * this._m12 - this._m02 * this._m11) / t,
            o = (-this._m00 * this._m12 + this._m10 * this._m02) / t;
        return new se(e, s, r, n, i, o);
      }
    }, {
      key: "compose",
      value: function compose(t) {
        var e = t._m00 * this._m00 + t._m01 * this._m10,
            n = t._m00 * this._m01 + t._m01 * this._m11,
            s = t._m00 * this._m02 + t._m01 * this._m12 + t._m02,
            i = t._m10 * this._m00 + t._m11 * this._m10,
            r = t._m10 * this._m01 + t._m11 * this._m11,
            o = t._m10 * this._m02 + t._m11 * this._m12 + t._m12;
        return this._m00 = e, this._m01 = n, this._m02 = s, this._m10 = i, this._m11 = r, this._m12 = o, this;
      }
    }, {
      key: "equals",
      value: function equals(t) {
        if (null === t) return !1;
        if (!(t instanceof se)) return !1;
        var e = t;
        return this._m00 === e._m00 && this._m01 === e._m01 && this._m02 === e._m02 && this._m10 === e._m10 && this._m11 === e._m11 && this._m12 === e._m12;
      }
    }, {
      key: "setToScale",
      value: function setToScale(t, e) {
        return this._m00 = t, this._m01 = 0, this._m02 = 0, this._m10 = 0, this._m11 = e, this._m12 = 0, this;
      }
    }, {
      key: "isIdentity",
      value: function isIdentity() {
        return 1 === this._m00 && 0 === this._m01 && 0 === this._m02 && 0 === this._m10 && 1 === this._m11 && 0 === this._m12;
      }
    }, {
      key: "scale",
      value: function scale(t, e) {
        return this.compose(se.scaleInstance(t, e)), this;
      }
    }, {
      key: "setToIdentity",
      value: function setToIdentity() {
        return this._m00 = 1, this._m01 = 0, this._m02 = 0, this._m10 = 0, this._m11 = 1, this._m12 = 0, this;
      }
    }, {
      key: "isGeometryChanged",
      value: function isGeometryChanged() {
        return !0;
      }
    }, {
      key: "setTransformation",
      value: function setTransformation() {
        if (1 === arguments.length) {
          var _t235 = arguments[0];
          return this._m00 = _t235._m00, this._m01 = _t235._m01, this._m02 = _t235._m02, this._m10 = _t235._m10, this._m11 = _t235._m11, this._m12 = _t235._m12, this;
        }

        if (6 === arguments.length) {
          var _t236 = arguments[0],
              _e170 = arguments[1],
              _n124 = arguments[2],
              _s64 = arguments[3],
              _i34 = arguments[4],
              _r24 = arguments[5];
          return this._m00 = _t236, this._m01 = _e170, this._m02 = _n124, this._m10 = _s64, this._m11 = _i34, this._m12 = _r24, this;
        }
      }
    }, {
      key: "setToRotation",
      value: function setToRotation() {
        if (1 === arguments.length) {
          var _t237 = arguments[0];
          return this.setToRotation(Math.sin(_t237), Math.cos(_t237)), this;
        }

        if (2 === arguments.length) {
          var _t238 = arguments[0],
              _e171 = arguments[1];
          return this._m00 = _e171, this._m01 = -_t238, this._m02 = 0, this._m10 = _t238, this._m11 = _e171, this._m12 = 0, this;
        }

        if (3 === arguments.length) {
          var _t239 = arguments[0],
              _e172 = arguments[1],
              _n125 = arguments[2];
          return this.setToRotation(Math.sin(_t239), Math.cos(_t239), _e172, _n125), this;
        }

        if (4 === arguments.length) {
          var _t240 = arguments[0],
              _e173 = arguments[1],
              _n126 = arguments[2],
              _s65 = arguments[3];
          return this._m00 = _e173, this._m01 = -_t240, this._m02 = _n126 - _n126 * _e173 + _s65 * _t240, this._m10 = _t240, this._m11 = _e173, this._m12 = _s65 - _n126 * _t240 - _s65 * _e173, this;
        }
      }
    }, {
      key: "getMatrixEntries",
      value: function getMatrixEntries() {
        return [this._m00, this._m01, this._m02, this._m10, this._m11, this._m12];
      }
    }, {
      key: "filter",
      value: function filter(t, e) {
        this.transform(t, e);
      }
    }, {
      key: "rotate",
      value: function rotate() {
        if (1 === arguments.length) {
          var _t241 = arguments[0];
          return this.compose(se.rotationInstance(_t241)), this;
        }

        if (2 === arguments.length) {
          var _t242 = arguments[0],
              _e174 = arguments[1];
          return this.compose(se.rotationInstance(_t242, _e174)), this;
        }

        if (3 === arguments.length) {
          var _t243 = arguments[0],
              _e175 = arguments[1],
              _n127 = arguments[2];
          return this.compose(se.rotationInstance(_t243, _e175, _n127)), this;
        }

        if (4 === arguments.length) {
          var _t244 = arguments[0],
              _e176 = arguments[1],
              _n128 = arguments[2],
              _s66 = arguments[3];
          return this.compose(se.rotationInstance(_t244, _e176, _n128, _s66)), this;
        }
      }
    }, {
      key: "getDeterminant",
      value: function getDeterminant() {
        return this._m00 * this._m11 - this._m01 * this._m10;
      }
    }, {
      key: "composeBefore",
      value: function composeBefore(t) {
        var e = this._m00 * t._m00 + this._m01 * t._m10,
            n = this._m00 * t._m01 + this._m01 * t._m11,
            s = this._m00 * t._m02 + this._m01 * t._m12 + this._m02,
            i = this._m10 * t._m00 + this._m11 * t._m10,
            r = this._m10 * t._m01 + this._m11 * t._m11,
            o = this._m10 * t._m02 + this._m11 * t._m12 + this._m12;
        return this._m00 = e, this._m01 = n, this._m02 = s, this._m10 = i, this._m11 = r, this._m12 = o, this;
      }
    }, {
      key: "setToShear",
      value: function setToShear(t, e) {
        return this._m00 = 1, this._m01 = t, this._m02 = 0, this._m10 = e, this._m11 = 1, this._m12 = 0, this;
      }
    }, {
      key: "isDone",
      value: function isDone() {
        return !1;
      }
    }, {
      key: "clone",
      value: function clone() {
        try {
          return null;
        } catch (t) {
          if (!(t instanceof n)) throw t;
          g.shouldNeverReachHere();
        }

        return null;
      }
    }, {
      key: "translate",
      value: function translate(t, e) {
        return this.compose(se.translationInstance(t, e)), this;
      }
    }, {
      key: "setToReflection",
      value: function setToReflection() {
        if (2 === arguments.length) {
          var _t245 = arguments[0],
              _e177 = arguments[1];
          if (0 === _t245 && 0 === _e177) throw new s("Reflection vector must be non-zero");
          if (_t245 === _e177) return this._m00 = 0, this._m01 = 1, this._m02 = 0, this._m10 = 1, this._m11 = 0, this._m12 = 0, this;

          var _n129 = Math.sqrt(_t245 * _t245 + _e177 * _e177),
              _i35 = _e177 / _n129,
              _r25 = _t245 / _n129;

          return this.rotate(-_i35, _r25), this.scale(1, -1), this.rotate(_i35, _r25), this;
        }

        if (4 === arguments.length) {
          var _t246 = arguments[0],
              _e178 = arguments[1],
              _n130 = arguments[2],
              _i36 = arguments[3];
          if (_t246 === _n130 && _e178 === _i36) throw new s("Reflection line points must be distinct");
          this.setToTranslation(-_t246, -_e178);

          var _r26 = _n130 - _t246,
              _o19 = _i36 - _e178,
              _l15 = Math.sqrt(_r26 * _r26 + _o19 * _o19),
              _a11 = _o19 / _l15,
              _c9 = _r26 / _l15;

          return this.rotate(-_a11, _c9), this.scale(1, -1), this.rotate(_a11, _c9), this.translate(_t246, _e178), this;
        }
      }
    }, {
      key: "toString",
      value: function toString() {
        return "AffineTransformation[[" + this._m00 + ", " + this._m01 + ", " + this._m02 + "], [" + this._m10 + ", " + this._m11 + ", " + this._m12 + "]]";
      }
    }, {
      key: "setToTranslation",
      value: function setToTranslation(t, e) {
        return this._m00 = 1, this._m01 = 0, this._m02 = t, this._m10 = 0, this._m11 = 1, this._m12 = e, this;
      }
    }, {
      key: "shear",
      value: function shear(t, e) {
        return this.compose(se.shearInstance(t, e)), this;
      }
    }, {
      key: "transform",
      value: function transform() {
        if (1 === arguments.length) {
          var _t247 = arguments[0].copy();

          return _t247.apply(this), _t247;
        }

        if (2 === arguments.length) {
          if (arguments[0] instanceof m && arguments[1] instanceof m) {
            var _t248 = arguments[0],
                _e179 = arguments[1],
                _n131 = this._m00 * _t248.x + this._m01 * _t248.y + this._m02,
                _s67 = this._m10 * _t248.x + this._m11 * _t248.y + this._m12;

            return _e179.x = _n131, _e179.y = _s67, _e179;
          }

          if (y(arguments[0], b) && Number.isInteger(arguments[1])) {
            var _t249 = arguments[0],
                _e180 = arguments[1],
                _n132 = this._m00 * _t249.getOrdinate(_e180, 0) + this._m01 * _t249.getOrdinate(_e180, 1) + this._m02,
                _s68 = this._m10 * _t249.getOrdinate(_e180, 0) + this._m11 * _t249.getOrdinate(_e180, 1) + this._m12;

            _t249.setOrdinate(_e180, 0, _n132), _t249.setOrdinate(_e180, 1, _s68);
          }
        }
      }
    }, {
      key: "reflect",
      value: function reflect() {
        if (2 === arguments.length) {
          var _t250 = arguments[0],
              _e181 = arguments[1];
          return this.compose(se.reflectionInstance(_t250, _e181)), this;
        }

        if (4 === arguments.length) {
          var _t251 = arguments[0],
              _e182 = arguments[1],
              _n133 = arguments[2],
              _s69 = arguments[3];
          return this.compose(se.reflectionInstance(_t251, _e182, _n133, _s69)), this;
        }
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [l, L];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._m00 = null, this._m01 = null, this._m02 = null, this._m10 = null, this._m11 = null, this._m12 = null, 0 === arguments.length) this.setToIdentity();else if (1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            var _t252 = arguments[0];
            this._m00 = _t252[0], this._m01 = _t252[1], this._m02 = _t252[2], this._m10 = _t252[3], this._m11 = _t252[4], this._m12 = _t252[5];
          } else if (arguments[0] instanceof se) {
            var _t253 = arguments[0];
            this.setTransformation(_t253);
          }
        } else if (6 === arguments.length && "number" == typeof arguments[5] && "number" == typeof arguments[4] && "number" == typeof arguments[3] && "number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
          var _t254 = arguments[0],
              _e183 = arguments[1],
              _n134 = arguments[2],
              _s70 = arguments[3],
              _i37 = arguments[4],
              _r27 = arguments[5];
          this.setTransformation(_t254, _e183, _n134, _s70, _i37, _r27);
        }
      }
    }, {
      key: "translationInstance",
      value: function translationInstance(t, e) {
        var n = new se();
        return n.setToTranslation(t, e), n;
      }
    }, {
      key: "shearInstance",
      value: function shearInstance(t, e) {
        var n = new se();
        return n.setToShear(t, e), n;
      }
    }, {
      key: "reflectionInstance",
      value: function reflectionInstance() {
        if (2 === arguments.length) {
          var _t255 = arguments[0],
              _e184 = arguments[1],
              _n135 = new se();

          return _n135.setToReflection(_t255, _e184), _n135;
        }

        if (4 === arguments.length) {
          var _t256 = arguments[0],
              _e185 = arguments[1],
              _n136 = arguments[2],
              _s71 = arguments[3],
              _i38 = new se();

          return _i38.setToReflection(_t256, _e185, _n136, _s71), _i38;
        }
      }
    }, {
      key: "rotationInstance",
      value: function rotationInstance() {
        if (1 === arguments.length) {
          var _t257 = arguments[0];
          return se.rotationInstance(Math.sin(_t257), Math.cos(_t257));
        }

        if (2 === arguments.length) {
          var _t258 = arguments[0],
              _e186 = arguments[1],
              _n137 = new se();

          return _n137.setToRotation(_t258, _e186), _n137;
        }

        if (3 === arguments.length) {
          var _t259 = arguments[0],
              _e187 = arguments[1],
              _n138 = arguments[2];
          return se.rotationInstance(Math.sin(_t259), Math.cos(_t259), _e187, _n138);
        }

        if (4 === arguments.length) {
          var _t260 = arguments[0],
              _e188 = arguments[1],
              _n139 = arguments[2],
              _s72 = arguments[3],
              _i39 = new se();

          return _i39.setToRotation(_t260, _e188, _n139, _s72), _i39;
        }
      }
    }, {
      key: "scaleInstance",
      value: function scaleInstance() {
        if (2 === arguments.length) {
          var _t261 = arguments[0],
              _e189 = arguments[1],
              _n140 = new se();

          return _n140.setToScale(_t261, _e189), _n140;
        }

        if (4 === arguments.length) {
          var _t262 = arguments[0],
              _e190 = arguments[1],
              _n141 = arguments[2],
              _s73 = arguments[3],
              _i40 = new se();

          return _i40.translate(-_n141, -_s73), _i40.scale(_t262, _e190), _i40.translate(_n141, _s73), _i40;
        }
      }
    }]);

    return se;
  }();

  var ie = /*#__PURE__*/function () {
    function ie() {
      _classCallCheck(this, ie);
    }

    _createClass(ie, null, [{
      key: "solve",
      value: function solve(t, e) {
        var n = e.length;
        if (t.length !== n || t[0].length !== n) throw new s("Matrix A is incorrectly sized");

        for (var _s74 = 0; _s74 < n; _s74++) {
          var _i41 = _s74;

          for (var _e191 = _s74 + 1; _e191 < n; _e191++) {
            Math.abs(t[_e191][_s74]) > Math.abs(t[_i41][_s74]) && (_i41 = _e191);
          }

          if (0 === t[_i41][_s74]) return null;
          ie.swapRows(t, _s74, _i41), ie.swapRows(e, _s74, _i41);

          for (var _i42 = _s74 + 1; _i42 < n; _i42++) {
            var _r28 = t[_i42][_s74] / t[_s74][_s74];

            for (var _e192 = n - 1; _e192 >= _s74; _e192--) {
              t[_i42][_e192] -= t[_s74][_e192] * _r28;
            }

            e[_i42] -= e[_s74] * _r28;
          }
        }

        var i = new Array(n).fill(null);

        for (var _s75 = n - 1; _s75 >= 0; _s75--) {
          var _r29 = 0;

          for (var _e193 = _s75 + 1; _e193 < n; _e193++) {
            _r29 += t[_s75][_e193] * i[_e193];
          }

          i[_s75] = (e[_s75] - _r29) / t[_s75][_s75];
        }

        return i;
      }
    }, {
      key: "swapRows",
      value: function swapRows() {
        if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
          var _t263 = arguments[0],
              _e194 = arguments[1],
              _n142 = arguments[2];
          if (_e194 === _n142) return null;

          for (var _s76 = 0; _s76 < _t263[0].length; _s76++) {
            var _i43 = _t263[_e194][_s76];
            _t263[_e194][_s76] = _t263[_n142][_s76], _t263[_n142][_s76] = _i43;
          }
        } else if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
          var _t264 = arguments[0],
              _e195 = arguments[1],
              _n143 = arguments[2];
          if (_e195 === _n143) return null;
          var _s77 = _t264[_e195];
          _t264[_e195] = _t264[_n143], _t264[_n143] = _s77;
        }
      }
    }]);

    return ie;
  }();

  var re = /*#__PURE__*/function () {
    function re() {
      _classCallCheck(this, re);

      re.constructor_.apply(this, arguments);
    }

    _createClass(re, [{
      key: "solve",
      value: function solve(t) {
        var e = [[this._src0.x, this._src0.y, 1], [this._src1.x, this._src1.y, 1], [this._src2.x, this._src2.y, 1]];
        return ie.solve(e, t);
      }
    }, {
      key: "compute",
      value: function compute() {
        var t = [this._dest0.x, this._dest1.x, this._dest2.x],
            e = this.solve(t);
        if (null === e) return !1;
        this._m00 = e[0], this._m01 = e[1], this._m02 = e[2];
        var n = [this._dest0.y, this._dest1.y, this._dest2.y],
            s = this.solve(n);
        return null !== s && (this._m10 = s[0], this._m11 = s[1], this._m12 = s[2], !0);
      }
    }, {
      key: "getTransformation",
      value: function getTransformation() {
        return this.compute() ? new se(this._m00, this._m01, this._m02, this._m10, this._m11, this._m12) : null;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._src0 = null, this._src1 = null, this._src2 = null, this._dest0 = null, this._dest1 = null, this._dest2 = null, this._m00 = null, this._m01 = null, this._m02 = null, this._m10 = null, this._m11 = null, this._m12 = null;
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2],
            s = arguments[3],
            i = arguments[4],
            r = arguments[5];
        this._src0 = t, this._src1 = e, this._src2 = n, this._dest0 = s, this._dest1 = i, this._dest2 = r;
      }
    }]);

    return re;
  }();

  var oe = /*#__PURE__*/function () {
    function oe() {
      _classCallCheck(this, oe);
    }

    _createClass(oe, null, [{
      key: "createFromBaseLines",
      value: function createFromBaseLines(t, e, n, s) {
        var i = new m(t.x + s.x - n.x, t.y + s.y - n.y),
            r = Jt.angleBetweenOriented(e, t, i),
            o = e.distance(t),
            l = s.distance(n);
        if (0 === o) return new se();
        var a = l / o,
            c = se.translationInstance(-t.x, -t.y);
        return c.rotate(r), c.scale(a, a), c.translate(n.x, n.y), c;
      }
    }, {
      key: "createFromControlVectors",
      value: function createFromControlVectors() {
        if (2 === arguments.length) {
          if (arguments[0] instanceof m && arguments[1] instanceof m) {
            var _t265 = arguments[0],
                _e196 = arguments[1],
                _n144 = _e196.x - _t265.x,
                _s78 = _e196.y - _t265.y;

            return se.translationInstance(_n144, _s78);
          }

          if (arguments[0] instanceof Array && arguments[1] instanceof Array) {
            var _t266 = arguments[0],
                _e197 = arguments[1];
            if (_t266.length !== _e197.length) throw new s("Src and Dest arrays are not the same length");
            if (_t266.length <= 0) throw new s("Too few control points");
            if (_t266.length > 3) throw new s("Too many control points");
            return 1 === _t266.length ? oe.createFromControlVectors(_t266[0], _e197[0]) : 2 === _t266.length ? oe.createFromControlVectors(_t266[0], _t266[1], _e197[0], _e197[1]) : oe.createFromControlVectors(_t266[0], _t266[1], _t266[2], _e197[0], _e197[1], _e197[2]);
          }
        } else {
          if (4 === arguments.length) {
            var _t267 = arguments[0],
                _e198 = arguments[1],
                _n145 = arguments[2],
                _s79 = arguments[3],
                _i44 = new m(_s79.x - _n145.x, _s79.y - _n145.y),
                _r30 = Jt.angleBetweenOriented(_e198, _t267, _i44),
                _o20 = _e198.distance(_t267),
                _l16 = _s79.distance(_n145);

            if (0 === _o20) return null;

            var _a12 = _l16 / _o20,
                _c10 = se.translationInstance(-_t267.x, -_t267.y);

            return _c10.rotate(_r30), _c10.scale(_a12, _a12), _c10.translate(_n145.x, _n145.y), _c10;
          }

          if (6 === arguments.length) {
            return new re(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]).getTransformation();
          }
        }
      }
    }]);

    return oe;
  }();

  var le = /*#__PURE__*/function () {
    function le() {
      _classCallCheck(this, le);

      le.constructor_.apply(this, arguments);
    }

    _createClass(le, [{
      key: "filter",
      value: function filter(t) {
        (t instanceof j || t instanceof Q) && this._coords.add(t.getCoordinate());
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Y];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._coords = null;
        var t = arguments[0];
        this._coords = t;
      }
    }, {
      key: "getCoordinates",
      value: function getCoordinates(t) {
        var e = new S();
        return t.apply(new le(e)), e;
      }
    }]);

    return le;
  }();

  var ae = /*#__PURE__*/function () {
    function ae() {
      _classCallCheck(this, ae);

      ae.constructor_.apply(this, arguments);
    }

    _createClass(ae, [{
      key: "map",
      value: function map(t) {
        var e = new S();

        for (var _n146 = 0; _n146 < t.getNumGeometries(); _n146++) {
          var _s80 = this._mapOp.map(t.getGeometryN(_n146));

          _s80.isEmpty() || e.add(_s80);
        }

        return t.getFactory().createGeometryCollection(Ct.toGeometryArray(e));
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._mapOp = null;
        var t = arguments[0];
        this._mapOp = t;
      }
    }, {
      key: "map",
      value: function map(t, e) {
        return new ae(e).map(t);
      }
    }]);

    return ae;
  }();

  var ce = /*#__PURE__*/function () {
    function ce() {
      _classCallCheck(this, ce);

      ce.constructor_.apply(this, arguments);
    }

    _createClass(ce, [{
      key: "extractElements",
      value: function extractElements(t, e) {
        if (null === t) return null;

        for (var _n147 = 0; _n147 < t.getNumGeometries(); _n147++) {
          var _s81 = t.getGeometryN(_n147);

          this._skipEmpty && _s81.isEmpty() || e.add(_s81);
        }
      }
    }, {
      key: "combine",
      value: function combine() {
        var t = new S();

        for (var _e199 = this._inputGeoms.iterator(); _e199.hasNext();) {
          var _n148 = _e199.next();

          this.extractElements(_n148, t);
        }

        return 0 === t.size() ? null !== this._geomFactory ? this._geomFactory.createGeometryCollection() : null : this._geomFactory.buildGeometry(t);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._geomFactory = null, this._skipEmpty = !1, this._inputGeoms = null;
        var t = arguments[0];
        this._geomFactory = ce.extractFactory(t), this._inputGeoms = t;
      }
    }, {
      key: "combine",
      value: function combine() {
        if (1 === arguments.length) {
          return new ce(arguments[0]).combine();
        }

        if (2 === arguments.length) {
          var _t268 = arguments[0],
              _e200 = arguments[1];
          return new ce(ce.createList(_t268, _e200)).combine();
        }

        if (3 === arguments.length) {
          var _t269 = arguments[0],
              _e201 = arguments[1],
              _n149 = arguments[2];
          return new ce(ce.createList(_t269, _e201, _n149)).combine();
        }
      }
    }, {
      key: "extractFactory",
      value: function extractFactory(t) {
        return t.isEmpty() ? null : t.iterator().next().getFactory();
      }
    }, {
      key: "createList",
      value: function createList() {
        if (2 === arguments.length) {
          var _t270 = arguments[0],
              _e202 = arguments[1],
              _n150 = new S();

          return _n150.add(_t270), _n150.add(_e202), _n150;
        }

        if (3 === arguments.length) {
          var _t271 = arguments[0],
              _e203 = arguments[1],
              _n151 = arguments[2],
              _s82 = new S();

          return _s82.add(_t271), _s82.add(_e203), _s82.add(_n151), _s82;
        }
      }
    }]);

    return ce;
  }();

  var he = /*#__PURE__*/function () {
    function he() {
      _classCallCheck(this, he);

      he.constructor_.apply(this, arguments);
    }

    _createClass(he, [{
      key: "setCopyUserData",
      value: function setCopyUserData(t) {
        this._isUserDataCopied = t;
      }
    }, {
      key: "edit",
      value: function edit(t, e) {
        if (null === t) return null;
        var n = this.editInternal(t, e);
        return this._isUserDataCopied && n.setUserData(t.getUserData()), n;
      }
    }, {
      key: "editInternal",
      value: function editInternal(t, e) {
        return null === this._factory && (this._factory = t.getFactory()), t instanceof ot ? this.editGeometryCollection(t, e) : t instanceof et ? this.editPolygon(t, e) : t instanceof Q || t instanceof j ? e.edit(t, this._factory) : (g.shouldNeverReachHere("Unsupported Geometry type: " + t.getGeometryType()), null);
      }
    }, {
      key: "editGeometryCollection",
      value: function editGeometryCollection(t, e) {
        var n = e.edit(t, this._factory),
            s = new S();

        for (var _t272 = 0; _t272 < n.getNumGeometries(); _t272++) {
          var _i45 = this.edit(n.getGeometryN(_t272), e);

          null === _i45 || _i45.isEmpty() || s.add(_i45);
        }

        return n.getGeometryType() === V.TYPENAME_MULTIPOINT ? this._factory.createMultiPoint(s.toArray([])) : n.getGeometryType() === V.TYPENAME_MULTILINESTRING ? this._factory.createMultiLineString(s.toArray([])) : n.getGeometryType() === V.TYPENAME_MULTIPOLYGON ? this._factory.createMultiPolygon(s.toArray([])) : this._factory.createGeometryCollection(s.toArray([]));
      }
    }, {
      key: "editPolygon",
      value: function editPolygon(t, e) {
        var n = e.edit(t, this._factory);
        if (null === n && (n = this._factory.createPolygon()), n.isEmpty()) return n;
        var s = this.edit(n.getExteriorRing(), e);
        if (null === s || s.isEmpty()) return this._factory.createPolygon();
        var i = new S();

        for (var _t273 = 0; _t273 < n.getNumInteriorRing(); _t273++) {
          var _s83 = this.edit(n.getInteriorRingN(_t273), e);

          null === _s83 || _s83.isEmpty() || i.add(_s83);
        }

        return this._factory.createPolygon(s, i.toArray([]));
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._factory = null, this._isUserDataCopied = !1, 0 === arguments.length) ;else if (1 === arguments.length) {
          var _t274 = arguments[0];
          this._factory = _t274;
        }
      }
    }]);

    return he;
  }();

  function ue() {}

  he.GeometryEditorOperation = ue;
  he.NoOpGeometryOperation = /*#__PURE__*/function () {
    function _class3() {
      _classCallCheck(this, _class3);
    }

    _createClass(_class3, [{
      key: "edit",
      value: function edit(t, e) {
        return t;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [ue];
      }
    }]);

    return _class3;
  }(), he.CoordinateOperation = /*#__PURE__*/function () {
    function _class4() {
      _classCallCheck(this, _class4);
    }

    _createClass(_class4, [{
      key: "edit",
      value: function edit(t, e) {
        var n = this.edit(t.getCoordinates(), t);
        return t instanceof at ? null === n ? e.createLinearRing() : e.createLinearRing(n) : t instanceof j ? null === n ? e.createLineString() : e.createLineString(n) : t instanceof Q ? null === n || 0 === n.length ? e.createPoint() : e.createPoint(n[0]) : t;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [ue];
      }
    }]);

    return _class4;
  }(), he.CoordinateSequenceOperation = /*#__PURE__*/function () {
    function _class5() {
      _classCallCheck(this, _class5);
    }

    _createClass(_class5, [{
      key: "edit",
      value: function edit(t, e) {
        return t instanceof at ? e.createLinearRing(this.edit(t.getCoordinateSequence(), t)) : t instanceof j ? e.createLineString(this.edit(t.getCoordinateSequence(), t)) : t instanceof Q ? e.createPoint(this.edit(t.getCoordinateSequence(), t)) : t;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [ue];
      }
    }]);

    return _class5;
  }();

  var ge = /*#__PURE__*/function () {
    function ge() {
      _classCallCheck(this, ge);

      ge.constructor_.apply(this, arguments);
    }

    _createClass(ge, [{
      key: "filter",
      value: function filter(t) {
        (null === this._geometryType || ge.isOfType(t, this._geometryType)) && this._comps.add(t);
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Z];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._geometryType = null, this._comps = null;
        var t = arguments[0],
            e = arguments[1];
        this._geometryType = t, this._comps = e;
      }
    }, {
      key: "isOfType",
      value: function isOfType(t, e) {
        return t.getGeometryType() === e || e === V.TYPENAME_LINESTRING && t.getGeometryType() === V.TYPENAME_LINEARRING;
      }
    }, {
      key: "extract",
      value: function extract() {
        if (2 === arguments.length) {
          var _t275 = arguments[0],
              _e204 = arguments[1];
          return ge.extract(_t275, _e204, new S());
        }

        if (3 === arguments.length) {
          var _t276 = arguments[0],
              _e205 = arguments[1],
              _n152 = arguments[2];
          return _t276.getGeometryType() === _e205 ? _n152.add(_t276) : _t276 instanceof ot && _t276.apply(new ge(_e205, _n152)), _n152;
        }
      }
    }]);

    return ge;
  }();

  var de = /*#__PURE__*/function () {
    function de() {
      _classCallCheck(this, de);
    }

    _createClass(de, null, [{
      key: "map",
      value: function map() {
        if (arguments[0] instanceof V && y(arguments[1], _e)) {
          var _t277 = arguments[0],
              _e206 = arguments[1],
              _n153 = new S();

          for (var _s84 = 0; _s84 < _t277.getNumGeometries(); _s84++) {
            var _i46 = _e206.map(_t277.getGeometryN(_s84));

            null !== _i46 && _n153.add(_i46);
          }

          return _t277.getFactory().buildGeometry(_n153);
        }

        if (y(arguments[0], x) && y(arguments[1], _e)) {
          var _t278 = arguments[0],
              _e207 = arguments[1],
              _n154 = new S();

          for (var _s85 = _t278.iterator(); _s85.hasNext();) {
            var _t279 = _s85.next(),
                _i47 = _e207.map(_t279);

            null !== _i47 && _n154.add(_i47);
          }

          return _n154;
        }
      }
    }]);

    return de;
  }();

  function _e() {}

  de.MapOp = _e;

  var pe = /*#__PURE__*/function () {
    function pe() {
      _classCallCheck(this, pe);

      pe.constructor_.apply(this, arguments);
    }

    _createClass(pe, [{
      key: "transformPoint",
      value: function transformPoint(t, e) {
        return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t));
      }
    }, {
      key: "transformPolygon",
      value: function transformPolygon(t, e) {
        var n = !0;
        var s = this.transformLinearRing(t.getExteriorRing(), t);
        null !== s && s instanceof at && !s.isEmpty() || (n = !1);
        var i = new S();

        for (var _e208 = 0; _e208 < t.getNumInteriorRing(); _e208++) {
          var _s86 = this.transformLinearRing(t.getInteriorRingN(_e208), t);

          null === _s86 || _s86.isEmpty() || (_s86 instanceof at || (n = !1), i.add(_s86));
        }

        if (n) return this._factory.createPolygon(s, i.toArray([]));
        {
          var _t280 = new S();

          return null !== s && _t280.add(s), _t280.addAll(i), this._factory.buildGeometry(_t280);
        }
      }
    }, {
      key: "createCoordinateSequence",
      value: function createCoordinateSequence(t) {
        return this._factory.getCoordinateSequenceFactory().create(t);
      }
    }, {
      key: "getInputGeometry",
      value: function getInputGeometry() {
        return this._inputGeom;
      }
    }, {
      key: "transformMultiLineString",
      value: function transformMultiLineString(t, e) {
        var n = new S();

        for (var _e209 = 0; _e209 < t.getNumGeometries(); _e209++) {
          var _s87 = this.transformLineString(t.getGeometryN(_e209), t);

          null !== _s87 && (_s87.isEmpty() || n.add(_s87));
        }

        return this._factory.buildGeometry(n);
      }
    }, {
      key: "transformCoordinates",
      value: function transformCoordinates(t, e) {
        return this.copy(t);
      }
    }, {
      key: "transformLineString",
      value: function transformLineString(t, e) {
        return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t));
      }
    }, {
      key: "transformMultiPoint",
      value: function transformMultiPoint(t, e) {
        var n = new S();

        for (var _e210 = 0; _e210 < t.getNumGeometries(); _e210++) {
          var _s88 = this.transformPoint(t.getGeometryN(_e210), t);

          null !== _s88 && (_s88.isEmpty() || n.add(_s88));
        }

        return this._factory.buildGeometry(n);
      }
    }, {
      key: "transformMultiPolygon",
      value: function transformMultiPolygon(t, e) {
        var n = new S();

        for (var _e211 = 0; _e211 < t.getNumGeometries(); _e211++) {
          var _s89 = this.transformPolygon(t.getGeometryN(_e211), t);

          null !== _s89 && (_s89.isEmpty() || n.add(_s89));
        }

        return this._factory.buildGeometry(n);
      }
    }, {
      key: "copy",
      value: function copy(t) {
        return t.copy();
      }
    }, {
      key: "transformGeometryCollection",
      value: function transformGeometryCollection(t, e) {
        var n = new S();

        for (var _e212 = 0; _e212 < t.getNumGeometries(); _e212++) {
          var _s90 = this.transform(t.getGeometryN(_e212));

          null !== _s90 && (this._pruneEmptyGeometry && _s90.isEmpty() || n.add(_s90));
        }

        return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(Ct.toGeometryArray(n)) : this._factory.buildGeometry(n);
      }
    }, {
      key: "transform",
      value: function transform(t) {
        if (this._inputGeom = t, this._factory = t.getFactory(), t instanceof Q) return this.transformPoint(t, null);
        if (t instanceof lt) return this.transformMultiPoint(t, null);
        if (t instanceof at) return this.transformLinearRing(t, null);
        if (t instanceof j) return this.transformLineString(t, null);
        if (t instanceof wt) return this.transformMultiLineString(t, null);
        if (t instanceof et) return this.transformPolygon(t, null);
        if (t instanceof ft) return this.transformMultiPolygon(t, null);
        if (t instanceof ot) return this.transformGeometryCollection(t, null);
        throw new s("Unknown Geometry subtype: " + t.getGeometryType());
      }
    }, {
      key: "transformLinearRing",
      value: function transformLinearRing(t, e) {
        var n = this.transformCoordinates(t.getCoordinateSequence(), t);
        if (null === n) return this._factory.createLinearRing(null);
        var s = n.size();
        return s > 0 && s < 4 && !this._preserveType ? this._factory.createLineString(n) : this._factory.createLinearRing(n);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = !0, this._preserveGeometryCollectionType = !0, this._preserveCollections = !1, this._preserveType = !1;
      }
    }]);

    return pe;
  }();

  var me = /*#__PURE__*/function () {
    function me() {
      _classCallCheck(this, me);

      me.constructor_.apply(this, arguments);
    }

    _createClass(me, [{
      key: "filter",
      value: function filter(t) {
        t instanceof j && this._comps.add(t);
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Z];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._comps = null;
        var t = arguments[0];
        this._comps = t;
      }
    }, {
      key: "getGeometry",
      value: function getGeometry(t) {
        return t.getFactory().buildGeometry(me.getLines(t));
      }
    }, {
      key: "getLines",
      value: function getLines() {
        if (1 === arguments.length) {
          var _t281 = arguments[0];
          return me.getLines(_t281, new S());
        }

        if (2 === arguments.length) {
          var _t282 = arguments[0],
              _e213 = arguments[1];
          return _t282 instanceof j ? _e213.add(_t282) : _t282 instanceof ot && _t282.apply(new me(_e213)), _e213;
        }
      }
    }]);

    return me;
  }();

  var fe = /*#__PURE__*/function () {
    function fe() {
      _classCallCheck(this, fe);

      fe.constructor_.apply(this, arguments);
    }

    _createClass(fe, [{
      key: "filter",
      value: function filter(t) {
        if (this._isForcedToLineString && t instanceof at) {
          var _e214 = t.getFactory().createLineString(t.getCoordinateSequence());

          return this._lines.add(_e214), null;
        }

        t instanceof j && this._lines.add(t);
      }
    }, {
      key: "setForceToLineString",
      value: function setForceToLineString(t) {
        this._isForcedToLineString = t;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Y];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._lines = null, this._isForcedToLineString = !1, 1 === arguments.length) {
          var _t283 = arguments[0];
          this._lines = _t283;
        } else if (2 === arguments.length) {
          var _t284 = arguments[0],
              _e215 = arguments[1];
          this._lines = _t284, this._isForcedToLineString = _e215;
        }
      }
    }, {
      key: "getGeometry",
      value: function getGeometry() {
        if (1 === arguments.length) {
          var _t285 = arguments[0];
          return _t285.getFactory().buildGeometry(fe.getLines(_t285));
        }

        if (2 === arguments.length) {
          var _t286 = arguments[0],
              _e216 = arguments[1];
          return _t286.getFactory().buildGeometry(fe.getLines(_t286, _e216));
        }
      }
    }, {
      key: "getLines",
      value: function getLines() {
        if (1 === arguments.length) {
          var _t287 = arguments[0];
          return fe.getLines(_t287, !1);
        }

        if (2 === arguments.length) {
          if (y(arguments[0], x) && y(arguments[1], x)) {
            var _t288 = arguments[1];

            for (var _e217 = arguments[0].iterator(); _e217.hasNext();) {
              var _n155 = _e217.next();

              fe.getLines(_n155, _t288);
            }

            return _t288;
          }

          if (arguments[0] instanceof V && "boolean" == typeof arguments[1]) {
            var _t289 = arguments[0],
                _e218 = arguments[1],
                _n156 = new S();

            return _t289.apply(new fe(_n156, _e218)), _n156;
          }

          if (arguments[0] instanceof V && y(arguments[1], x)) {
            var _t290 = arguments[0],
                _e219 = arguments[1];
            return _t290 instanceof j ? _e219.add(_t290) : _t290.apply(new fe(_e219)), _e219;
          }
        } else if (3 === arguments.length) {
          if ("boolean" == typeof arguments[2] && y(arguments[0], x) && y(arguments[1], x)) {
            var _t291 = arguments[1],
                _e220 = arguments[2];

            for (var _n157 = arguments[0].iterator(); _n157.hasNext();) {
              var _s91 = _n157.next();

              fe.getLines(_s91, _t291, _e220);
            }

            return _t291;
          }

          if ("boolean" == typeof arguments[2] && arguments[0] instanceof V && y(arguments[1], x)) {
            var _t292 = arguments[1],
                _e221 = arguments[2];
            return arguments[0].apply(new fe(_t292, _e221)), _t292;
          }
        }
      }
    }]);

    return fe;
  }();

  var ye = {
    reverseOrder: function reverseOrder() {
      return {
        compare: function compare(t, e) {
          return e.compareTo(t);
        }
      };
    },
    min: function min(t) {
      return ye.sort(t), t.get(0);
    },
    sort: function sort(t, e) {
      var n = t.toArray();
      e ? $.sort(n, e) : $.sort(n);
      var s = t.iterator();

      for (var _t293 = 0, _e222 = n.length; _t293 < _e222; _t293++) {
        s.next(), s.set(n[_t293]);
      }
    },
    singletonList: function singletonList(t) {
      var e = new S();
      return e.add(t), e;
    }
  };

  var xe = /*#__PURE__*/function () {
    function xe() {
      _classCallCheck(this, xe);

      xe.constructor_.apply(this, arguments);
    }

    _createClass(xe, [{
      key: "filter",
      value: function filter(t) {
        t instanceof Q && this._pts.add(t);
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Z];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._pts = null;
        var t = arguments[0];
        this._pts = t;
      }
    }, {
      key: "getPoints",
      value: function getPoints() {
        if (1 === arguments.length) {
          var _t294 = arguments[0];
          return _t294 instanceof Q ? ye.singletonList(_t294) : xe.getPoints(_t294, new S());
        }

        if (2 === arguments.length) {
          var _t295 = arguments[0],
              _e223 = arguments[1];
          return _t295 instanceof Q ? _e223.add(_t295) : _t295 instanceof ot && _t295.apply(new xe(_e223)), _e223;
        }
      }
    }]);

    return xe;
  }();

  var Ee = /*#__PURE__*/function () {
    function Ee() {
      _classCallCheck(this, Ee);

      Ee.constructor_.apply(this, arguments);
    }

    _createClass(Ee, [{
      key: "filter",
      value: function filter(t) {
        t instanceof et && this._comps.add(t);
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Z];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._comps = null;
        var t = arguments[0];
        this._comps = t;
      }
    }, {
      key: "getPolygons",
      value: function getPolygons() {
        if (1 === arguments.length) {
          var _t296 = arguments[0];
          return Ee.getPolygons(_t296, new S());
        }

        if (2 === arguments.length) {
          var _t297 = arguments[0],
              _e224 = arguments[1];
          return _t297 instanceof et ? _e224.add(_t297) : _t297 instanceof ot && _t297.apply(new Ee(_e224)), _e224;
        }
      }
    }]);

    return Ee;
  }();

  var Ie = /*#__PURE__*/function () {
    function Ie() {
      _classCallCheck(this, Ie);

      Ie.constructor_.apply(this, arguments);
    }

    _createClass(Ie, [{
      key: "applyTo",
      value: function applyTo(t) {
        for (var _e225 = 0; _e225 < t.getNumGeometries() && !this._isDone; _e225++) {
          var _n158 = t.getGeometryN(_e225);

          if (_n158 instanceof ot) this.applyTo(_n158);else if (this.visit(_n158), this.isDone()) return this._isDone = !0, null;
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._isDone = !1;
      }
    }]);

    return Ie;
  }();

  var Ne = /*#__PURE__*/function () {
    function Ne() {
      _classCallCheck(this, Ne);

      Ne.constructor_.apply(this, arguments);
    }

    _createClass(Ne, [{
      key: "createSupercircle",
      value: function createSupercircle(t) {
        var e = 1 / t,
            n = this._dim.getMinSize() / 2,
            s = this._dim.getCentre(),
            i = Math.pow(n, t),
            r = n,
            o = Math.pow(i / 2, e),
            l = Math.trunc(this._nPts / 8),
            a = new Array(8 * l + 1).fill(null),
            c = o / l;

        for (var _n159 = 0; _n159 <= l; _n159++) {
          var _o21 = 0,
              _h6 = r;

          if (0 !== _n159) {
            _o21 = c * _n159;

            var _s92 = Math.pow(_o21, t);

            _h6 = Math.pow(i - _s92, e);
          }

          a[_n159] = this.coordTrans(_o21, _h6, s), a[2 * l - _n159] = this.coordTrans(_h6, _o21, s), a[2 * l + _n159] = this.coordTrans(_h6, -_o21, s), a[4 * l - _n159] = this.coordTrans(_o21, -_h6, s), a[4 * l + _n159] = this.coordTrans(-_o21, -_h6, s), a[6 * l - _n159] = this.coordTrans(-_h6, -_o21, s), a[6 * l + _n159] = this.coordTrans(-_h6, _o21, s), a[8 * l - _n159] = this.coordTrans(-_o21, _h6, s);
        }

        a[a.length - 1] = new m(a[0]);

        var h = this._geomFact.createLinearRing(a),
            u = this._geomFact.createPolygon(h);

        return this.rotate(u);
      }
    }, {
      key: "setNumPoints",
      value: function setNumPoints(t) {
        this._nPts = t;
      }
    }, {
      key: "setBase",
      value: function setBase(t) {
        this._dim.setBase(t);
      }
    }, {
      key: "setRotation",
      value: function setRotation(t) {
        this._rotationAngle = t;
      }
    }, {
      key: "setWidth",
      value: function setWidth(t) {
        this._dim.setWidth(t);
      }
    }, {
      key: "createEllipse",
      value: function createEllipse() {
        var t = this._dim.getEnvelope(),
            e = t.getWidth() / 2,
            n = t.getHeight() / 2,
            s = t.getMinX() + e,
            i = t.getMinY() + n,
            r = new Array(this._nPts + 1).fill(null);

        var o = 0;

        for (var _t298 = 0; _t298 < this._nPts; _t298++) {
          var _l17 = _t298 * (2 * Math.PI / this._nPts),
              _a13 = e * Math.cos(_l17) + s,
              _c11 = n * Math.sin(_l17) + i;

          r[o++] = this.coord(_a13, _c11);
        }

        r[o] = new m(r[0]);

        var l = this._geomFact.createLinearRing(r),
            a = this._geomFact.createPolygon(l);

        return this.rotate(a);
      }
    }, {
      key: "coordTrans",
      value: function coordTrans(t, e, n) {
        return this.coord(t + n.x, e + n.y);
      }
    }, {
      key: "createSquircle",
      value: function createSquircle() {
        return this.createSupercircle(4);
      }
    }, {
      key: "setEnvelope",
      value: function setEnvelope(t) {
        this._dim.setEnvelope(t);
      }
    }, {
      key: "setCentre",
      value: function setCentre(t) {
        this._dim.setCentre(t);
      }
    }, {
      key: "createArc",
      value: function createArc(t, e) {
        var n = this._dim.getEnvelope(),
            s = n.getWidth() / 2,
            i = n.getHeight() / 2,
            r = n.getMinX() + s,
            o = n.getMinY() + i;

        var l = e;
        (l <= 0 || l > 2 * Math.PI) && (l = 2 * Math.PI);
        var a = l / (this._nPts - 1),
            c = new Array(this._nPts).fill(null);
        var h = 0;

        for (var _e226 = 0; _e226 < this._nPts; _e226++) {
          var _n160 = t + _e226 * a,
              _l18 = s * Math.cos(_n160) + r,
              _u2 = i * Math.sin(_n160) + o;

          c[h++] = this.coord(_l18, _u2);
        }

        var u = this._geomFact.createLineString(c);

        return this.rotate(u);
      }
    }, {
      key: "rotate",
      value: function rotate(t) {
        if (0 !== this._rotationAngle) {
          var _e227 = se.rotationInstance(this._rotationAngle, this._dim.getCentre().x, this._dim.getCentre().y);

          t.apply(_e227);
        }

        return t;
      }
    }, {
      key: "coord",
      value: function coord(t, e) {
        var n = new m(t, e);
        return this._precModel.makePrecise(n), n;
      }
    }, {
      key: "createArcPolygon",
      value: function createArcPolygon(t, e) {
        var n = this._dim.getEnvelope(),
            s = n.getWidth() / 2,
            i = n.getHeight() / 2,
            r = n.getMinX() + s,
            o = n.getMinY() + i;

        var l = e;
        (l <= 0 || l > 2 * Math.PI) && (l = 2 * Math.PI);
        var a = l / (this._nPts - 1),
            c = new Array(this._nPts + 2).fill(null);
        var h = 0;
        c[h++] = this.coord(r, o);

        for (var _e228 = 0; _e228 < this._nPts; _e228++) {
          var _n161 = t + a * _e228,
              _l19 = s * Math.cos(_n161) + r,
              _u3 = i * Math.sin(_n161) + o;

          c[h++] = this.coord(_l19, _u3);
        }

        c[h++] = this.coord(r, o);

        var u = this._geomFact.createLinearRing(c),
            g = this._geomFact.createPolygon(u);

        return this.rotate(g);
      }
    }, {
      key: "createRectangle",
      value: function createRectangle() {
        var t = null,
            e = 0,
            n = Math.trunc(this._nPts / 4);
        n < 1 && (n = 1);

        var s = this._dim.getEnvelope().getWidth() / n,
            i = this._dim.getEnvelope().getHeight() / n,
            r = new Array(4 * n + 1).fill(null),
            o = this._dim.getEnvelope();

        for (t = 0; t < n; t++) {
          var _n162 = o.getMinX() + t * s,
              _i48 = o.getMinY();

          r[e++] = this.coord(_n162, _i48);
        }

        for (t = 0; t < n; t++) {
          var _n163 = o.getMaxX(),
              _s93 = o.getMinY() + t * i;

          r[e++] = this.coord(_n163, _s93);
        }

        for (t = 0; t < n; t++) {
          var _n164 = o.getMaxX() - t * s,
              _i49 = o.getMaxY();

          r[e++] = this.coord(_n164, _i49);
        }

        for (t = 0; t < n; t++) {
          var _n165 = o.getMinX(),
              _s94 = o.getMaxY() - t * i;

          r[e++] = this.coord(_n165, _s94);
        }

        r[e++] = new m(r[0]);

        var l = this._geomFact.createLinearRing(r),
            a = this._geomFact.createPolygon(l);

        return this.rotate(a);
      }
    }, {
      key: "createCircle",
      value: function createCircle() {
        return this.createEllipse();
      }
    }, {
      key: "setHeight",
      value: function setHeight(t) {
        this._dim.setHeight(t);
      }
    }, {
      key: "setSize",
      value: function setSize(t) {
        this._dim.setSize(t);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._geomFact = null, this._precModel = null, this._dim = new Se(), this._nPts = 100, this._rotationAngle = 0, 0 === arguments.length) Ne.constructor_.call(this, new Ct());else if (1 === arguments.length) {
          var _t299 = arguments[0];
          this._geomFact = _t299, this._precModel = _t299.getPrecisionModel();
        }
      }
    }]);

    return Ne;
  }();

  var Se = /*#__PURE__*/function () {
    function Se() {
      _classCallCheck(this, Se);

      Se.constructor_.apply(this, arguments);
    }

    _createClass(Se, [{
      key: "setBase",
      value: function setBase(t) {
        this.base = t;
      }
    }, {
      key: "setWidth",
      value: function setWidth(t) {
        this.width = t;
      }
    }, {
      key: "getBase",
      value: function getBase() {
        return this.base;
      }
    }, {
      key: "getWidth",
      value: function getWidth() {
        return this.width;
      }
    }, {
      key: "setEnvelope",
      value: function setEnvelope(t) {
        this.width = t.getWidth(), this.height = t.getHeight(), this.base = new m(t.getMinX(), t.getMinY()), this.centre = new m(t.centre());
      }
    }, {
      key: "setCentre",
      value: function setCentre(t) {
        this.centre = t;
      }
    }, {
      key: "getMinSize",
      value: function getMinSize() {
        return Math.min(this.width, this.height);
      }
    }, {
      key: "getEnvelope",
      value: function getEnvelope() {
        return null !== this.base ? new T(this.base.x, this.base.x + this.width, this.base.y, this.base.y + this.height) : null !== this.centre ? new T(this.centre.x - this.width / 2, this.centre.x + this.width / 2, this.centre.y - this.height / 2, this.centre.y + this.height / 2) : new T(0, this.width, 0, this.height);
      }
    }, {
      key: "getCentre",
      value: function getCentre() {
        return null === this.centre && (this.centre = new m(this.base.x + this.width / 2, this.base.y + this.height / 2)), this.centre;
      }
    }, {
      key: "getHeight",
      value: function getHeight() {
        return this.height;
      }
    }, {
      key: "setHeight",
      value: function setHeight(t) {
        this.height = t;
      }
    }, {
      key: "setSize",
      value: function setSize(t) {
        this.height = t, this.width = t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this.base = null, this.centre = null, this.width = null, this.height = null;
      }
    }]);

    return Se;
  }();

  Ne.Dimensions = Se;

  var we = /*#__PURE__*/function (_Ne) {
    _inherits(we, _Ne);

    var _super29 = _createSuper(we);

    function we() {
      var _this20;

      _classCallCheck(this, we);

      _this20 = _super29.call(this), we.constructor_.apply(_assertThisInitialized(_this20), arguments);
      return _this20;
    }

    _createClass(we, [{
      key: "setNumArms",
      value: function setNumArms(t) {
        this._numArms = t;
      }
    }, {
      key: "setArmLengthRatio",
      value: function setArmLengthRatio(t) {
        this._armLengthRatio = t;
      }
    }, {
      key: "createSineStar",
      value: function createSineStar() {
        var t = this._dim.getEnvelope(),
            e = t.getWidth() / 2;

        var n = this._armLengthRatio;
        n < 0 && (n = 0), n > 1 && (n = 1);
        var s = n * e,
            i = (1 - n) * e,
            r = t.getMinX() + e,
            o = t.getMinY() + e,
            l = new Array(this._nPts + 1).fill(null);
        var a = 0;

        for (var _t300 = 0; _t300 < this._nPts; _t300++) {
          var _e229 = _t300 / this._nPts * this._numArms,
              _n166 = _e229 - Math.floor(_e229),
              _c12 = 2 * Math.PI * _n166,
              _h7 = i + s * ((Math.cos(_c12) + 1) / 2),
              _u4 = _t300 * (2 * Math.PI / this._nPts),
              _g = _h7 * Math.cos(_u4) + r,
              _d = _h7 * Math.sin(_u4) + o;

          l[a++] = this.coord(_g, _d);
        }

        l[a] = new m(l[0]);

        var c = this._geomFact.createLinearRing(l);

        return this._geomFact.createPolygon(c);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._numArms = 8, this._armLengthRatio = .5, 0 === arguments.length) Ne.constructor_.call(this);else if (1 === arguments.length) {
          var _t301 = arguments[0];
          Ne.constructor_.call(this, _t301);
        }
      }
    }, {
      key: "create",
      value: function create(t, e, n, s, i) {
        var r = new we();
        r.setCentre(t), r.setSize(e), r.setNumPoints(n), r.setArmLengthRatio(i), r.setNumArms(s);
        return r.createSineStar();
      }
    }]);

    return we;
  }(Ne);

  var Ce = Object.freeze({
    __proto__: null,
    AffineTransformation: se,
    AffineTransformationBuilder: re,
    AffineTransformationFactory: oe,
    ComponentCoordinateExtracter: le,
    GeometryCollectionMapper: ae,
    GeometryCombiner: ce,
    GeometryEditor: he,
    GeometryExtracter: ge,
    GeometryMapper: de,
    GeometryTransformer: pe,
    LineStringExtracter: me,
    LinearComponentExtracter: fe,
    PointExtracter: xe,
    PolygonExtracter: Ee,
    ShortCircuitedGeometryVisitor: Ie,
    SineStarFactory: we
  }),
      Le = Object.freeze({
    __proto__: null,
    Coordinate: m,
    CoordinateList: C,
    CoordinateSequenceFilter: L,
    Envelope: T,
    LineSegment: jt,
    GeometryFactory: Ct,
    Geometry: V,
    Point: Q,
    LineString: j,
    LinearRing: at,
    Polygon: et,
    GeometryCollection: ot,
    MultiPoint: lt,
    MultiLineString: wt,
    MultiPolygon: ft,
    Dimension: W,
    IntersectionMatrix: Qt,
    PrecisionModel: Nt,
    Location: Kt,
    Triangle: ee,
    util: Ce
  });

  var Te = /*#__PURE__*/function () {
    function Te() {
      _classCallCheck(this, Te);

      Te.constructor_.apply(this, arguments);
    }

    _createClass(Te, [{
      key: "getCoordinates",
      value: function getCoordinates() {
        return this._pt;
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate(t) {
        return this._pt[t];
      }
    }, {
      key: "setMinimum",
      value: function setMinimum() {
        if (1 === arguments.length) {
          var _t302 = arguments[0];
          this.setMinimum(_t302._pt[0], _t302._pt[1]);
        } else if (2 === arguments.length) {
          var _t303 = arguments[0],
              _e230 = arguments[1];
          if (this._isNull) return this.initialize(_t303, _e230), null;

          var _n167 = _t303.distance(_e230);

          _n167 < this._distance && this.initialize(_t303, _e230, _n167);
        }
      }
    }, {
      key: "initialize",
      value: function initialize() {
        if (0 === arguments.length) this._isNull = !0;else if (2 === arguments.length) {
          var _t304 = arguments[0],
              _e231 = arguments[1];
          this._pt[0].setCoordinate(_t304), this._pt[1].setCoordinate(_e231), this._distance = _t304.distance(_e231), this._isNull = !1;
        } else if (3 === arguments.length) {
          var _t305 = arguments[0],
              _e232 = arguments[1],
              _n168 = arguments[2];
          this._pt[0].setCoordinate(_t305), this._pt[1].setCoordinate(_e232), this._distance = _n168, this._isNull = !1;
        }
      }
    }, {
      key: "toString",
      value: function toString() {
        return Ht.toLineString(this._pt[0], this._pt[1]);
      }
    }, {
      key: "getDistance",
      value: function getDistance() {
        return this._distance;
      }
    }, {
      key: "setMaximum",
      value: function setMaximum() {
        if (1 === arguments.length) {
          var _t306 = arguments[0];
          this.setMaximum(_t306._pt[0], _t306._pt[1]);
        } else if (2 === arguments.length) {
          var _t307 = arguments[0],
              _e233 = arguments[1];
          if (this._isNull) return this.initialize(_t307, _e233), null;

          var _n169 = _t307.distance(_e233);

          _n169 > this._distance && this.initialize(_t307, _e233, _n169);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._pt = [new m(), new m()], this._distance = r.NaN, this._isNull = !0;
      }
    }]);

    return Te;
  }();

  var Re = /*#__PURE__*/function () {
    function Re() {
      _classCallCheck(this, Re);
    }

    _createClass(Re, null, [{
      key: "computeDistance",
      value: function computeDistance() {
        if (arguments[2] instanceof Te && arguments[0] instanceof j && arguments[1] instanceof m) {
          var _t308 = arguments[0],
              _e234 = arguments[1],
              _n170 = arguments[2],
              _s95 = new jt(),
              _i50 = _t308.getCoordinates();

          for (var _t309 = 0; _t309 < _i50.length - 1; _t309++) {
            _s95.setCoordinates(_i50[_t309], _i50[_t309 + 1]);

            var _r31 = _s95.closestPoint(_e234);

            _n170.setMinimum(_r31, _e234);
          }
        } else if (arguments[2] instanceof Te && arguments[0] instanceof et && arguments[1] instanceof m) {
          var _t310 = arguments[0],
              _e235 = arguments[1],
              _n171 = arguments[2];
          Re.computeDistance(_t310.getExteriorRing(), _e235, _n171);

          for (var _s96 = 0; _s96 < _t310.getNumInteriorRing(); _s96++) {
            Re.computeDistance(_t310.getInteriorRingN(_s96), _e235, _n171);
          }
        } else if (arguments[2] instanceof Te && arguments[0] instanceof V && arguments[1] instanceof m) {
          var _t311 = arguments[0],
              _e236 = arguments[1],
              _n172 = arguments[2];
          if (_t311 instanceof j) Re.computeDistance(_t311, _e236, _n172);else if (_t311 instanceof et) Re.computeDistance(_t311, _e236, _n172);else if (_t311 instanceof ot) {
            var _s97 = _t311;

            for (var _t312 = 0; _t312 < _s97.getNumGeometries(); _t312++) {
              var _i51 = _s97.getGeometryN(_t312);

              Re.computeDistance(_i51, _e236, _n172);
            }
          } else _n172.setMinimum(_t311.getCoordinate(), _e236);
        } else if (arguments[2] instanceof Te && arguments[0] instanceof jt && arguments[1] instanceof m) {
          var _t313 = arguments[1],
              _e237 = arguments[2],
              _n173 = arguments[0].closestPoint(_t313);

          _e237.setMinimum(_n173, _t313);
        }
      }
    }]);

    return Re;
  }();

  var Pe = /*#__PURE__*/function () {
    function Pe() {
      _classCallCheck(this, Pe);

      Pe.constructor_.apply(this, arguments);
    }

    _createClass(Pe, [{
      key: "getCoordinates",
      value: function getCoordinates() {
        return this._ptDist.getCoordinates();
      }
    }, {
      key: "setDensifyFraction",
      value: function setDensifyFraction(t) {
        if (t > 1 || t <= 0) throw new s("Fraction is not in range (0.0 - 1.0]");
        this._densifyFrac = t;
      }
    }, {
      key: "compute",
      value: function compute(t, e) {
        this.computeOrientedDistance(t, e, this._ptDist), this.computeOrientedDistance(e, t, this._ptDist);
      }
    }, {
      key: "distance",
      value: function distance() {
        return this.compute(this._g0, this._g1), this._ptDist.getDistance();
      }
    }, {
      key: "computeOrientedDistance",
      value: function computeOrientedDistance(t, e, n) {
        var s = new Oe(e);

        if (t.apply(s), n.setMaximum(s.getMaxPointDistance()), this._densifyFrac > 0) {
          var _s98 = new ve(e, this._densifyFrac);

          t.apply(_s98), n.setMaximum(_s98.getMaxPointDistance());
        }
      }
    }, {
      key: "orientedDistance",
      value: function orientedDistance() {
        return this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._g0 = null, this._g1 = null, this._ptDist = new Te(), this._densifyFrac = 0;
        var t = arguments[0],
            e = arguments[1];
        this._g0 = t, this._g1 = e;
      }
    }, {
      key: "distance",
      value: function distance() {
        if (2 === arguments.length) {
          return new Pe(arguments[0], arguments[1]).distance();
        }

        if (3 === arguments.length) {
          var _t314 = arguments[2],
              _e238 = new Pe(arguments[0], arguments[1]);

          return _e238.setDensifyFraction(_t314), _e238.distance();
        }
      }
    }]);

    return Pe;
  }();

  var Oe = /*#__PURE__*/function () {
    function Oe() {
      _classCallCheck(this, Oe);

      Oe.constructor_.apply(this, arguments);
    }

    _createClass(Oe, [{
      key: "filter",
      value: function filter(t) {
        this._minPtDist.initialize(), Re.computeDistance(this._geom, t, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
      }
    }, {
      key: "getMaxPointDistance",
      value: function getMaxPointDistance() {
        return this._maxPtDist;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [z];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._maxPtDist = new Te(), this._minPtDist = new Te(), this._euclideanDist = new Re(), this._geom = null;
        var t = arguments[0];
        this._geom = t;
      }
    }]);

    return Oe;
  }();

  var ve = /*#__PURE__*/function () {
    function ve() {
      _classCallCheck(this, ve);

      ve.constructor_.apply(this, arguments);
    }

    _createClass(ve, [{
      key: "filter",
      value: function filter(t, e) {
        if (0 === e) return null;
        var n = t.getCoordinate(e - 1),
            s = t.getCoordinate(e),
            i = (s.x - n.x) / this._numSubSegs,
            r = (s.y - n.y) / this._numSubSegs;

        for (var _t315 = 0; _t315 < this._numSubSegs; _t315++) {
          var _e239 = n.x + _t315 * i,
              _s99 = n.y + _t315 * r,
              _o22 = new m(_e239, _s99);

          this._minPtDist.initialize(), Re.computeDistance(this._geom, _o22, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
        }
      }
    }, {
      key: "isDone",
      value: function isDone() {
        return !1;
      }
    }, {
      key: "isGeometryChanged",
      value: function isGeometryChanged() {
        return !1;
      }
    }, {
      key: "getMaxPointDistance",
      value: function getMaxPointDistance() {
        return this._maxPtDist;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [L];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._maxPtDist = new Te(), this._minPtDist = new Te(), this._geom = null, this._numSubSegs = 0;
        var t = arguments[0],
            e = arguments[1];
        this._geom = t, this._numSubSegs = Math.trunc(Math.round(1 / e));
      }
    }]);

    return ve;
  }();

  Pe.MaxPointDistanceFilter = Oe, Pe.MaxDensifiedByFractionDistanceFilter = ve;
  var Me = Object.freeze({
    __proto__: null,
    DiscreteHausdorffDistance: Pe,
    DistanceToPoint: Re,
    PointPairDistance: Te
  });

  var be = /*#__PURE__*/function () {
    function be() {
      _classCallCheck(this, be);
    }

    _createClass(be, [{
      key: "visitItem",
      value: function visitItem(t) {}
    }]);

    return be;
  }();

  var De = /*#__PURE__*/function () {
    function De() {
      _classCallCheck(this, De);
    }

    _createClass(De, [{
      key: "locate",
      value: function locate(t) {}
    }]);

    return De;
  }();

  var Ae = /*#__PURE__*/function () {
    function Ae() {
      _classCallCheck(this, Ae);

      Ae.constructor_.apply(this, arguments);
    }

    _createClass(Ae, [{
      key: "getMin",
      value: function getMin() {
        return this._min;
      }
    }, {
      key: "intersects",
      value: function intersects(t, e) {
        return !(this._min > e || this._max < t);
      }
    }, {
      key: "getMax",
      value: function getMax() {
        return this._max;
      }
    }, {
      key: "toString",
      value: function toString() {
        return Ht.toLineString(new m(this._min, 0), new m(this._max, 0));
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._min = r.POSITIVE_INFINITY, this._max = r.NEGATIVE_INFINITY;
      }
    }]);

    return Ae;
  }();

  Ae.NodeComparator = /*#__PURE__*/function () {
    function _class6() {
      _classCallCheck(this, _class6);
    }

    _createClass(_class6, [{
      key: "compare",
      value: function compare(t, e) {
        var n = t,
            s = e,
            i = (n._min + n._max) / 2,
            r = (s._min + s._max) / 2;
        return i < r ? -1 : i > r ? 1 : 0;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [a];
      }
    }]);

    return _class6;
  }();

  var Fe = /*#__PURE__*/function (_Ae) {
    _inherits(Fe, _Ae);

    var _super30 = _createSuper(Fe);

    function Fe() {
      var _this21;

      _classCallCheck(this, Fe);

      _this21 = _super30.call(this), Fe.constructor_.apply(_assertThisInitialized(_this21), arguments);
      return _this21;
    }

    _createClass(Fe, [{
      key: "query",
      value: function query(t, e, n) {
        if (!this.intersects(t, e)) return null;
        n.visitItem(this._item);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._item = null;
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2];
        this._min = t, this._max = e, this._item = n;
      }
    }]);

    return Fe;
  }(Ae);

  var Ge = /*#__PURE__*/function (_Ae2) {
    _inherits(Ge, _Ae2);

    var _super31 = _createSuper(Ge);

    function Ge() {
      var _this22;

      _classCallCheck(this, Ge);

      _this22 = _super31.call(this), Ge.constructor_.apply(_assertThisInitialized(_this22), arguments);
      return _this22;
    }

    _createClass(Ge, [{
      key: "buildExtent",
      value: function buildExtent(t, e) {
        this._min = Math.min(t._min, e._min), this._max = Math.max(t._max, e._max);
      }
    }, {
      key: "query",
      value: function query(t, e, n) {
        if (!this.intersects(t, e)) return null;
        null !== this._node1 && this._node1.query(t, e, n), null !== this._node2 && this._node2.query(t, e, n);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._node1 = null, this._node2 = null;
        var t = arguments[0],
            e = arguments[1];
        this._node1 = t, this._node2 = e, this.buildExtent(this._node1, this._node2);
      }
    }]);

    return Ge;
  }(Ae);

  var qe = /*#__PURE__*/function () {
    function qe() {
      _classCallCheck(this, qe);

      qe.constructor_.apply(this, arguments);
    }

    _createClass(qe, [{
      key: "buildTree",
      value: function buildTree() {
        ye.sort(this._leaves, new Ae.NodeComparator());
        var t = this._leaves,
            e = null,
            n = new S();

        for (;;) {
          if (this.buildLevel(t, n), 1 === n.size()) return n.get(0);
          e = t, t = n, n = e;
        }
      }
    }, {
      key: "insert",
      value: function insert(t, e, n) {
        if (null !== this._root) throw new IllegalStateException("Index cannot be added to once it has been queried");

        this._leaves.add(new Fe(t, e, n));
      }
    }, {
      key: "query",
      value: function query(t, e, n) {
        if (this.init(), null === this._root) return null;

        this._root.query(t, e, n);
      }
    }, {
      key: "buildRoot",
      value: function buildRoot() {
        if (null !== this._root) return null;
        this._root = this.buildTree();
      }
    }, {
      key: "printNode",
      value: function printNode(t) {
        F.out.println(Ht.toLineString(new m(t._min, this._level), new m(t._max, this._level)));
      }
    }, {
      key: "init",
      value: function init() {
        return null !== this._root || 0 === this._leaves.size() ? null : void this.buildRoot();
      }
    }, {
      key: "buildLevel",
      value: function buildLevel(t, e) {
        this._level++, e.clear();

        for (var _n174 = 0; _n174 < t.size(); _n174 += 2) {
          var _s100 = t.get(_n174);

          if (null === (_n174 + 1 < t.size() ? t.get(_n174) : null)) e.add(_s100);else {
            var _s101 = new Ge(t.get(_n174), t.get(_n174 + 1));

            e.add(_s101);
          }
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._leaves = new S(), this._root = null, this._level = 0;
      }
    }]);

    return qe;
  }();

  var Be = /*#__PURE__*/function () {
    function Be() {
      _classCallCheck(this, Be);

      Be.constructor_.apply(this, arguments);
    }

    _createClass(Be, [{
      key: "visitItem",
      value: function visitItem(t) {
        this._items.add(t);
      }
    }, {
      key: "getItems",
      value: function getItems() {
        return this._items;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [be];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._items = new S();
      }
    }]);

    return Be;
  }();

  var Ye = /*#__PURE__*/function () {
    function Ye() {
      _classCallCheck(this, Ye);

      Ye.constructor_.apply(this, arguments);
    }

    _createClass(Ye, [{
      key: "countSegment",
      value: function countSegment(t, e) {
        if (t.x < this._p.x && e.x < this._p.x) return null;
        if (this._p.x === e.x && this._p.y === e.y) return this._isPointOnSegment = !0, null;

        if (t.y === this._p.y && e.y === this._p.y) {
          var _n175 = t.x,
              _s102 = e.x;
          return _n175 > _s102 && (_n175 = e.x, _s102 = t.x), this._p.x >= _n175 && this._p.x <= _s102 && (this._isPointOnSegment = !0), null;
        }

        if (t.y > this._p.y && e.y <= this._p.y || e.y > this._p.y && t.y <= this._p.y) {
          var _n176 = D.index(t, e, this._p);

          if (_n176 === D.COLLINEAR) return this._isPointOnSegment = !0, null;
          e.y < t.y && (_n176 = -_n176), _n176 === D.LEFT && this._crossingCount++;
        }
      }
    }, {
      key: "isPointInPolygon",
      value: function isPointInPolygon() {
        return this.getLocation() !== Kt.EXTERIOR;
      }
    }, {
      key: "getLocation",
      value: function getLocation() {
        return this._isPointOnSegment ? Kt.BOUNDARY : this._crossingCount % 2 == 1 ? Kt.INTERIOR : Kt.EXTERIOR;
      }
    }, {
      key: "isOnSegment",
      value: function isOnSegment() {
        return this._isPointOnSegment;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1;
        var t = arguments[0];
        this._p = t;
      }
    }, {
      key: "locatePointInRing",
      value: function locatePointInRing() {
        if (arguments[0] instanceof m && y(arguments[1], b)) {
          var _t316 = arguments[1],
              _e240 = new Ye(arguments[0]),
              _n177 = new m(),
              _s103 = new m();

          for (var _i52 = 1; _i52 < _t316.size(); _i52++) {
            if (_t316.getCoordinate(_i52, _n177), _t316.getCoordinate(_i52 - 1, _s103), _e240.countSegment(_n177, _s103), _e240.isOnSegment()) return _e240.getLocation();
          }

          return _e240.getLocation();
        }

        if (arguments[0] instanceof m && arguments[1] instanceof Array) {
          var _t317 = arguments[1],
              _e241 = new Ye(arguments[0]);

          for (var _n178 = 1; _n178 < _t317.length; _n178++) {
            var _s104 = _t317[_n178],
                _i53 = _t317[_n178 - 1];
            if (_e241.countSegment(_s104, _i53), _e241.isOnSegment()) return _e241.getLocation();
          }

          return _e241.getLocation();
        }
      }
    }]);

    return Ye;
  }();

  var Ve = /*#__PURE__*/function () {
    function Ve() {
      _classCallCheck(this, Ve);

      Ve.constructor_.apply(this, arguments);
    }

    _createClass(Ve, [{
      key: "locate",
      value: function locate(t) {
        null === this._index && (this._index = new Xe(this._geom), this._geom = null);
        var e = new Ye(t),
            n = new ze(e);
        return this._index.query(t.y, t.y, n), e.getLocation();
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [De];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._geom = null, this._index = null;
        var t = arguments[0];
        if (!(y(t, tt) || t instanceof at)) throw new s("Argument must be Polygonal or LinearRing");
        this._geom = t;
      }
    }]);

    return Ve;
  }();

  var ze = /*#__PURE__*/function () {
    function ze() {
      _classCallCheck(this, ze);

      ze.constructor_.apply(this, arguments);
    }

    _createClass(ze, [{
      key: "visitItem",
      value: function visitItem(t) {
        var e = t;

        this._counter.countSegment(e.getCoordinate(0), e.getCoordinate(1));
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [be];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._counter = null;
        var t = arguments[0];
        this._counter = t;
      }
    }]);

    return ze;
  }();

  var Xe = /*#__PURE__*/function () {
    function Xe() {
      _classCallCheck(this, Xe);

      Xe.constructor_.apply(this, arguments);
    }

    _createClass(Xe, [{
      key: "init",
      value: function init(t) {
        for (var _e242 = fe.getLines(t).iterator(); _e242.hasNext();) {
          var _t318 = _e242.next().getCoordinates();

          this.addLine(_t318);
        }
      }
    }, {
      key: "addLine",
      value: function addLine(t) {
        for (var _e243 = 1; _e243 < t.length; _e243++) {
          var _n179 = new jt(t[_e243 - 1], t[_e243]),
              _s105 = Math.min(_n179.p0.y, _n179.p1.y),
              _i54 = Math.max(_n179.p0.y, _n179.p1.y);

          this._index.insert(_s105, _i54, _n179);
        }
      }
    }, {
      key: "query",
      value: function query() {
        if (2 === arguments.length) {
          var _t319 = arguments[0],
              _e244 = arguments[1];
          if (this._isEmpty) return new S();

          var _n180 = new Be();

          return this._index.query(_t319, _e244, _n180), _n180.getItems();
        }

        if (3 === arguments.length) {
          var _t320 = arguments[0],
              _e245 = arguments[1],
              _n181 = arguments[2];
          if (this._isEmpty) return null;

          this._index.query(_t320, _e245, _n181);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._isEmpty = !1, this._index = new qe();
        var t = arguments[0];
        t.isEmpty() ? this._isEmpty = !0 : this.init(t);
      }
    }]);

    return Xe;
  }();

  Ve.SegmentVisitor = ze, Ve.IntervalIndexedGeometry = Xe;

  var ke = /*#__PURE__*/function () {
    function ke() {
      _classCallCheck(this, ke);
    }

    _createClass(ke, null, [{
      key: "isOnLine",
      value: function isOnLine() {
        if (arguments[0] instanceof m && y(arguments[1], b)) {
          var _t321 = arguments[0],
              _e246 = arguments[1],
              _n182 = new Zt(),
              _s106 = new m(),
              _i55 = new m(),
              _r32 = _e246.size();

          for (var _o23 = 1; _o23 < _r32; _o23++) {
            if (_e246.getCoordinate(_o23 - 1, _s106), _e246.getCoordinate(_o23, _i55), _n182.computeIntersection(_t321, _s106, _i55), _n182.hasIntersection()) return !0;
          }

          return !1;
        }

        if (arguments[0] instanceof m && arguments[1] instanceof Array) {
          var _t322 = arguments[0],
              _e247 = arguments[1],
              _n183 = new Zt();

          for (var _s107 = 1; _s107 < _e247.length; _s107++) {
            var _i56 = _e247[_s107 - 1],
                _r33 = _e247[_s107];
            if (_n183.computeIntersection(_t322, _i56, _r33), _n183.hasIntersection()) return !0;
          }

          return !1;
        }
      }
    }, {
      key: "locateInRing",
      value: function locateInRing(t, e) {
        return Ye.locatePointInRing(t, e);
      }
    }, {
      key: "isInRing",
      value: function isInRing(t, e) {
        return ke.locateInRing(t, e) !== Kt.EXTERIOR;
      }
    }]);

    return ke;
  }();

  var Ue = /*#__PURE__*/function () {
    function Ue() {
      _classCallCheck(this, Ue);
    }

    _createClass(Ue, [{
      key: "hasNext",
      value: function hasNext() {}
    }, {
      key: "next",
      value: function next() {}
    }, {
      key: "remove",
      value: function remove() {}
    }]);

    return Ue;
  }();

  var He = /*#__PURE__*/function () {
    function He() {
      _classCallCheck(this, He);

      He.constructor_.apply(this, arguments);
    }

    _createClass(He, [{
      key: "next",
      value: function next() {
        if (this._atStart) return this._atStart = !1, He.isAtomic(this._parent) && this._index++, this._parent;

        if (null !== this._subcollectionIterator) {
          if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
          this._subcollectionIterator = null;
        }

        if (this._index >= this._max) throw new N();

        var t = this._parent.getGeometryN(this._index++);

        return t instanceof ot ? (this._subcollectionIterator = new He(t), this._subcollectionIterator.next()) : t;
      }
    }, {
      key: "remove",
      value: function remove() {
        throw new H(this.getClass().getName());
      }
    }, {
      key: "hasNext",
      value: function hasNext() {
        if (this._atStart) return !0;

        if (null !== this._subcollectionIterator) {
          if (this._subcollectionIterator.hasNext()) return !0;
          this._subcollectionIterator = null;
        }

        return !(this._index >= this._max);
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Ue];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
        var t = arguments[0];
        this._parent = t, this._atStart = !0, this._index = 0, this._max = t.getNumGeometries();
      }
    }, {
      key: "isAtomic",
      value: function isAtomic(t) {
        return !(t instanceof ot);
      }
    }]);

    return He;
  }();

  var We = /*#__PURE__*/function () {
    function We() {
      _classCallCheck(this, We);

      We.constructor_.apply(this, arguments);
    }

    _createClass(We, [{
      key: "locate",
      value: function locate(t) {
        return We.locate(t, this._geom);
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [De];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._geom = null;
        var t = arguments[0];
        this._geom = t;
      }
    }, {
      key: "locatePointInPolygon",
      value: function locatePointInPolygon(t, e) {
        if (e.isEmpty()) return Kt.EXTERIOR;
        var n = e.getExteriorRing(),
            s = We.locatePointInRing(t, n);
        if (s !== Kt.INTERIOR) return s;

        for (var _n184 = 0; _n184 < e.getNumInteriorRing(); _n184++) {
          var _s108 = e.getInteriorRingN(_n184),
              _i57 = We.locatePointInRing(t, _s108);

          if (_i57 === Kt.BOUNDARY) return Kt.BOUNDARY;
          if (_i57 === Kt.INTERIOR) return Kt.EXTERIOR;
        }

        return Kt.INTERIOR;
      }
    }, {
      key: "locatePointInRing",
      value: function locatePointInRing(t, e) {
        return e.getEnvelopeInternal().intersects(t) ? ke.locateInRing(t, e.getCoordinates()) : Kt.EXTERIOR;
      }
    }, {
      key: "containsPointInPolygon",
      value: function containsPointInPolygon(t, e) {
        return Kt.EXTERIOR !== We.locatePointInPolygon(t, e);
      }
    }, {
      key: "locateInGeometry",
      value: function locateInGeometry(t, e) {
        if (e instanceof et) return We.locatePointInPolygon(t, e);

        if (e instanceof ot) {
          var _n185 = new He(e);

          for (; _n185.hasNext();) {
            var _s109 = _n185.next();

            if (_s109 !== e) {
              var _e248 = We.locateInGeometry(t, _s109);

              if (_e248 !== Kt.EXTERIOR) return _e248;
            }
          }
        }

        return Kt.EXTERIOR;
      }
    }, {
      key: "isContained",
      value: function isContained(t, e) {
        return Kt.EXTERIOR !== We.locate(t, e);
      }
    }, {
      key: "locate",
      value: function locate(t, e) {
        return e.isEmpty() ? Kt.EXTERIOR : e.getEnvelopeInternal().intersects(t) ? We.locateInGeometry(t, e) : Kt.EXTERIOR;
      }
    }]);

    return We;
  }();

  var Ze = Object.freeze({
    __proto__: null,
    IndexedPointInAreaLocator: Ve,
    PointOnGeometryLocator: De,
    SimplePointInAreaLocator: We
  });

  var je = /*#__PURE__*/function () {
    function je() {
      _classCallCheck(this, je);
    }

    _createClass(je, [{
      key: "measure",
      value: function measure(t, e) {}
    }]);

    return je;
  }();

  var Ke = /*#__PURE__*/function () {
    function Ke() {
      _classCallCheck(this, Ke);
    }

    _createClass(Ke, [{
      key: "measure",
      value: function measure(t, e) {
        var n = Pe.distance(t, e, Ke.DENSIFY_FRACTION),
            s = new T(t.getEnvelopeInternal());
        s.expandToInclude(e.getEnvelopeInternal());
        return 1 - n / Ke.diagonalSize(s);
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [je];
      }
    }], [{
      key: "diagonalSize",
      value: function diagonalSize(t) {
        if (t.isNull()) return 0;
        var e = t.getWidth(),
            n = t.getHeight();
        return Math.sqrt(e * e + n * n);
      }
    }]);

    return Ke;
  }();

  Ke.DENSIFY_FRACTION = .25;
  var Qe = Object.freeze({
    __proto__: null,
    AreaSimilarityMeasure: /*#__PURE__*/function () {
      function AreaSimilarityMeasure() {
        _classCallCheck(this, AreaSimilarityMeasure);
      }

      _createClass(AreaSimilarityMeasure, [{
        key: "measure",
        value: function measure(t, e) {
          return t.intersection(e).getArea() / t.union(e).getArea();
        }
      }, {
        key: "interfaces_",
        get: function get() {
          return [je];
        }
      }]);

      return AreaSimilarityMeasure;
    }(),
    HausdorffSimilarityMeasure: Ke,
    SimilarityMeasure: je,
    SimilarityMeasureCombiner: /*#__PURE__*/function () {
      function SimilarityMeasureCombiner() {
        _classCallCheck(this, SimilarityMeasureCombiner);
      }

      _createClass(SimilarityMeasureCombiner, null, [{
        key: "combine",
        value: function combine(t, e) {
          return Math.min(t, e);
        }
      }]);

      return SimilarityMeasureCombiner;
    }()
  });

  var Je = /*#__PURE__*/function () {
    function Je() {
      _classCallCheck(this, Je);

      Je.constructor_.apply(this, arguments);
    }

    _createClass(Je, [{
      key: "setAreaBasePoint",
      value: function setAreaBasePoint(t) {
        this._areaBasePt = t;
      }
    }, {
      key: "addPoint",
      value: function addPoint(t) {
        this._ptCount += 1, this._ptCentSum.x += t.x, this._ptCentSum.y += t.y;
      }
    }, {
      key: "addLineSegments",
      value: function addLineSegments(t) {
        var e = 0;

        for (var _n186 = 0; _n186 < t.length - 1; _n186++) {
          var _s110 = t[_n186].distance(t[_n186 + 1]);

          if (0 === _s110) continue;
          e += _s110;

          var _i58 = (t[_n186].x + t[_n186 + 1].x) / 2;

          this._lineCentSum.x += _s110 * _i58;

          var _r34 = (t[_n186].y + t[_n186 + 1].y) / 2;

          this._lineCentSum.y += _s110 * _r34;
        }

        this._totalLength += e, 0 === e && t.length > 0 && this.addPoint(t[0]);
      }
    }, {
      key: "addHole",
      value: function addHole(t) {
        var e = D.isCCW(t);

        for (var _n187 = 0; _n187 < t.length - 1; _n187++) {
          this.addTriangle(this._areaBasePt, t[_n187], t[_n187 + 1], e);
        }

        this.addLineSegments(t);
      }
    }, {
      key: "getCentroid",
      value: function getCentroid() {
        var t = new m();
        if (Math.abs(this._areasum2) > 0) t.x = this._cg3.x / 3 / this._areasum2, t.y = this._cg3.y / 3 / this._areasum2;else if (this._totalLength > 0) t.x = this._lineCentSum.x / this._totalLength, t.y = this._lineCentSum.y / this._totalLength;else {
          if (!(this._ptCount > 0)) return null;
          t.x = this._ptCentSum.x / this._ptCount, t.y = this._ptCentSum.y / this._ptCount;
        }
        return t;
      }
    }, {
      key: "addShell",
      value: function addShell(t) {
        t.length > 0 && this.setAreaBasePoint(t[0]);
        var e = !D.isCCW(t);

        for (var _n188 = 0; _n188 < t.length - 1; _n188++) {
          this.addTriangle(this._areaBasePt, t[_n188], t[_n188 + 1], e);
        }

        this.addLineSegments(t);
      }
    }, {
      key: "addTriangle",
      value: function addTriangle(t, e, n, s) {
        var i = s ? 1 : -1;
        Je.centroid3(t, e, n, this._triangleCent3);
        var r = Je.area2(t, e, n);
        this._cg3.x += i * r * this._triangleCent3.x, this._cg3.y += i * r * this._triangleCent3.y, this._areasum2 += i * r;
      }
    }, {
      key: "add",
      value: function add() {
        if (arguments[0] instanceof et) {
          var _t323 = arguments[0];
          this.addShell(_t323.getExteriorRing().getCoordinates());

          for (var _e249 = 0; _e249 < _t323.getNumInteriorRing(); _e249++) {
            this.addHole(_t323.getInteriorRingN(_e249).getCoordinates());
          }
        } else if (arguments[0] instanceof V) {
          var _t324 = arguments[0];
          if (_t324.isEmpty()) return null;
          if (_t324 instanceof Q) this.addPoint(_t324.getCoordinate());else if (_t324 instanceof j) this.addLineSegments(_t324.getCoordinates());else if (_t324 instanceof et) {
            var _e250 = _t324;
            this.add(_e250);
          } else if (_t324 instanceof ot) {
            var _e251 = _t324;

            for (var _t325 = 0; _t325 < _e251.getNumGeometries(); _t325++) {
              this.add(_e251.getGeometryN(_t325));
            }
          }
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._areaBasePt = null, this._triangleCent3 = new m(), this._areasum2 = 0, this._cg3 = new m(), this._lineCentSum = new m(), this._totalLength = 0, this._ptCount = 0, this._ptCentSum = new m();
        var t = arguments[0];
        this._areaBasePt = null, this.add(t);
      }
    }, {
      key: "area2",
      value: function area2(t, e, n) {
        return (e.x - t.x) * (n.y - t.y) - (n.x - t.x) * (e.y - t.y);
      }
    }, {
      key: "centroid3",
      value: function centroid3(t, e, n, s) {
        return s.x = t.x + e.x + n.x, s.y = t.y + e.y + n.y, null;
      }
    }, {
      key: "getCentroid",
      value: function getCentroid(t) {
        return new Je(t).getCentroid();
      }
    }]);

    return Je;
  }();

  var $e = /*#__PURE__*/function (_n189) {
    _inherits($e, _n189);

    var _super32 = _createSuper($e);

    function $e() {
      _classCallCheck(this, $e);

      return _super32.apply(this, arguments);
    }

    return $e;
  }(n);

  var tn = /*#__PURE__*/function (_I2) {
    _inherits(tn, _I2);

    var _super33 = _createSuper(tn);

    function tn() {
      var _this23;

      _classCallCheck(this, tn);

      _this23 = _super33.call(this), _this23.array = [];
      return _this23;
    }

    _createClass(tn, [{
      key: "add",
      value: function add(t) {
        return this.array.push(t), !0;
      }
    }, {
      key: "get",
      value: function get(t) {
        if (t < 0 || t >= this.size()) throw new E();
        return this.array[t];
      }
    }, {
      key: "push",
      value: function push(t) {
        return this.array.push(t), t;
      }
    }, {
      key: "pop",
      value: function pop() {
        if (0 === this.array.length) throw new $e();
        return this.array.pop();
      }
    }, {
      key: "peek",
      value: function peek() {
        if (0 === this.array.length) throw new $e();
        return this.array[this.array.length - 1];
      }
    }, {
      key: "empty",
      value: function empty() {
        return 0 === this.array.length;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return this.empty();
      }
    }, {
      key: "search",
      value: function search(t) {
        return this.array.indexOf(t);
      }
    }, {
      key: "size",
      value: function size() {
        return this.array.length;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        return this.array.slice();
      }
    }]);

    return tn;
  }(I);

  var en = /*#__PURE__*/function () {
    function en() {
      _classCallCheck(this, en);

      en.constructor_.apply(this, arguments);
    }

    _createClass(en, [{
      key: "filter",
      value: function filter(t) {
        this._coordSet.add(t) && this._list.add(t);
      }
    }, {
      key: "getCoordinates",
      value: function getCoordinates() {
        var t = new Array(this._list.size()).fill(null);
        return this._list.toArray(t);
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [z];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._coordSet = new xt(), this._list = new S();
      }
    }, {
      key: "filterCoordinates",
      value: function filterCoordinates(t) {
        var e = new en();

        for (var _n190 = 0; _n190 < t.length; _n190++) {
          e.filter(t[_n190]);
        }

        return e.getCoordinates();
      }
    }]);

    return en;
  }();

  var nn = /*#__PURE__*/function () {
    function nn() {
      _classCallCheck(this, nn);

      nn.constructor_.apply(this, arguments);
    }

    _createClass(nn, [{
      key: "preSort",
      value: function preSort(t) {
        var e = null;

        for (var _n191 = 1; _n191 < t.length; _n191++) {
          (t[_n191].y < t[0].y || t[_n191].y === t[0].y && t[_n191].x < t[0].x) && (e = t[0], t[0] = t[_n191], t[_n191] = e);
        }

        return $.sort(t, 1, t.length, new sn(t[0])), t;
      }
    }, {
      key: "computeOctRing",
      value: function computeOctRing(t) {
        var e = this.computeOctPts(t),
            n = new C();
        return n.add(e, !1), n.size() < 3 ? null : (n.closeRing(), n.toCoordinateArray());
      }
    }, {
      key: "lineOrPolygon",
      value: function lineOrPolygon(t) {
        if (3 === (t = this.cleanRing(t)).length) return this._geomFactory.createLineString([t[0], t[1]]);

        var e = this._geomFactory.createLinearRing(t);

        return this._geomFactory.createPolygon(e);
      }
    }, {
      key: "cleanRing",
      value: function cleanRing(t) {
        g.equals(t[0], t[t.length - 1]);
        var e = new S();
        var n = null;

        for (var _s111 = 0; _s111 <= t.length - 2; _s111++) {
          var _i59 = t[_s111],
              _r35 = t[_s111 + 1];
          _i59.equals(_r35) || null !== n && this.isBetween(n, _i59, _r35) || (e.add(_i59), n = _i59);
        }

        e.add(t[t.length - 1]);
        var s = new Array(e.size()).fill(null);
        return e.toArray(s);
      }
    }, {
      key: "isBetween",
      value: function isBetween(t, e, n) {
        if (0 !== D.index(t, e, n)) return !1;

        if (t.x !== n.x) {
          if (t.x <= e.x && e.x <= n.x) return !0;
          if (n.x <= e.x && e.x <= t.x) return !0;
        }

        if (t.y !== n.y) {
          if (t.y <= e.y && e.y <= n.y) return !0;
          if (n.y <= e.y && e.y <= t.y) return !0;
        }

        return !1;
      }
    }, {
      key: "reduce",
      value: function reduce(t) {
        var e = this.computeOctRing(t);
        if (null === e) return t;
        var n = new it();

        for (var _t326 = 0; _t326 < e.length; _t326++) {
          n.add(e[_t326]);
        }

        for (var _s112 = 0; _s112 < t.length; _s112++) {
          ke.isInRing(t[_s112], e) || n.add(t[_s112]);
        }

        var s = dt.toCoordinateArray(n);
        return s.length < 3 ? this.padArray3(s) : s;
      }
    }, {
      key: "getConvexHull",
      value: function getConvexHull() {
        if (0 === this._inputPts.length) return this._geomFactory.createGeometryCollection();
        if (1 === this._inputPts.length) return this._geomFactory.createPoint(this._inputPts[0]);
        if (2 === this._inputPts.length) return this._geomFactory.createLineString(this._inputPts);
        var t = this._inputPts;
        this._inputPts.length > 50 && (t = this.reduce(this._inputPts));
        var e = this.preSort(t),
            n = this.grahamScan(e),
            s = this.toCoordinateArray(n);
        return this.lineOrPolygon(s);
      }
    }, {
      key: "padArray3",
      value: function padArray3(t) {
        var e = new Array(3).fill(null);

        for (var _n192 = 0; _n192 < e.length; _n192++) {
          _n192 < t.length ? e[_n192] = t[_n192] : e[_n192] = t[0];
        }

        return e;
      }
    }, {
      key: "computeOctPts",
      value: function computeOctPts(t) {
        var e = new Array(8).fill(null);

        for (var _n193 = 0; _n193 < e.length; _n193++) {
          e[_n193] = t[0];
        }

        for (var _n194 = 1; _n194 < t.length; _n194++) {
          t[_n194].x < e[0].x && (e[0] = t[_n194]), t[_n194].x - t[_n194].y < e[1].x - e[1].y && (e[1] = t[_n194]), t[_n194].y > e[2].y && (e[2] = t[_n194]), t[_n194].x + t[_n194].y > e[3].x + e[3].y && (e[3] = t[_n194]), t[_n194].x > e[4].x && (e[4] = t[_n194]), t[_n194].x - t[_n194].y > e[5].x - e[5].y && (e[5] = t[_n194]), t[_n194].y < e[6].y && (e[6] = t[_n194]), t[_n194].x + t[_n194].y < e[7].x + e[7].y && (e[7] = t[_n194]);
        }

        return e;
      }
    }, {
      key: "toCoordinateArray",
      value: function toCoordinateArray(t) {
        var e = new Array(t.size()).fill(null);

        for (var _n195 = 0; _n195 < t.size(); _n195++) {
          var _s113 = t.get(_n195);

          e[_n195] = _s113;
        }

        return e;
      }
    }, {
      key: "grahamScan",
      value: function grahamScan(t) {
        var e = null;
        var n = new tn();
        n.push(t[0]), n.push(t[1]), n.push(t[2]);

        for (var _s114 = 3; _s114 < t.length; _s114++) {
          for (e = n.pop(); !n.empty() && D.index(n.peek(), e, t[_s114]) > 0;) {
            e = n.pop();
          }

          n.push(e), n.push(t[_s114]);
        }

        return n.push(t[0]), n;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._geomFactory = null, this._inputPts = null, 1 === arguments.length) {
          var _t327 = arguments[0];
          nn.constructor_.call(this, nn.extractCoordinates(_t327), _t327.getFactory());
        } else if (2 === arguments.length) {
          var _t328 = arguments[0],
              _e252 = arguments[1];
          this._inputPts = en.filterCoordinates(_t328), this._geomFactory = _e252;
        }
      }
    }, {
      key: "extractCoordinates",
      value: function extractCoordinates(t) {
        var e = new en();
        return t.apply(e), e.getCoordinates();
      }
    }]);

    return nn;
  }();

  var sn = /*#__PURE__*/function () {
    function sn() {
      _classCallCheck(this, sn);

      sn.constructor_.apply(this, arguments);
    }

    _createClass(sn, [{
      key: "compare",
      value: function compare(t, e) {
        var n = t,
            s = e;
        return sn.polarCompare(this._origin, n, s);
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [a];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._origin = null;
        var t = arguments[0];
        this._origin = t;
      }
    }, {
      key: "polarCompare",
      value: function polarCompare(t, e, n) {
        var s = e.x - t.x,
            i = e.y - t.y,
            r = n.x - t.x,
            o = n.y - t.y,
            l = D.index(t, e, n);
        if (l === D.COUNTERCLOCKWISE) return 1;
        if (l === D.CLOCKWISE) return -1;
        var a = s * s + i * i,
            c = r * r + o * o;
        return a < c ? -1 : a > c ? 1 : 0;
      }
    }]);

    return sn;
  }();

  nn.RadialComparator = sn;

  var rn = /*#__PURE__*/function () {
    function rn() {
      _classCallCheck(this, rn);

      rn.constructor_.apply(this, arguments);
    }

    _createClass(rn, [{
      key: "getInteriorPoint",
      value: function getInteriorPoint() {
        return this._interiorPoint;
      }
    }, {
      key: "process",
      value: function process(t) {
        if (t.isEmpty()) return null;
        if (t instanceof et) this.processPolygon(t);else if (t instanceof ot) {
          var _e253 = t;

          for (var _t329 = 0; _t329 < _e253.getNumGeometries(); _t329++) {
            this.process(_e253.getGeometryN(_t329));
          }
        }
      }
    }, {
      key: "processPolygon",
      value: function processPolygon(t) {
        var e = new on(t);
        e.process();
        var n = e.getWidth();
        n > this._maxWidth && (this._maxWidth = n, this._interiorPoint = e.getInteriorPoint());
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._interiorPoint = null, this._maxWidth = -1;
        var t = arguments[0];
        this.process(t);
      }
    }, {
      key: "getInteriorPoint",
      value: function getInteriorPoint(t) {
        return new rn(t).getInteriorPoint();
      }
    }, {
      key: "avg",
      value: function avg(t, e) {
        return (t + e) / 2;
      }
    }]);

    return rn;
  }();

  var on = /*#__PURE__*/function () {
    function on() {
      _classCallCheck(this, on);

      on.constructor_.apply(this, arguments);
    }

    _createClass(on, [{
      key: "findBestMidpoint",
      value: function findBestMidpoint(t) {
        if (0 === t.size()) return null;
        g.isTrue(0 == t.size() % 2, "Interior Point robustness failure: odd number of scanline crossings"), t.sort(new ln());

        for (var _e254 = 0; _e254 < t.size(); _e254 += 2) {
          var _n196 = t.get(_e254),
              _s115 = t.get(_e254 + 1),
              _i60 = _s115 - _n196;

          if (_i60 > this._interiorSectionWidth) {
            this._interiorSectionWidth = _i60;

            var _t330 = rn.avg(_n196, _s115);

            this._interiorPoint = new m(_t330, this._interiorPointY);
          }
        }
      }
    }, {
      key: "process",
      value: function process() {
        if (this._polygon.isEmpty()) return null;
        this._interiorPoint = new m(this._polygon.getCoordinate());
        var t = new S();
        this.scanRing(this._polygon.getExteriorRing(), t);

        for (var _e255 = 0; _e255 < this._polygon.getNumInteriorRing(); _e255++) {
          this.scanRing(this._polygon.getInteriorRingN(_e255), t);
        }

        this.findBestMidpoint(t);
      }
    }, {
      key: "scanRing",
      value: function scanRing(t, e) {
        if (!on.intersectsHorizontalLine(t.getEnvelopeInternal(), this._interiorPointY)) return null;
        var n = t.getCoordinateSequence();

        for (var _t331 = 1; _t331 < n.size(); _t331++) {
          var _s116 = n.getCoordinate(_t331 - 1),
              _i61 = n.getCoordinate(_t331);

          this.addEdgeCrossing(_s116, _i61, this._interiorPointY, e);
        }
      }
    }, {
      key: "getWidth",
      value: function getWidth() {
        return this._interiorSectionWidth;
      }
    }, {
      key: "getInteriorPoint",
      value: function getInteriorPoint() {
        return this._interiorPoint;
      }
    }, {
      key: "addEdgeCrossing",
      value: function addEdgeCrossing(t, e, n, s) {
        if (!on.intersectsHorizontalLine(t, e, n)) return null;
        if (!on.isEdgeCrossingCounted(t, e, n)) return null;
        var i = on.intersection(t, e, n);
        s.add(i);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._polygon = null, this._interiorPointY = null, this._interiorSectionWidth = 0, this._interiorPoint = null;
        var t = arguments[0];
        this._polygon = t, this._interiorPointY = an.getScanLineY(t);
      }
    }, {
      key: "isEdgeCrossingCounted",
      value: function isEdgeCrossingCounted(t, e, n) {
        var s = t.getY(),
            i = e.getY();
        return s !== i && !(s === n && i < n) && !(i === n && s < n);
      }
    }, {
      key: "intersectsHorizontalLine",
      value: function intersectsHorizontalLine() {
        if (2 === arguments.length) {
          var _t332 = arguments[0],
              _e256 = arguments[1];
          return !(_e256 < _t332.getMinY()) && !(_e256 > _t332.getMaxY());
        }

        if (3 === arguments.length) {
          var _t333 = arguments[0],
              _e257 = arguments[1],
              _n197 = arguments[2];
          return !(_t333.getY() > _n197 && _e257.getY() > _n197) && !(_t333.getY() < _n197 && _e257.getY() < _n197);
        }
      }
    }, {
      key: "intersection",
      value: function intersection(t, e, n) {
        var s = t.getX(),
            i = e.getX();
        if (s === i) return s;
        var r = i - s,
            o = (e.getY() - t.getY()) / r;
        return s + (n - t.getY()) / o;
      }
    }]);

    return on;
  }();

  var ln = /*#__PURE__*/function () {
    function ln() {
      _classCallCheck(this, ln);
    }

    _createClass(ln, [{
      key: "compare",
      value: function compare(t, e) {
        return t < e ? -1 : t > e ? 1 : 0;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [a];
      }
    }]);

    return ln;
  }();

  on.DoubleComparator = ln;

  var an = /*#__PURE__*/function () {
    function an() {
      _classCallCheck(this, an);

      an.constructor_.apply(this, arguments);
    }

    _createClass(an, [{
      key: "updateInterval",
      value: function updateInterval(t) {
        t <= this._centreY ? t > this._loY && (this._loY = t) : t > this._centreY && t < this._hiY && (this._hiY = t);
      }
    }, {
      key: "getScanLineY",
      value: function getScanLineY() {
        this.process(this._poly.getExteriorRing());

        for (var _t334 = 0; _t334 < this._poly.getNumInteriorRing(); _t334++) {
          this.process(this._poly.getInteriorRingN(_t334));
        }

        return rn.avg(this._hiY, this._loY);
      }
    }, {
      key: "process",
      value: function process(t) {
        var e = t.getCoordinateSequence();

        for (var _t335 = 0; _t335 < e.size(); _t335++) {
          var _n198 = e.getY(_t335);

          this.updateInterval(_n198);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._poly = null, this._centreY = null, this._hiY = r.MAX_VALUE, this._loY = -r.MAX_VALUE;
        var t = arguments[0];
        this._poly = t, this._hiY = t.getEnvelopeInternal().getMaxY(), this._loY = t.getEnvelopeInternal().getMinY(), this._centreY = rn.avg(this._loY, this._hiY);
      }
    }, {
      key: "getScanLineY",
      value: function getScanLineY(t) {
        return new an(t).getScanLineY();
      }
    }]);

    return an;
  }();

  rn.InteriorPointPolygon = on, rn.ScanLineYOrdinateFinder = an;

  var cn = /*#__PURE__*/function () {
    function cn() {
      _classCallCheck(this, cn);

      cn.constructor_.apply(this, arguments);
    }

    _createClass(cn, [{
      key: "addEndpoints",
      value: function addEndpoints() {
        if (arguments[0] instanceof V) {
          var _t336 = arguments[0];
          if (_t336 instanceof j) this.addEndpoints(_t336.getCoordinates());else if (_t336 instanceof ot) {
            var _e258 = _t336;

            for (var _t337 = 0; _t337 < _e258.getNumGeometries(); _t337++) {
              this.addEndpoints(_e258.getGeometryN(_t337));
            }
          }
        } else if (arguments[0] instanceof Array) {
          var _t338 = arguments[0];
          this.add(_t338[0]), this.add(_t338[_t338.length - 1]);
        }
      }
    }, {
      key: "getInteriorPoint",
      value: function getInteriorPoint() {
        return this._interiorPoint;
      }
    }, {
      key: "addInterior",
      value: function addInterior() {
        if (arguments[0] instanceof V) {
          var _t339 = arguments[0];
          if (_t339 instanceof j) this.addInterior(_t339.getCoordinates());else if (_t339 instanceof ot) {
            var _e259 = _t339;

            for (var _t340 = 0; _t340 < _e259.getNumGeometries(); _t340++) {
              this.addInterior(_e259.getGeometryN(_t340));
            }
          }
        } else if (arguments[0] instanceof Array) {
          var _t341 = arguments[0];

          for (var _e260 = 1; _e260 < _t341.length - 1; _e260++) {
            this.add(_t341[_e260]);
          }
        }
      }
    }, {
      key: "add",
      value: function add(t) {
        var e = t.distance(this._centroid);
        e < this._minDistance && (this._interiorPoint = new m(t), this._minDistance = e);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._centroid = null, this._minDistance = r.MAX_VALUE, this._interiorPoint = null;
        var t = arguments[0];
        t.isEmpty() ? this._centroid = null : (this._centroid = Je.getCentroid(t), t.getPrecisionModel().makePrecise(this._centroid)), this.addInterior(t), null === this._interiorPoint && this.addEndpoints(t);
      }
    }, {
      key: "getInteriorPoint",
      value: function getInteriorPoint(t) {
        return new cn(t).getInteriorPoint();
      }
    }]);

    return cn;
  }();

  var hn = /*#__PURE__*/function () {
    function hn() {
      _classCallCheck(this, hn);

      hn.constructor_.apply(this, arguments);
    }

    _createClass(hn, [{
      key: "getInteriorPoint",
      value: function getInteriorPoint() {
        return this._interiorPoint;
      }
    }, {
      key: "add",
      value: function add() {
        if (arguments[0] instanceof V) {
          var _t342 = arguments[0];
          if (_t342 instanceof Q) this.add(_t342.getCoordinate());else if (_t342 instanceof ot) {
            var _e261 = _t342;

            for (var _t343 = 0; _t343 < _e261.getNumGeometries(); _t343++) {
              this.add(_e261.getGeometryN(_t343));
            }
          }
        } else if (arguments[0] instanceof m) {
          var _t344 = arguments[0],
              _e262 = _t344.distance(this._centroid);

          _e262 < this._minDistance && (this._interiorPoint = new m(_t344), this._minDistance = _e262);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._centroid = null, this._minDistance = r.MAX_VALUE, this._interiorPoint = null;
        var t = arguments[0];
        this._centroid = Je.getCentroid(t), this.add(t);
      }
    }, {
      key: "getInteriorPoint",
      value: function getInteriorPoint(t) {
        return new hn(t).getInteriorPoint();
      }
    }]);

    return hn;
  }();

  var un = /*#__PURE__*/function () {
    function un() {
      _classCallCheck(this, un);
    }

    _createClass(un, [{
      key: "isInBoundary",
      value: function isInBoundary(t) {}
    }]);

    return un;
  }();

  var gn = /*#__PURE__*/function () {
    function gn() {
      _classCallCheck(this, gn);
    }

    _createClass(gn, [{
      key: "isInBoundary",
      value: function isInBoundary(t) {
        return t % 2 == 1;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [un];
      }
    }]);

    return gn;
  }();

  var dn = /*#__PURE__*/function () {
    function dn() {
      _classCallCheck(this, dn);
    }

    _createClass(dn, [{
      key: "isInBoundary",
      value: function isInBoundary(t) {
        return t > 0;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [un];
      }
    }]);

    return dn;
  }();

  var _n = /*#__PURE__*/function () {
    function _n() {
      _classCallCheck(this, _n);
    }

    _createClass(_n, [{
      key: "isInBoundary",
      value: function isInBoundary(t) {
        return t > 1;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [un];
      }
    }]);

    return _n;
  }();

  var pn = /*#__PURE__*/function () {
    function pn() {
      _classCallCheck(this, pn);
    }

    _createClass(pn, [{
      key: "isInBoundary",
      value: function isInBoundary(t) {
        return 1 === t;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [un];
      }
    }]);

    return pn;
  }();

  un.Mod2BoundaryNodeRule = gn, un.EndPointBoundaryNodeRule = dn, un.MultiValentEndPointBoundaryNodeRule = _n, un.MonoValentEndPointBoundaryNodeRule = pn, un.MOD2_BOUNDARY_RULE = new gn(), un.ENDPOINT_BOUNDARY_RULE = new dn(), un.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new _n(), un.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new pn(), un.OGC_SFS_BOUNDARY_RULE = un.MOD2_BOUNDARY_RULE;

  var mn = /*#__PURE__*/function () {
    function mn() {
      _classCallCheck(this, mn);

      mn.constructor_.apply(this, arguments);
    }

    _createClass(mn, [{
      key: "locateInPolygonRing",
      value: function locateInPolygonRing(t, e) {
        return e.getEnvelopeInternal().intersects(t) ? ke.locateInRing(t, e.getCoordinates()) : Kt.EXTERIOR;
      }
    }, {
      key: "intersects",
      value: function intersects(t, e) {
        return this.locate(t, e) !== Kt.EXTERIOR;
      }
    }, {
      key: "updateLocationInfo",
      value: function updateLocationInfo(t) {
        t === Kt.INTERIOR && (this._isIn = !0), t === Kt.BOUNDARY && this._numBoundaries++;
      }
    }, {
      key: "computeLocation",
      value: function computeLocation(t, e) {
        if (e instanceof Q && this.updateLocationInfo(this.locateOnPoint(t, e)), e instanceof j) this.updateLocationInfo(this.locateOnLineString(t, e));else if (e instanceof et) this.updateLocationInfo(this.locateInPolygon(t, e));else if (e instanceof wt) {
          var _n199 = e;

          for (var _e263 = 0; _e263 < _n199.getNumGeometries(); _e263++) {
            var _s117 = _n199.getGeometryN(_e263);

            this.updateLocationInfo(this.locateOnLineString(t, _s117));
          }
        } else if (e instanceof ft) {
          var _n200 = e;

          for (var _e264 = 0; _e264 < _n200.getNumGeometries(); _e264++) {
            var _s118 = _n200.getGeometryN(_e264);

            this.updateLocationInfo(this.locateInPolygon(t, _s118));
          }
        } else if (e instanceof ot) {
          var _n201 = new He(e);

          for (; _n201.hasNext();) {
            var _s119 = _n201.next();

            _s119 !== e && this.computeLocation(t, _s119);
          }
        }
      }
    }, {
      key: "locateOnPoint",
      value: function locateOnPoint(t, e) {
        return e.getCoordinate().equals2D(t) ? Kt.INTERIOR : Kt.EXTERIOR;
      }
    }, {
      key: "locateOnLineString",
      value: function locateOnLineString(t, e) {
        if (!e.getEnvelopeInternal().intersects(t)) return Kt.EXTERIOR;
        var n = e.getCoordinateSequence();
        return e.isClosed() || !t.equals(n.getCoordinate(0)) && !t.equals(n.getCoordinate(n.size() - 1)) ? ke.isOnLine(t, n) ? Kt.INTERIOR : Kt.EXTERIOR : Kt.BOUNDARY;
      }
    }, {
      key: "locateInPolygon",
      value: function locateInPolygon(t, e) {
        if (e.isEmpty()) return Kt.EXTERIOR;
        var n = e.getExteriorRing(),
            s = this.locateInPolygonRing(t, n);
        if (s === Kt.EXTERIOR) return Kt.EXTERIOR;
        if (s === Kt.BOUNDARY) return Kt.BOUNDARY;

        for (var _n202 = 0; _n202 < e.getNumInteriorRing(); _n202++) {
          var _s120 = e.getInteriorRingN(_n202),
              _i62 = this.locateInPolygonRing(t, _s120);

          if (_i62 === Kt.INTERIOR) return Kt.EXTERIOR;
          if (_i62 === Kt.BOUNDARY) return Kt.BOUNDARY;
        }

        return Kt.INTERIOR;
      }
    }, {
      key: "locate",
      value: function locate(t, e) {
        return e.isEmpty() ? Kt.EXTERIOR : e instanceof j ? this.locateOnLineString(t, e) : e instanceof et ? this.locateInPolygon(t, e) : (this._isIn = !1, this._numBoundaries = 0, this.computeLocation(t, e), this._boundaryRule.isInBoundary(this._numBoundaries) ? Kt.BOUNDARY : this._numBoundaries > 0 || this._isIn ? Kt.INTERIOR : Kt.EXTERIOR);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._boundaryRule = un.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, 0 === arguments.length) ;else if (1 === arguments.length) {
          var _t345 = arguments[0];
          if (null === _t345) throw new s("Rule must be non-null");
          this._boundaryRule = _t345;
        }
      }
    }]);

    return mn;
  }();

  var fn = /*#__PURE__*/function () {
    function fn() {
      _classCallCheck(this, fn);

      fn.constructor_.apply(this, arguments);
    }

    _createClass(fn, [{
      key: "getRadius",
      value: function getRadius() {
        return this.compute(), this._radius;
      }
    }, {
      key: "getDiameter",
      value: function getDiameter() {
        switch (this.compute(), this._extremalPts.length) {
          case 0:
            return this._input.getFactory().createLineString();

          case 1:
            return this._input.getFactory().createPoint(this._centre);
        }

        var t = this._extremalPts[0],
            e = this._extremalPts[1];
        return this._input.getFactory().createLineString([t, e]);
      }
    }, {
      key: "getExtremalPoints",
      value: function getExtremalPoints() {
        return this.compute(), this._extremalPts;
      }
    }, {
      key: "computeCirclePoints",
      value: function computeCirclePoints() {
        if (this._input.isEmpty()) return this._extremalPts = new Array(0).fill(null), null;

        if (1 === this._input.getNumPoints()) {
          var _t346 = this._input.getCoordinates();

          return this._extremalPts = [new m(_t346[0])], null;
        }

        var t = this._input.convexHull().getCoordinates();

        var e = t;
        if (t[0].equals2D(t[t.length - 1]) && (e = new Array(t.length - 1).fill(null), dt.copyDeep(t, 0, e, 0, t.length - 1)), e.length <= 2) return this._extremalPts = dt.copyDeep(e), null;
        var n = fn.lowestPoint(e),
            s = fn.pointWitMinAngleWithX(e, n);

        for (var _t347 = 0; _t347 < e.length; _t347++) {
          var _t348 = fn.pointWithMinAngleWithSegment(e, n, s);

          if (Jt.isObtuse(n, _t348, s)) return this._extremalPts = [new m(n), new m(s)], null;
          if (Jt.isObtuse(_t348, n, s)) n = _t348;else {
            if (!Jt.isObtuse(_t348, s, n)) return this._extremalPts = [new m(n), new m(s), new m(_t348)], null;
            s = _t348;
          }
        }

        g.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!");
      }
    }, {
      key: "compute",
      value: function compute() {
        if (null !== this._extremalPts) return null;
        this.computeCirclePoints(), this.computeCentre(), null !== this._centre && (this._radius = this._centre.distance(this._extremalPts[0]));
      }
    }, {
      key: "getCircle",
      value: function getCircle() {
        if (this.compute(), null === this._centre) return this._input.getFactory().createPolygon();

        var t = this._input.getFactory().createPoint(this._centre);

        return 0 === this._radius ? t : t.buffer(this._radius);
      }
    }, {
      key: "getCentre",
      value: function getCentre() {
        return this.compute(), this._centre;
      }
    }, {
      key: "getMaximumDiameter",
      value: function getMaximumDiameter() {
        switch (this.compute(), this._extremalPts.length) {
          case 0:
            return this._input.getFactory().createLineString();

          case 1:
            return this._input.getFactory().createPoint(this._centre);

          case 2:
            return this._input.getFactory().createLineString([this._extremalPts[0], this._extremalPts[1]]);

          default:
            var _t349 = fn.farthestPoints(this._extremalPts);

            return this._input.getFactory().createLineString(_t349);
        }
      }
    }, {
      key: "computeCentre",
      value: function computeCentre() {
        switch (this._extremalPts.length) {
          case 0:
            this._centre = null;
            break;

          case 1:
            this._centre = this._extremalPts[0];
            break;

          case 2:
            this._centre = new m((this._extremalPts[0].x + this._extremalPts[1].x) / 2, (this._extremalPts[0].y + this._extremalPts[1].y) / 2);
            break;

          case 3:
            this._centre = ee.circumcentre(this._extremalPts[0], this._extremalPts[1], this._extremalPts[2]);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._input = null, this._extremalPts = null, this._centre = null, this._radius = 0;
        var t = arguments[0];
        this._input = t;
      }
    }, {
      key: "farthestPoints",
      value: function farthestPoints(t) {
        var e = t[0].distance(t[1]),
            n = t[1].distance(t[2]),
            s = t[2].distance(t[0]);
        return e >= n && e >= s ? [t[0], t[1]] : n >= e && n >= s ? [t[1], t[2]] : [t[2], t[0]];
      }
    }, {
      key: "pointWitMinAngleWithX",
      value: function pointWitMinAngleWithX(t, e) {
        var n = r.MAX_VALUE,
            s = null;

        for (var _i63 = 0; _i63 < t.length; _i63++) {
          var _r36 = t[_i63];
          if (_r36 === e) continue;

          var _o24 = _r36.x - e.x;

          var _l20 = _r36.y - e.y;

          _l20 < 0 && (_l20 = -_l20);

          var _a14 = _l20 / Math.sqrt(_o24 * _o24 + _l20 * _l20);

          _a14 < n && (n = _a14, s = _r36);
        }

        return s;
      }
    }, {
      key: "lowestPoint",
      value: function lowestPoint(t) {
        var e = t[0];

        for (var _n203 = 1; _n203 < t.length; _n203++) {
          t[_n203].y < e.y && (e = t[_n203]);
        }

        return e;
      }
    }, {
      key: "pointWithMinAngleWithSegment",
      value: function pointWithMinAngleWithSegment(t, e, n) {
        var s = r.MAX_VALUE,
            i = null;

        for (var _r37 = 0; _r37 < t.length; _r37++) {
          var _o25 = t[_r37];
          if (_o25 === e) continue;
          if (_o25 === n) continue;

          var _l21 = Jt.angleBetween(e, _o25, n);

          _l21 < s && (s = _l21, i = _o25);
        }

        return i;
      }
    }]);

    return fn;
  }();

  var yn = /*#__PURE__*/function () {
    function yn() {
      _classCallCheck(this, yn);

      yn.constructor_.apply(this, arguments);
    }

    _createClass(yn, [{
      key: "getWidthCoordinate",
      value: function getWidthCoordinate() {
        return this.computeMinimumDiameter(), this._minWidthPt;
      }
    }, {
      key: "getSupportingSegment",
      value: function getSupportingSegment() {
        return this.computeMinimumDiameter(), this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0, this._minBaseSeg.p1]);
      }
    }, {
      key: "getDiameter",
      value: function getDiameter() {
        if (this.computeMinimumDiameter(), null === this._minWidthPt) return this._inputGeom.getFactory().createLineString();

        var t = this._minBaseSeg.project(this._minWidthPt);

        return this._inputGeom.getFactory().createLineString([t, this._minWidthPt]);
      }
    }, {
      key: "computeWidthConvex",
      value: function computeWidthConvex(t) {
        this._convexHullPts = t instanceof et ? t.getExteriorRing().getCoordinates() : t.getCoordinates(), 0 === this._convexHullPts.length ? (this._minWidth = 0, this._minWidthPt = null, this._minBaseSeg = null) : 1 === this._convexHullPts.length ? (this._minWidth = 0, this._minWidthPt = this._convexHullPts[0], this._minBaseSeg.p0 = this._convexHullPts[0], this._minBaseSeg.p1 = this._convexHullPts[0]) : 2 === this._convexHullPts.length || 3 === this._convexHullPts.length ? (this._minWidth = 0, this._minWidthPt = this._convexHullPts[0], this._minBaseSeg.p0 = this._convexHullPts[0], this._minBaseSeg.p1 = this._convexHullPts[1]) : this.computeConvexRingMinDiameter(this._convexHullPts);
      }
    }, {
      key: "computeConvexRingMinDiameter",
      value: function computeConvexRingMinDiameter(t) {
        this._minWidth = r.MAX_VALUE;
        var e = 1;
        var n = new jt();

        for (var _s121 = 0; _s121 < t.length - 1; _s121++) {
          n.p0 = t[_s121], n.p1 = t[_s121 + 1], e = this.findMaxPerpDistance(t, n, e);
        }
      }
    }, {
      key: "computeMinimumDiameter",
      value: function computeMinimumDiameter() {
        if (null !== this._minWidthPt) return null;
        if (this._isConvex) this.computeWidthConvex(this._inputGeom);else {
          var _t350 = new nn(this._inputGeom).getConvexHull();

          this.computeWidthConvex(_t350);
        }
      }
    }, {
      key: "getLength",
      value: function getLength() {
        return this.computeMinimumDiameter(), this._minWidth;
      }
    }, {
      key: "findMaxPerpDistance",
      value: function findMaxPerpDistance(t, e, n) {
        var s = e.distancePerpendicular(t[n]),
            i = s,
            r = n,
            o = r;

        for (; i >= s;) {
          s = i, r = o, o = yn.nextIndex(t, r), i = e.distancePerpendicular(t[o]);
        }

        return s < this._minWidth && (this._minPtIndex = r, this._minWidth = s, this._minWidthPt = t[this._minPtIndex], this._minBaseSeg = new jt(e)), r;
      }
    }, {
      key: "getMinimumRectangle",
      value: function getMinimumRectangle() {
        if (this.computeMinimumDiameter(), 0 === this._minWidth) return this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1) ? this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0) : this._minBaseSeg.toGeometry(this._inputGeom.getFactory());
        var t = this._minBaseSeg.p1.x - this._minBaseSeg.p0.x,
            e = this._minBaseSeg.p1.y - this._minBaseSeg.p0.y;
        var n = r.MAX_VALUE,
            s = -r.MAX_VALUE,
            i = r.MAX_VALUE,
            o = -r.MAX_VALUE;

        for (var _r38 = 0; _r38 < this._convexHullPts.length; _r38++) {
          var _l22 = yn.computeC(t, e, this._convexHullPts[_r38]);

          _l22 > s && (s = _l22), _l22 < n && (n = _l22);

          var _a15 = yn.computeC(-e, t, this._convexHullPts[_r38]);

          _a15 > o && (o = _a15), _a15 < i && (i = _a15);
        }

        var l = yn.computeSegmentForLine(-t, -e, o),
            a = yn.computeSegmentForLine(-t, -e, i),
            c = yn.computeSegmentForLine(-e, t, s),
            h = yn.computeSegmentForLine(-e, t, n),
            u = c.lineIntersection(l),
            g = h.lineIntersection(l),
            d = h.lineIntersection(a),
            _ = c.lineIntersection(a),
            p = this._inputGeom.getFactory().createLinearRing([u, g, d, _, u]);

        return this._inputGeom.getFactory().createPolygon(p);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._inputGeom = null, this._isConvex = null, this._convexHullPts = null, this._minBaseSeg = new jt(), this._minWidthPt = null, this._minPtIndex = null, this._minWidth = 0, 1 === arguments.length) {
          var _t351 = arguments[0];
          yn.constructor_.call(this, _t351, !1);
        } else if (2 === arguments.length) {
          var _t352 = arguments[0],
              _e265 = arguments[1];
          this._inputGeom = _t352, this._isConvex = _e265;
        }
      }
    }, {
      key: "nextIndex",
      value: function nextIndex(t, e) {
        return ++e >= t.length && (e = 0), e;
      }
    }, {
      key: "computeC",
      value: function computeC(t, e, n) {
        return t * n.y - e * n.x;
      }
    }, {
      key: "getMinimumDiameter",
      value: function getMinimumDiameter(t) {
        return new yn(t).getDiameter();
      }
    }, {
      key: "getMinimumRectangle",
      value: function getMinimumRectangle(t) {
        return new yn(t).getMinimumRectangle();
      }
    }, {
      key: "computeSegmentForLine",
      value: function computeSegmentForLine(t, e, n) {
        var s = null,
            i = null;
        return Math.abs(e) > Math.abs(t) ? (s = new m(0, n / e), i = new m(1, n / e - t / e)) : (s = new m(n / t, 0), i = new m(n / t - e / t, 1)), new jt(s, i);
      }
    }]);

    return yn;
  }();

  var xn = Object.freeze({
    __proto__: null,
    distance: Me,
    locate: Ze,
    match: Qe,
    Angle: Jt,
    Area: J,
    Centroid: Je,
    ConvexHull: nn,
    Distance: q,
    InteriorPointArea: rn,
    InteriorPointLine: cn,
    InteriorPointPoint: hn,
    Length: X,
    Orientation: D,
    PointLocation: ke,
    PointLocator: mn,
    RobustLineIntersector: Zt,
    MinimumBoundingCircle: fn,
    MinimumDiameter: yn
  });

  var En = /*#__PURE__*/function () {
    function En() {
      _classCallCheck(this, En);

      En.constructor_.apply(this, arguments);
    }

    _createClass(En, [{
      key: "getResultGeometry",
      value: function getResultGeometry() {
        return new In(this._distanceTolerance).transform(this._inputGeom);
      }
    }, {
      key: "setDistanceTolerance",
      value: function setDistanceTolerance(t) {
        if (t <= 0) throw new s("Tolerance must be positive");
        this._distanceTolerance = t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._inputGeom = null, this._distanceTolerance = null;
        var t = arguments[0];
        this._inputGeom = t;
      }
    }, {
      key: "densifyPoints",
      value: function densifyPoints(t, e, n) {
        var s = new jt(),
            i = new C();

        for (var _r39 = 0; _r39 < t.length - 1; _r39++) {
          s.p0 = t[_r39], s.p1 = t[_r39 + 1], i.add(s.p0, !1);

          var _o26 = s.getLength(),
              _l23 = Math.trunc(_o26 / e) + 1;

          if (_l23 > 1) {
            var _t353 = _o26 / _l23;

            for (var _e266 = 1; _e266 < _l23; _e266++) {
              var _r40 = _e266 * _t353 / _o26,
                  _l24 = s.pointAlong(_r40);

              n.makePrecise(_l24), i.add(_l24, !1);
            }
          }
        }

        return i.add(t[t.length - 1], !1), i.toCoordinateArray();
      }
    }, {
      key: "densify",
      value: function densify(t, e) {
        var n = new En(t);
        return n.setDistanceTolerance(e), n.getResultGeometry();
      }
    }]);

    return En;
  }();

  var In = /*#__PURE__*/function (_pe) {
    _inherits(In, _pe);

    var _super34 = _createSuper(In);

    function In() {
      var _this24;

      _classCallCheck(this, In);

      _this24 = _super34.call(this), In.constructor_.apply(_assertThisInitialized(_this24), arguments);
      return _this24;
    }

    _createClass(In, [{
      key: "transformMultiPolygon",
      value: function transformMultiPolygon(t, e) {
        var n = _get(_getPrototypeOf(In.prototype), "transformMultiPolygon", this).call(this, t, e);

        return this.createValidArea(n);
      }
    }, {
      key: "transformPolygon",
      value: function transformPolygon(t, e) {
        var n = _get(_getPrototypeOf(In.prototype), "transformPolygon", this).call(this, t, e);

        return e instanceof ft ? n : this.createValidArea(n);
      }
    }, {
      key: "transformCoordinates",
      value: function transformCoordinates(t, e) {
        var n = t.toCoordinateArray();
        var s = En.densifyPoints(n, this.distanceTolerance, e.getPrecisionModel());
        return e instanceof j && 1 === s.length && (s = new Array(0).fill(null)), this._factory.getCoordinateSequenceFactory().create(s);
      }
    }, {
      key: "createValidArea",
      value: function createValidArea(t) {
        return t.buffer(0);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this.distanceTolerance = null;
        var t = arguments[0];
        this.distanceTolerance = t;
      }
    }]);

    return In;
  }(pe);

  En.DensifyTransformer = In;
  var Nn = Object.freeze({
    __proto__: null,
    Densifier: En
  });

  var Sn = /*#__PURE__*/function () {
    function Sn() {
      _classCallCheck(this, Sn);
    }

    _createClass(Sn, null, [{
      key: "isNorthern",
      value: function isNorthern(t) {
        return t === Sn.NE || t === Sn.NW;
      }
    }, {
      key: "isOpposite",
      value: function isOpposite(t, e) {
        if (t === e) return !1;
        return 2 === (t - e + 4) % 4;
      }
    }, {
      key: "commonHalfPlane",
      value: function commonHalfPlane(t, e) {
        if (t === e) return t;
        if (2 === (t - e + 4) % 4) return -1;
        var n = t < e ? t : e;
        return 0 === n && 3 === (t > e ? t : e) ? 3 : n;
      }
    }, {
      key: "isInHalfPlane",
      value: function isInHalfPlane(t, e) {
        return e === Sn.SE ? t === Sn.SE || t === Sn.SW : t === e || t === e + 1;
      }
    }, {
      key: "quadrant",
      value: function quadrant() {
        if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
          var _t354 = arguments[0],
              _e267 = arguments[1];
          if (0 === _t354 && 0 === _e267) throw new s("Cannot compute the quadrant for point ( " + _t354 + ", " + _e267 + " )");
          return _t354 >= 0 ? _e267 >= 0 ? Sn.NE : Sn.SE : _e267 >= 0 ? Sn.NW : Sn.SW;
        }

        if (arguments[0] instanceof m && arguments[1] instanceof m) {
          var _t355 = arguments[0],
              _e268 = arguments[1];
          if (_e268.x === _t355.x && _e268.y === _t355.y) throw new s("Cannot compute the quadrant for two identical points " + _t355);
          return _e268.x >= _t355.x ? _e268.y >= _t355.y ? Sn.NE : Sn.SE : _e268.y >= _t355.y ? Sn.NW : Sn.SW;
        }
      }
    }]);

    return Sn;
  }();

  Sn.NE = 0, Sn.NW = 1, Sn.SW = 2, Sn.SE = 3;

  var wn = /*#__PURE__*/function () {
    function wn() {
      _classCallCheck(this, wn);

      wn.constructor_.apply(this, arguments);
    }

    _createClass(wn, [{
      key: "find",
      value: function find(t) {
        var e = this;

        do {
          if (null === e) return null;
          if (e.dest().equals2D(t)) return e;
          e = e.oNext();
        } while (e !== this);

        return null;
      }
    }, {
      key: "dest",
      value: function dest() {
        return this._sym._orig;
      }
    }, {
      key: "isEdgesSorted",
      value: function isEdgesSorted() {
        var t = this.findLowest();
        var e = t;

        do {
          var _n204 = e.oNext();

          if (_n204 === t) break;
          if (!(_n204.compareTo(e) > 0)) return !1;
          e = _n204;
        } while (e !== t);

        return !0;
      }
    }, {
      key: "oNext",
      value: function oNext() {
        return this._sym._next;
      }
    }, {
      key: "directionY",
      value: function directionY() {
        return this.directionPt().getY() - this._orig.getY();
      }
    }, {
      key: "insert",
      value: function insert(t) {
        if (this.oNext() === this) return this.insertAfter(t), null;
        this.insertionEdge(t).insertAfter(t);
      }
    }, {
      key: "insertAfter",
      value: function insertAfter(t) {
        g.equals(this._orig, t.orig());
        var e = this.oNext();
        this._sym.setNext(t), t.sym().setNext(e);
      }
    }, {
      key: "degree",
      value: function degree() {
        var t = 0,
            e = this;

        do {
          t++, e = e.oNext();
        } while (e !== this);

        return t;
      }
    }, {
      key: "equals",
      value: function equals() {
        if (2 === arguments.length && arguments[1] instanceof m && arguments[0] instanceof m) {
          var _t356 = arguments[0],
              _e269 = arguments[1];
          return this._orig.equals2D(_t356) && this._sym._orig.equals(_e269);
        }
      }
    }, {
      key: "findLowest",
      value: function findLowest() {
        var t = this,
            e = this.oNext();

        do {
          e.compareTo(t) < 0 && (t = e), e = e.oNext();
        } while (e !== this);

        return t;
      }
    }, {
      key: "directionPt",
      value: function directionPt() {
        return this.dest();
      }
    }, {
      key: "sym",
      value: function sym() {
        return this._sym;
      }
    }, {
      key: "prev",
      value: function prev() {
        return this._sym.next()._sym;
      }
    }, {
      key: "compareAngularDirection",
      value: function compareAngularDirection(t) {
        var e = this.directionX(),
            n = this.directionY(),
            s = t.directionX(),
            i = t.directionY();
        if (e === s && n === i) return 0;
        var r = Sn.quadrant(e, n),
            o = Sn.quadrant(s, i);
        if (r > o) return 1;
        if (r < o) return -1;
        var l = this.directionPt(),
            a = t.directionPt();
        return D.index(t._orig, a, l);
      }
    }, {
      key: "prevNode",
      value: function prevNode() {
        var t = this;

        for (; 2 === t.degree();) {
          if (t = t.prev(), t === this) return null;
        }

        return t;
      }
    }, {
      key: "directionX",
      value: function directionX() {
        return this.directionPt().getX() - this._orig.getX();
      }
    }, {
      key: "insertionEdge",
      value: function insertionEdge(t) {
        var e = this;

        do {
          var _n205 = e.oNext();

          if (_n205.compareTo(e) > 0 && t.compareTo(e) >= 0 && t.compareTo(_n205) <= 0) return e;
          if (_n205.compareTo(e) <= 0 && (t.compareTo(_n205) <= 0 || t.compareTo(e) >= 0)) return e;
          e = _n205;
        } while (e !== this);

        return g.shouldNeverReachHere(), null;
      }
    }, {
      key: "compareTo",
      value: function compareTo(t) {
        var e = t;
        return this.compareAngularDirection(e);
      }
    }, {
      key: "toStringNode",
      value: function toStringNode() {
        var t = this.orig(),
            e = (this.dest(), new _t());
        e.append("Node( " + Ht.format(t) + " )\n");
        var n = this;

        do {
          e.append("  -> " + n), e.append("\n"), n = n.oNext();
        } while (n !== this);

        return e.toString();
      }
    }, {
      key: "link",
      value: function link(t) {
        this.setSym(t), t.setSym(this), this.setNext(t), t.setNext(this);
      }
    }, {
      key: "next",
      value: function next() {
        return this._next;
      }
    }, {
      key: "setSym",
      value: function setSym(t) {
        this._sym = t;
      }
    }, {
      key: "orig",
      value: function orig() {
        return this._orig;
      }
    }, {
      key: "toString",
      value: function toString() {
        return "HE(" + this._orig.x + " " + this._orig.y + ", " + this._sym._orig.x + " " + this._sym._orig.y + ")";
      }
    }, {
      key: "toStringNodeEdge",
      value: function toStringNodeEdge() {
        return "  -> (" + Ht.format(this.dest());
      }
    }, {
      key: "setNext",
      value: function setNext(t) {
        this._next = t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._orig = null, this._sym = null, this._next = null;
        var t = arguments[0];
        this._orig = t;
      }
    }, {
      key: "create",
      value: function create(t, e) {
        var n = new wn(t),
            s = new wn(e);
        return n.link(s), n;
      }
    }]);

    return wn;
  }();

  var Cn = /*#__PURE__*/function (_wn) {
    _inherits(Cn, _wn);

    var _super35 = _createSuper(Cn);

    function Cn() {
      var _this25;

      _classCallCheck(this, Cn);

      _this25 = _super35.call(this), Cn.constructor_.apply(_assertThisInitialized(_this25), arguments);
      return _this25;
    }

    _createClass(Cn, [{
      key: "mark",
      value: function mark() {
        this._isMarked = !0;
      }
    }, {
      key: "setMark",
      value: function setMark(t) {
        this._isMarked = t;
      }
    }, {
      key: "isMarked",
      value: function isMarked() {
        return this._isMarked;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._isMarked = !1;
        var t = arguments[0];
        wn.constructor_.call(this, t);
      }
    }, {
      key: "setMarkBoth",
      value: function setMarkBoth(t, e) {
        t.setMark(e), t.sym().setMark(e);
      }
    }, {
      key: "isMarked",
      value: function isMarked(t) {
        return t.isMarked();
      }
    }, {
      key: "setMark",
      value: function setMark(t, e) {
        t.setMark(e);
      }
    }, {
      key: "markBoth",
      value: function markBoth(t) {
        t.mark(), t.sym().mark();
      }
    }, {
      key: "mark",
      value: function mark(t) {
        t.mark();
      }
    }]);

    return Cn;
  }(wn);

  var Ln = /*#__PURE__*/function () {
    function Ln() {
      _classCallCheck(this, Ln);

      Ln.constructor_.apply(this, arguments);
    }

    _createClass(Ln, [{
      key: "insert",
      value: function insert(t, e, n) {
        var s = this.create(t, e);
        null !== n ? n.insert(s) : this._vertexMap.put(t, s);

        var i = this._vertexMap.get(e);

        return null !== i ? i.insert(s.sym()) : this._vertexMap.put(e, s.sym()), s;
      }
    }, {
      key: "create",
      value: function create(t, e) {
        var n = this.createEdge(t),
            s = this.createEdge(e);
        return n.link(s), n;
      }
    }, {
      key: "createEdge",
      value: function createEdge(t) {
        return new wn(t);
      }
    }, {
      key: "addEdge",
      value: function addEdge(t, e) {
        if (!Ln.isValidEdge(t, e)) return null;

        var n = this._vertexMap.get(t);

        var s = null;
        if (null !== n && (s = n.find(e)), null !== s) return s;
        return this.insert(t, e, n);
      }
    }, {
      key: "getVertexEdges",
      value: function getVertexEdges() {
        return this._vertexMap.values();
      }
    }, {
      key: "findEdge",
      value: function findEdge(t, e) {
        var n = this._vertexMap.get(t);

        return null === n ? null : n.find(e);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._vertexMap = new It();
      }
    }, {
      key: "isValidEdge",
      value: function isValidEdge(t, e) {
        return 0 !== e.compareTo(t);
      }
    }]);

    return Ln;
  }();

  var Tn = /*#__PURE__*/function (_Cn) {
    _inherits(Tn, _Cn);

    var _super36 = _createSuper(Tn);

    function Tn() {
      var _this26;

      _classCallCheck(this, Tn);

      _this26 = _super36.call(this), Tn.constructor_.apply(_assertThisInitialized(_this26), arguments);
      return _this26;
    }

    _createClass(Tn, [{
      key: "setStart",
      value: function setStart() {
        this._isStart = !0;
      }
    }, {
      key: "isStart",
      value: function isStart() {
        return this._isStart;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._isStart = !1;
        var t = arguments[0];
        Cn.constructor_.call(this, t);
      }
    }]);

    return Tn;
  }(Cn);

  var Rn = /*#__PURE__*/function (_Ln) {
    _inherits(Rn, _Ln);

    var _super37 = _createSuper(Rn);

    function Rn() {
      _classCallCheck(this, Rn);

      return _super37.call(this);
    }

    _createClass(Rn, [{
      key: "createEdge",
      value: function createEdge(t) {
        return new Tn(t);
      }
    }]);

    return Rn;
  }(Ln);

  var Pn = /*#__PURE__*/function () {
    function Pn() {
      _classCallCheck(this, Pn);

      Pn.constructor_.apply(this, arguments);
    }

    _createClass(Pn, [{
      key: "addLine",
      value: function addLine(t) {
        this._lines.add(this._factory.createLineString(t.toCoordinateArray()));
      }
    }, {
      key: "updateRingStartEdge",
      value: function updateRingStartEdge(t) {
        return t.isStart() || (t = t.sym()).isStart() ? null === this._ringStartEdge ? (this._ringStartEdge = t, null) : void (t.orig().compareTo(this._ringStartEdge.orig()) < 0 && (this._ringStartEdge = t)) : null;
      }
    }, {
      key: "getResult",
      value: function getResult() {
        return null === this._result && this.computeResult(), this._result;
      }
    }, {
      key: "process",
      value: function process(t) {
        var e = t.prevNode();
        null === e && (e = t), this.stackEdges(e), this.buildLines();
      }
    }, {
      key: "buildRing",
      value: function buildRing(t) {
        var e = new C();
        var n = t;

        for (e.add(n.orig().copy(), !1); 2 === n.sym().degree();) {
          var _s122 = n.next();

          if (_s122 === t) break;
          e.add(_s122.orig().copy(), !1), n = _s122;
        }

        e.add(n.dest().copy(), !1), this.addLine(e);
      }
    }, {
      key: "buildLine",
      value: function buildLine(t) {
        var e = new C();
        var n = t;

        for (this._ringStartEdge = null, Cn.markBoth(n), e.add(n.orig().copy(), !1); 2 === n.sym().degree();) {
          this.updateRingStartEdge(n);

          var _s123 = n.next();

          if (_s123 === t) return this.buildRing(this._ringStartEdge), null;
          e.add(_s123.orig().copy(), !1), n = _s123, Cn.markBoth(n);
        }

        e.add(n.dest().clone(), !1), this.stackEdges(n.sym()), this.addLine(e);
      }
    }, {
      key: "stackEdges",
      value: function stackEdges(t) {
        var e = t;

        do {
          Cn.isMarked(e) || this._nodeEdgeStack.add(e), e = e.oNext();
        } while (e !== t);
      }
    }, {
      key: "computeResult",
      value: function computeResult() {
        for (var _t357 = this._graph.getVertexEdges().iterator(); _t357.hasNext();) {
          var _e270 = _t357.next();

          Cn.isMarked(_e270) || this.process(_e270);
        }

        this._result = this._factory.buildGeometry(this._lines);
      }
    }, {
      key: "buildLines",
      value: function buildLines() {
        for (; !this._nodeEdgeStack.empty();) {
          var _t358 = this._nodeEdgeStack.pop();

          Cn.isMarked(_t358) || this.buildLine(_t358);
        }
      }
    }, {
      key: "add",
      value: function add() {
        if (arguments[0] instanceof V) {
          arguments[0].apply(new ( /*#__PURE__*/function () {
            function _class7() {
              _classCallCheck(this, _class7);
            }

            _createClass(_class7, [{
              key: "filter",
              value: function filter(t) {
                t instanceof j && this.add(t);
              }
            }, {
              key: "interfaces_",
              get: function get() {
                return [Y];
              }
            }]);

            return _class7;
          }())());
        } else if (y(arguments[0], x)) {
          for (var _t359 = arguments[0].iterator(); _t359.hasNext();) {
            var _e271 = _t359.next();

            this.add(_e271);
          }
        } else if (arguments[0] instanceof j) {
          var _t360 = arguments[0];
          null === this._factory && (this._factory = _t360.getFactory());

          var _e272 = _t360.getCoordinateSequence();

          var _n206 = !1;

          for (var _t361 = 1; _t361 < _e272.size(); _t361++) {
            var _s124 = this._graph.addEdge(_e272.getCoordinate(_t361 - 1), _e272.getCoordinate(_t361));

            null !== _s124 && (_n206 || (_s124.setStart(), _n206 = !0));
          }
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._result = null, this._factory = null, this._graph = null, this._lines = new S(), this._nodeEdgeStack = new tn(), this._ringStartEdge = null, this._graph = new Rn();
      }
    }, {
      key: "dissolve",
      value: function dissolve(t) {
        var e = new Pn();
        return e.add(t), e.getResult();
      }
    }]);

    return Pn;
  }();

  var On = Object.freeze({
    __proto__: null,
    LineDissolver: Pn
  });

  var vn = /*#__PURE__*/function () {
    function vn() {
      _classCallCheck(this, vn);
    }

    _createClass(vn, null, [{
      key: "opposite",
      value: function opposite(t) {
        return t === vn.LEFT ? vn.RIGHT : t === vn.RIGHT ? vn.LEFT : t;
      }
    }]);

    return vn;
  }();

  vn.ON = 0, vn.LEFT = 1, vn.RIGHT = 2;

  var Mn = /*#__PURE__*/function () {
    function Mn() {
      _classCallCheck(this, Mn);

      Mn.constructor_.apply(this, arguments);
    }

    _createClass(Mn, [{
      key: "computeIntersections",
      value: function computeIntersections(t, e) {
        this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this.mce = null, this.chainIndex = null;
        var t = arguments[0],
            e = arguments[1];
        this.mce = t, this.chainIndex = e;
      }
    }]);

    return Mn;
  }();

  var bn = /*#__PURE__*/function () {
    function bn() {
      _classCallCheck(this, bn);

      bn.constructor_.apply(this, arguments);
    }

    _createClass(bn, [{
      key: "isDelete",
      value: function isDelete() {
        return this._eventType === bn.DELETE;
      }
    }, {
      key: "setDeleteEventIndex",
      value: function setDeleteEventIndex(t) {
        this._deleteEventIndex = t;
      }
    }, {
      key: "getObject",
      value: function getObject() {
        return this._obj;
      }
    }, {
      key: "compareTo",
      value: function compareTo(t) {
        var e = t;
        return this._xValue < e._xValue ? -1 : this._xValue > e._xValue ? 1 : this._eventType < e._eventType ? -1 : this._eventType > e._eventType ? 1 : 0;
      }
    }, {
      key: "getInsertEvent",
      value: function getInsertEvent() {
        return this._insertEvent;
      }
    }, {
      key: "isInsert",
      value: function isInsert() {
        return this._eventType === bn.INSERT;
      }
    }, {
      key: "isSameLabel",
      value: function isSameLabel(t) {
        return null !== this._label && this._label === t._label;
      }
    }, {
      key: "getDeleteEventIndex",
      value: function getDeleteEventIndex() {
        return this._deleteEventIndex;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [o];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, 2 === arguments.length) {
          var _t362 = arguments[0],
              _e273 = arguments[1];
          this._eventType = bn.DELETE, this._xValue = _t362, this._insertEvent = _e273;
        } else if (3 === arguments.length) {
          var _t363 = arguments[0],
              _e274 = arguments[1],
              _n207 = arguments[2];
          this._eventType = bn.INSERT, this._label = _t363, this._xValue = _e274, this._obj = _n207;
        }
      }
    }]);

    return bn;
  }();

  bn.INSERT = 1, bn.DELETE = 2;

  var Dn = /*#__PURE__*/function () {
    function Dn() {
      _classCallCheck(this, Dn);

      Dn.constructor_.apply(this, arguments);
    }

    _createClass(Dn, [{
      key: "isTrivialIntersection",
      value: function isTrivialIntersection(t, e, n, s) {
        if (t === n && 1 === this._li.getIntersectionNum()) {
          if (Dn.isAdjacentSegments(e, s)) return !0;

          if (t.isClosed()) {
            var _n208 = t.getNumPoints() - 1;

            if (0 === e && s === _n208 || 0 === s && e === _n208) return !0;
          }
        }

        return !1;
      }
    }, {
      key: "getProperIntersectionPoint",
      value: function getProperIntersectionPoint() {
        return this._properIntersectionPoint;
      }
    }, {
      key: "setIsDoneIfProperInt",
      value: function setIsDoneIfProperInt(t) {
        this._isDoneWhenProperInt = t;
      }
    }, {
      key: "hasProperInteriorIntersection",
      value: function hasProperInteriorIntersection() {
        return this._hasProperInterior;
      }
    }, {
      key: "isBoundaryPointInternal",
      value: function isBoundaryPointInternal(t, e) {
        for (var _n209 = e.iterator(); _n209.hasNext();) {
          var _e275 = _n209.next().getCoordinate();

          if (t.isIntersection(_e275)) return !0;
        }

        return !1;
      }
    }, {
      key: "hasProperIntersection",
      value: function hasProperIntersection() {
        return this._hasProper;
      }
    }, {
      key: "hasIntersection",
      value: function hasIntersection() {
        return this._hasIntersection;
      }
    }, {
      key: "isDone",
      value: function isDone() {
        return this._isDone;
      }
    }, {
      key: "isBoundaryPoint",
      value: function isBoundaryPoint(t, e) {
        return null !== e && (!!this.isBoundaryPointInternal(t, e[0]) || !!this.isBoundaryPointInternal(t, e[1]));
      }
    }, {
      key: "setBoundaryNodes",
      value: function setBoundaryNodes(t, e) {
        this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = t, this._bdyNodes[1] = e;
      }
    }, {
      key: "addIntersections",
      value: function addIntersections(t, e, n, s) {
        if (t === n && e === s) return null;
        this.numTests++;
        var i = t.getCoordinates()[e],
            r = t.getCoordinates()[e + 1],
            o = n.getCoordinates()[s],
            l = n.getCoordinates()[s + 1];
        this._li.computeIntersection(i, r, o, l), this._li.hasIntersection() && (this._recordIsolated && (t.setIsolated(!1), n.setIsolated(!1)), this._numIntersections++, this.isTrivialIntersection(t, e, n, s) || (this._hasIntersection = !0, !this._includeProper && this._li.isProper() || (t.addIntersections(this._li, e, 0), n.addIntersections(this._li, s, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = !0, this._isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = !0))));
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = !1, this._isDoneWhenProperInt = !1;
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2];
        this._li = t, this._includeProper = e, this._recordIsolated = n;
      }
    }, {
      key: "isAdjacentSegments",
      value: function isAdjacentSegments(t, e) {
        return 1 === Math.abs(t - e);
      }
    }]);

    return Dn;
  }();

  var An = /*#__PURE__*/function (_ref) {
    _inherits(An, _ref);

    var _super38 = _createSuper(An);

    function An() {
      var _this27;

      _classCallCheck(this, An);

      _this27 = _super38.call(this), An.constructor_.apply(_assertThisInitialized(_this27), arguments);
      return _this27;
    }

    _createClass(An, [{
      key: "prepareEvents",
      value: function prepareEvents() {
        ye.sort(this.events);

        for (var _t364 = 0; _t364 < this.events.size(); _t364++) {
          var _e276 = this.events.get(_t364);

          _e276.isDelete() && _e276.getInsertEvent().setDeleteEventIndex(_t364);
        }
      }
    }, {
      key: "computeIntersections",
      value: function computeIntersections() {
        if (1 === arguments.length) {
          var _t365 = arguments[0];
          this.nOverlaps = 0, this.prepareEvents();

          for (var _e277 = 0; _e277 < this.events.size(); _e277++) {
            var _n210 = this.events.get(_e277);

            if (_n210.isInsert() && this.processOverlaps(_e277, _n210.getDeleteEventIndex(), _n210, _t365), _t365.isDone()) break;
          }
        } else if (3 === arguments.length) if (arguments[2] instanceof Dn && y(arguments[0], I) && y(arguments[1], I)) {
          var _t366 = arguments[0],
              _e278 = arguments[1],
              _n211 = arguments[2];
          this.addEdges(_t366, _t366), this.addEdges(_e278, _e278), this.computeIntersections(_n211);
        } else if ("boolean" == typeof arguments[2] && y(arguments[0], I) && arguments[1] instanceof Dn) {
          var _t367 = arguments[0],
              _e279 = arguments[1];
          arguments[2] ? this.addEdges(_t367, null) : this.addEdges(_t367), this.computeIntersections(_e279);
        }
      }
    }, {
      key: "addEdge",
      value: function addEdge(t, e) {
        var n = t.getMonotoneChainEdge(),
            s = n.getStartIndexes();

        for (var _t368 = 0; _t368 < s.length - 1; _t368++) {
          var _s125 = new Mn(n, _t368),
              _i64 = new bn(e, n.getMinX(_t368), _s125);

          this.events.add(_i64), this.events.add(new bn(n.getMaxX(_t368), _i64));
        }
      }
    }, {
      key: "processOverlaps",
      value: function processOverlaps(t, e, n, s) {
        var i = n.getObject();

        for (var _r41 = t; _r41 < e; _r41++) {
          var _t369 = this.events.get(_r41);

          if (_t369.isInsert()) {
            var _e280 = _t369.getObject();

            n.isSameLabel(_t369) || (i.computeIntersections(_e280, s), this.nOverlaps++);
          }
        }
      }
    }, {
      key: "addEdges",
      value: function addEdges() {
        if (1 === arguments.length) {
          for (var _t370 = arguments[0].iterator(); _t370.hasNext();) {
            var _e281 = _t370.next();

            this.addEdge(_e281, _e281);
          }
        } else if (2 === arguments.length) {
          var _t371 = arguments[1];

          for (var _e282 = arguments[0].iterator(); _e282.hasNext();) {
            var _n212 = _e282.next();

            this.addEdge(_n212, _t371);
          }
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this.events = new S(), this.nOverlaps = null;
      }
    }]);

    return An;
  }( /*#__PURE__*/function () {
    function _class8() {
      _classCallCheck(this, _class8);
    }

    return _class8;
  }());

  var Fn = /*#__PURE__*/function () {
    function Fn() {
      _classCallCheck(this, Fn);

      Fn.constructor_.apply(this, arguments);
    }

    _createClass(Fn, [{
      key: "setAllLocations",
      value: function setAllLocations(t) {
        for (var _e283 = 0; _e283 < this.location.length; _e283++) {
          this.location[_e283] = t;
        }
      }
    }, {
      key: "isNull",
      value: function isNull() {
        for (var _t372 = 0; _t372 < this.location.length; _t372++) {
          if (this.location[_t372] !== Kt.NONE) return !1;
        }

        return !0;
      }
    }, {
      key: "setAllLocationsIfNull",
      value: function setAllLocationsIfNull(t) {
        for (var _e284 = 0; _e284 < this.location.length; _e284++) {
          this.location[_e284] === Kt.NONE && (this.location[_e284] = t);
        }
      }
    }, {
      key: "isLine",
      value: function isLine() {
        return 1 === this.location.length;
      }
    }, {
      key: "merge",
      value: function merge(t) {
        if (t.location.length > this.location.length) {
          var _t373 = new Array(3).fill(null);

          _t373[vn.ON] = this.location[vn.ON], _t373[vn.LEFT] = Kt.NONE, _t373[vn.RIGHT] = Kt.NONE, this.location = _t373;
        }

        for (var _e285 = 0; _e285 < this.location.length; _e285++) {
          this.location[_e285] === Kt.NONE && _e285 < t.location.length && (this.location[_e285] = t.location[_e285]);
        }
      }
    }, {
      key: "getLocations",
      value: function getLocations() {
        return this.location;
      }
    }, {
      key: "flip",
      value: function flip() {
        if (this.location.length <= 1) return null;
        var t = this.location[vn.LEFT];
        this.location[vn.LEFT] = this.location[vn.RIGHT], this.location[vn.RIGHT] = t;
      }
    }, {
      key: "toString",
      value: function toString() {
        var t = new R();
        return this.location.length > 1 && t.append(Kt.toLocationSymbol(this.location[vn.LEFT])), t.append(Kt.toLocationSymbol(this.location[vn.ON])), this.location.length > 1 && t.append(Kt.toLocationSymbol(this.location[vn.RIGHT])), t.toString();
      }
    }, {
      key: "setLocations",
      value: function setLocations(t, e, n) {
        this.location[vn.ON] = t, this.location[vn.LEFT] = e, this.location[vn.RIGHT] = n;
      }
    }, {
      key: "get",
      value: function get(t) {
        return t < this.location.length ? this.location[t] : Kt.NONE;
      }
    }, {
      key: "isArea",
      value: function isArea() {
        return this.location.length > 1;
      }
    }, {
      key: "isAnyNull",
      value: function isAnyNull() {
        for (var _t374 = 0; _t374 < this.location.length; _t374++) {
          if (this.location[_t374] === Kt.NONE) return !0;
        }

        return !1;
      }
    }, {
      key: "setLocation",
      value: function setLocation() {
        if (1 === arguments.length) {
          var _t375 = arguments[0];
          this.setLocation(vn.ON, _t375);
        } else if (2 === arguments.length) {
          var _t376 = arguments[0],
              _e286 = arguments[1];
          this.location[_t376] = _e286;
        }
      }
    }, {
      key: "init",
      value: function init(t) {
        this.location = new Array(t).fill(null), this.setAllLocations(Kt.NONE);
      }
    }, {
      key: "isEqualOnSide",
      value: function isEqualOnSide(t, e) {
        return this.location[e] === t.location[e];
      }
    }, {
      key: "allPositionsEqual",
      value: function allPositionsEqual(t) {
        for (var _e287 = 0; _e287 < this.location.length; _e287++) {
          if (this.location[_e287] !== t) return !1;
        }

        return !0;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this.location = null, 1 === arguments.length) {
          if (arguments[0] instanceof Array) {
            var _t377 = arguments[0];
            this.init(_t377.length);
          } else if (Number.isInteger(arguments[0])) {
            var _t378 = arguments[0];
            this.init(1), this.location[vn.ON] = _t378;
          } else if (arguments[0] instanceof Fn) {
            var _t379 = arguments[0];
            if (this.init(_t379.location.length), null !== _t379) for (var _e288 = 0; _e288 < this.location.length; _e288++) {
              this.location[_e288] = _t379.location[_e288];
            }
          }
        } else if (3 === arguments.length) {
          var _t380 = arguments[0],
              _e289 = arguments[1],
              _n213 = arguments[2];
          this.init(3), this.location[vn.ON] = _t380, this.location[vn.LEFT] = _e289, this.location[vn.RIGHT] = _n213;
        }
      }
    }]);

    return Fn;
  }();

  var Gn = /*#__PURE__*/function () {
    function Gn() {
      _classCallCheck(this, Gn);

      Gn.constructor_.apply(this, arguments);
    }

    _createClass(Gn, [{
      key: "getGeometryCount",
      value: function getGeometryCount() {
        var t = 0;
        return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t;
      }
    }, {
      key: "setAllLocations",
      value: function setAllLocations(t, e) {
        this.elt[t].setAllLocations(e);
      }
    }, {
      key: "isNull",
      value: function isNull(t) {
        return this.elt[t].isNull();
      }
    }, {
      key: "setAllLocationsIfNull",
      value: function setAllLocationsIfNull() {
        if (1 === arguments.length) {
          var _t381 = arguments[0];
          this.setAllLocationsIfNull(0, _t381), this.setAllLocationsIfNull(1, _t381);
        } else if (2 === arguments.length) {
          var _t382 = arguments[0],
              _e290 = arguments[1];

          this.elt[_t382].setAllLocationsIfNull(_e290);
        }
      }
    }, {
      key: "isLine",
      value: function isLine(t) {
        return this.elt[t].isLine();
      }
    }, {
      key: "merge",
      value: function merge(t) {
        for (var _e291 = 0; _e291 < 2; _e291++) {
          null === this.elt[_e291] && null !== t.elt[_e291] ? this.elt[_e291] = new Fn(t.elt[_e291]) : this.elt[_e291].merge(t.elt[_e291]);
        }
      }
    }, {
      key: "flip",
      value: function flip() {
        this.elt[0].flip(), this.elt[1].flip();
      }
    }, {
      key: "getLocation",
      value: function getLocation() {
        if (1 === arguments.length) {
          var _t383 = arguments[0];
          return this.elt[_t383].get(vn.ON);
        }

        if (2 === arguments.length) {
          var _t384 = arguments[0],
              _e292 = arguments[1];
          return this.elt[_t384].get(_e292);
        }
      }
    }, {
      key: "toString",
      value: function toString() {
        var t = new R();
        return null !== this.elt[0] && (t.append("A:"), t.append(this.elt[0].toString())), null !== this.elt[1] && (t.append(" B:"), t.append(this.elt[1].toString())), t.toString();
      }
    }, {
      key: "isArea",
      value: function isArea() {
        if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea();

        if (1 === arguments.length) {
          var _t385 = arguments[0];
          return this.elt[_t385].isArea();
        }
      }
    }, {
      key: "isAnyNull",
      value: function isAnyNull(t) {
        return this.elt[t].isAnyNull();
      }
    }, {
      key: "setLocation",
      value: function setLocation() {
        if (2 === arguments.length) {
          var _t386 = arguments[0],
              _e293 = arguments[1];

          this.elt[_t386].setLocation(vn.ON, _e293);
        } else if (3 === arguments.length) {
          var _t387 = arguments[0],
              _e294 = arguments[1],
              _n214 = arguments[2];

          this.elt[_t387].setLocation(_e294, _n214);
        }
      }
    }, {
      key: "isEqualOnSide",
      value: function isEqualOnSide(t, e) {
        return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e);
      }
    }, {
      key: "allPositionsEqual",
      value: function allPositionsEqual(t, e) {
        return this.elt[t].allPositionsEqual(e);
      }
    }, {
      key: "toLine",
      value: function toLine(t) {
        this.elt[t].isArea() && (this.elt[t] = new Fn(this.elt[t].location[0]));
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
          if (Number.isInteger(arguments[0])) {
            var _t388 = arguments[0];
            this.elt[0] = new Fn(_t388), this.elt[1] = new Fn(_t388);
          } else if (arguments[0] instanceof Gn) {
            var _t389 = arguments[0];
            this.elt[0] = new Fn(_t389.elt[0]), this.elt[1] = new Fn(_t389.elt[1]);
          }
        } else if (2 === arguments.length) {
          var _t390 = arguments[0],
              _e295 = arguments[1];
          this.elt[0] = new Fn(Kt.NONE), this.elt[1] = new Fn(Kt.NONE), this.elt[_t390].setLocation(_e295);
        } else if (3 === arguments.length) {
          var _t391 = arguments[0],
              _e296 = arguments[1],
              _n215 = arguments[2];
          this.elt[0] = new Fn(_t391, _e296, _n215), this.elt[1] = new Fn(_t391, _e296, _n215);
        } else if (4 === arguments.length) {
          var _t392 = arguments[0],
              _e297 = arguments[1],
              _n216 = arguments[2],
              _s126 = arguments[3];
          this.elt[0] = new Fn(Kt.NONE, Kt.NONE, Kt.NONE), this.elt[1] = new Fn(Kt.NONE, Kt.NONE, Kt.NONE), this.elt[_t392].setLocations(_e297, _n216, _s126);
        }
      }
    }, {
      key: "toLineLabel",
      value: function toLineLabel(t) {
        var e = new Gn(Kt.NONE);

        for (var _n217 = 0; _n217 < 2; _n217++) {
          e.setLocation(_n217, t.getLocation(_n217));
        }

        return e;
      }
    }]);

    return Gn;
  }();

  var qn = /*#__PURE__*/function () {
    function qn() {
      _classCallCheck(this, qn);

      qn.constructor_.apply(this, arguments);
    }

    _createClass(qn, [{
      key: "getSegmentIndex",
      value: function getSegmentIndex() {
        return this.segmentIndex;
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        return this.coord;
      }
    }, {
      key: "print",
      value: function print(t) {
        t.print(this.coord), t.print(" seg # = " + this.segmentIndex), t.println(" dist = " + this.dist);
      }
    }, {
      key: "compareTo",
      value: function compareTo(t) {
        var e = t;
        return this.compare(e.segmentIndex, e.dist);
      }
    }, {
      key: "isEndPoint",
      value: function isEndPoint(t) {
        return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t;
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
      }
    }, {
      key: "getDistance",
      value: function getDistance() {
        return this.dist;
      }
    }, {
      key: "compare",
      value: function compare(t, e) {
        return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [o];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this.coord = null, this.segmentIndex = null, this.dist = null;
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2];
        this.coord = new m(t), this.segmentIndex = e, this.dist = n;
      }
    }]);

    return qn;
  }();

  var Bn = /*#__PURE__*/function (_yt2) {
    _inherits(Bn, _yt2);

    var _super39 = _createSuper(Bn);

    function Bn() {
      _classCallCheck(this, Bn);

      return _super39.apply(this, arguments);
    }

    return Bn;
  }(yt);

  function Yn(t) {
    return null == t ? 0 : t.color;
  }

  function Vn(t) {
    return null == t ? null : t.parent;
  }

  function zn(t, e) {
    null !== t && (t.color = e);
  }

  function Xn(t) {
    return null == t ? null : t.left;
  }

  function kn(t) {
    return null == t ? null : t.right;
  }

  var Un = /*#__PURE__*/function (_Bn) {
    _inherits(Un, _Bn);

    var _super40 = _createSuper(Un);

    function Un() {
      var _this28;

      _classCallCheck(this, Un);

      _this28 = _super40.call(this), _this28.root_ = null, _this28.size_ = 0;
      return _this28;
    }

    _createClass(Un, [{
      key: "get",
      value: function get(t) {
        var e = this.root_;

        for (; null !== e;) {
          var _n218 = t.compareTo(e.key);

          if (_n218 < 0) e = e.left;else {
            if (!(_n218 > 0)) return e.value;
            e = e.right;
          }
        }

        return null;
      }
    }, {
      key: "put",
      value: function put(t, e) {
        if (null === this.root_) return this.root_ = {
          key: t,
          value: e,
          left: null,
          right: null,
          parent: null,
          color: 0,
          getValue: function getValue() {
            return this.value;
          },
          getKey: function getKey() {
            return this.key;
          }
        }, this.size_ = 1, null;
        var n,
            s,
            i = this.root_;

        do {
          if (n = i, s = t.compareTo(i.key), s < 0) i = i.left;else {
            if (!(s > 0)) {
              var _t393 = i.value;
              return i.value = e, _t393;
            }

            i = i.right;
          }
        } while (null !== i);

        var r = {
          key: t,
          left: null,
          right: null,
          value: e,
          parent: n,
          color: 0,
          getValue: function getValue() {
            return this.value;
          },
          getKey: function getKey() {
            return this.key;
          }
        };
        return s < 0 ? n.left = r : n.right = r, this.fixAfterInsertion(r), this.size_++, null;
      }
    }, {
      key: "fixAfterInsertion",
      value: function fixAfterInsertion(t) {
        var e;

        for (t.color = 1; null != t && t !== this.root_ && 1 === t.parent.color;) {
          Vn(t) === Xn(Vn(Vn(t))) ? (e = kn(Vn(Vn(t))), 1 === Yn(e) ? (zn(Vn(t), 0), zn(e, 0), zn(Vn(Vn(t)), 1), t = Vn(Vn(t))) : (t === kn(Vn(t)) && (t = Vn(t), this.rotateLeft(t)), zn(Vn(t), 0), zn(Vn(Vn(t)), 1), this.rotateRight(Vn(Vn(t))))) : (e = Xn(Vn(Vn(t))), 1 === Yn(e) ? (zn(Vn(t), 0), zn(e, 0), zn(Vn(Vn(t)), 1), t = Vn(Vn(t))) : (t === Xn(Vn(t)) && (t = Vn(t), this.rotateRight(t)), zn(Vn(t), 0), zn(Vn(Vn(t)), 1), this.rotateLeft(Vn(Vn(t)))));
        }

        this.root_.color = 0;
      }
    }, {
      key: "values",
      value: function values() {
        var t = new S();
        var e = this.getFirstEntry();
        if (null !== e) for (t.add(e.value); null !== (e = Un.successor(e));) {
          t.add(e.value);
        }
        return t;
      }
    }, {
      key: "entrySet",
      value: function entrySet() {
        var t = new xt();
        var e = this.getFirstEntry();
        if (null !== e) for (t.add(e); null !== (e = Un.successor(e));) {
          t.add(e);
        }
        return t;
      }
    }, {
      key: "rotateLeft",
      value: function rotateLeft(t) {
        if (null != t) {
          var _e298 = t.right;
          t.right = _e298.left, null != _e298.left && (_e298.left.parent = t), _e298.parent = t.parent, null == t.parent ? this.root_ = _e298 : t.parent.left === t ? t.parent.left = _e298 : t.parent.right = _e298, _e298.left = t, t.parent = _e298;
        }
      }
    }, {
      key: "rotateRight",
      value: function rotateRight(t) {
        if (null != t) {
          var _e299 = t.left;
          t.left = _e299.right, null != _e299.right && (_e299.right.parent = t), _e299.parent = t.parent, null == t.parent ? this.root_ = _e299 : t.parent.right === t ? t.parent.right = _e299 : t.parent.left = _e299, _e299.right = t, t.parent = _e299;
        }
      }
    }, {
      key: "getFirstEntry",
      value: function getFirstEntry() {
        var t = this.root_;
        if (null != t) for (; null != t.left;) {
          t = t.left;
        }
        return t;
      }
    }, {
      key: "size",
      value: function size() {
        return this.size_;
      }
    }, {
      key: "containsKey",
      value: function containsKey(t) {
        var e = this.root_;

        for (; null !== e;) {
          var _n219 = t.compareTo(e.key);

          if (_n219 < 0) e = e.left;else {
            if (!(_n219 > 0)) return !0;
            e = e.right;
          }
        }

        return !1;
      }
    }], [{
      key: "successor",
      value: function successor(t) {
        var e;
        if (null === t) return null;

        if (null !== t.right) {
          for (e = t.right; null !== e.left;) {
            e = e.left;
          }

          return e;
        }

        {
          e = t.parent;
          var _n220 = t;

          for (; null !== e && _n220 === e.right;) {
            _n220 = e, e = e.parent;
          }

          return e;
        }
      }
    }]);

    return Un;
  }(Bn);

  var Hn = /*#__PURE__*/function () {
    function Hn() {
      _classCallCheck(this, Hn);

      Hn.constructor_.apply(this, arguments);
    }

    _createClass(Hn, [{
      key: "print",
      value: function print(t) {
        t.println("Intersections:");

        for (var _e300 = this.iterator(); _e300.hasNext();) {
          _e300.next().print(t);
        }
      }
    }, {
      key: "iterator",
      value: function iterator() {
        return this._nodeMap.values().iterator();
      }
    }, {
      key: "addSplitEdges",
      value: function addSplitEdges(t) {
        this.addEndpoints();
        var e = this.iterator();
        var n = e.next();

        for (; e.hasNext();) {
          var _s127 = e.next(),
              _i65 = this.createSplitEdge(n, _s127);

          t.add(_i65), n = _s127;
        }
      }
    }, {
      key: "addEndpoints",
      value: function addEndpoints() {
        var t = this.edge.pts.length - 1;
        this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0);
      }
    }, {
      key: "createSplitEdge",
      value: function createSplitEdge(t, e) {
        var n = e.segmentIndex - t.segmentIndex + 2;
        var s = this.edge.pts[e.segmentIndex],
            i = e.dist > 0 || !e.coord.equals2D(s);
        i || n--;
        var r = new Array(n).fill(null);
        var o = 0;
        r[o++] = new m(t.coord);

        for (var _n221 = t.segmentIndex + 1; _n221 <= e.segmentIndex; _n221++) {
          r[o++] = this.edge.pts[_n221];
        }

        return i && (r[o] = e.coord), new Jn(r, new Gn(this.edge._label));
      }
    }, {
      key: "add",
      value: function add(t, e, n) {
        var s = new qn(t, e, n),
            i = this._nodeMap.get(s);

        return null !== i ? i : (this._nodeMap.put(s, s), s);
      }
    }, {
      key: "isIntersection",
      value: function isIntersection(t) {
        for (var _e301 = this.iterator(); _e301.hasNext();) {
          if (_e301.next().coord.equals(t)) return !0;
        }

        return !1;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._nodeMap = new Un(), this.edge = null;
        var t = arguments[0];
        this.edge = t;
      }
    }]);

    return Hn;
  }();

  var Wn = /*#__PURE__*/function () {
    function Wn() {
      _classCallCheck(this, Wn);

      Wn.constructor_.apply(this, arguments);
    }

    _createClass(Wn, [{
      key: "size",
      value: function size() {
        return this._size;
      }
    }, {
      key: "addAll",
      value: function addAll(t) {
        return null === t || 0 === t.length ? null : (this.ensureCapacity(this._size + t.length), F.arraycopy(t, 0, this._data, this._size, t.length), void (this._size += t.length));
      }
    }, {
      key: "ensureCapacity",
      value: function ensureCapacity(t) {
        if (t <= this._data.length) return null;
        var e = Math.max(t, 2 * this._data.length);
        this._data = $.copyOf(this._data, e);
      }
    }, {
      key: "toArray",
      value: function toArray() {
        var t = new Array(this._size).fill(null);
        return F.arraycopy(this._data, 0, t, 0, this._size), t;
      }
    }, {
      key: "add",
      value: function add(t) {
        this.ensureCapacity(this._size + 1), this._data[this._size] = t, ++this._size;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._data = null, this._size = 0, 0 === arguments.length) Wn.constructor_.call(this, 10);else if (1 === arguments.length) {
          var _t394 = arguments[0];
          this._data = new Array(_t394).fill(null);
        }
      }
    }]);

    return Wn;
  }();

  var Zn = /*#__PURE__*/function () {
    function Zn() {
      _classCallCheck(this, Zn);
    }

    _createClass(Zn, [{
      key: "getChainStartIndices",
      value: function getChainStartIndices(t) {
        var e = 0;
        var n = new Wn(Math.trunc(t.length / 2));
        n.add(e);

        do {
          var _s128 = this.findChainEnd(t, e);

          n.add(_s128), e = _s128;
        } while (e < t.length - 1);

        return n.toArray();
      }
    }, {
      key: "findChainEnd",
      value: function findChainEnd(t, e) {
        var n = Sn.quadrant(t[e], t[e + 1]);
        var s = e + 1;

        for (; s < t.length;) {
          if (Sn.quadrant(t[s - 1], t[s]) !== n) break;
          s++;
        }

        return s - 1;
      }
    }, {
      key: "OLDgetChainStartIndices",
      value: function OLDgetChainStartIndices(t) {
        var e = 0;
        var n = new S();
        n.add(e);

        do {
          var _s129 = this.findChainEnd(t, e);

          n.add(_s129), e = _s129;
        } while (e < t.length - 1);

        return Zn.toIntArray(n);
      }
    }], [{
      key: "toIntArray",
      value: function toIntArray(t) {
        var e = new Array(t.size()).fill(null);

        for (var _n222 = 0; _n222 < e.length; _n222++) {
          e[_n222] = t.get(_n222).intValue();
        }

        return e;
      }
    }]);

    return Zn;
  }();

  var jn = /*#__PURE__*/function () {
    function jn() {
      _classCallCheck(this, jn);

      jn.constructor_.apply(this, arguments);
    }

    _createClass(jn, [{
      key: "getCoordinates",
      value: function getCoordinates() {
        return this.pts;
      }
    }, {
      key: "getMaxX",
      value: function getMaxX(t) {
        var e = this.pts[this.startIndex[t]].x,
            n = this.pts[this.startIndex[t + 1]].x;
        return e > n ? e : n;
      }
    }, {
      key: "getMinX",
      value: function getMinX(t) {
        var e = this.pts[this.startIndex[t]].x,
            n = this.pts[this.startIndex[t + 1]].x;
        return e < n ? e : n;
      }
    }, {
      key: "computeIntersectsForChain",
      value: function computeIntersectsForChain() {
        if (4 === arguments.length) {
          var _t395 = arguments[0],
              _e302 = arguments[1],
              _n223 = arguments[2],
              _s130 = arguments[3];
          this.computeIntersectsForChain(this.startIndex[_t395], this.startIndex[_t395 + 1], _e302, _e302.startIndex[_n223], _e302.startIndex[_n223 + 1], _s130);
        } else if (6 === arguments.length) {
          var _t396 = arguments[0],
              _e303 = arguments[1],
              _n224 = arguments[2],
              _s131 = arguments[3],
              _i66 = arguments[4],
              _r42 = arguments[5];
          if (_e303 - _t396 == 1 && _i66 - _s131 == 1) return _r42.addIntersections(this.e, _t396, _n224.e, _s131), null;
          if (!this.overlaps(_t396, _e303, _n224, _s131, _i66)) return null;

          var _o27 = Math.trunc((_t396 + _e303) / 2),
              _l25 = Math.trunc((_s131 + _i66) / 2);

          _t396 < _o27 && (_s131 < _l25 && this.computeIntersectsForChain(_t396, _o27, _n224, _s131, _l25, _r42), _l25 < _i66 && this.computeIntersectsForChain(_t396, _o27, _n224, _l25, _i66, _r42)), _o27 < _e303 && (_s131 < _l25 && this.computeIntersectsForChain(_o27, _e303, _n224, _s131, _l25, _r42), _l25 < _i66 && this.computeIntersectsForChain(_o27, _e303, _n224, _l25, _i66, _r42));
        }
      }
    }, {
      key: "overlaps",
      value: function overlaps(t, e, n, s, i) {
        return T.intersects(this.pts[t], this.pts[e], n.pts[s], n.pts[i]);
      }
    }, {
      key: "getStartIndexes",
      value: function getStartIndexes() {
        return this.startIndex;
      }
    }, {
      key: "computeIntersects",
      value: function computeIntersects(t, e) {
        for (var _n225 = 0; _n225 < this.startIndex.length - 1; _n225++) {
          for (var _s132 = 0; _s132 < t.startIndex.length - 1; _s132++) {
            this.computeIntersectsForChain(_n225, t, _s132, e);
          }
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this.e = null, this.pts = null, this.startIndex = null;
        var t = arguments[0];
        this.e = t, this.pts = t.getCoordinates();
        var e = new Zn();
        this.startIndex = e.getChainStartIndices(this.pts);
      }
    }]);

    return jn;
  }();

  var Kn = /*#__PURE__*/function () {
    function Kn() {
      _classCallCheck(this, Kn);

      Kn.constructor_.apply(this, arguments);
    }

    _createClass(Kn, [{
      key: "getDepth",
      value: function getDepth(t, e) {
        return this._depth[t][e];
      }
    }, {
      key: "setDepth",
      value: function setDepth(t, e, n) {
        this._depth[t][e] = n;
      }
    }, {
      key: "isNull",
      value: function isNull() {
        if (0 === arguments.length) {
          for (var _t397 = 0; _t397 < 2; _t397++) {
            for (var _e304 = 0; _e304 < 3; _e304++) {
              if (this._depth[_t397][_e304] !== Kn.NULL_VALUE) return !1;
            }
          }

          return !0;
        }

        if (1 === arguments.length) {
          var _t398 = arguments[0];
          return this._depth[_t398][1] === Kn.NULL_VALUE;
        }

        if (2 === arguments.length) {
          var _t399 = arguments[0],
              _e305 = arguments[1];
          return this._depth[_t399][_e305] === Kn.NULL_VALUE;
        }
      }
    }, {
      key: "normalize",
      value: function normalize() {
        for (var _t400 = 0; _t400 < 2; _t400++) {
          if (!this.isNull(_t400)) {
            var _e306 = this._depth[_t400][1];
            this._depth[_t400][2] < _e306 && (_e306 = this._depth[_t400][2]), _e306 < 0 && (_e306 = 0);

            for (var _n226 = 1; _n226 < 3; _n226++) {
              var _s133 = 0;
              this._depth[_t400][_n226] > _e306 && (_s133 = 1), this._depth[_t400][_n226] = _s133;
            }
          }
        }
      }
    }, {
      key: "getDelta",
      value: function getDelta(t) {
        return this._depth[t][vn.RIGHT] - this._depth[t][vn.LEFT];
      }
    }, {
      key: "getLocation",
      value: function getLocation(t, e) {
        return this._depth[t][e] <= 0 ? Kt.EXTERIOR : Kt.INTERIOR;
      }
    }, {
      key: "toString",
      value: function toString() {
        return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
      }
    }, {
      key: "add",
      value: function add() {
        if (1 === arguments.length) {
          var _t401 = arguments[0];

          for (var _e307 = 0; _e307 < 2; _e307++) {
            for (var _n227 = 1; _n227 < 3; _n227++) {
              var _s134 = _t401.getLocation(_e307, _n227);

              _s134 !== Kt.EXTERIOR && _s134 !== Kt.INTERIOR || (this.isNull(_e307, _n227) ? this._depth[_e307][_n227] = Kn.depthAtLocation(_s134) : this._depth[_e307][_n227] += Kn.depthAtLocation(_s134));
            }
          }
        } else if (3 === arguments.length) {
          var _t402 = arguments[0],
              _e308 = arguments[1];
          arguments[2] === Kt.INTERIOR && this._depth[_t402][_e308]++;
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._depth = Array(2).fill().map(function () {
          return Array(3);
        });

        for (var _t403 = 0; _t403 < 2; _t403++) {
          for (var _e309 = 0; _e309 < 3; _e309++) {
            this._depth[_t403][_e309] = Kn.NULL_VALUE;
          }
        }
      }
    }, {
      key: "depthAtLocation",
      value: function depthAtLocation(t) {
        return t === Kt.EXTERIOR ? 0 : t === Kt.INTERIOR ? 1 : Kn.NULL_VALUE;
      }
    }]);

    return Kn;
  }();

  Kn.NULL_VALUE = -1;

  var Qn = /*#__PURE__*/function () {
    function Qn() {
      _classCallCheck(this, Qn);

      Qn.constructor_.apply(this, arguments);
    }

    _createClass(Qn, [{
      key: "setVisited",
      value: function setVisited(t) {
        this._isVisited = t;
      }
    }, {
      key: "setInResult",
      value: function setInResult(t) {
        this._isInResult = t;
      }
    }, {
      key: "isCovered",
      value: function isCovered() {
        return this._isCovered;
      }
    }, {
      key: "isCoveredSet",
      value: function isCoveredSet() {
        return this._isCoveredSet;
      }
    }, {
      key: "setLabel",
      value: function setLabel(t) {
        this._label = t;
      }
    }, {
      key: "getLabel",
      value: function getLabel() {
        return this._label;
      }
    }, {
      key: "setCovered",
      value: function setCovered(t) {
        this._isCovered = t, this._isCoveredSet = !0;
      }
    }, {
      key: "updateIM",
      value: function updateIM(t) {
        g.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t);
      }
    }, {
      key: "isInResult",
      value: function isInResult() {
        return this._isInResult;
      }
    }, {
      key: "isVisited",
      value: function isVisited() {
        return this._isVisited;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 === arguments.length) ;else if (1 === arguments.length) {
          var _t404 = arguments[0];
          this._label = _t404;
        }
      }
    }]);

    return Qn;
  }();

  var Jn = /*#__PURE__*/function (_Qn) {
    _inherits(Jn, _Qn);

    var _super41 = _createSuper(Jn);

    function Jn() {
      var _this29;

      _classCallCheck(this, Jn);

      _this29 = _super41.call(this), Jn.constructor_.apply(_assertThisInitialized(_this29), arguments);
      return _this29;
    }

    _createClass(Jn, [{
      key: "getDepth",
      value: function getDepth() {
        return this._depth;
      }
    }, {
      key: "getCollapsedEdge",
      value: function getCollapsedEdge() {
        var t = new Array(2).fill(null);
        t[0] = this.pts[0], t[1] = this.pts[1];
        return new Jn(t, Gn.toLineLabel(this._label));
      }
    }, {
      key: "isIsolated",
      value: function isIsolated() {
        return this._isIsolated;
      }
    }, {
      key: "getCoordinates",
      value: function getCoordinates() {
        return this.pts;
      }
    }, {
      key: "setIsolated",
      value: function setIsolated(t) {
        this._isIsolated = t;
      }
    }, {
      key: "setName",
      value: function setName(t) {
        this._name = t;
      }
    }, {
      key: "equals",
      value: function equals(t) {
        if (!(t instanceof Jn)) return !1;
        var e = t;
        if (this.pts.length !== e.pts.length) return !1;
        var n = !0,
            s = !0,
            i = this.pts.length;

        for (var _t405 = 0; _t405 < this.pts.length; _t405++) {
          if (this.pts[_t405].equals2D(e.pts[_t405]) || (n = !1), this.pts[_t405].equals2D(e.pts[--i]) || (s = !1), !n && !s) return !1;
        }

        return !0;
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null;

        if (1 === arguments.length) {
          var _t406 = arguments[0];
          return this.pts[_t406];
        }
      }
    }, {
      key: "print",
      value: function print(t) {
        t.print("edge " + this._name + ": "), t.print("LINESTRING (");

        for (var _e310 = 0; _e310 < this.pts.length; _e310++) {
          _e310 > 0 && t.print(","), t.print(this.pts[_e310].x + " " + this.pts[_e310].y);
        }

        t.print(")  " + this._label + " " + this._depthDelta);
      }
    }, {
      key: "computeIM",
      value: function computeIM(t) {
        Jn.updateIM(this._label, t);
      }
    }, {
      key: "isCollapsed",
      value: function isCollapsed() {
        return !!this._label.isArea() && 3 === this.pts.length && !!this.pts[0].equals(this.pts[2]);
      }
    }, {
      key: "isClosed",
      value: function isClosed() {
        return this.pts[0].equals(this.pts[this.pts.length - 1]);
      }
    }, {
      key: "getMaximumSegmentIndex",
      value: function getMaximumSegmentIndex() {
        return this.pts.length - 1;
      }
    }, {
      key: "getDepthDelta",
      value: function getDepthDelta() {
        return this._depthDelta;
      }
    }, {
      key: "getNumPoints",
      value: function getNumPoints() {
        return this.pts.length;
      }
    }, {
      key: "printReverse",
      value: function printReverse(t) {
        t.print("edge " + this._name + ": ");

        for (var _e311 = this.pts.length - 1; _e311 >= 0; _e311--) {
          t.print(this.pts[_e311] + " ");
        }

        t.println("");
      }
    }, {
      key: "getMonotoneChainEdge",
      value: function getMonotoneChainEdge() {
        return null === this._mce && (this._mce = new jn(this)), this._mce;
      }
    }, {
      key: "getEnvelope",
      value: function getEnvelope() {
        if (null === this._env) {
          this._env = new T();

          for (var _t407 = 0; _t407 < this.pts.length; _t407++) {
            this._env.expandToInclude(this.pts[_t407]);
          }
        }

        return this._env;
      }
    }, {
      key: "addIntersection",
      value: function addIntersection(t, e, n, s) {
        var i = new m(t.getIntersection(s));
        var r = e,
            o = t.getEdgeDistance(n, s);
        var l = r + 1;

        if (l < this.pts.length) {
          var _t408 = this.pts[l];
          i.equals2D(_t408) && (r = l, o = 0);
        }

        this.eiList.add(i, r, o);
      }
    }, {
      key: "toString",
      value: function toString() {
        var t = new _t();
        t.append("edge " + this._name + ": "), t.append("LINESTRING (");

        for (var _e312 = 0; _e312 < this.pts.length; _e312++) {
          _e312 > 0 && t.append(","), t.append(this.pts[_e312].x + " " + this.pts[_e312].y);
        }

        return t.append(")  " + this._label + " " + this._depthDelta), t.toString();
      }
    }, {
      key: "isPointwiseEqual",
      value: function isPointwiseEqual(t) {
        if (this.pts.length !== t.pts.length) return !1;

        for (var _e313 = 0; _e313 < this.pts.length; _e313++) {
          if (!this.pts[_e313].equals2D(t.pts[_e313])) return !1;
        }

        return !0;
      }
    }, {
      key: "setDepthDelta",
      value: function setDepthDelta(t) {
        this._depthDelta = t;
      }
    }, {
      key: "getEdgeIntersectionList",
      value: function getEdgeIntersectionList() {
        return this.eiList;
      }
    }, {
      key: "addIntersections",
      value: function addIntersections(t, e, n) {
        for (var _s135 = 0; _s135 < t.getIntersectionNum(); _s135++) {
          this.addIntersection(t, e, n, _s135);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this.pts = null, this._env = null, this.eiList = new Hn(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new Kn(), this._depthDelta = 0, 1 === arguments.length) {
          var _t409 = arguments[0];
          Jn.constructor_.call(this, _t409, null);
        } else if (2 === arguments.length) {
          var _t410 = arguments[0],
              _e314 = arguments[1];
          this.pts = _t410, this._label = _e314;
        }
      }
    }, {
      key: "updateIM",
      value: function updateIM() {
        if (!(2 === arguments.length && arguments[1] instanceof Qt && arguments[0] instanceof Gn)) return _get(_getPrototypeOf(Jn), "updateIM", this).apply(this, arguments);
        {
          var _t411 = arguments[0],
              _e315 = arguments[1];
          _e315.setAtLeastIfValid(_t411.getLocation(0, vn.ON), _t411.getLocation(1, vn.ON), 1), _t411.isArea() && (_e315.setAtLeastIfValid(_t411.getLocation(0, vn.LEFT), _t411.getLocation(1, vn.LEFT), 2), _e315.setAtLeastIfValid(_t411.getLocation(0, vn.RIGHT), _t411.getLocation(1, vn.RIGHT), 2));
        }
      }
    }]);

    return Jn;
  }(Qn);

  var $n = /*#__PURE__*/function (_Qn2) {
    _inherits($n, _Qn2);

    var _super42 = _createSuper($n);

    function $n() {
      var _this30;

      _classCallCheck(this, $n);

      _this30 = _super42.call(this), $n.constructor_.apply(_assertThisInitialized(_this30), arguments);
      return _this30;
    }

    _createClass($n, [{
      key: "isIncidentEdgeInResult",
      value: function isIncidentEdgeInResult() {
        for (var _t412 = this.getEdges().getEdges().iterator(); _t412.hasNext();) {
          if (_t412.next().getEdge().isInResult()) return !0;
        }

        return !1;
      }
    }, {
      key: "isIsolated",
      value: function isIsolated() {
        return 1 === this._label.getGeometryCount();
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        return this._coord;
      }
    }, {
      key: "print",
      value: function print(t) {
        t.println("node " + this._coord + " lbl: " + this._label);
      }
    }, {
      key: "computeIM",
      value: function computeIM(t) {}
    }, {
      key: "computeMergedLocation",
      value: function computeMergedLocation(t, e) {
        var n = Kt.NONE;

        if (n = this._label.getLocation(e), !t.isNull(e)) {
          var _s136 = t.getLocation(e);

          n !== Kt.BOUNDARY && (n = _s136);
        }

        return n;
      }
    }, {
      key: "setLabel",
      value: function setLabel() {
        if (2 !== arguments.length || !Number.isInteger(arguments[1]) || !Number.isInteger(arguments[0])) return _get(_getPrototypeOf($n.prototype), "setLabel", this).apply(this, arguments);
        {
          var _t413 = arguments[0],
              _e316 = arguments[1];
          null === this._label ? this._label = new Gn(_t413, _e316) : this._label.setLocation(_t413, _e316);
        }
      }
    }, {
      key: "getEdges",
      value: function getEdges() {
        return this._edges;
      }
    }, {
      key: "mergeLabel",
      value: function mergeLabel() {
        if (arguments[0] instanceof $n) {
          var _t414 = arguments[0];
          this.mergeLabel(_t414._label);
        } else if (arguments[0] instanceof Gn) {
          var _t415 = arguments[0];

          for (var _e317 = 0; _e317 < 2; _e317++) {
            var _n228 = this.computeMergedLocation(_t415, _e317);

            this._label.getLocation(_e317) === Kt.NONE && this._label.setLocation(_e317, _n228);
          }
        }
      }
    }, {
      key: "add",
      value: function add(t) {
        this._edges.insert(t), t.setNode(this);
      }
    }, {
      key: "setLabelBoundary",
      value: function setLabelBoundary(t) {
        if (null === this._label) return null;
        var e = Kt.NONE;
        null !== this._label && (e = this._label.getLocation(t));
        var n = null;

        switch (e) {
          case Kt.BOUNDARY:
            n = Kt.INTERIOR;
            break;

          case Kt.INTERIOR:
          default:
            n = Kt.BOUNDARY;
        }

        this._label.setLocation(t, n);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._coord = null, this._edges = null;
        var t = arguments[0],
            e = arguments[1];
        this._coord = t, this._edges = e, this._label = new Gn(0, Kt.NONE);
      }
    }]);

    return $n;
  }(Qn);

  var ts = /*#__PURE__*/function () {
    function ts() {
      _classCallCheck(this, ts);

      ts.constructor_.apply(this, arguments);
    }

    _createClass(ts, [{
      key: "find",
      value: function find(t) {
        return this.nodeMap.get(t);
      }
    }, {
      key: "addNode",
      value: function addNode() {
        if (arguments[0] instanceof m) {
          var _t416 = arguments[0];

          var _e318 = this.nodeMap.get(_t416);

          return null === _e318 && (_e318 = this.nodeFact.createNode(_t416), this.nodeMap.put(_t416, _e318)), _e318;
        }

        if (arguments[0] instanceof $n) {
          var _t417 = arguments[0],
              _e319 = this.nodeMap.get(_t417.getCoordinate());

          return null === _e319 ? (this.nodeMap.put(_t417.getCoordinate(), _t417), _t417) : (_e319.mergeLabel(_t417), _e319);
        }
      }
    }, {
      key: "print",
      value: function print(t) {
        for (var _e320 = this.iterator(); _e320.hasNext();) {
          _e320.next().print(t);
        }
      }
    }, {
      key: "iterator",
      value: function iterator() {
        return this.nodeMap.values().iterator();
      }
    }, {
      key: "values",
      value: function values() {
        return this.nodeMap.values();
      }
    }, {
      key: "getBoundaryNodes",
      value: function getBoundaryNodes(t) {
        var e = new S();

        for (var _n229 = this.iterator(); _n229.hasNext();) {
          var _s137 = _n229.next();

          _s137.getLabel().getLocation(t) === Kt.BOUNDARY && e.add(_s137);
        }

        return e;
      }
    }, {
      key: "add",
      value: function add(t) {
        var e = t.getCoordinate();
        this.addNode(e).add(t);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this.nodeMap = new Un(), this.nodeFact = null;
        var t = arguments[0];
        this.nodeFact = t;
      }
    }]);

    return ts;
  }();

  var es = /*#__PURE__*/function () {
    function es() {
      _classCallCheck(this, es);

      es.constructor_.apply(this, arguments);
    }

    _createClass(es, [{
      key: "compareDirection",
      value: function compareDirection(t) {
        return this._dx === t._dx && this._dy === t._dy ? 0 : this._quadrant > t._quadrant ? 1 : this._quadrant < t._quadrant ? -1 : D.index(t._p0, t._p1, this._p1);
      }
    }, {
      key: "getDy",
      value: function getDy() {
        return this._dy;
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        return this._p0;
      }
    }, {
      key: "setNode",
      value: function setNode(t) {
        this._node = t;
      }
    }, {
      key: "print",
      value: function print(t) {
        var e = Math.atan2(this._dy, this._dx),
            n = this.getClass().getName(),
            s = n.lastIndexOf("."),
            i = n.substring(s + 1);
        t.print("  " + i + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e + "   " + this._label);
      }
    }, {
      key: "compareTo",
      value: function compareTo(t) {
        var e = t;
        return this.compareDirection(e);
      }
    }, {
      key: "getDirectedCoordinate",
      value: function getDirectedCoordinate() {
        return this._p1;
      }
    }, {
      key: "getDx",
      value: function getDx() {
        return this._dx;
      }
    }, {
      key: "getLabel",
      value: function getLabel() {
        return this._label;
      }
    }, {
      key: "getEdge",
      value: function getEdge() {
        return this._edge;
      }
    }, {
      key: "getQuadrant",
      value: function getQuadrant() {
        return this._quadrant;
      }
    }, {
      key: "getNode",
      value: function getNode() {
        return this._node;
      }
    }, {
      key: "toString",
      value: function toString() {
        var t = Math.atan2(this._dy, this._dx),
            e = this.getClass().getName(),
            n = e.lastIndexOf(".");
        return "  " + e.substring(n + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t + "   " + this._label;
      }
    }, {
      key: "computeLabel",
      value: function computeLabel(t) {}
    }, {
      key: "init",
      value: function init(t, e) {
        this._p0 = t, this._p1 = e, this._dx = e.x - t.x, this._dy = e.y - t.y, this._quadrant = Sn.quadrant(this._dx, this._dy), g.isTrue(!(0 === this._dx && 0 === this._dy), "EdgeEnd with identical endpoints found");
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [o];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) {
          var _t418 = arguments[0];
          this._edge = _t418;
        } else if (3 === arguments.length) {
          var _t419 = arguments[0],
              _e321 = arguments[1],
              _n230 = arguments[2];
          es.constructor_.call(this, _t419, _e321, _n230, null);
        } else if (4 === arguments.length) {
          var _t420 = arguments[0],
              _e322 = arguments[1],
              _n231 = arguments[2],
              _s138 = arguments[3];
          es.constructor_.call(this, _t420), this.init(_e322, _n231), this._label = _s138;
        }
      }
    }]);

    return es;
  }();

  var ns = /*#__PURE__*/function (_h8) {
    _inherits(ns, _h8);

    var _super43 = _createSuper(ns);

    function ns(t, e) {
      var _this31;

      _classCallCheck(this, ns);

      _this31 = _super43.call(this, e ? t + " [ " + e + " ]" : t), _this31.pt = e ? new m(e) : void 0;
      return _this31;
    }

    _createClass(ns, [{
      key: "getCoordinate",
      value: function getCoordinate() {
        return this.pt;
      }
    }]);

    return ns;
  }(h);

  var ss = /*#__PURE__*/function (_es) {
    _inherits(ss, _es);

    var _super44 = _createSuper(ss);

    function ss() {
      var _this32;

      _classCallCheck(this, ss);

      _this32 = _super44.call(this), ss.constructor_.apply(_assertThisInitialized(_this32), arguments);
      return _this32;
    }

    _createClass(ss, [{
      key: "getNextMin",
      value: function getNextMin() {
        return this._nextMin;
      }
    }, {
      key: "getDepth",
      value: function getDepth(t) {
        return this._depth[t];
      }
    }, {
      key: "setVisited",
      value: function setVisited(t) {
        this._isVisited = t;
      }
    }, {
      key: "computeDirectedLabel",
      value: function computeDirectedLabel() {
        this._label = new Gn(this._edge.getLabel()), this._isForward || this._label.flip();
      }
    }, {
      key: "getNext",
      value: function getNext() {
        return this._next;
      }
    }, {
      key: "setDepth",
      value: function setDepth(t, e) {
        if (-999 !== this._depth[t] && this._depth[t] !== e) throw new ns("assigned depths do not match", this.getCoordinate());
        this._depth[t] = e;
      }
    }, {
      key: "isInteriorAreaEdge",
      value: function isInteriorAreaEdge() {
        var t = !0;

        for (var _e323 = 0; _e323 < 2; _e323++) {
          this._label.isArea(_e323) && this._label.getLocation(_e323, vn.LEFT) === Kt.INTERIOR && this._label.getLocation(_e323, vn.RIGHT) === Kt.INTERIOR || (t = !1);
        }

        return t;
      }
    }, {
      key: "setNextMin",
      value: function setNextMin(t) {
        this._nextMin = t;
      }
    }, {
      key: "print",
      value: function print(t) {
        _get(_getPrototypeOf(ss.prototype), "print", this).call(this, t), t.print(" " + this._depth[vn.LEFT] + "/" + this._depth[vn.RIGHT]), t.print(" (" + this.getDepthDelta() + ")"), this._isInResult && t.print(" inResult");
      }
    }, {
      key: "setMinEdgeRing",
      value: function setMinEdgeRing(t) {
        this._minEdgeRing = t;
      }
    }, {
      key: "isLineEdge",
      value: function isLineEdge() {
        var t = this._label.isLine(0) || this._label.isLine(1),
            e = !this._label.isArea(0) || this._label.allPositionsEqual(0, Kt.EXTERIOR),
            n = !this._label.isArea(1) || this._label.allPositionsEqual(1, Kt.EXTERIOR);

        return t && e && n;
      }
    }, {
      key: "setEdgeRing",
      value: function setEdgeRing(t) {
        this._edgeRing = t;
      }
    }, {
      key: "getMinEdgeRing",
      value: function getMinEdgeRing() {
        return this._minEdgeRing;
      }
    }, {
      key: "getDepthDelta",
      value: function getDepthDelta() {
        var t = this._edge.getDepthDelta();

        return this._isForward || (t = -t), t;
      }
    }, {
      key: "setInResult",
      value: function setInResult(t) {
        this._isInResult = t;
      }
    }, {
      key: "getSym",
      value: function getSym() {
        return this._sym;
      }
    }, {
      key: "isForward",
      value: function isForward() {
        return this._isForward;
      }
    }, {
      key: "getEdge",
      value: function getEdge() {
        return this._edge;
      }
    }, {
      key: "printEdge",
      value: function printEdge(t) {
        this.print(t), t.print(" "), this._isForward ? this._edge.print(t) : this._edge.printReverse(t);
      }
    }, {
      key: "setSym",
      value: function setSym(t) {
        this._sym = t;
      }
    }, {
      key: "setVisitedEdge",
      value: function setVisitedEdge(t) {
        this.setVisited(t), this._sym.setVisited(t);
      }
    }, {
      key: "setEdgeDepths",
      value: function setEdgeDepths(t, e) {
        var n = this.getEdge().getDepthDelta();
        this._isForward || (n = -n);
        var s = 1;
        t === vn.LEFT && (s = -1);
        var i = vn.opposite(t),
            r = e + n * s;
        this.setDepth(t, e), this.setDepth(i, r);
      }
    }, {
      key: "getEdgeRing",
      value: function getEdgeRing() {
        return this._edgeRing;
      }
    }, {
      key: "isInResult",
      value: function isInResult() {
        return this._isInResult;
      }
    }, {
      key: "setNext",
      value: function setNext(t) {
        this._next = t;
      }
    }, {
      key: "isVisited",
      value: function isVisited() {
        return this._isVisited;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999];
        var t = arguments[0],
            e = arguments[1];
        if (es.constructor_.call(this, t), this._isForward = e, e) this.init(t.getCoordinate(0), t.getCoordinate(1));else {
          var _e324 = t.getNumPoints() - 1;

          this.init(t.getCoordinate(_e324), t.getCoordinate(_e324 - 1));
        }
        this.computeDirectedLabel();
      }
    }, {
      key: "depthFactor",
      value: function depthFactor(t, e) {
        return t === Kt.EXTERIOR && e === Kt.INTERIOR ? 1 : t === Kt.INTERIOR && e === Kt.EXTERIOR ? -1 : 0;
      }
    }]);

    return ss;
  }(es);

  var is = /*#__PURE__*/function () {
    function is() {
      _classCallCheck(this, is);
    }

    _createClass(is, [{
      key: "createNode",
      value: function createNode(t) {
        return new $n(t, null);
      }
    }]);

    return is;
  }();

  var rs = /*#__PURE__*/function () {
    function rs() {
      _classCallCheck(this, rs);

      rs.constructor_.apply(this, arguments);
    }

    _createClass(rs, [{
      key: "printEdges",
      value: function printEdges(t) {
        t.println("Edges:");

        for (var _e325 = 0; _e325 < this._edges.size(); _e325++) {
          t.println("edge " + _e325 + ":");

          var _n232 = this._edges.get(_e325);

          _n232.print(t), _n232.eiList.print(t);
        }
      }
    }, {
      key: "find",
      value: function find(t) {
        return this._nodes.find(t);
      }
    }, {
      key: "addNode",
      value: function addNode() {
        if (arguments[0] instanceof $n) {
          var _t421 = arguments[0];
          return this._nodes.addNode(_t421);
        }

        if (arguments[0] instanceof m) {
          var _t422 = arguments[0];
          return this._nodes.addNode(_t422);
        }
      }
    }, {
      key: "getNodeIterator",
      value: function getNodeIterator() {
        return this._nodes.iterator();
      }
    }, {
      key: "linkResultDirectedEdges",
      value: function linkResultDirectedEdges() {
        for (var _t423 = this._nodes.iterator(); _t423.hasNext();) {
          _t423.next().getEdges().linkResultDirectedEdges();
        }
      }
    }, {
      key: "debugPrintln",
      value: function debugPrintln(t) {
        F.out.println(t);
      }
    }, {
      key: "isBoundaryNode",
      value: function isBoundaryNode(t, e) {
        var n = this._nodes.find(e);

        if (null === n) return !1;
        var s = n.getLabel();
        return null !== s && s.getLocation(t) === Kt.BOUNDARY;
      }
    }, {
      key: "linkAllDirectedEdges",
      value: function linkAllDirectedEdges() {
        for (var _t424 = this._nodes.iterator(); _t424.hasNext();) {
          _t424.next().getEdges().linkAllDirectedEdges();
        }
      }
    }, {
      key: "matchInSameDirection",
      value: function matchInSameDirection(t, e, n, s) {
        return !!t.equals(n) && D.index(t, e, s) === D.COLLINEAR && Sn.quadrant(t, e) === Sn.quadrant(n, s);
      }
    }, {
      key: "getEdgeEnds",
      value: function getEdgeEnds() {
        return this._edgeEndList;
      }
    }, {
      key: "debugPrint",
      value: function debugPrint(t) {
        F.out.print(t);
      }
    }, {
      key: "getEdgeIterator",
      value: function getEdgeIterator() {
        return this._edges.iterator();
      }
    }, {
      key: "findEdgeInSameDirection",
      value: function findEdgeInSameDirection(t, e) {
        for (var _n233 = 0; _n233 < this._edges.size(); _n233++) {
          var _s139 = this._edges.get(_n233),
              _i67 = _s139.getCoordinates();

          if (this.matchInSameDirection(t, e, _i67[0], _i67[1])) return _s139;
          if (this.matchInSameDirection(t, e, _i67[_i67.length - 1], _i67[_i67.length - 2])) return _s139;
        }

        return null;
      }
    }, {
      key: "insertEdge",
      value: function insertEdge(t) {
        this._edges.add(t);
      }
    }, {
      key: "findEdgeEnd",
      value: function findEdgeEnd(t) {
        for (var _e326 = this.getEdgeEnds().iterator(); _e326.hasNext();) {
          var _n234 = _e326.next();

          if (_n234.getEdge() === t) return _n234;
        }

        return null;
      }
    }, {
      key: "addEdges",
      value: function addEdges(t) {
        for (var _e327 = t.iterator(); _e327.hasNext();) {
          var _t425 = _e327.next();

          this._edges.add(_t425);

          var _n235 = new ss(_t425, !0),
              _s140 = new ss(_t425, !1);

          _n235.setSym(_s140), _s140.setSym(_n235), this.add(_n235), this.add(_s140);
        }
      }
    }, {
      key: "add",
      value: function add(t) {
        this._nodes.add(t), this._edgeEndList.add(t);
      }
    }, {
      key: "getNodes",
      value: function getNodes() {
        return this._nodes.values();
      }
    }, {
      key: "findEdge",
      value: function findEdge(t, e) {
        for (var _n236 = 0; _n236 < this._edges.size(); _n236++) {
          var _s141 = this._edges.get(_n236),
              _i68 = _s141.getCoordinates();

          if (t.equals(_i68[0]) && e.equals(_i68[1])) return _s141;
        }

        return null;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._edges = new S(), this._nodes = null, this._edgeEndList = new S(), 0 === arguments.length) this._nodes = new ts(new is());else if (1 === arguments.length) {
          var _t426 = arguments[0];
          this._nodes = new ts(_t426);
        }
      }
    }, {
      key: "linkResultDirectedEdges",
      value: function linkResultDirectedEdges(t) {
        for (var _e328 = t.iterator(); _e328.hasNext();) {
          _e328.next().getEdges().linkResultDirectedEdges();
        }
      }
    }]);

    return rs;
  }();

  var os = /*#__PURE__*/function (_rs) {
    _inherits(os, _rs);

    var _super45 = _createSuper(os);

    function os() {
      var _this33;

      _classCallCheck(this, os);

      _this33 = _super45.call(this), os.constructor_.apply(_assertThisInitialized(_this33), arguments);
      return _this33;
    }

    _createClass(os, [{
      key: "insertBoundaryPoint",
      value: function insertBoundaryPoint(t, e) {
        var n = this._nodes.addNode(e).getLabel();

        var s = 1,
            i = Kt.NONE;
        i = n.getLocation(t, vn.ON), i === Kt.BOUNDARY && s++;
        var r = os.determineBoundary(this._boundaryNodeRule, s);
        n.setLocation(t, r);
      }
    }, {
      key: "computeSelfNodes",
      value: function computeSelfNodes() {
        if (2 === arguments.length) {
          var _t427 = arguments[0],
              _e329 = arguments[1];
          return this.computeSelfNodes(_t427, _e329, !1);
        }

        if (3 === arguments.length) {
          var _t428 = arguments[1],
              _e330 = arguments[2],
              _n237 = new Dn(arguments[0], !0, !1);

          _n237.setIsDoneIfProperInt(_e330);

          var _s142 = this.createEdgeSetIntersector(),
              _i69 = this._parentGeom instanceof at || this._parentGeom instanceof et || this._parentGeom instanceof ft,
              _r43 = _t428 || !_i69;

          return _s142.computeIntersections(this._edges, _n237, _r43), this.addSelfIntersectionNodes(this._argIndex), _n237;
        }
      }
    }, {
      key: "computeSplitEdges",
      value: function computeSplitEdges(t) {
        for (var _e331 = this._edges.iterator(); _e331.hasNext();) {
          _e331.next().eiList.addSplitEdges(t);
        }
      }
    }, {
      key: "computeEdgeIntersections",
      value: function computeEdgeIntersections(t, e, n) {
        var s = new Dn(e, n, !0);
        s.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes());
        return this.createEdgeSetIntersector().computeIntersections(this._edges, t._edges, s), s;
      }
    }, {
      key: "getGeometry",
      value: function getGeometry() {
        return this._parentGeom;
      }
    }, {
      key: "getBoundaryNodeRule",
      value: function getBoundaryNodeRule() {
        return this._boundaryNodeRule;
      }
    }, {
      key: "hasTooFewPoints",
      value: function hasTooFewPoints() {
        return this._hasTooFewPoints;
      }
    }, {
      key: "addPoint",
      value: function addPoint() {
        if (arguments[0] instanceof Q) {
          var _t429 = arguments[0].getCoordinate();

          this.insertPoint(this._argIndex, _t429, Kt.INTERIOR);
        } else if (arguments[0] instanceof m) {
          var _t430 = arguments[0];
          this.insertPoint(this._argIndex, _t430, Kt.INTERIOR);
        }
      }
    }, {
      key: "addPolygon",
      value: function addPolygon(t) {
        this.addPolygonRing(t.getExteriorRing(), Kt.EXTERIOR, Kt.INTERIOR);

        for (var _e332 = 0; _e332 < t.getNumInteriorRing(); _e332++) {
          var _n238 = t.getInteriorRingN(_e332);

          this.addPolygonRing(_n238, Kt.INTERIOR, Kt.EXTERIOR);
        }
      }
    }, {
      key: "addEdge",
      value: function addEdge(t) {
        this.insertEdge(t);
        var e = t.getCoordinates();
        this.insertPoint(this._argIndex, e[0], Kt.BOUNDARY), this.insertPoint(this._argIndex, e[e.length - 1], Kt.BOUNDARY);
      }
    }, {
      key: "addLineString",
      value: function addLineString(t) {
        var e = dt.removeRepeatedPoints(t.getCoordinates());
        if (e.length < 2) return this._hasTooFewPoints = !0, this._invalidPoint = e[0], null;
        var n = new Jn(e, new Gn(this._argIndex, Kt.INTERIOR));
        this._lineEdgeMap.put(t, n), this.insertEdge(n), g.isTrue(e.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this._argIndex, e[0]), this.insertBoundaryPoint(this._argIndex, e[e.length - 1]);
      }
    }, {
      key: "getInvalidPoint",
      value: function getInvalidPoint() {
        return this._invalidPoint;
      }
    }, {
      key: "getBoundaryPoints",
      value: function getBoundaryPoints() {
        var t = this.getBoundaryNodes(),
            e = new Array(t.size()).fill(null);
        var n = 0;

        for (var _s143 = t.iterator(); _s143.hasNext();) {
          var _t431 = _s143.next();

          e[n++] = _t431.getCoordinate().copy();
        }

        return e;
      }
    }, {
      key: "getBoundaryNodes",
      value: function getBoundaryNodes() {
        return null === this._boundaryNodes && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes;
      }
    }, {
      key: "addSelfIntersectionNode",
      value: function addSelfIntersectionNode(t, e, n) {
        if (this.isBoundaryNode(t, e)) return null;
        n === Kt.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(t, e) : this.insertPoint(t, e, n);
      }
    }, {
      key: "addPolygonRing",
      value: function addPolygonRing(t, e, n) {
        if (t.isEmpty()) return null;
        var s = dt.removeRepeatedPoints(t.getCoordinates());
        if (s.length < 4) return this._hasTooFewPoints = !0, this._invalidPoint = s[0], null;
        var i = e,
            r = n;
        D.isCCW(s) && (i = n, r = e);
        var o = new Jn(s, new Gn(this._argIndex, Kt.BOUNDARY, i, r));
        this._lineEdgeMap.put(t, o), this.insertEdge(o), this.insertPoint(this._argIndex, s[0], Kt.BOUNDARY);
      }
    }, {
      key: "insertPoint",
      value: function insertPoint(t, e, n) {
        var s = this._nodes.addNode(e),
            i = s.getLabel();

        null === i ? s._label = new Gn(t, n) : i.setLocation(t, n);
      }
    }, {
      key: "createEdgeSetIntersector",
      value: function createEdgeSetIntersector() {
        return new An();
      }
    }, {
      key: "addSelfIntersectionNodes",
      value: function addSelfIntersectionNodes(t) {
        for (var _e333 = this._edges.iterator(); _e333.hasNext();) {
          var _n239 = _e333.next(),
              _s144 = _n239.getLabel().getLocation(t);

          for (var _e334 = _n239.eiList.iterator(); _e334.hasNext();) {
            var _n240 = _e334.next();

            this.addSelfIntersectionNode(t, _n240.coord, _s144);
          }
        }
      }
    }, {
      key: "add",
      value: function add() {
        if (!(1 === arguments.length && arguments[0] instanceof V)) return _get(_getPrototypeOf(os.prototype), "add", this).apply(this, arguments);
        {
          var _t432 = arguments[0];
          if (_t432.isEmpty()) return null;
          if (_t432 instanceof ft && (this._useBoundaryDeterminationRule = !1), _t432 instanceof et) this.addPolygon(_t432);else if (_t432 instanceof j) this.addLineString(_t432);else if (_t432 instanceof Q) this.addPoint(_t432);else if (_t432 instanceof lt) this.addCollection(_t432);else if (_t432 instanceof wt) this.addCollection(_t432);else if (_t432 instanceof ft) this.addCollection(_t432);else {
            if (!(_t432 instanceof ot)) throw new H(_t432.getGeometryType());
            this.addCollection(_t432);
          }
        }
      }
    }, {
      key: "addCollection",
      value: function addCollection(t) {
        for (var _e335 = 0; _e335 < t.getNumGeometries(); _e335++) {
          var _n241 = t.getGeometryN(_e335);

          this.add(_n241);
        }
      }
    }, {
      key: "locate",
      value: function locate(t) {
        return y(this._parentGeom, tt) && this._parentGeom.getNumGeometries() > 50 ? (null === this._areaPtLocator && (this._areaPtLocator = new Ve(this._parentGeom)), this._areaPtLocator.locate(t)) : this._ptLocator.locate(t, this._parentGeom);
      }
    }, {
      key: "findEdge",
      value: function findEdge() {
        if (1 === arguments.length && arguments[0] instanceof j) {
          var _t433 = arguments[0];
          return this._lineEdgeMap.get(_t433);
        }

        return _get(_getPrototypeOf(os.prototype), "findEdge", this).apply(this, arguments);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._parentGeom = null, this._lineEdgeMap = new It(), this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = !0, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = !1, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new mn(), 2 === arguments.length) {
          var _t434 = arguments[0],
              _e336 = arguments[1];
          os.constructor_.call(this, _t434, _e336, un.OGC_SFS_BOUNDARY_RULE);
        } else if (3 === arguments.length) {
          var _t435 = arguments[0],
              _e337 = arguments[1],
              _n242 = arguments[2];
          this._argIndex = _t435, this._parentGeom = _e337, this._boundaryNodeRule = _n242, null !== _e337 && this.add(_e337);
        }
      }
    }, {
      key: "determineBoundary",
      value: function determineBoundary(t, e) {
        return t.isInBoundary(e) ? Kt.BOUNDARY : Kt.INTERIOR;
      }
    }]);

    return os;
  }(rs);

  var ls = Object.freeze({
    __proto__: null,
    GeometryGraph: os
  });

  var as = /*#__PURE__*/function () {
    function as() {
      _classCallCheck(this, as);
    }

    _createClass(as, [{
      key: "visit",
      value: function visit(t) {}
    }]);

    return as;
  }();

  var cs = /*#__PURE__*/function () {
    function cs() {
      _classCallCheck(this, cs);

      cs.constructor_.apply(this, arguments);
    }

    _createClass(cs, [{
      key: "isRepeated",
      value: function isRepeated() {
        return this._count > 1;
      }
    }, {
      key: "getRight",
      value: function getRight() {
        return this._right;
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        return this._p;
      }
    }, {
      key: "setLeft",
      value: function setLeft(t) {
        this._left = t;
      }
    }, {
      key: "getX",
      value: function getX() {
        return this._p.x;
      }
    }, {
      key: "getData",
      value: function getData() {
        return this._data;
      }
    }, {
      key: "getCount",
      value: function getCount() {
        return this._count;
      }
    }, {
      key: "getLeft",
      value: function getLeft() {
        return this._left;
      }
    }, {
      key: "getY",
      value: function getY() {
        return this._p.y;
      }
    }, {
      key: "increment",
      value: function increment() {
        this._count = this._count + 1;
      }
    }, {
      key: "setRight",
      value: function setRight(t) {
        this._right = t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._p = null, this._data = null, this._left = null, this._right = null, this._count = null, 2 === arguments.length) {
          var _t436 = arguments[0],
              _e338 = arguments[1];
          this._p = new m(_t436), this._left = null, this._right = null, this._count = 1, this._data = _e338;
        } else if (3 === arguments.length) {
          var _t437 = arguments[0],
              _e339 = arguments[1],
              _n243 = arguments[2];
          this._p = new m(_t437, _e339), this._left = null, this._right = null, this._count = 1, this._data = _n243;
        }
      }
    }]);

    return cs;
  }();

  var hs = /*#__PURE__*/function () {
    function hs() {
      _classCallCheck(this, hs);

      hs.constructor_.apply(this, arguments);
    }

    _createClass(hs, [{
      key: "insert",
      value: function insert() {
        if (1 === arguments.length) {
          var _t438 = arguments[0];
          return this.insert(_t438, null);
        }

        if (2 === arguments.length) {
          var _t439 = arguments[0],
              _e340 = arguments[1];
          if (null === this._root) return this._root = new cs(_t439, _e340), this._root;

          if (this._tolerance > 0) {
            var _e341 = this.findBestMatchNode(_t439);

            if (null !== _e341) return _e341.increment(), _e341;
          }

          return this.insertExact(_t439, _e340);
        }
      }
    }, {
      key: "query",
      value: function query() {
        if (1 === arguments.length) {
          var _t440 = arguments[0],
              _e342 = new S();

          return this.query(_t440, _e342), _e342;
        }

        if (2 === arguments.length) if (arguments[0] instanceof T && y(arguments[1], I)) {
          var _t441 = arguments[0],
              _e343 = arguments[1];
          this.queryNode(this._root, _t441, !0, new ( /*#__PURE__*/function () {
            function _class9() {
              _classCallCheck(this, _class9);
            }

            _createClass(_class9, [{
              key: "visit",
              value: function visit(t) {
                _e343.add(t);
              }
            }, {
              key: "interfaces_",
              get: function get() {
                return [as];
              }
            }]);

            return _class9;
          }())());
        } else if (arguments[0] instanceof T && y(arguments[1], as)) {
          var _t442 = arguments[0],
              _e344 = arguments[1];
          this.queryNode(this._root, _t442, !0, _e344);
        }
      }
    }, {
      key: "queryNode",
      value: function queryNode(t, e, n, s) {
        if (null === t) return null;
        var i = null,
            r = null,
            o = null;
        n ? (i = e.getMinX(), r = e.getMaxX(), o = t.getX()) : (i = e.getMinY(), r = e.getMaxY(), o = t.getY());
        var l = o <= r;
        i < o && this.queryNode(t.getLeft(), e, !n, s), e.contains(t.getCoordinate()) && s.visit(t), l && this.queryNode(t.getRight(), e, !n, s);
      }
    }, {
      key: "findBestMatchNode",
      value: function findBestMatchNode(t) {
        var e = new us(t, this._tolerance);
        return this.query(e.queryEnvelope(), e), e.getNode();
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return null === this._root;
      }
    }, {
      key: "insertExact",
      value: function insertExact(t, e) {
        var n = this._root,
            s = this._root,
            i = !0,
            r = !0;

        for (; null !== n;) {
          if (null !== n) {
            if (t.distance(n.getCoordinate()) <= this._tolerance) return n.increment(), n;
          }

          r = i ? t.x < n.getX() : t.y < n.getY(), s = n, n = r ? n.getLeft() : n.getRight(), i = !i;
        }

        this._numberOfNodes = this._numberOfNodes + 1;
        var o = new cs(t, e);
        return r ? s.setLeft(o) : s.setRight(o), o;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._root = null, this._numberOfNodes = null, this._tolerance = null, 0 === arguments.length) hs.constructor_.call(this, 0);else if (1 === arguments.length) {
          var _t443 = arguments[0];
          this._tolerance = _t443;
        }
      }
    }, {
      key: "toCoordinates",
      value: function toCoordinates() {
        if (1 === arguments.length) {
          var _t444 = arguments[0];
          return hs.toCoordinates(_t444, !1);
        }

        if (2 === arguments.length) {
          var _t445 = arguments[0],
              _e345 = arguments[1],
              _n244 = new C();

          for (var _s145 = _t445.iterator(); _s145.hasNext();) {
            var _t446 = _s145.next(),
                _i70 = _e345 ? _t446.getCount() : 1;

            for (var _e346 = 0; _e346 < _i70; _e346++) {
              _n244.add(_t446.getCoordinate(), !0);
            }
          }

          return _n244.toCoordinateArray();
        }
      }
    }]);

    return hs;
  }();

  var us = /*#__PURE__*/function () {
    function us() {
      _classCallCheck(this, us);

      us.constructor_.apply(this, arguments);
    }

    _createClass(us, [{
      key: "visit",
      value: function visit(t) {
        var e = this._p.distance(t.getCoordinate());

        if (!(e <= this._tolerance)) return null;
        var n = !1;
        (null === this._matchNode || e < this._matchDist || null !== this._matchNode && e === this._matchDist && t.getCoordinate().compareTo(this._matchNode.getCoordinate()) < 1) && (n = !0), n && (this._matchNode = t, this._matchDist = e);
      }
    }, {
      key: "queryEnvelope",
      value: function queryEnvelope() {
        var t = new T(this._p);
        return t.expandBy(this._tolerance), t;
      }
    }, {
      key: "getNode",
      value: function getNode() {
        return this._matchNode;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [as];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._tolerance = null, this._matchNode = null, this._matchDist = 0, this._p = null;
        var t = arguments[0],
            e = arguments[1];
        this._p = t, this._tolerance = e;
      }
    }]);

    return us;
  }();

  hs.BestMatchVisitor = us;
  var gs = Object.freeze({
    __proto__: null,
    KdTree: hs
  });

  var ds = /*#__PURE__*/function () {
    function ds() {
      _classCallCheck(this, ds);

      ds.constructor_.apply(this, arguments);
    }

    _createClass(ds, [{
      key: "hasChildren",
      value: function hasChildren() {
        for (var _t447 = 0; _t447 < 4; _t447++) {
          if (null !== this._subnode[_t447]) return !0;
        }

        return !1;
      }
    }, {
      key: "isPrunable",
      value: function isPrunable() {
        return !(this.hasChildren() || this.hasItems());
      }
    }, {
      key: "addAllItems",
      value: function addAllItems(t) {
        t.addAll(this._items);

        for (var _e347 = 0; _e347 < 4; _e347++) {
          null !== this._subnode[_e347] && this._subnode[_e347].addAllItems(t);
        }

        return t;
      }
    }, {
      key: "getNodeCount",
      value: function getNodeCount() {
        var t = 0;

        for (var _e348 = 0; _e348 < 4; _e348++) {
          null !== this._subnode[_e348] && (t += this._subnode[_e348].size());
        }

        return t + 1;
      }
    }, {
      key: "size",
      value: function size() {
        var t = 0;

        for (var _e349 = 0; _e349 < 4; _e349++) {
          null !== this._subnode[_e349] && (t += this._subnode[_e349].size());
        }

        return t + this._items.size();
      }
    }, {
      key: "addAllItemsFromOverlapping",
      value: function addAllItemsFromOverlapping(t, e) {
        if (!this.isSearchMatch(t)) return null;
        e.addAll(this._items);

        for (var _n245 = 0; _n245 < 4; _n245++) {
          null !== this._subnode[_n245] && this._subnode[_n245].addAllItemsFromOverlapping(t, e);
        }
      }
    }, {
      key: "visitItems",
      value: function visitItems(t, e) {
        for (var _t448 = this._items.iterator(); _t448.hasNext();) {
          e.visitItem(_t448.next());
        }
      }
    }, {
      key: "hasItems",
      value: function hasItems() {
        return !this._items.isEmpty();
      }
    }, {
      key: "remove",
      value: function remove(t, e) {
        if (!this.isSearchMatch(t)) return !1;
        var n = !1;

        for (var _s146 = 0; _s146 < 4; _s146++) {
          if (null !== this._subnode[_s146] && (n = this._subnode[_s146].remove(t, e), n)) {
            this._subnode[_s146].isPrunable() && (this._subnode[_s146] = null);
            break;
          }
        }

        return n || (n = this._items.remove(e), n);
      }
    }, {
      key: "visit",
      value: function visit(t, e) {
        if (!this.isSearchMatch(t)) return null;
        this.visitItems(t, e);

        for (var _n246 = 0; _n246 < 4; _n246++) {
          null !== this._subnode[_n246] && this._subnode[_n246].visit(t, e);
        }
      }
    }, {
      key: "getItems",
      value: function getItems() {
        return this._items;
      }
    }, {
      key: "depth",
      value: function depth() {
        var t = 0;

        for (var _e350 = 0; _e350 < 4; _e350++) {
          if (null !== this._subnode[_e350]) {
            var _n247 = this._subnode[_e350].depth();

            _n247 > t && (t = _n247);
          }
        }

        return t + 1;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        var t = !0;

        if (this._items.isEmpty()) {
          for (var _e351 = 0; _e351 < 4; _e351++) {
            if (null !== this._subnode[_e351] && !this._subnode[_e351].isEmpty()) {
              t = !1;
              break;
            }
          }
        } else t = !1;

        return t;
      }
    }, {
      key: "add",
      value: function add(t) {
        this._items.add(t);
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [c];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._items = new S(), this._subnode = new Array(4).fill(null);
      }
    }, {
      key: "getSubnodeIndex",
      value: function getSubnodeIndex(t, e, n) {
        var s = -1;
        return t.getMinX() >= e && (t.getMinY() >= n && (s = 3), t.getMaxY() <= n && (s = 1)), t.getMaxX() <= e && (t.getMinY() >= n && (s = 2), t.getMaxY() <= n && (s = 0)), s;
      }
    }]);

    return ds;
  }();

  function _s() {}

  _s.exponent = function (t) {
    return function (t, e) {
      var n, s, i, r;
      var o = {
        32: {
          d: 127,
          c: 128,
          b: 0,
          a: 0
        },
        64: {
          d: 32752,
          c: 0,
          b: 0,
          a: 0
        }
      },
          l = {
        32: 8,
        64: 11
      }[t];
      r || (n = e < 0 || 1 / e < 0, isFinite(e) || (r = o[t], n && (r.d += 1 << t / 4 - 1), s = Math.pow(2, l) - 1, i = 0));

      if (!r) {
        for (s = {
          32: 127,
          64: 1023
        }[t], i = Math.abs(e); i >= 2;) {
          s++, i /= 2;
        }

        for (; i < 1 && s > 0;) {
          s--, i *= 2;
        }

        s <= 0 && (i /= 2), 32 === t && s > 254 && (r = {
          d: n ? 255 : 127,
          c: 128,
          b: 0,
          a: 0
        }, s = Math.pow(2, l) - 1, i = 0);
      }

      return s;
    }(64, t) - 1023;
  }, _s.powerOf2 = function (t) {
    return Math.pow(2, t);
  };

  var ps = /*#__PURE__*/function () {
    function ps() {
      _classCallCheck(this, ps);

      ps.constructor_.apply(this, arguments);
    }

    _createClass(ps, [{
      key: "getLevel",
      value: function getLevel() {
        return this._level;
      }
    }, {
      key: "computeKey",
      value: function computeKey() {
        if (1 === arguments.length) {
          var _t449 = arguments[0];

          for (this._level = ps.computeQuadLevel(_t449), this._env = new T(), this.computeKey(this._level, _t449); !this._env.contains(_t449);) {
            this._level += 1, this.computeKey(this._level, _t449);
          }
        } else if (2 === arguments.length) {
          var _t450 = arguments[0],
              _e352 = arguments[1],
              _n248 = _s.powerOf2(_t450);

          this._pt.x = Math.floor(_e352.getMinX() / _n248) * _n248, this._pt.y = Math.floor(_e352.getMinY() / _n248) * _n248, this._env.init(this._pt.x, this._pt.x + _n248, this._pt.y, this._pt.y + _n248);
        }
      }
    }, {
      key: "getEnvelope",
      value: function getEnvelope() {
        return this._env;
      }
    }, {
      key: "getCentre",
      value: function getCentre() {
        return new m((this._env.getMinX() + this._env.getMaxX()) / 2, (this._env.getMinY() + this._env.getMaxY()) / 2);
      }
    }, {
      key: "getPoint",
      value: function getPoint() {
        return this._pt;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._pt = new m(), this._level = 0, this._env = null;
        var t = arguments[0];
        this.computeKey(t);
      }
    }, {
      key: "computeQuadLevel",
      value: function computeQuadLevel(t) {
        var e = t.getWidth(),
            n = t.getHeight(),
            s = e > n ? e : n;
        return _s.exponent(s) + 1;
      }
    }]);

    return ps;
  }();

  var ms = /*#__PURE__*/function (_ds) {
    _inherits(ms, _ds);

    var _super46 = _createSuper(ms);

    function ms() {
      var _this34;

      _classCallCheck(this, ms);

      _this34 = _super46.call(this), ms.constructor_.apply(_assertThisInitialized(_this34), arguments);
      return _this34;
    }

    _createClass(ms, [{
      key: "find",
      value: function find(t) {
        var e = ds.getSubnodeIndex(t, this._centrex, this._centrey);
        if (-1 === e) return this;

        if (null !== this._subnode[e]) {
          return this._subnode[e].find(t);
        }

        return this;
      }
    }, {
      key: "isSearchMatch",
      value: function isSearchMatch(t) {
        return null !== t && this._env.intersects(t);
      }
    }, {
      key: "getSubnode",
      value: function getSubnode(t) {
        return null === this._subnode[t] && (this._subnode[t] = this.createSubnode(t)), this._subnode[t];
      }
    }, {
      key: "getEnvelope",
      value: function getEnvelope() {
        return this._env;
      }
    }, {
      key: "getNode",
      value: function getNode(t) {
        var e = ds.getSubnodeIndex(t, this._centrex, this._centrey);

        if (-1 !== e) {
          return this.getSubnode(e).getNode(t);
        }

        return this;
      }
    }, {
      key: "createSubnode",
      value: function createSubnode(t) {
        var e = 0,
            n = 0,
            s = 0,
            i = 0;

        switch (t) {
          case 0:
            e = this._env.getMinX(), n = this._centrex, s = this._env.getMinY(), i = this._centrey;
            break;

          case 1:
            e = this._centrex, n = this._env.getMaxX(), s = this._env.getMinY(), i = this._centrey;
            break;

          case 2:
            e = this._env.getMinX(), n = this._centrex, s = this._centrey, i = this._env.getMaxY();
            break;

          case 3:
            e = this._centrex, n = this._env.getMaxX(), s = this._centrey, i = this._env.getMaxY();
        }

        var r = new T(e, n, s, i);
        return new ms(r, this._level - 1);
      }
    }, {
      key: "insertNode",
      value: function insertNode(t) {
        g.isTrue(null === this._env || this._env.contains(t._env));
        var e = ds.getSubnodeIndex(t._env, this._centrex, this._centrey);
        if (t._level === this._level - 1) this._subnode[e] = t;else {
          var _n249 = this.createSubnode(e);

          _n249.insertNode(t), this._subnode[e] = _n249;
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._env = null, this._centrex = null, this._centrey = null, this._level = null;
        var t = arguments[0],
            e = arguments[1];
        this._env = t, this._level = e, this._centrex = (t.getMinX() + t.getMaxX()) / 2, this._centrey = (t.getMinY() + t.getMaxY()) / 2;
      }
    }, {
      key: "createNode",
      value: function createNode(t) {
        var e = new ps(t);
        return new ms(e.getEnvelope(), e.getLevel());
      }
    }, {
      key: "createExpanded",
      value: function createExpanded(t, e) {
        var n = new T(e);
        null !== t && n.expandToInclude(t._env);
        var s = ms.createNode(n);
        return null !== t && s.insertNode(t), s;
      }
    }]);

    return ms;
  }(ds);

  var fs = /*#__PURE__*/function () {
    function fs() {
      _classCallCheck(this, fs);
    }

    _createClass(fs, null, [{
      key: "isZeroWidth",
      value: function isZeroWidth(t, e) {
        var n = e - t;
        if (0 === n) return !0;
        var s = n / Math.max(Math.abs(t), Math.abs(e));
        return _s.exponent(s) <= fs.MIN_BINARY_EXPONENT;
      }
    }]);

    return fs;
  }();

  fs.MIN_BINARY_EXPONENT = -50;

  var ys = /*#__PURE__*/function (_ds2) {
    _inherits(ys, _ds2);

    var _super47 = _createSuper(ys);

    function ys() {
      _classCallCheck(this, ys);

      return _super47.call(this);
    }

    _createClass(ys, [{
      key: "insert",
      value: function insert(t, e) {
        var n = ds.getSubnodeIndex(t, ys.origin.x, ys.origin.y);
        if (-1 === n) return this.add(e), null;
        var s = this._subnode[n];

        if (null === s || !s.getEnvelope().contains(t)) {
          var _e353 = ms.createExpanded(s, t);

          this._subnode[n] = _e353;
        }

        this.insertContained(this._subnode[n], t, e);
      }
    }, {
      key: "isSearchMatch",
      value: function isSearchMatch(t) {
        return !0;
      }
    }, {
      key: "insertContained",
      value: function insertContained(t, e, n) {
        g.isTrue(t.getEnvelope().contains(e));
        var s = fs.isZeroWidth(e.getMinX(), e.getMaxX()),
            i = fs.isZeroWidth(e.getMinY(), e.getMaxY());
        var r = null;
        r = s || i ? t.find(e) : t.getNode(e), r.add(n);
      }
    }]);

    return ys;
  }(ds);

  ys.origin = new m(0, 0);

  var xs = /*#__PURE__*/function () {
    function xs() {
      _classCallCheck(this, xs);
    }

    _createClass(xs, [{
      key: "insert",
      value: function insert(t, e) {}
    }, {
      key: "remove",
      value: function remove(t, e) {}
    }, {
      key: "query",
      value: function query() {}
    }]);

    return xs;
  }();

  var Es = /*#__PURE__*/function () {
    function Es() {
      _classCallCheck(this, Es);

      Es.constructor_.apply(this, arguments);
    }

    _createClass(Es, [{
      key: "size",
      value: function size() {
        return null !== this._root ? this._root.size() : 0;
      }
    }, {
      key: "insert",
      value: function insert(t, e) {
        this.collectStats(t);
        var n = Es.ensureExtent(t, this._minExtent);

        this._root.insert(n, e);
      }
    }, {
      key: "query",
      value: function query() {
        if (1 === arguments.length) {
          var _t451 = arguments[0],
              _e354 = new Be();

          return this.query(_t451, _e354), _e354.getItems();
        }

        if (2 === arguments.length) {
          var _t452 = arguments[0],
              _e355 = arguments[1];

          this._root.visit(_t452, _e355);
        }
      }
    }, {
      key: "queryAll",
      value: function queryAll() {
        var t = new S();
        return this._root.addAllItems(t), t;
      }
    }, {
      key: "remove",
      value: function remove(t, e) {
        var n = Es.ensureExtent(t, this._minExtent);
        return this._root.remove(n, e);
      }
    }, {
      key: "collectStats",
      value: function collectStats(t) {
        var e = t.getWidth();
        e < this._minExtent && e > 0 && (this._minExtent = e);
        var n = t.getHeight();
        n < this._minExtent && n > 0 && (this._minExtent = n);
      }
    }, {
      key: "depth",
      value: function depth() {
        return null !== this._root ? this._root.depth() : 0;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return null === this._root || this._root.isEmpty();
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [xs, c];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._root = null, this._minExtent = 1, this._root = new ys();
      }
    }, {
      key: "ensureExtent",
      value: function ensureExtent(t, e) {
        var n = t.getMinX(),
            s = t.getMaxX(),
            i = t.getMinY(),
            r = t.getMaxY();
        return n !== s && i !== r ? t : (n === s && (n -= e / 2, s += e / 2), i === r && (i -= e / 2, r += e / 2), new T(n, s, i, r));
      }
    }]);

    return Es;
  }();

  var Is = Object.freeze({
    __proto__: null,
    Quadtree: Es
  });

  var Ns = /*#__PURE__*/function () {
    function Ns() {
      _classCallCheck(this, Ns);
    }

    _createClass(Ns, [{
      key: "getBounds",
      value: function getBounds() {}
    }]);

    return Ns;
  }();

  var Ss = /*#__PURE__*/function () {
    function Ss() {
      _classCallCheck(this, Ss);

      Ss.constructor_.apply(this, arguments);
    }

    _createClass(Ss, [{
      key: "getItem",
      value: function getItem() {
        return this._item;
      }
    }, {
      key: "getBounds",
      value: function getBounds() {
        return this._bounds;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Ns, c];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._bounds = null, this._item = null;
        var t = arguments[0],
            e = arguments[1];
        this._bounds = t, this._item = e;
      }
    }]);

    return Ss;
  }();

  var ws = /*#__PURE__*/function () {
    function ws() {
      _classCallCheck(this, ws);

      ws.constructor_.apply(this, arguments);
    }

    _createClass(ws, [{
      key: "poll",
      value: function poll() {
        if (this.isEmpty()) return null;

        var t = this._items.get(1);

        return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t;
      }
    }, {
      key: "size",
      value: function size() {
        return this._size;
      }
    }, {
      key: "reorder",
      value: function reorder(t) {
        var e = null;

        var n = this._items.get(t);

        for (; 2 * t <= this._size && (e = 2 * t, e !== this._size && this._items.get(e + 1).compareTo(this._items.get(e)) < 0 && e++, this._items.get(e).compareTo(n) < 0); t = e) {
          this._items.set(t, this._items.get(e));
        }

        this._items.set(t, n);
      }
    }, {
      key: "clear",
      value: function clear() {
        this._size = 0, this._items.clear();
      }
    }, {
      key: "peek",
      value: function peek() {
        if (this.isEmpty()) return null;
        return this._items.get(1);
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return 0 === this._size;
      }
    }, {
      key: "add",
      value: function add(t) {
        this._items.add(null), this._size += 1;
        var e = this._size;

        for (this._items.set(0, t); t.compareTo(this._items.get(Math.trunc(e / 2))) < 0; e /= 2) {
          this._items.set(e, this._items.get(Math.trunc(e / 2)));
        }

        this._items.set(e, t);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._size = null, this._items = null, this._size = 0, this._items = new S(), this._items.add(null);
      }
    }]);

    return ws;
  }();

  var Cs = /*#__PURE__*/function () {
    function Cs() {
      _classCallCheck(this, Cs);

      Cs.constructor_.apply(this, arguments);
    }

    _createClass(Cs, [{
      key: "getLevel",
      value: function getLevel() {
        return this._level;
      }
    }, {
      key: "size",
      value: function size() {
        return this._childBoundables.size();
      }
    }, {
      key: "getChildBoundables",
      value: function getChildBoundables() {
        return this._childBoundables;
      }
    }, {
      key: "addChildBoundable",
      value: function addChildBoundable(t) {
        g.isTrue(null === this._bounds), this._childBoundables.add(t);
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return this._childBoundables.isEmpty();
      }
    }, {
      key: "getBounds",
      value: function getBounds() {
        return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Ns, c];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._childBoundables = new S(), this._bounds = null, this._level = null, 0 === arguments.length) ;else if (1 === arguments.length) {
          var _t453 = arguments[0];
          this._level = _t453;
        }
      }
    }]);

    return Cs;
  }();

  var Ls = /*#__PURE__*/function () {
    function Ls() {
      _classCallCheck(this, Ls);
    }

    _createClass(Ls, null, [{
      key: "maxDistance",
      value: function maxDistance(t, e, n, s, i, r, o, l) {
        var a = Ls.distance(t, e, i, r);
        return a = Math.max(a, Ls.distance(t, e, o, l)), a = Math.max(a, Ls.distance(n, s, i, r)), a = Math.max(a, Ls.distance(n, s, o, l)), a;
      }
    }, {
      key: "distance",
      value: function distance(t, e, n, s) {
        var i = n - t,
            r = s - e;
        return Math.sqrt(i * i + r * r);
      }
    }, {
      key: "maximumDistance",
      value: function maximumDistance(t, e) {
        var n = Math.min(t.getMinX(), e.getMinX()),
            s = Math.min(t.getMinY(), e.getMinY()),
            i = Math.max(t.getMaxX(), e.getMaxX()),
            r = Math.max(t.getMaxY(), e.getMaxY());
        return Ls.distance(n, s, i, r);
      }
    }, {
      key: "minMaxDistance",
      value: function minMaxDistance(t, e) {
        var n = t.getMinX(),
            s = t.getMinY(),
            i = t.getMaxX(),
            r = t.getMaxY(),
            o = e.getMinX(),
            l = e.getMinY(),
            a = e.getMaxX(),
            c = e.getMaxY();
        var h = Ls.maxDistance(n, s, n, r, o, l, o, c);
        return h = Math.min(h, Ls.maxDistance(n, s, n, r, o, l, a, l)), h = Math.min(h, Ls.maxDistance(n, s, n, r, a, c, o, c)), h = Math.min(h, Ls.maxDistance(n, s, n, r, a, c, a, l)), h = Math.min(h, Ls.maxDistance(n, s, i, s, o, l, o, c)), h = Math.min(h, Ls.maxDistance(n, s, i, s, o, l, a, l)), h = Math.min(h, Ls.maxDistance(n, s, i, s, a, c, o, c)), h = Math.min(h, Ls.maxDistance(n, s, i, s, a, c, a, l)), h = Math.min(h, Ls.maxDistance(i, r, n, r, o, l, o, c)), h = Math.min(h, Ls.maxDistance(i, r, n, r, o, l, a, l)), h = Math.min(h, Ls.maxDistance(i, r, n, r, a, c, o, c)), h = Math.min(h, Ls.maxDistance(i, r, n, r, a, c, a, l)), h = Math.min(h, Ls.maxDistance(i, r, i, s, o, l, o, c)), h = Math.min(h, Ls.maxDistance(i, r, i, s, o, l, a, l)), h = Math.min(h, Ls.maxDistance(i, r, i, s, a, c, o, c)), h = Math.min(h, Ls.maxDistance(i, r, i, s, a, c, a, l)), h;
      }
    }]);

    return Ls;
  }();

  var Ts = /*#__PURE__*/function () {
    function Ts() {
      _classCallCheck(this, Ts);

      Ts.constructor_.apply(this, arguments);
    }

    _createClass(Ts, [{
      key: "maximumDistance",
      value: function maximumDistance() {
        return Ls.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds());
      }
    }, {
      key: "expandToQueue",
      value: function expandToQueue(t, e) {
        var n = Ts.isComposite(this._boundable1),
            i = Ts.isComposite(this._boundable2);
        if (n && i) return Ts.area(this._boundable1) > Ts.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, !1, t, e), null) : (this.expand(this._boundable2, this._boundable1, !0, t, e), null);
        if (n) return this.expand(this._boundable1, this._boundable2, !1, t, e), null;
        if (i) return this.expand(this._boundable2, this._boundable1, !0, t, e), null;
        throw new s("neither boundable is composite");
      }
    }, {
      key: "isLeaves",
      value: function isLeaves() {
        return !(Ts.isComposite(this._boundable1) || Ts.isComposite(this._boundable2));
      }
    }, {
      key: "compareTo",
      value: function compareTo(t) {
        var e = t;
        return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0;
      }
    }, {
      key: "expand",
      value: function expand(t, e, n, s, i) {
        for (var _r44 = t.getChildBoundables().iterator(); _r44.hasNext();) {
          var _t454 = _r44.next();

          var _o28 = null;
          _o28 = n ? new Ts(e, _t454, this._itemDistance) : new Ts(_t454, e, this._itemDistance), _o28.getDistance() < i && s.add(_o28);
        }
      }
    }, {
      key: "getBoundable",
      value: function getBoundable(t) {
        return 0 === t ? this._boundable1 : this._boundable2;
      }
    }, {
      key: "getDistance",
      value: function getDistance() {
        return this._distance;
      }
    }, {
      key: "distance",
      value: function distance() {
        return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [o];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2];
        this._boundable1 = t, this._boundable2 = e, this._itemDistance = n, this._distance = this.distance();
      }
    }, {
      key: "area",
      value: function area(t) {
        return t.getBounds().getArea();
      }
    }, {
      key: "isComposite",
      value: function isComposite(t) {
        return t instanceof Cs;
      }
    }]);

    return Ts;
  }();

  var Rs = /*#__PURE__*/function () {
    function Rs() {
      _classCallCheck(this, Rs);

      Rs.constructor_.apply(this, arguments);
    }

    _createClass(Rs, [{
      key: "queryInternal",
      value: function queryInternal() {
        if (y(arguments[2], be) && arguments[0] instanceof Object && arguments[1] instanceof Cs) {
          var _t455 = arguments[0],
              _e356 = arguments[2],
              _n250 = arguments[1].getChildBoundables();

          for (var _s147 = 0; _s147 < _n250.size(); _s147++) {
            var _i71 = _n250.get(_s147);

            this.getIntersectsOp().intersects(_i71.getBounds(), _t455) && (_i71 instanceof Cs ? this.queryInternal(_t455, _i71, _e356) : _i71 instanceof Ss ? _e356.visitItem(_i71.getItem()) : g.shouldNeverReachHere());
          }
        } else if (y(arguments[2], I) && arguments[0] instanceof Object && arguments[1] instanceof Cs) {
          var _t456 = arguments[0],
              _e357 = arguments[2],
              _n251 = arguments[1].getChildBoundables();

          for (var _s148 = 0; _s148 < _n251.size(); _s148++) {
            var _i72 = _n251.get(_s148);

            this.getIntersectsOp().intersects(_i72.getBounds(), _t456) && (_i72 instanceof Cs ? this.queryInternal(_t456, _i72, _e357) : _i72 instanceof Ss ? _e357.add(_i72.getItem()) : g.shouldNeverReachHere());
          }
        }
      }
    }, {
      key: "getNodeCapacity",
      value: function getNodeCapacity() {
        return this._nodeCapacity;
      }
    }, {
      key: "lastNode",
      value: function lastNode(t) {
        return t.get(t.size() - 1);
      }
    }, {
      key: "size",
      value: function size() {
        if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));

        if (1 === arguments.length) {
          var _t457 = 0;

          for (var _e358 = arguments[0].getChildBoundables().iterator(); _e358.hasNext();) {
            var _n252 = _e358.next();

            _n252 instanceof Cs ? _t457 += this.size(_n252) : _n252 instanceof Ss && (_t457 += 1);
          }

          return _t457;
        }
      }
    }, {
      key: "removeItem",
      value: function removeItem(t, e) {
        var n = null;

        for (var _s149 = t.getChildBoundables().iterator(); _s149.hasNext();) {
          var _t458 = _s149.next();

          _t458 instanceof Ss && _t458.getItem() === e && (n = _t458);
        }

        return null !== n && (t.getChildBoundables().remove(n), !0);
      }
    }, {
      key: "itemsTree",
      value: function itemsTree() {
        if (0 === arguments.length) {
          this.build();

          var _t459 = this.itemsTree(this._root);

          return null === _t459 ? new S() : _t459;
        }

        if (1 === arguments.length) {
          var _t460 = arguments[0],
              _e359 = new S();

          for (var _n253 = _t460.getChildBoundables().iterator(); _n253.hasNext();) {
            var _t461 = _n253.next();

            if (_t461 instanceof Cs) {
              var _n254 = this.itemsTree(_t461);

              null !== _n254 && _e359.add(_n254);
            } else _t461 instanceof Ss ? _e359.add(_t461.getItem()) : g.shouldNeverReachHere();
          }

          return _e359.size() <= 0 ? null : _e359;
        }
      }
    }, {
      key: "insert",
      value: function insert(t, e) {
        g.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new Ss(t, e));
      }
    }, {
      key: "boundablesAtLevel",
      value: function boundablesAtLevel() {
        if (1 === arguments.length) {
          var _t462 = arguments[0],
              _e360 = new S();

          return this.boundablesAtLevel(_t462, this._root, _e360), _e360;
        }

        if (3 === arguments.length) {
          var _t463 = arguments[0],
              _e361 = arguments[1],
              _n255 = arguments[2];
          if (g.isTrue(_t463 > -2), _e361.getLevel() === _t463) return _n255.add(_e361), null;

          for (var _s150 = _e361.getChildBoundables().iterator(); _s150.hasNext();) {
            var _e362 = _s150.next();

            _e362 instanceof Cs ? this.boundablesAtLevel(_t463, _e362, _n255) : (g.isTrue(_e362 instanceof Ss), -1 === _t463 && _n255.add(_e362));
          }

          return null;
        }
      }
    }, {
      key: "query",
      value: function query() {
        if (1 === arguments.length) {
          var _t464 = arguments[0];
          this.build();

          var _e363 = new S();

          return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), _t464) && this.queryInternal(_t464, this._root, _e363), _e363;
        }

        if (2 === arguments.length) {
          var _t465 = arguments[0],
              _e364 = arguments[1];
          if (this.build(), this.isEmpty()) return null;
          this.getIntersectsOp().intersects(this._root.getBounds(), _t465) && this.queryInternal(_t465, this._root, _e364);
        }
      }
    }, {
      key: "build",
      value: function build() {
        if (this._built) return null;
        this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0;
      }
    }, {
      key: "getRoot",
      value: function getRoot() {
        return this.build(), this._root;
      }
    }, {
      key: "remove",
      value: function remove() {
        if (2 === arguments.length) {
          var _t466 = arguments[0],
              _e365 = arguments[1];
          return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), _t466) && this.remove(_t466, this._root, _e365);
        }

        if (3 === arguments.length) {
          var _t467 = arguments[0],
              _e366 = arguments[1],
              _n256 = arguments[2];

          var _s151 = this.removeItem(_e366, _n256);

          if (_s151) return !0;
          var _i73 = null;

          for (var _r45 = _e366.getChildBoundables().iterator(); _r45.hasNext();) {
            var _e367 = _r45.next();

            if (this.getIntersectsOp().intersects(_e367.getBounds(), _t467) && _e367 instanceof Cs && (_s151 = this.remove(_t467, _e367, _n256), _s151)) {
              _i73 = _e367;
              break;
            }
          }

          return null !== _i73 && _i73.getChildBoundables().isEmpty() && _e366.getChildBoundables().remove(_i73), _s151;
        }
      }
    }, {
      key: "createHigherLevels",
      value: function createHigherLevels(t, e) {
        g.isTrue(!t.isEmpty());
        var n = this.createParentBoundables(t, e + 1);
        return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1);
      }
    }, {
      key: "depth",
      value: function depth() {
        if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));

        if (1 === arguments.length) {
          var _t468 = 0;

          for (var _e368 = arguments[0].getChildBoundables().iterator(); _e368.hasNext();) {
            var _n257 = _e368.next();

            if (_n257 instanceof Cs) {
              var _e369 = this.depth(_n257);

              _e369 > _t468 && (_t468 = _e369);
            }
          }

          return _t468 + 1;
        }
      }
    }, {
      key: "createParentBoundables",
      value: function createParentBoundables(t, e) {
        g.isTrue(!t.isEmpty());
        var n = new S();
        n.add(this.createNode(e));
        var s = new S(t);
        ye.sort(s, this.getComparator());

        for (var _t469 = s.iterator(); _t469.hasNext();) {
          var _s152 = _t469.next();

          this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() && n.add(this.createNode(e)), this.lastNode(n).addChildBoundable(_s152);
        }

        return n;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [c];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._root = null, this._built = !1, this._itemBoundables = new S(), this._nodeCapacity = null, 0 === arguments.length) Rs.constructor_.call(this, Rs.DEFAULT_NODE_CAPACITY);else if (1 === arguments.length) {
          var _t470 = arguments[0];
          g.isTrue(_t470 > 1, "Node capacity must be greater than 1"), this._nodeCapacity = _t470;
        }
      }
    }, {
      key: "compareDoubles",
      value: function compareDoubles(t, e) {
        return t > e ? 1 : t < e ? -1 : 0;
      }
    }]);

    return Rs;
  }();

  Rs.IntersectsOp = function () {}, Rs.DEFAULT_NODE_CAPACITY = 10;

  var Ps = /*#__PURE__*/function () {
    function Ps() {
      _classCallCheck(this, Ps);
    }

    _createClass(Ps, [{
      key: "distance",
      value: function distance(t, e) {}
    }]);

    return Ps;
  }();

  var Os = /*#__PURE__*/function (_Rs) {
    _inherits(Os, _Rs);

    var _super48 = _createSuper(Os);

    function Os() {
      var _this35;

      _classCallCheck(this, Os);

      _this35 = _super48.call(this), Os.constructor_.apply(_assertThisInitialized(_this35), arguments);
      return _this35;
    }

    _createClass(Os, [{
      key: "createParentBoundablesFromVerticalSlices",
      value: function createParentBoundablesFromVerticalSlices(t, e) {
        g.isTrue(t.length > 0);
        var n = new S();

        for (var _s153 = 0; _s153 < t.length; _s153++) {
          n.addAll(this.createParentBoundablesFromVerticalSlice(t[_s153], e));
        }

        return n;
      }
    }, {
      key: "nearestNeighbourK",
      value: function nearestNeighbourK() {
        if (2 === arguments.length) {
          var _t471 = arguments[0],
              _e370 = arguments[1];
          return this.nearestNeighbourK(_t471, r.POSITIVE_INFINITY, _e370);
        }

        if (3 === arguments.length) {
          var _t472 = arguments[0],
              _e371 = arguments[2];
          var _n258 = arguments[1];

          var _s154 = new ws();

          _s154.add(_t472);

          var _i74 = new ws();

          for (; !_s154.isEmpty() && _n258 >= 0;) {
            var _t473 = _s154.poll(),
                _r46 = _t473.getDistance();

            if (_r46 >= _n258) break;
            if (_t473.isLeaves()) {
              if (_i74.size() < _e371) _i74.add(_t473);else {
                _i74.peek().getDistance() > _r46 && (_i74.poll(), _i74.add(_t473));
                _n258 = _i74.peek().getDistance();
              }
            } else _t473.expandToQueue(_s154, _n258);
          }

          return Os.getItems(_i74);
        }
      }
    }, {
      key: "createNode",
      value: function createNode(t) {
        return new vs(t);
      }
    }, {
      key: "size",
      value: function size() {
        return 0 === arguments.length ? _get(_getPrototypeOf(Os.prototype), "size", this).call(this) : _get(_getPrototypeOf(Os.prototype), "size", this).apply(this, arguments);
      }
    }, {
      key: "insert",
      value: function insert() {
        if (!(2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof T)) return _get(_getPrototypeOf(Os.prototype), "insert", this).apply(this, arguments);
        {
          var _t474 = arguments[0],
              _e372 = arguments[1];
          if (_t474.isNull()) return null;

          _get(_getPrototypeOf(Os.prototype), "insert", this).call(this, _t474, _e372);
        }
      }
    }, {
      key: "getIntersectsOp",
      value: function getIntersectsOp() {
        return Os.intersectsOp;
      }
    }, {
      key: "verticalSlices",
      value: function verticalSlices(t, e) {
        var n = Math.trunc(Math.ceil(t.size() / e)),
            s = new Array(e).fill(null),
            i = t.iterator();

        for (var _t475 = 0; _t475 < e; _t475++) {
          s[_t475] = new S();
          var _e373 = 0;

          for (; i.hasNext() && _e373 < n;) {
            var _n259 = i.next();

            s[_t475].add(_n259), _e373++;
          }
        }

        return s;
      }
    }, {
      key: "query",
      value: function query() {
        if (1 === arguments.length) {
          var _t476 = arguments[0];
          return _get(_getPrototypeOf(Os.prototype), "query", this).call(this, _t476);
        }

        if (2 === arguments.length) {
          var _t477 = arguments[0],
              _e374 = arguments[1];

          _get(_getPrototypeOf(Os.prototype), "query", this).call(this, _t477, _e374);
        }
      }
    }, {
      key: "getComparator",
      value: function getComparator() {
        return Os.yComparator;
      }
    }, {
      key: "createParentBoundablesFromVerticalSlice",
      value: function createParentBoundablesFromVerticalSlice(t, e) {
        return _get(_getPrototypeOf(Os.prototype), "createParentBoundables", this).call(this, t, e);
      }
    }, {
      key: "remove",
      value: function remove() {
        if (2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof T) {
          var _t478 = arguments[0],
              _e375 = arguments[1];
          return _get(_getPrototypeOf(Os.prototype), "remove", this).call(this, _t478, _e375);
        }

        return _get(_getPrototypeOf(Os.prototype), "remove", this).apply(this, arguments);
      }
    }, {
      key: "depth",
      value: function depth() {
        return 0 === arguments.length ? _get(_getPrototypeOf(Os.prototype), "depth", this).call(this) : _get(_getPrototypeOf(Os.prototype), "depth", this).apply(this, arguments);
      }
    }, {
      key: "createParentBoundables",
      value: function createParentBoundables(t, e) {
        g.isTrue(!t.isEmpty());
        var n = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())),
            s = new S(t);
        ye.sort(s, Os.xComparator);
        var i = this.verticalSlices(s, Math.trunc(Math.ceil(Math.sqrt(n))));
        return this.createParentBoundablesFromVerticalSlices(i, e);
      }
    }, {
      key: "nearestNeighbour",
      value: function nearestNeighbour() {
        if (1 === arguments.length) {
          if (y(arguments[0], Ps)) {
            var _t479 = arguments[0];
            if (this.isEmpty()) return null;

            var _e376 = new Ts(this.getRoot(), this.getRoot(), _t479);

            return this.nearestNeighbour(_e376);
          }

          if (arguments[0] instanceof Ts) {
            var _t480 = arguments[0];
            var _e377 = r.POSITIVE_INFINITY,
                _n260 = null;

            var _s155 = new ws();

            for (_s155.add(_t480); !_s155.isEmpty() && _e377 > 0;) {
              var _t481 = _s155.poll(),
                  _i75 = _t481.getDistance();

              if (_i75 >= _e377) break;
              _t481.isLeaves() ? (_e377 = _i75, _n260 = _t481) : _t481.expandToQueue(_s155, _e377);
            }

            return null === _n260 ? null : [_n260.getBoundable(0).getItem(), _n260.getBoundable(1).getItem()];
          }
        } else {
          if (2 === arguments.length) {
            var _t482 = arguments[0],
                _e378 = arguments[1];
            if (this.isEmpty() || _t482.isEmpty()) return null;

            var _n261 = new Ts(this.getRoot(), _t482.getRoot(), _e378);

            return this.nearestNeighbour(_n261);
          }

          if (3 === arguments.length) {
            var _t483 = arguments[2],
                _e379 = new Ss(arguments[0], arguments[1]),
                _n262 = new Ts(this.getRoot(), _e379, _t483);

            return this.nearestNeighbour(_n262)[0];
          }

          if (4 === arguments.length) {
            var _t484 = arguments[2],
                _e380 = arguments[3],
                _n263 = new Ss(arguments[0], arguments[1]),
                _s156 = new Ts(this.getRoot(), _n263, _t484);

            return this.nearestNeighbourK(_s156, _e380);
          }
        }
      }
    }, {
      key: "isWithinDistance",
      value: function isWithinDistance() {
        if (2 === arguments.length) {
          var _t485 = arguments[0],
              _e381 = arguments[1];
          var _n264 = r.POSITIVE_INFINITY;

          var _s157 = new ws();

          for (_s157.add(_t485); !_s157.isEmpty();) {
            var _t486 = _s157.poll(),
                _i76 = _t486.getDistance();

            if (_i76 > _e381) return !1;
            if (_t486.maximumDistance() <= _e381) return !0;

            if (_t486.isLeaves()) {
              if (_n264 = _i76, _n264 <= _e381) return !0;
            } else _t486.expandToQueue(_s157, _n264);
          }

          return !1;
        }

        if (3 === arguments.length) {
          var _t487 = arguments[0],
              _e382 = arguments[1],
              _n265 = arguments[2],
              _s158 = new Ts(this.getRoot(), _t487.getRoot(), _e382);

          return this.isWithinDistance(_s158, _n265);
        }
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [xs, c];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (0 === arguments.length) Os.constructor_.call(this, Os.DEFAULT_NODE_CAPACITY);else if (1 === arguments.length) {
          var _t488 = arguments[0];
          Rs.constructor_.call(this, _t488);
        }
      }
    }, {
      key: "centreX",
      value: function centreX(t) {
        return Os.avg(t.getMinX(), t.getMaxX());
      }
    }, {
      key: "avg",
      value: function avg(t, e) {
        return (t + e) / 2;
      }
    }, {
      key: "getItems",
      value: function getItems(t) {
        var e = new Array(t.size()).fill(null);
        var n = 0;

        for (; !t.isEmpty();) {
          var _s159 = t.poll();

          e[n] = _s159.getBoundable(0).getItem(), n++;
        }

        return e;
      }
    }, {
      key: "centreY",
      value: function centreY(t) {
        return Os.avg(t.getMinY(), t.getMaxY());
      }
    }]);

    return Os;
  }(Rs);

  var vs = /*#__PURE__*/function (_Cs) {
    _inherits(vs, _Cs);

    var _super49 = _createSuper(vs);

    function vs() {
      var _this36;

      _classCallCheck(this, vs);

      _this36 = _super49.call(this), vs.constructor_.apply(_assertThisInitialized(_this36), arguments);
      return _this36;
    }

    _createClass(vs, [{
      key: "computeBounds",
      value: function computeBounds() {
        var t = null;

        for (var _e383 = this.getChildBoundables().iterator(); _e383.hasNext();) {
          var _n266 = _e383.next();

          null === t ? t = new T(_n266.getBounds()) : t.expandToInclude(_n266.getBounds());
        }

        return t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        var t = arguments[0];
        Cs.constructor_.call(this, t);
      }
    }]);

    return vs;
  }(Cs);

  Os.STRtreeNode = vs, Os.xComparator = new ( /*#__PURE__*/function () {
    function _class10() {
      _classCallCheck(this, _class10);
    }

    _createClass(_class10, [{
      key: "compare",
      value: function compare(t, e) {
        return Rs.compareDoubles(Os.centreX(t.getBounds()), Os.centreX(e.getBounds()));
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [a];
      }
    }]);

    return _class10;
  }())(), Os.yComparator = new ( /*#__PURE__*/function () {
    function _class11() {
      _classCallCheck(this, _class11);
    }

    _createClass(_class11, [{
      key: "compare",
      value: function compare(t, e) {
        return Rs.compareDoubles(Os.centreY(t.getBounds()), Os.centreY(e.getBounds()));
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [a];
      }
    }]);

    return _class11;
  }())(), Os.intersectsOp = new ( /*#__PURE__*/function () {
    function _class12() {
      _classCallCheck(this, _class12);
    }

    _createClass(_class12, [{
      key: "intersects",
      value: function intersects(t, e) {
        return t.intersects(e);
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [IntersectsOp];
      }
    }]);

    return _class12;
  }())(), Os.DEFAULT_NODE_CAPACITY = 10;
  var Ms = Object.freeze({
    __proto__: null,
    STRtree: Os
  }),
      bs = Object.freeze({
    __proto__: null,
    kdtree: gs,
    quadtree: Is,
    strtree: Ms
  });
  var Ds = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"];

  var As = /*#__PURE__*/function () {
    function As(t) {
      _classCallCheck(this, As);

      this.geometryFactory = t || new Ct();
    }

    _createClass(As, [{
      key: "read",
      value: function read(t) {
        var e;
        e = "string" == typeof t ? JSON.parse(t) : t;
        var n = e.type;
        if (!Fs[n]) throw new Error("Unknown GeoJSON type: " + e.type);
        return -1 !== Ds.indexOf(n) ? Fs[n].call(this, e.coordinates) : "GeometryCollection" === n ? Fs[n].call(this, e.geometries) : Fs[n].call(this, e);
      }
    }, {
      key: "write",
      value: function write(t) {
        var e = t.getGeometryType();
        if (!Gs[e]) throw new Error("Geometry is not supported");
        return Gs[e].call(this, t);
      }
    }]);

    return As;
  }();

  var Fs = {
    Feature: function Feature(t) {
      var e = {};

      for (var _n267 in t) {
        e[_n267] = t[_n267];
      }

      if (t.geometry) {
        var _n268 = t.geometry.type;
        if (!Fs[_n268]) throw new Error("Unknown GeoJSON type: " + t.type);
        e.geometry = this.read(t.geometry);
      }

      return t.bbox && (e.bbox = Fs.bbox.call(this, t.bbox)), e;
    },
    FeatureCollection: function FeatureCollection(t) {
      var e = {};

      if (t.features) {
        e.features = [];

        for (var _n269 = 0; _n269 < t.features.length; ++_n269) {
          e.features.push(this.read(t.features[_n269]));
        }
      }

      return t.bbox && (e.bbox = this.parse.bbox.call(this, t.bbox)), e;
    },
    coordinates: function coordinates(t) {
      var e = [];

      for (var _n270 = 0; _n270 < t.length; ++_n270) {
        var _s160 = t[_n270];
        e.push(new m(_s160[0], _s160[1]));
      }

      return e;
    },
    bbox: function bbox(t) {
      return this.geometryFactory.createLinearRing([new m(t[0], t[1]), new m(t[2], t[1]), new m(t[2], t[3]), new m(t[0], t[3]), new m(t[0], t[1])]);
    },
    Point: function Point(t) {
      var e = _construct(m, _toConsumableArray(t));

      return this.geometryFactory.createPoint(e);
    },
    MultiPoint: function MultiPoint(t) {
      var e = [];

      for (var _n271 = 0; _n271 < t.length; ++_n271) {
        e.push(Fs.Point.call(this, t[_n271]));
      }

      return this.geometryFactory.createMultiPoint(e);
    },
    LineString: function LineString(t) {
      var e = Fs.coordinates.call(this, t);
      return this.geometryFactory.createLineString(e);
    },
    MultiLineString: function MultiLineString(t) {
      var e = [];

      for (var _n272 = 0; _n272 < t.length; ++_n272) {
        e.push(Fs.LineString.call(this, t[_n272]));
      }

      return this.geometryFactory.createMultiLineString(e);
    },
    Polygon: function Polygon(t) {
      var e = Fs.coordinates.call(this, t[0]),
          n = this.geometryFactory.createLinearRing(e),
          s = [];

      for (var _e384 = 1; _e384 < t.length; ++_e384) {
        var _n273 = t[_e384],
            _i77 = Fs.coordinates.call(this, _n273),
            _r47 = this.geometryFactory.createLinearRing(_i77);

        s.push(_r47);
      }

      return this.geometryFactory.createPolygon(n, s);
    },
    MultiPolygon: function MultiPolygon(t) {
      var e = [];

      for (var _n274 = 0; _n274 < t.length; ++_n274) {
        var _s161 = t[_n274];
        e.push(Fs.Polygon.call(this, _s161));
      }

      return this.geometryFactory.createMultiPolygon(e);
    },
    GeometryCollection: function GeometryCollection(t) {
      var e = [];

      for (var _n275 = 0; _n275 < t.length; ++_n275) {
        var _s162 = t[_n275];
        e.push(this.read(_s162));
      }

      return this.geometryFactory.createGeometryCollection(e);
    }
  },
      Gs = {
    coordinate: function coordinate(t) {
      var e = [t.x, t.y];
      return t.z && e.push(t.z), t.m && e.push(t.m), e;
    },
    Point: function Point(t) {
      return {
        type: "Point",
        coordinates: Gs.coordinate.call(this, t.getCoordinate())
      };
    },
    MultiPoint: function MultiPoint(t) {
      var e = [];

      for (var _n276 = 0; _n276 < t._geometries.length; ++_n276) {
        var _s163 = t._geometries[_n276],
            _i78 = Gs.Point.call(this, _s163);

        e.push(_i78.coordinates);
      }

      return {
        type: "MultiPoint",
        coordinates: e
      };
    },
    LineString: function LineString(t) {
      var e = [],
          n = t.getCoordinates();

      for (var _t489 = 0; _t489 < n.length; ++_t489) {
        var _s164 = n[_t489];
        e.push(Gs.coordinate.call(this, _s164));
      }

      return {
        type: "LineString",
        coordinates: e
      };
    },
    MultiLineString: function MultiLineString(t) {
      var e = [];

      for (var _n277 = 0; _n277 < t._geometries.length; ++_n277) {
        var _s165 = t._geometries[_n277],
            _i79 = Gs.LineString.call(this, _s165);

        e.push(_i79.coordinates);
      }

      return {
        type: "MultiLineString",
        coordinates: e
      };
    },
    Polygon: function Polygon(t) {
      var e = [],
          n = Gs.LineString.call(this, t._shell);
      e.push(n.coordinates);

      for (var _n278 = 0; _n278 < t._holes.length; ++_n278) {
        var _s166 = t._holes[_n278],
            _i80 = Gs.LineString.call(this, _s166);

        e.push(_i80.coordinates);
      }

      return {
        type: "Polygon",
        coordinates: e
      };
    },
    MultiPolygon: function MultiPolygon(t) {
      var e = [];

      for (var _n279 = 0; _n279 < t._geometries.length; ++_n279) {
        var _s167 = t._geometries[_n279],
            _i81 = Gs.Polygon.call(this, _s167);

        e.push(_i81.coordinates);
      }

      return {
        type: "MultiPolygon",
        coordinates: e
      };
    },
    GeometryCollection: function GeometryCollection(t) {
      var e = [];

      for (var _n280 = 0; _n280 < t._geometries.length; ++_n280) {
        var _s168 = t._geometries[_n280],
            _i82 = _s168.getGeometryType();

        e.push(Gs[_i82].call(this, _s168));
      }

      return {
        type: "GeometryCollection",
        geometries: e
      };
    }
  };

  function qs(t) {
    return [t.x, t.y];
  }

  var Bs = Object.freeze({
    __proto__: null,
    GeoJSONReader: /*#__PURE__*/function () {
      function GeoJSONReader(t) {
        _classCallCheck(this, GeoJSONReader);

        this.parser = new As(t || new Ct());
      }

      _createClass(GeoJSONReader, [{
        key: "read",
        value: function read(t) {
          return this.parser.read(t);
        }
      }]);

      return GeoJSONReader;
    }(),
    GeoJSONWriter: /*#__PURE__*/function () {
      function GeoJSONWriter() {
        _classCallCheck(this, GeoJSONWriter);

        this.parser = new As(this.geometryFactory);
      }

      _createClass(GeoJSONWriter, [{
        key: "write",
        value: function write(t) {
          return this.parser.write(t);
        }
      }]);

      return GeoJSONWriter;
    }(),
    OL3Parser: /*#__PURE__*/function () {
      function OL3Parser(t, e) {
        _classCallCheck(this, OL3Parser);

        this.geometryFactory = t || new Ct(), this.ol = e || "undefined" != typeof ol && ol;
      }

      _createClass(OL3Parser, [{
        key: "inject",
        value: function inject(t, e, n, s, i, r, o, l) {
          this.ol = {
            geom: {
              Point: t,
              LineString: e,
              LinearRing: n,
              Polygon: s,
              MultiPoint: i,
              MultiLineString: r,
              MultiPolygon: o,
              GeometryCollection: l
            }
          };
        }
      }, {
        key: "read",
        value: function read(t) {
          var e = this.ol;
          return t instanceof e.geom.Point ? this.convertFromPoint(t) : t instanceof e.geom.LineString ? this.convertFromLineString(t) : t instanceof e.geom.LinearRing ? this.convertFromLinearRing(t) : t instanceof e.geom.Polygon ? this.convertFromPolygon(t) : t instanceof e.geom.MultiPoint ? this.convertFromMultiPoint(t) : t instanceof e.geom.MultiLineString ? this.convertFromMultiLineString(t) : t instanceof e.geom.MultiPolygon ? this.convertFromMultiPolygon(t) : t instanceof e.geom.GeometryCollection ? this.convertFromCollection(t) : void 0;
        }
      }, {
        key: "convertFromPoint",
        value: function convertFromPoint(t) {
          var e = t.getCoordinates();
          return this.geometryFactory.createPoint(new m(e[0], e[1]));
        }
      }, {
        key: "convertFromLineString",
        value: function convertFromLineString(t) {
          return this.geometryFactory.createLineString(t.getCoordinates().map(function (t) {
            return new m(t[0], t[1]);
          }));
        }
      }, {
        key: "convertFromLinearRing",
        value: function convertFromLinearRing(t) {
          return this.geometryFactory.createLinearRing(t.getCoordinates().map(function (t) {
            return new m(t[0], t[1]);
          }));
        }
      }, {
        key: "convertFromPolygon",
        value: function convertFromPolygon(t) {
          var e = t.getLinearRings();
          var n = null;
          var s = [];

          for (var _t490 = 0; _t490 < e.length; _t490++) {
            var _i83 = this.convertFromLinearRing(e[_t490]);

            0 === _t490 ? n = _i83 : s.push(_i83);
          }

          return this.geometryFactory.createPolygon(n, s);
        }
      }, {
        key: "convertFromMultiPoint",
        value: function convertFromMultiPoint(t) {
          var e = t.getPoints().map(function (t) {
            return this.convertFromPoint(t);
          }, this);
          return this.geometryFactory.createMultiPoint(e);
        }
      }, {
        key: "convertFromMultiLineString",
        value: function convertFromMultiLineString(t) {
          var e = t.getLineStrings().map(function (t) {
            return this.convertFromLineString(t);
          }, this);
          return this.geometryFactory.createMultiLineString(e);
        }
      }, {
        key: "convertFromMultiPolygon",
        value: function convertFromMultiPolygon(t) {
          var e = t.getPolygons().map(function (t) {
            return this.convertFromPolygon(t);
          }, this);
          return this.geometryFactory.createMultiPolygon(e);
        }
      }, {
        key: "convertFromCollection",
        value: function convertFromCollection(t) {
          var e = t.getGeometries().map(function (t) {
            return this.read(t);
          }, this);
          return this.geometryFactory.createGeometryCollection(e);
        }
      }, {
        key: "write",
        value: function write(t) {
          return "Point" === t.getGeometryType() ? this.convertToPoint(t.getCoordinate()) : "LineString" === t.getGeometryType() ? this.convertToLineString(t) : "LinearRing" === t.getGeometryType() ? this.convertToLinearRing(t) : "Polygon" === t.getGeometryType() ? this.convertToPolygon(t) : "MultiPoint" === t.getGeometryType() ? this.convertToMultiPoint(t) : "MultiLineString" === t.getGeometryType() ? this.convertToMultiLineString(t) : "MultiPolygon" === t.getGeometryType() ? this.convertToMultiPolygon(t) : "GeometryCollection" === t.getGeometryType() ? this.convertToCollection(t) : void 0;
        }
      }, {
        key: "convertToPoint",
        value: function convertToPoint(t) {
          return new this.ol.geom.Point([t.x, t.y]);
        }
      }, {
        key: "convertToLineString",
        value: function convertToLineString(t) {
          var e = t._points._coordinates.map(qs);

          return new this.ol.geom.LineString(e);
        }
      }, {
        key: "convertToLinearRing",
        value: function convertToLinearRing(t) {
          var e = t._points._coordinates.map(qs);

          return new this.ol.geom.LinearRing(e);
        }
      }, {
        key: "convertToPolygon",
        value: function convertToPolygon(t) {
          var e = [t._shell._points._coordinates.map(qs)];

          for (var _n281 = 0; _n281 < t._holes.length; _n281++) {
            e.push(t._holes[_n281]._points._coordinates.map(qs));
          }

          return new this.ol.geom.Polygon(e);
        }
      }, {
        key: "convertToMultiPoint",
        value: function convertToMultiPoint(t) {
          return new this.ol.geom.MultiPoint(t.getCoordinates().map(qs));
        }
      }, {
        key: "convertToMultiLineString",
        value: function convertToMultiLineString(t) {
          var e = [];

          for (var _n282 = 0; _n282 < t._geometries.length; _n282++) {
            e.push(this.convertToLineString(t._geometries[_n282]).getCoordinates());
          }

          return new this.ol.geom.MultiLineString(e);
        }
      }, {
        key: "convertToMultiPolygon",
        value: function convertToMultiPolygon(t) {
          var e = [];

          for (var _n283 = 0; _n283 < t._geometries.length; _n283++) {
            e.push(this.convertToPolygon(t._geometries[_n283]).getCoordinates());
          }

          return new this.ol.geom.MultiPolygon(e);
        }
      }, {
        key: "convertToCollection",
        value: function convertToCollection(t) {
          var e = [];

          for (var _n284 = 0; _n284 < t._geometries.length; _n284++) {
            var _s169 = t._geometries[_n284];
            e.push(this.write(_s169));
          }

          return new this.ol.geom.GeometryCollection(e);
        }
      }]);

      return OL3Parser;
    }(),
    WKTReader: /*#__PURE__*/function () {
      function WKTReader(t) {
        _classCallCheck(this, WKTReader);

        this.parser = new Ut(t || new Ct());
      }

      _createClass(WKTReader, [{
        key: "read",
        value: function read(t) {
          return this.parser.read(t);
        }
      }]);

      return WKTReader;
    }(),
    WKTWriter: Ht
  });

  var Ys = /*#__PURE__*/function () {
    function Ys() {
      _classCallCheck(this, Ys);
    }

    _createClass(Ys, null, [{
      key: "relativeSign",
      value: function relativeSign(t, e) {
        return t < e ? -1 : t > e ? 1 : 0;
      }
    }, {
      key: "compare",
      value: function compare(t, e, n) {
        if (e.equals2D(n)) return 0;
        var s = Ys.relativeSign(e.x, n.x),
            i = Ys.relativeSign(e.y, n.y);

        switch (t) {
          case 0:
            return Ys.compareValue(s, i);

          case 1:
            return Ys.compareValue(i, s);

          case 2:
            return Ys.compareValue(i, -s);

          case 3:
            return Ys.compareValue(-s, i);

          case 4:
            return Ys.compareValue(-s, -i);

          case 5:
            return Ys.compareValue(-i, -s);

          case 6:
            return Ys.compareValue(-i, s);

          case 7:
            return Ys.compareValue(s, -i);
        }

        return g.shouldNeverReachHere("invalid octant value"), 0;
      }
    }, {
      key: "compareValue",
      value: function compareValue(t, e) {
        return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0;
      }
    }]);

    return Ys;
  }();

  var Vs = /*#__PURE__*/function () {
    function Vs() {
      _classCallCheck(this, Vs);

      Vs.constructor_.apply(this, arguments);
    }

    _createClass(Vs, [{
      key: "getCoordinate",
      value: function getCoordinate() {
        return this.coord;
      }
    }, {
      key: "print",
      value: function print(t) {
        t.print(this.coord), t.print(" seg # = " + this.segmentIndex);
      }
    }, {
      key: "compareTo",
      value: function compareTo(t) {
        var e = t;
        return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : this._isInterior ? e._isInterior ? Ys.compare(this._segmentOctant, this.coord, e.coord) : 1 : -1;
      }
    }, {
      key: "isEndPoint",
      value: function isEndPoint(t) {
        return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t;
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.segmentIndex + ":" + this.coord.toString();
      }
    }, {
      key: "isInterior",
      value: function isInterior() {
        return this._isInterior;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [o];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2],
            s = arguments[3];
        this._segString = t, this.coord = new m(e), this.segmentIndex = n, this._segmentOctant = s, this._isInterior = !e.equals2D(t.getCoordinate(n));
      }
    }]);

    return Vs;
  }();

  var zs = /*#__PURE__*/function () {
    function zs() {
      _classCallCheck(this, zs);

      zs.constructor_.apply(this, arguments);
    }

    _createClass(zs, [{
      key: "getSplitCoordinates",
      value: function getSplitCoordinates() {
        var t = new C();
        this.addEndpoints();
        var e = this.iterator();
        var n = e.next();

        for (; e.hasNext();) {
          var _s170 = e.next();

          this.addEdgeCoordinates(n, _s170, t), n = _s170;
        }

        return t.toCoordinateArray();
      }
    }, {
      key: "addCollapsedNodes",
      value: function addCollapsedNodes() {
        var t = new S();
        this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);

        for (var _e385 = t.iterator(); _e385.hasNext();) {
          var _t491 = _e385.next().intValue();

          this.add(this._edge.getCoordinate(_t491), _t491);
        }
      }
    }, {
      key: "createSplitEdgePts",
      value: function createSplitEdgePts(t, e) {
        var n = e.segmentIndex - t.segmentIndex + 2;
        if (2 === n) return [new m(t.coord), new m(e.coord)];

        var s = this._edge.getCoordinate(e.segmentIndex),
            i = e.isInterior() || !e.coord.equals2D(s);

        i || n--;
        var r = new Array(n).fill(null);
        var o = 0;
        r[o++] = new m(t.coord);

        for (var _n285 = t.segmentIndex + 1; _n285 <= e.segmentIndex; _n285++) {
          r[o++] = this._edge.getCoordinate(_n285);
        }

        return i && (r[o] = new m(e.coord)), r;
      }
    }, {
      key: "print",
      value: function print(t) {
        t.println("Intersections:");

        for (var _e386 = this.iterator(); _e386.hasNext();) {
          _e386.next().print(t);
        }
      }
    }, {
      key: "findCollapsesFromExistingVertices",
      value: function findCollapsesFromExistingVertices(t) {
        for (var _e387 = 0; _e387 < this._edge.size() - 2; _e387++) {
          var _n286 = this._edge.getCoordinate(_e387),
              _s171 = (this._edge.getCoordinate(_e387 + 1), this._edge.getCoordinate(_e387 + 2));

          _n286.equals2D(_s171) && t.add(P.valueOf(_e387 + 1));
        }
      }
    }, {
      key: "addEdgeCoordinates",
      value: function addEdgeCoordinates(t, e, n) {
        var s = this.createSplitEdgePts(t, e);
        n.add(s, !1);
      }
    }, {
      key: "iterator",
      value: function iterator() {
        return this._nodeMap.values().iterator();
      }
    }, {
      key: "addSplitEdges",
      value: function addSplitEdges(t) {
        this.addEndpoints(), this.addCollapsedNodes();
        var e = this.iterator();
        var n = e.next();

        for (; e.hasNext();) {
          var _s172 = e.next(),
              _i84 = this.createSplitEdge(n, _s172);

          t.add(_i84), n = _s172;
        }
      }
    }, {
      key: "findCollapseIndex",
      value: function findCollapseIndex(t, e, n) {
        if (!t.coord.equals2D(e.coord)) return !1;
        var s = e.segmentIndex - t.segmentIndex;
        return e.isInterior() || s--, 1 === s && (n[0] = t.segmentIndex + 1, !0);
      }
    }, {
      key: "findCollapsesFromInsertedNodes",
      value: function findCollapsesFromInsertedNodes(t) {
        var e = new Array(1).fill(null),
            n = this.iterator();
        var s = n.next();

        for (; n.hasNext();) {
          var _i85 = n.next();

          this.findCollapseIndex(s, _i85, e) && t.add(P.valueOf(e[0])), s = _i85;
        }
      }
    }, {
      key: "getEdge",
      value: function getEdge() {
        return this._edge;
      }
    }, {
      key: "addEndpoints",
      value: function addEndpoints() {
        var t = this._edge.size() - 1;
        this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t), t);
      }
    }, {
      key: "createSplitEdge",
      value: function createSplitEdge(t, e) {
        var n = this.createSplitEdgePts(t, e);
        return new Hs(n, this._edge.getData());
      }
    }, {
      key: "add",
      value: function add(t, e) {
        var n = new Vs(this._edge, t, e, this._edge.getSegmentOctant(e)),
            s = this._nodeMap.get(n);

        return null !== s ? (g.isTrue(s.coord.equals2D(t), "Found equal nodes with different coordinates"), s) : (this._nodeMap.put(n, n), n);
      }
    }, {
      key: "checkSplitEdgesCorrectness",
      value: function checkSplitEdgesCorrectness(t) {
        var e = this._edge.getCoordinates(),
            n = t.get(0).getCoordinate(0);

        if (!n.equals2D(e[0])) throw new h("bad split edge start point at " + n);
        var s = t.get(t.size() - 1).getCoordinates(),
            i = s[s.length - 1];
        if (!i.equals2D(e[e.length - 1])) throw new h("bad split edge end point at " + i);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._nodeMap = new Un(), this._edge = null;
        var t = arguments[0];
        this._edge = t;
      }
    }]);

    return zs;
  }();

  var Xs = /*#__PURE__*/function () {
    function Xs() {
      _classCallCheck(this, Xs);
    }

    _createClass(Xs, null, [{
      key: "octant",
      value: function octant() {
        if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
          var _t492 = arguments[0],
              _e388 = arguments[1];
          if (0 === _t492 && 0 === _e388) throw new s("Cannot compute the octant for point ( " + _t492 + ", " + _e388 + " )");

          var _n287 = Math.abs(_t492),
              _i86 = Math.abs(_e388);

          return _t492 >= 0 ? _e388 >= 0 ? _n287 >= _i86 ? 0 : 1 : _n287 >= _i86 ? 7 : 6 : _e388 >= 0 ? _n287 >= _i86 ? 3 : 2 : _n287 >= _i86 ? 4 : 5;
        }

        if (arguments[0] instanceof m && arguments[1] instanceof m) {
          var _t493 = arguments[0],
              _e389 = arguments[1],
              _n288 = _e389.x - _t493.x,
              _i87 = _e389.y - _t493.y;

          if (0 === _n288 && 0 === _i87) throw new s("Cannot compute the octant for two identical points " + _t493);
          return Xs.octant(_n288, _i87);
        }
      }
    }]);

    return Xs;
  }();

  var ks = /*#__PURE__*/function () {
    function ks() {
      _classCallCheck(this, ks);
    }

    _createClass(ks, [{
      key: "getCoordinates",
      value: function getCoordinates() {}
    }, {
      key: "size",
      value: function size() {}
    }, {
      key: "getCoordinate",
      value: function getCoordinate(t) {}
    }, {
      key: "isClosed",
      value: function isClosed() {}
    }, {
      key: "setData",
      value: function setData(t) {}
    }, {
      key: "getData",
      value: function getData() {}
    }]);

    return ks;
  }();

  var Us = /*#__PURE__*/function () {
    function Us() {
      _classCallCheck(this, Us);
    }

    _createClass(Us, [{
      key: "addIntersection",
      value: function addIntersection(t, e) {}
    }, {
      key: "interfaces_",
      get: function get() {
        return [ks];
      }
    }]);

    return Us;
  }();

  var Hs = /*#__PURE__*/function () {
    function Hs() {
      _classCallCheck(this, Hs);

      Hs.constructor_.apply(this, arguments);
    }

    _createClass(Hs, [{
      key: "getCoordinates",
      value: function getCoordinates() {
        return this._pts;
      }
    }, {
      key: "size",
      value: function size() {
        return this._pts.length;
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate(t) {
        return this._pts[t];
      }
    }, {
      key: "isClosed",
      value: function isClosed() {
        return this._pts[0].equals(this._pts[this._pts.length - 1]);
      }
    }, {
      key: "getSegmentOctant",
      value: function getSegmentOctant(t) {
        return t === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1));
      }
    }, {
      key: "setData",
      value: function setData(t) {
        this._data = t;
      }
    }, {
      key: "safeOctant",
      value: function safeOctant(t, e) {
        return t.equals2D(e) ? 0 : Xs.octant(t, e);
      }
    }, {
      key: "getData",
      value: function getData() {
        return this._data;
      }
    }, {
      key: "addIntersection",
      value: function addIntersection() {
        if (2 === arguments.length) {
          var _t494 = arguments[0],
              _e390 = arguments[1];
          this.addIntersectionNode(_t494, _e390);
        } else if (4 === arguments.length) {
          var _t495 = arguments[1],
              _e391 = arguments[3],
              _n289 = new m(arguments[0].getIntersection(_e391));

          this.addIntersection(_n289, _t495);
        }
      }
    }, {
      key: "toString",
      value: function toString() {
        return Ht.toLineString(new pt(this._pts));
      }
    }, {
      key: "getNodeList",
      value: function getNodeList() {
        return this._nodeList;
      }
    }, {
      key: "addIntersectionNode",
      value: function addIntersectionNode(t, e) {
        var n = e;
        var s = n + 1;

        if (s < this._pts.length) {
          var _e392 = this._pts[s];
          t.equals2D(_e392) && (n = s);
        }

        return this._nodeList.add(t, n);
      }
    }, {
      key: "addIntersections",
      value: function addIntersections(t, e, n) {
        for (var _s173 = 0; _s173 < t.getIntersectionNum(); _s173++) {
          this.addIntersection(t, e, n, _s173);
        }
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Us];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._nodeList = new zs(this), this._pts = null, this._data = null;
        var t = arguments[0],
            e = arguments[1];
        this._pts = t, this._data = e;
      }
    }, {
      key: "getNodedSubstrings",
      value: function getNodedSubstrings() {
        if (1 === arguments.length) {
          var _t496 = arguments[0],
              _e393 = new S();

          return Hs.getNodedSubstrings(_t496, _e393), _e393;
        }

        if (2 === arguments.length) {
          var _t497 = arguments[1];

          for (var _e394 = arguments[0].iterator(); _e394.hasNext();) {
            _e394.next().getNodeList().addSplitEdges(_t497);
          }
        }
      }
    }]);

    return Hs;
  }();

  var Ws = /*#__PURE__*/function () {
    function Ws() {
      _classCallCheck(this, Ws);

      Ws.constructor_.apply(this, arguments);
    }

    _createClass(Ws, [{
      key: "overlap",
      value: function overlap() {
        if (2 === arguments.length) ;else if (4 === arguments.length) {
          var _t498 = arguments[1],
              _e395 = arguments[2],
              _n290 = arguments[3];
          arguments[0].getLineSegment(_t498, this._overlapSeg1), _e395.getLineSegment(_n290, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._overlapSeg1 = new jt(), this._overlapSeg2 = new jt();
      }
    }]);

    return Ws;
  }();

  var Zs = /*#__PURE__*/function () {
    function Zs() {
      _classCallCheck(this, Zs);

      Zs.constructor_.apply(this, arguments);
    }

    _createClass(Zs, [{
      key: "getLineSegment",
      value: function getLineSegment(t, e) {
        e.p0 = this._pts[t], e.p1 = this._pts[t + 1];
      }
    }, {
      key: "computeSelect",
      value: function computeSelect(t, e, n, s) {
        var i = this._pts[e],
            r = this._pts[n];
        if (n - e == 1) return s.select(this, e), null;
        if (!t.intersects(i, r)) return null;
        var o = Math.trunc((e + n) / 2);
        e < o && this.computeSelect(t, e, o, s), o < n && this.computeSelect(t, o, n, s);
      }
    }, {
      key: "getCoordinates",
      value: function getCoordinates() {
        var t = new Array(this._end - this._start + 1).fill(null);
        var e = 0;

        for (var _n291 = this._start; _n291 <= this._end; _n291++) {
          t[e++] = this._pts[_n291];
        }

        return t;
      }
    }, {
      key: "computeOverlaps",
      value: function computeOverlaps() {
        if (2 === arguments.length) {
          var _t499 = arguments[0],
              _e396 = arguments[1];
          this.computeOverlaps(this._start, this._end, _t499, _t499._start, _t499._end, _e396);
        } else if (6 === arguments.length) {
          var _t500 = arguments[0],
              _e397 = arguments[1],
              _n292 = arguments[2],
              _s174 = arguments[3],
              _i88 = arguments[4],
              _r48 = arguments[5];
          if (_e397 - _t500 == 1 && _i88 - _s174 == 1) return _r48.overlap(this, _t500, _n292, _s174), null;
          if (!this.overlaps(_t500, _e397, _n292, _s174, _i88)) return null;

          var _o29 = Math.trunc((_t500 + _e397) / 2),
              _l26 = Math.trunc((_s174 + _i88) / 2);

          _t500 < _o29 && (_s174 < _l26 && this.computeOverlaps(_t500, _o29, _n292, _s174, _l26, _r48), _l26 < _i88 && this.computeOverlaps(_t500, _o29, _n292, _l26, _i88, _r48)), _o29 < _e397 && (_s174 < _l26 && this.computeOverlaps(_o29, _e397, _n292, _s174, _l26, _r48), _l26 < _i88 && this.computeOverlaps(_o29, _e397, _n292, _l26, _i88, _r48));
        }
      }
    }, {
      key: "setId",
      value: function setId(t) {
        this._id = t;
      }
    }, {
      key: "select",
      value: function select(t, e) {
        this.computeSelect(t, this._start, this._end, e);
      }
    }, {
      key: "getEnvelope",
      value: function getEnvelope() {
        if (null === this._env) {
          var _t501 = this._pts[this._start],
              _e398 = this._pts[this._end];
          this._env = new T(_t501, _e398);
        }

        return this._env;
      }
    }, {
      key: "overlaps",
      value: function overlaps(t, e, n, s, i) {
        return T.intersects(this._pts[t], this._pts[e], n._pts[s], n._pts[i]);
      }
    }, {
      key: "getEndIndex",
      value: function getEndIndex() {
        return this._end;
      }
    }, {
      key: "getStartIndex",
      value: function getStartIndex() {
        return this._start;
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return this._context;
      }
    }, {
      key: "getId",
      value: function getId() {
        return this._id;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2],
            s = arguments[3];
        this._pts = t, this._start = e, this._end = n, this._context = s;
      }
    }]);

    return Zs;
  }();

  var js = /*#__PURE__*/function () {
    function js() {
      _classCallCheck(this, js);
    }

    _createClass(js, null, [{
      key: "findChainEnd",
      value: function findChainEnd(t, e) {
        var n = e;

        for (; n < t.length - 1 && t[n].equals2D(t[n + 1]);) {
          n++;
        }

        if (n >= t.length - 1) return t.length - 1;
        var s = Sn.quadrant(t[n], t[n + 1]);
        var i = e + 1;

        for (; i < t.length;) {
          if (!t[i - 1].equals2D(t[i])) {
            if (Sn.quadrant(t[i - 1], t[i]) !== s) break;
          }

          i++;
        }

        return i - 1;
      }
    }, {
      key: "getChains",
      value: function getChains() {
        if (1 === arguments.length) {
          var _t502 = arguments[0];
          return js.getChains(_t502, null);
        }

        if (2 === arguments.length) {
          var _t503 = arguments[0],
              _e399 = arguments[1],
              _n293 = new S();

          var _s175 = 0;

          do {
            var _i89 = js.findChainEnd(_t503, _s175),
                _r49 = new Zs(_t503, _s175, _i89, _e399);

            _n293.add(_r49), _s175 = _i89;
          } while (_s175 < _t503.length - 1);

          return _n293;
        }
      }
    }]);

    return js;
  }();

  var Ks = /*#__PURE__*/function () {
    function Ks() {
      _classCallCheck(this, Ks);
    }

    _createClass(Ks, [{
      key: "computeNodes",
      value: function computeNodes(t) {}
    }, {
      key: "getNodedSubstrings",
      value: function getNodedSubstrings() {}
    }]);

    return Ks;
  }();

  var Qs = /*#__PURE__*/function () {
    function Qs() {
      _classCallCheck(this, Qs);

      Qs.constructor_.apply(this, arguments);
    }

    _createClass(Qs, [{
      key: "setSegmentIntersector",
      value: function setSegmentIntersector(t) {
        this._segInt = t;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Ks];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._segInt = null, 0 === arguments.length) ;else if (1 === arguments.length) {
          var _t504 = arguments[0];
          this.setSegmentIntersector(_t504);
        }
      }
    }]);

    return Qs;
  }();

  var Js = /*#__PURE__*/function (_Qs) {
    _inherits(Js, _Qs);

    var _super50 = _createSuper(Js);

    function Js() {
      var _this37;

      _classCallCheck(this, Js);

      _this37 = _super50.call(this), Js.constructor_.apply(_assertThisInitialized(_this37), arguments);
      return _this37;
    }

    _createClass(Js, [{
      key: "getMonotoneChains",
      value: function getMonotoneChains() {
        return this._monoChains;
      }
    }, {
      key: "getNodedSubstrings",
      value: function getNodedSubstrings() {
        return Hs.getNodedSubstrings(this._nodedSegStrings);
      }
    }, {
      key: "getIndex",
      value: function getIndex() {
        return this._index;
      }
    }, {
      key: "add",
      value: function add(t) {
        for (var _e400 = js.getChains(t.getCoordinates(), t).iterator(); _e400.hasNext();) {
          var _t505 = _e400.next();

          _t505.setId(this._idCounter++), this._index.insert(_t505.getEnvelope(), _t505), this._monoChains.add(_t505);
        }
      }
    }, {
      key: "computeNodes",
      value: function computeNodes(t) {
        this._nodedSegStrings = t;

        for (var _e401 = t.iterator(); _e401.hasNext();) {
          this.add(_e401.next());
        }

        this.intersectChains();
      }
    }, {
      key: "intersectChains",
      value: function intersectChains() {
        var t = new $s(this._segInt);

        for (var _e402 = this._monoChains.iterator(); _e402.hasNext();) {
          var _n294 = _e402.next();

          for (var _e403 = this._index.query(_n294.getEnvelope()).iterator(); _e403.hasNext();) {
            var _s176 = _e403.next();

            if (_s176.getId() > _n294.getId() && (_n294.computeOverlaps(_s176, t), this._nOverlaps++), this._segInt.isDone()) return null;
          }
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._monoChains = new S(), this._index = new Os(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0, 0 === arguments.length) ;else if (1 === arguments.length) {
          var _t506 = arguments[0];
          Qs.constructor_.call(this, _t506);
        }
      }
    }]);

    return Js;
  }(Qs);

  var $s = /*#__PURE__*/function (_Ws) {
    _inherits($s, _Ws);

    var _super51 = _createSuper($s);

    function $s() {
      var _this38;

      _classCallCheck(this, $s);

      _this38 = _super51.call(this), $s.constructor_.apply(_assertThisInitialized(_this38), arguments);
      return _this38;
    }

    _createClass($s, [{
      key: "overlap",
      value: function overlap() {
        if (4 !== arguments.length) return _get(_getPrototypeOf($s.prototype), "overlap", this).apply(this, arguments);
        {
          var _t507 = arguments[1],
              _e404 = arguments[2],
              _n295 = arguments[3],
              _s177 = arguments[0].getContext(),
              _i90 = _e404.getContext();

          this._si.processIntersections(_s177, _t507, _i90, _n295);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._si = null;
        var t = arguments[0];
        this._si = t;
      }
    }]);

    return $s;
  }(Ws);

  Js.SegmentOverlapAction = $s;

  var ti = /*#__PURE__*/function () {
    function ti() {
      _classCallCheck(this, ti);

      ti.constructor_.apply(this, arguments);
    }

    _createClass(ti, [{
      key: "rescale",
      value: function rescale() {
        if (y(arguments[0], x)) {
          for (var _t508 = arguments[0].iterator(); _t508.hasNext();) {
            var _e405 = _t508.next();

            this.rescale(_e405.getCoordinates());
          }
        } else if (arguments[0] instanceof Array) {
          var _t509 = arguments[0];

          for (var _e406 = 0; _e406 < _t509.length; _e406++) {
            _t509[_e406].x = _t509[_e406].x / this._scaleFactor + this._offsetX, _t509[_e406].y = _t509[_e406].y / this._scaleFactor + this._offsetY;
          }

          2 === _t509.length && _t509[0].equals2D(_t509[1]) && F.out.println(_t509);
        }
      }
    }, {
      key: "scale",
      value: function scale() {
        if (y(arguments[0], x)) {
          var _t510 = arguments[0],
              _e407 = new S(_t510.size());

          for (var _n296 = _t510.iterator(); _n296.hasNext();) {
            var _t511 = _n296.next();

            _e407.add(new Hs(this.scale(_t511.getCoordinates()), _t511.getData()));
          }

          return _e407;
        }

        if (arguments[0] instanceof Array) {
          var _t512 = arguments[0],
              _e408 = new Array(_t512.length).fill(null);

          for (var _n297 = 0; _n297 < _t512.length; _n297++) {
            _e408[_n297] = new m(Math.round((_t512[_n297].x - this._offsetX) * this._scaleFactor), Math.round((_t512[_n297].y - this._offsetY) * this._scaleFactor), _t512[_n297].getZ());
          }

          return dt.removeRepeatedPoints(_e408);
        }
      }
    }, {
      key: "isIntegerPrecision",
      value: function isIntegerPrecision() {
        return 1 === this._scaleFactor;
      }
    }, {
      key: "getNodedSubstrings",
      value: function getNodedSubstrings() {
        var t = this._noder.getNodedSubstrings();

        return this._isScaled && this.rescale(t), t;
      }
    }, {
      key: "computeNodes",
      value: function computeNodes(t) {
        var e = t;
        this._isScaled && (e = this.scale(t)), this._noder.computeNodes(e);
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Ks];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, 2 === arguments.length) {
          var _t513 = arguments[0],
              _e409 = arguments[1];
          ti.constructor_.call(this, _t513, _e409, 0, 0);
        } else if (4 === arguments.length) {
          var _t514 = arguments[0],
              _e410 = arguments[1];
          this._noder = _t514, this._scaleFactor = _e410, this._isScaled = !this.isIntegerPrecision();
        }
      }
    }]);

    return ti;
  }();

  var ei = Object.freeze({
    __proto__: null,
    MCIndexNoder: Js,
    ScaledNoder: ti,
    SegmentString: ks
  });

  var ni = /*#__PURE__*/function () {
    function ni() {
      _classCallCheck(this, ni);

      ni.constructor_.apply(this, arguments);
    }

    _createClass(ni, [{
      key: "boundaryMultiLineString",
      value: function boundaryMultiLineString(t) {
        if (this._geom.isEmpty()) return this.getEmptyMultiPoint();
        var e = this.computeBoundaryCoordinates(t);
        return 1 === e.length ? this._geomFact.createPoint(e[0]) : this._geomFact.createMultiPointFromCoords(e);
      }
    }, {
      key: "getBoundary",
      value: function getBoundary() {
        return this._geom instanceof j ? this.boundaryLineString(this._geom) : this._geom instanceof wt ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary();
      }
    }, {
      key: "boundaryLineString",
      value: function boundaryLineString(t) {
        if (this._geom.isEmpty()) return this.getEmptyMultiPoint();

        if (t.isClosed()) {
          return this._bnRule.isInBoundary(2) ? t.getStartPoint() : this._geomFact.createMultiPoint();
        }

        return this._geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()]);
      }
    }, {
      key: "getEmptyMultiPoint",
      value: function getEmptyMultiPoint() {
        return this._geomFact.createMultiPoint();
      }
    }, {
      key: "computeBoundaryCoordinates",
      value: function computeBoundaryCoordinates(t) {
        var e = new S();
        this._endpointMap = new Un();

        for (var _e411 = 0; _e411 < t.getNumGeometries(); _e411++) {
          var _n298 = t.getGeometryN(_e411);

          0 !== _n298.getNumPoints() && (this.addEndpoint(_n298.getCoordinateN(0)), this.addEndpoint(_n298.getCoordinateN(_n298.getNumPoints() - 1)));
        }

        for (var _t515 = this._endpointMap.entrySet().iterator(); _t515.hasNext();) {
          var _n299 = _t515.next(),
              _s178 = _n299.getValue().count;

          this._bnRule.isInBoundary(_s178) && e.add(_n299.getKey());
        }

        return dt.toCoordinateArray(e);
      }
    }, {
      key: "addEndpoint",
      value: function addEndpoint(t) {
        var e = this._endpointMap.get(t);

        null === e && (e = new si(), this._endpointMap.put(t, e)), e.count++;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, 1 === arguments.length) {
          var _t516 = arguments[0];
          ni.constructor_.call(this, _t516, un.MOD2_BOUNDARY_RULE);
        } else if (2 === arguments.length) {
          var _t517 = arguments[0],
              _e412 = arguments[1];
          this._geom = _t517, this._geomFact = _t517.getFactory(), this._bnRule = _e412;
        }
      }
    }, {
      key: "getBoundary",
      value: function getBoundary() {
        if (1 === arguments.length) {
          return new ni(arguments[0]).getBoundary();
        }

        if (2 === arguments.length) {
          return new ni(arguments[0], arguments[1]).getBoundary();
        }
      }
    }]);

    return ni;
  }();

  var si = /*#__PURE__*/function () {
    function si() {
      _classCallCheck(this, si);

      si.constructor_.apply(this, arguments);
    }

    _createClass(si, null, [{
      key: "constructor_",
      value: function constructor_() {
        this.count = null;
      }
    }]);

    return si;
  }();

  var ii = /*#__PURE__*/function () {
    function ii() {
      _classCallCheck(this, ii);

      ii.constructor_.apply(this, arguments);
    }

    _createClass(ii, [{
      key: "isSimpleMultiPoint",
      value: function isSimpleMultiPoint(t) {
        if (t.isEmpty()) return !0;
        var e = new it();

        for (var _n300 = 0; _n300 < t.getNumGeometries(); _n300++) {
          var _s179 = t.getGeometryN(_n300).getCoordinate();

          if (e.contains(_s179)) return this._nonSimpleLocation = _s179, !1;
          e.add(_s179);
        }

        return !0;
      }
    }, {
      key: "isSimplePolygonal",
      value: function isSimplePolygonal(t) {
        for (var _e413 = fe.getLines(t).iterator(); _e413.hasNext();) {
          var _t518 = _e413.next();

          if (!this.isSimpleLinearGeometry(_t518)) return !1;
        }

        return !0;
      }
    }, {
      key: "hasClosedEndpointIntersection",
      value: function hasClosedEndpointIntersection(t) {
        var e = new Un();

        for (var _n301 = t.getEdgeIterator(); _n301.hasNext();) {
          var _t519 = _n301.next(),
              _s180 = _t519.isClosed(),
              _i91 = _t519.getCoordinate(0);

          this.addEndpoint(e, _i91, _s180);

          var _r50 = _t519.getCoordinate(_t519.getNumPoints() - 1);

          this.addEndpoint(e, _r50, _s180);
        }

        for (var _t520 = e.values().iterator(); _t520.hasNext();) {
          var _e414 = _t520.next();

          if (_e414.isClosed && 2 !== _e414.degree) return this._nonSimpleLocation = _e414.getCoordinate(), !0;
        }

        return !1;
      }
    }, {
      key: "getNonSimpleLocation",
      value: function getNonSimpleLocation() {
        return this._nonSimpleLocation;
      }
    }, {
      key: "isSimpleLinearGeometry",
      value: function isSimpleLinearGeometry(t) {
        if (t.isEmpty()) return !0;
        var e = new os(0, t),
            n = new Zt(),
            s = e.computeSelfNodes(n, !0);
        return !s.hasIntersection() || (s.hasProperIntersection() ? (this._nonSimpleLocation = s.getProperIntersectionPoint(), !1) : !this.hasNonEndpointIntersection(e) && (!this._isClosedEndpointsInInterior || !this.hasClosedEndpointIntersection(e)));
      }
    }, {
      key: "hasNonEndpointIntersection",
      value: function hasNonEndpointIntersection(t) {
        for (var _e415 = t.getEdgeIterator(); _e415.hasNext();) {
          var _t521 = _e415.next(),
              _n302 = _t521.getMaximumSegmentIndex();

          for (var _e416 = _t521.getEdgeIntersectionList().iterator(); _e416.hasNext();) {
            var _t522 = _e416.next();

            if (!_t522.isEndPoint(_n302)) return this._nonSimpleLocation = _t522.getCoordinate(), !0;
          }
        }

        return !1;
      }
    }, {
      key: "addEndpoint",
      value: function addEndpoint(t, e, n) {
        var s = t.get(e);
        null === s && (s = new ri(e), t.put(e, s)), s.addEndpoint(n);
      }
    }, {
      key: "computeSimple",
      value: function computeSimple(t) {
        return this._nonSimpleLocation = null, !!t.isEmpty() || (t instanceof j || t instanceof wt ? this.isSimpleLinearGeometry(t) : t instanceof lt ? this.isSimpleMultiPoint(t) : y(t, tt) ? this.isSimplePolygonal(t) : !(t instanceof ot) || this.isSimpleGeometryCollection(t));
      }
    }, {
      key: "isSimple",
      value: function isSimple() {
        return this._nonSimpleLocation = null, this.computeSimple(this._inputGeom);
      }
    }, {
      key: "isSimpleGeometryCollection",
      value: function isSimpleGeometryCollection(t) {
        for (var _e417 = 0; _e417 < t.getNumGeometries(); _e417++) {
          var _n303 = t.getGeometryN(_e417);

          if (!this.computeSimple(_n303)) return !1;
        }

        return !0;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._inputGeom = null, this._isClosedEndpointsInInterior = !0, this._nonSimpleLocation = null, 1 === arguments.length) {
          var _t523 = arguments[0];
          this._inputGeom = _t523;
        } else if (2 === arguments.length) {
          var _t524 = arguments[0],
              _e418 = arguments[1];
          this._inputGeom = _t524, this._isClosedEndpointsInInterior = !_e418.isInBoundary(2);
        }
      }
    }, {
      key: "isSimple",
      value: function isSimple() {
        if (1 === arguments.length) {
          return new ii(arguments[0]).isSimple();
        }

        if (2 === arguments.length) {
          return new ii(arguments[0], arguments[1]).isSimple();
        }
      }
    }]);

    return ii;
  }();

  var ri = /*#__PURE__*/function () {
    function ri() {
      _classCallCheck(this, ri);

      ri.constructor_.apply(this, arguments);
    }

    _createClass(ri, [{
      key: "addEndpoint",
      value: function addEndpoint(t) {
        this.degree++, this.isClosed |= t;
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        return this.pt;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this.pt = null, this.isClosed = null, this.degree = null;
        var t = arguments[0];
        this.pt = t, this.isClosed = !1, this.degree = 0;
      }
    }]);

    return ri;
  }();

  ii.EndpointInfo = ri;

  var oi = /*#__PURE__*/function () {
    function oi() {
      _classCallCheck(this, oi);

      oi.constructor_.apply(this, arguments);
    }

    _createClass(oi, [{
      key: "getEndCapStyle",
      value: function getEndCapStyle() {
        return this._endCapStyle;
      }
    }, {
      key: "isSingleSided",
      value: function isSingleSided() {
        return this._isSingleSided;
      }
    }, {
      key: "setQuadrantSegments",
      value: function setQuadrantSegments(t) {
        this._quadrantSegments = t, 0 === this._quadrantSegments && (this._joinStyle = oi.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = oi.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t <= 0 && (this._quadrantSegments = 1), this._joinStyle !== oi.JOIN_ROUND && (this._quadrantSegments = oi.DEFAULT_QUADRANT_SEGMENTS);
      }
    }, {
      key: "getJoinStyle",
      value: function getJoinStyle() {
        return this._joinStyle;
      }
    }, {
      key: "setJoinStyle",
      value: function setJoinStyle(t) {
        this._joinStyle = t;
      }
    }, {
      key: "setSimplifyFactor",
      value: function setSimplifyFactor(t) {
        this._simplifyFactor = t < 0 ? 0 : t;
      }
    }, {
      key: "getSimplifyFactor",
      value: function getSimplifyFactor() {
        return this._simplifyFactor;
      }
    }, {
      key: "getQuadrantSegments",
      value: function getQuadrantSegments() {
        return this._quadrantSegments;
      }
    }, {
      key: "setEndCapStyle",
      value: function setEndCapStyle(t) {
        this._endCapStyle = t;
      }
    }, {
      key: "getMitreLimit",
      value: function getMitreLimit() {
        return this._mitreLimit;
      }
    }, {
      key: "setMitreLimit",
      value: function setMitreLimit(t) {
        this._mitreLimit = t;
      }
    }, {
      key: "setSingleSided",
      value: function setSingleSided(t) {
        this._isSingleSided = t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._quadrantSegments = oi.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = oi.CAP_ROUND, this._joinStyle = oi.JOIN_ROUND, this._mitreLimit = oi.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = oi.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length) ;else if (1 === arguments.length) {
          var _t525 = arguments[0];
          this.setQuadrantSegments(_t525);
        } else if (2 === arguments.length) {
          var _t526 = arguments[0],
              _e419 = arguments[1];
          this.setQuadrantSegments(_t526), this.setEndCapStyle(_e419);
        } else if (4 === arguments.length) {
          var _t527 = arguments[0],
              _e420 = arguments[1],
              _n304 = arguments[2],
              _s181 = arguments[3];
          this.setQuadrantSegments(_t527), this.setEndCapStyle(_e420), this.setJoinStyle(_n304), this.setMitreLimit(_s181);
        }
      }
    }, {
      key: "bufferDistanceError",
      value: function bufferDistanceError(t) {
        var e = Math.PI / 2 / t;
        return 1 - Math.cos(e / 2);
      }
    }]);

    return oi;
  }();

  oi.CAP_ROUND = 1, oi.CAP_FLAT = 2, oi.CAP_SQUARE = 3, oi.JOIN_ROUND = 1, oi.JOIN_MITRE = 2, oi.JOIN_BEVEL = 3, oi.DEFAULT_QUADRANT_SEGMENTS = 8, oi.DEFAULT_MITRE_LIMIT = 5, oi.DEFAULT_SIMPLIFY_FACTOR = .01;

  var li = /*#__PURE__*/function () {
    function li() {
      _classCallCheck(this, li);

      li.constructor_.apply(this, arguments);
    }

    _createClass(li, [{
      key: "getCoordinate",
      value: function getCoordinate() {
        return this._minCoord;
      }
    }, {
      key: "getRightmostSide",
      value: function getRightmostSide(t, e) {
        var n = this.getRightmostSideOfSegment(t, e);
        return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)), n < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t)), n;
      }
    }, {
      key: "findRightmostEdgeAtVertex",
      value: function findRightmostEdgeAtVertex() {
        var t = this._minDe.getEdge().getCoordinates();

        g.isTrue(this._minIndex > 0 && this._minIndex < t.length, "rightmost point expected to be interior vertex of edge");
        var e = t[this._minIndex - 1],
            n = t[this._minIndex + 1],
            s = D.index(this._minCoord, n, e);
        var i = !1;
        (e.y < this._minCoord.y && n.y < this._minCoord.y && s === D.COUNTERCLOCKWISE || e.y > this._minCoord.y && n.y > this._minCoord.y && s === D.CLOCKWISE) && (i = !0), i && (this._minIndex = this._minIndex - 1);
      }
    }, {
      key: "getRightmostSideOfSegment",
      value: function getRightmostSideOfSegment(t, e) {
        var n = t.getEdge().getCoordinates();
        if (e < 0 || e + 1 >= n.length) return -1;
        if (n[e].y === n[e + 1].y) return -1;
        var s = vn.LEFT;
        return n[e].y < n[e + 1].y && (s = vn.RIGHT), s;
      }
    }, {
      key: "getEdge",
      value: function getEdge() {
        return this._orientedDe;
      }
    }, {
      key: "checkForRightmostCoordinate",
      value: function checkForRightmostCoordinate(t) {
        var e = t.getEdge().getCoordinates();

        for (var _n305 = 0; _n305 < e.length - 1; _n305++) {
          (null === this._minCoord || e[_n305].x > this._minCoord.x) && (this._minDe = t, this._minIndex = _n305, this._minCoord = e[_n305]);
        }
      }
    }, {
      key: "findRightmostEdgeAtNode",
      value: function findRightmostEdgeAtNode() {
        var t = this._minDe.getNode().getEdges();

        this._minDe = t.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
      }
    }, {
      key: "findEdge",
      value: function findEdge(t) {
        for (var _e421 = t.iterator(); _e421.hasNext();) {
          var _t528 = _e421.next();

          _t528.isForward() && this.checkForRightmostCoordinate(_t528);
        }

        g.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe;
        this.getRightmostSide(this._minDe, this._minIndex) === vn.LEFT && (this._orientedDe = this._minDe.getSym());
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
      }
    }]);

    return li;
  }();

  var ai = /*#__PURE__*/function () {
    function ai() {
      _classCallCheck(this, ai);

      this.array = [];
    }

    _createClass(ai, [{
      key: "addLast",
      value: function addLast(t) {
        this.array.push(t);
      }
    }, {
      key: "removeFirst",
      value: function removeFirst() {
        return this.array.shift();
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return 0 === this.array.length;
      }
    }]);

    return ai;
  }();

  var ci = /*#__PURE__*/function () {
    function ci() {
      _classCallCheck(this, ci);

      ci.constructor_.apply(this, arguments);
    }

    _createClass(ci, [{
      key: "clearVisitedEdges",
      value: function clearVisitedEdges() {
        for (var _t529 = this._dirEdgeList.iterator(); _t529.hasNext();) {
          _t529.next().setVisited(!1);
        }
      }
    }, {
      key: "getRightmostCoordinate",
      value: function getRightmostCoordinate() {
        return this._rightMostCoord;
      }
    }, {
      key: "computeNodeDepth",
      value: function computeNodeDepth(t) {
        var e = null;

        for (var _n306 = t.getEdges().iterator(); _n306.hasNext();) {
          var _t530 = _n306.next();

          if (_t530.isVisited() || _t530.getSym().isVisited()) {
            e = _t530;
            break;
          }
        }

        if (null === e) throw new ns("unable to find edge to compute depths at " + t.getCoordinate());
        t.getEdges().computeDepths(e);

        for (var _e422 = t.getEdges().iterator(); _e422.hasNext();) {
          var _t531 = _e422.next();

          _t531.setVisited(!0), this.copySymDepths(_t531);
        }
      }
    }, {
      key: "computeDepth",
      value: function computeDepth(t) {
        this.clearVisitedEdges();

        var e = this._finder.getEdge();

        e.getNode(), e.getLabel();
        e.setEdgeDepths(vn.RIGHT, t), this.copySymDepths(e), this.computeDepths(e);
      }
    }, {
      key: "create",
      value: function create(t) {
        this.addReachable(t), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
      }
    }, {
      key: "findResultEdges",
      value: function findResultEdges() {
        for (var _t532 = this._dirEdgeList.iterator(); _t532.hasNext();) {
          var _e423 = _t532.next();

          _e423.getDepth(vn.RIGHT) >= 1 && _e423.getDepth(vn.LEFT) <= 0 && !_e423.isInteriorAreaEdge() && _e423.setInResult(!0);
        }
      }
    }, {
      key: "computeDepths",
      value: function computeDepths(t) {
        var e = new xt(),
            n = new ai(),
            s = t.getNode();

        for (n.addLast(s), e.add(s), t.setVisited(!0); !n.isEmpty();) {
          var _t533 = n.removeFirst();

          e.add(_t533), this.computeNodeDepth(_t533);

          for (var _s182 = _t533.getEdges().iterator(); _s182.hasNext();) {
            var _t534 = _s182.next().getSym();

            if (_t534.isVisited()) continue;

            var _i92 = _t534.getNode();

            e.contains(_i92) || (n.addLast(_i92), e.add(_i92));
          }
        }
      }
    }, {
      key: "compareTo",
      value: function compareTo(t) {
        var e = t;
        return this._rightMostCoord.x < e._rightMostCoord.x ? -1 : this._rightMostCoord.x > e._rightMostCoord.x ? 1 : 0;
      }
    }, {
      key: "getEnvelope",
      value: function getEnvelope() {
        if (null === this._env) {
          var _t535 = new T();

          for (var _e424 = this._dirEdgeList.iterator(); _e424.hasNext();) {
            var _n307 = _e424.next().getEdge().getCoordinates();

            for (var _e425 = 0; _e425 < _n307.length - 1; _e425++) {
              _t535.expandToInclude(_n307[_e425]);
            }
          }

          this._env = _t535;
        }

        return this._env;
      }
    }, {
      key: "addReachable",
      value: function addReachable(t) {
        var e = new tn();

        for (e.add(t); !e.empty();) {
          var _t536 = e.pop();

          this.add(_t536, e);
        }
      }
    }, {
      key: "copySymDepths",
      value: function copySymDepths(t) {
        var e = t.getSym();
        e.setDepth(vn.LEFT, t.getDepth(vn.RIGHT)), e.setDepth(vn.RIGHT, t.getDepth(vn.LEFT));
      }
    }, {
      key: "add",
      value: function add(t, e) {
        t.setVisited(!0), this._nodes.add(t);

        for (var _n308 = t.getEdges().iterator(); _n308.hasNext();) {
          var _t537 = _n308.next();

          this._dirEdgeList.add(_t537);

          var _s183 = _t537.getSym().getNode();

          _s183.isVisited() || e.push(_s183);
        }
      }
    }, {
      key: "getNodes",
      value: function getNodes() {
        return this._nodes;
      }
    }, {
      key: "getDirectedEdges",
      value: function getDirectedEdges() {
        return this._dirEdgeList;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [o];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._finder = null, this._dirEdgeList = new S(), this._nodes = new S(), this._rightMostCoord = null, this._env = null, this._finder = new li();
      }
    }]);

    return ci;
  }();

  var hi = /*#__PURE__*/function () {
    function hi() {
      _classCallCheck(this, hi);

      hi.constructor_.apply(this, arguments);
    }

    _createClass(hi, [{
      key: "computeRing",
      value: function computeRing() {
        if (null !== this._ring) return null;
        var t = new Array(this._pts.size()).fill(null);

        for (var _e426 = 0; _e426 < this._pts.size(); _e426++) {
          t[_e426] = this._pts.get(_e426);
        }

        this._ring = this._geometryFactory.createLinearRing(t), this._isHole = D.isCCW(this._ring.getCoordinates());
      }
    }, {
      key: "isIsolated",
      value: function isIsolated() {
        return 1 === this._label.getGeometryCount();
      }
    }, {
      key: "computePoints",
      value: function computePoints(t) {
        this._startDe = t;
        var e = t,
            n = !0;

        do {
          if (null === e) throw new ns("Found null DirectedEdge");
          if (e.getEdgeRing() === this) throw new ns("Directed Edge visited twice during ring-building at " + e.getCoordinate());

          this._edges.add(e);

          var _t538 = e.getLabel();

          g.isTrue(_t538.isArea()), this.mergeLabel(_t538), this.addPoints(e.getEdge(), e.isForward(), n), n = !1, this.setEdgeRing(e, this), e = this.getNext(e);
        } while (e !== this._startDe);
      }
    }, {
      key: "getLinearRing",
      value: function getLinearRing() {
        return this._ring;
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate(t) {
        return this._pts.get(t);
      }
    }, {
      key: "computeMaxNodeDegree",
      value: function computeMaxNodeDegree() {
        this._maxNodeDegree = 0;
        var t = this._startDe;

        do {
          var _e427 = t.getNode().getEdges().getOutgoingDegree(this);

          _e427 > this._maxNodeDegree && (this._maxNodeDegree = _e427), t = this.getNext(t);
        } while (t !== this._startDe);

        this._maxNodeDegree *= 2;
      }
    }, {
      key: "addPoints",
      value: function addPoints(t, e, n) {
        var s = t.getCoordinates();

        if (e) {
          var _t539 = 1;
          n && (_t539 = 0);

          for (var _e428 = _t539; _e428 < s.length; _e428++) {
            this._pts.add(s[_e428]);
          }
        } else {
          var _t540 = s.length - 2;

          n && (_t540 = s.length - 1);

          for (var _e429 = _t540; _e429 >= 0; _e429--) {
            this._pts.add(s[_e429]);
          }
        }
      }
    }, {
      key: "isHole",
      value: function isHole() {
        return this._isHole;
      }
    }, {
      key: "setInResult",
      value: function setInResult() {
        var t = this._startDe;

        do {
          t.getEdge().setInResult(!0), t = t.getNext();
        } while (t !== this._startDe);
      }
    }, {
      key: "containsPoint",
      value: function containsPoint(t) {
        var e = this.getLinearRing();
        if (!e.getEnvelopeInternal().contains(t)) return !1;
        if (!ke.isInRing(t, e.getCoordinates())) return !1;

        for (var _e430 = this._holes.iterator(); _e430.hasNext();) {
          if (_e430.next().containsPoint(t)) return !1;
        }

        return !0;
      }
    }, {
      key: "addHole",
      value: function addHole(t) {
        this._holes.add(t);
      }
    }, {
      key: "isShell",
      value: function isShell() {
        return null === this._shell;
      }
    }, {
      key: "getLabel",
      value: function getLabel() {
        return this._label;
      }
    }, {
      key: "getEdges",
      value: function getEdges() {
        return this._edges;
      }
    }, {
      key: "getMaxNodeDegree",
      value: function getMaxNodeDegree() {
        return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
      }
    }, {
      key: "getShell",
      value: function getShell() {
        return this._shell;
      }
    }, {
      key: "mergeLabel",
      value: function mergeLabel() {
        if (1 === arguments.length) {
          var _t541 = arguments[0];
          this.mergeLabel(_t541, 0), this.mergeLabel(_t541, 1);
        } else if (2 === arguments.length) {
          var _t542 = arguments[1],
              _e431 = arguments[0].getLocation(_t542, vn.RIGHT);

          if (_e431 === Kt.NONE) return null;
          if (this._label.getLocation(_t542) === Kt.NONE) return this._label.setLocation(_t542, _e431), null;
        }
      }
    }, {
      key: "setShell",
      value: function setShell(t) {
        this._shell = t, null !== t && t.addHole(this);
      }
    }, {
      key: "toPolygon",
      value: function toPolygon(t) {
        var e = new Array(this._holes.size()).fill(null);

        for (var _t543 = 0; _t543 < this._holes.size(); _t543++) {
          e[_t543] = this._holes.get(_t543).getLinearRing();
        }

        return t.createPolygon(this.getLinearRing(), e);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._startDe = null, this._maxNodeDegree = -1, this._edges = new S(), this._pts = new S(), this._label = new Gn(Kt.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new S(), this._geometryFactory = null, 0 === arguments.length) ;else if (2 === arguments.length) {
          var _t544 = arguments[0],
              _e432 = arguments[1];
          this._geometryFactory = _e432, this.computePoints(_t544), this.computeRing();
        }
      }
    }]);

    return hi;
  }();

  var ui = /*#__PURE__*/function (_hi) {
    _inherits(ui, _hi);

    var _super52 = _createSuper(ui);

    function ui() {
      var _this39;

      _classCallCheck(this, ui);

      _this39 = _super52.call(this), ui.constructor_.apply(_assertThisInitialized(_this39), arguments);
      return _this39;
    }

    _createClass(ui, [{
      key: "setEdgeRing",
      value: function setEdgeRing(t, e) {
        t.setMinEdgeRing(e);
      }
    }, {
      key: "getNext",
      value: function getNext(t) {
        return t.getNextMin();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        var t = arguments[0],
            e = arguments[1];
        hi.constructor_.call(this, t, e);
      }
    }]);

    return ui;
  }(hi);

  var gi = /*#__PURE__*/function (_hi2) {
    _inherits(gi, _hi2);

    var _super53 = _createSuper(gi);

    function gi() {
      var _this40;

      _classCallCheck(this, gi);

      _this40 = _super53.call(this), gi.constructor_.apply(_assertThisInitialized(_this40), arguments);
      return _this40;
    }

    _createClass(gi, [{
      key: "buildMinimalRings",
      value: function buildMinimalRings() {
        var t = new S();
        var e = this._startDe;

        do {
          if (null === e.getMinEdgeRing()) {
            var _n309 = new ui(e, this._geometryFactory);

            t.add(_n309);
          }

          e = e.getNext();
        } while (e !== this._startDe);

        return t;
      }
    }, {
      key: "setEdgeRing",
      value: function setEdgeRing(t, e) {
        t.setEdgeRing(e);
      }
    }, {
      key: "linkDirectedEdgesForMinimalEdgeRings",
      value: function linkDirectedEdgesForMinimalEdgeRings() {
        var t = this._startDe;

        do {
          t.getNode().getEdges().linkMinimalDirectedEdges(this), t = t.getNext();
        } while (t !== this._startDe);
      }
    }, {
      key: "getNext",
      value: function getNext(t) {
        return t.getNext();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        var t = arguments[0],
            e = arguments[1];
        hi.constructor_.call(this, t, e);
      }
    }]);

    return gi;
  }(hi);

  var di = /*#__PURE__*/function () {
    function di() {
      _classCallCheck(this, di);

      di.constructor_.apply(this, arguments);
    }

    _createClass(di, [{
      key: "sortShellsAndHoles",
      value: function sortShellsAndHoles(t, e, n) {
        for (var _s184 = t.iterator(); _s184.hasNext();) {
          var _t545 = _s184.next();

          _t545.isHole() ? n.add(_t545) : e.add(_t545);
        }
      }
    }, {
      key: "computePolygons",
      value: function computePolygons(t) {
        var e = new S();

        for (var _n310 = t.iterator(); _n310.hasNext();) {
          var _t546 = _n310.next().toPolygon(this._geometryFactory);

          e.add(_t546);
        }

        return e;
      }
    }, {
      key: "placeFreeHoles",
      value: function placeFreeHoles(t, e) {
        for (var _n311 = e.iterator(); _n311.hasNext();) {
          var _e433 = _n311.next();

          if (null === _e433.getShell()) {
            var _n312 = di.findEdgeRingContaining(_e433, t);

            if (null === _n312) throw new ns("unable to assign hole to a shell", _e433.getCoordinate(0));

            _e433.setShell(_n312);
          }
        }
      }
    }, {
      key: "buildMinimalEdgeRings",
      value: function buildMinimalEdgeRings(t, e, n) {
        var s = new S();

        for (var _i93 = t.iterator(); _i93.hasNext();) {
          var _t547 = _i93.next();

          if (_t547.getMaxNodeDegree() > 2) {
            _t547.linkDirectedEdgesForMinimalEdgeRings();

            var _s185 = _t547.buildMinimalRings(),
                _i94 = this.findShell(_s185);

            null !== _i94 ? (this.placePolygonHoles(_i94, _s185), e.add(_i94)) : n.addAll(_s185);
          } else s.add(_t547);
        }

        return s;
      }
    }, {
      key: "buildMaximalEdgeRings",
      value: function buildMaximalEdgeRings(t) {
        var e = new S();

        for (var _n313 = t.iterator(); _n313.hasNext();) {
          var _t548 = _n313.next();

          if (_t548.isInResult() && _t548.getLabel().isArea() && null === _t548.getEdgeRing()) {
            var _n314 = new gi(_t548, this._geometryFactory);

            e.add(_n314), _n314.setInResult();
          }
        }

        return e;
      }
    }, {
      key: "placePolygonHoles",
      value: function placePolygonHoles(t, e) {
        for (var _n315 = e.iterator(); _n315.hasNext();) {
          var _e434 = _n315.next();

          _e434.isHole() && _e434.setShell(t);
        }
      }
    }, {
      key: "getPolygons",
      value: function getPolygons() {
        return this.computePolygons(this._shellList);
      }
    }, {
      key: "findShell",
      value: function findShell(t) {
        var e = 0,
            n = null;

        for (var _s186 = t.iterator(); _s186.hasNext();) {
          var _t549 = _s186.next();

          _t549.isHole() || (n = _t549, e++);
        }

        return g.isTrue(e <= 1, "found two shells in MinimalEdgeRing list"), n;
      }
    }, {
      key: "add",
      value: function add() {
        if (1 === arguments.length) {
          var _t550 = arguments[0];
          this.add(_t550.getEdgeEnds(), _t550.getNodes());
        } else if (2 === arguments.length) {
          var _t551 = arguments[0],
              _e435 = arguments[1];
          rs.linkResultDirectedEdges(_e435);

          var _n316 = this.buildMaximalEdgeRings(_t551),
              _s187 = new S(),
              _i95 = this.buildMinimalEdgeRings(_n316, this._shellList, _s187);

          this.sortShellsAndHoles(_i95, this._shellList, _s187), this.placeFreeHoles(this._shellList, _s187);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._geometryFactory = null, this._shellList = new S();
        var t = arguments[0];
        this._geometryFactory = t;
      }
    }, {
      key: "findEdgeRingContaining",
      value: function findEdgeRingContaining(t, e) {
        var n = t.getLinearRing(),
            s = n.getEnvelopeInternal();
        var i = n.getCoordinateN(0),
            r = null,
            o = null;

        for (var _t552 = e.iterator(); _t552.hasNext();) {
          var _e436 = _t552.next(),
              _l27 = _e436.getLinearRing(),
              _a16 = _l27.getEnvelopeInternal();

          if (_a16.equals(s)) continue;
          if (!_a16.contains(s)) continue;
          i = dt.ptNotInList(n.getCoordinates(), _l27.getCoordinates());

          var _c13 = !1;

          ke.isInRing(i, _l27.getCoordinates()) && (_c13 = !0), _c13 && (null === r || o.contains(_a16)) && (r = _e436, o = r.getLinearRing().getEnvelopeInternal());
        }

        return r;
      }
    }]);

    return di;
  }();

  var _i = /*#__PURE__*/function () {
    function _i() {
      _classCallCheck(this, _i);

      _i.constructor_.apply(this, arguments);
    }

    _createClass(_i, [{
      key: "isDeletable",
      value: function isDeletable(t, e, n, s) {
        var i = this._inputLine[t],
            r = this._inputLine[e],
            o = this._inputLine[n];
        return !!this.isConcave(i, r, o) && !!this.isShallow(i, r, o, s) && this.isShallowSampled(i, r, t, n, s);
      }
    }, {
      key: "deleteShallowConcavities",
      value: function deleteShallowConcavities() {
        var t = 1,
            e = this.findNextNonDeletedIndex(t),
            n = this.findNextNonDeletedIndex(e),
            s = !1;

        for (; n < this._inputLine.length;) {
          var _i96 = !1;

          this.isDeletable(t, e, n, this._distanceTol) && (this._isDeleted[e] = _i.DELETE, _i96 = !0, s = !0), t = _i96 ? n : e, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e);
        }

        return s;
      }
    }, {
      key: "isShallowConcavity",
      value: function isShallowConcavity(t, e, n, s) {
        if (!(D.index(t, e, n) === this._angleOrientation)) return !1;
        return q.pointToSegment(e, t, n) < s;
      }
    }, {
      key: "isShallowSampled",
      value: function isShallowSampled(t, e, n, s, i) {
        var r = Math.trunc((s - n) / _i.NUM_PTS_TO_CHECK);
        r <= 0 && (r = 1);

        for (var _o30 = n; _o30 < s; _o30 += r) {
          if (!this.isShallow(t, e, this._inputLine[_o30], i)) return !1;
        }

        return !0;
      }
    }, {
      key: "isConcave",
      value: function isConcave(t, e, n) {
        return D.index(t, e, n) === this._angleOrientation;
      }
    }, {
      key: "simplify",
      value: function simplify(t) {
        this._distanceTol = Math.abs(t), t < 0 && (this._angleOrientation = D.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
        var e = !1;

        do {
          e = this.deleteShallowConcavities();
        } while (e);

        return this.collapseLine();
      }
    }, {
      key: "findNextNonDeletedIndex",
      value: function findNextNonDeletedIndex(t) {
        var e = t + 1;

        for (; e < this._inputLine.length && this._isDeleted[e] === _i.DELETE;) {
          e++;
        }

        return e;
      }
    }, {
      key: "isShallow",
      value: function isShallow(t, e, n, s) {
        return q.pointToSegment(e, t, n) < s;
      }
    }, {
      key: "collapseLine",
      value: function collapseLine() {
        var t = new C();

        for (var _e437 = 0; _e437 < this._inputLine.length; _e437++) {
          this._isDeleted[_e437] !== _i.DELETE && t.add(this._inputLine[_e437]);
        }

        return t.toCoordinateArray();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._inputLine = null, this._distanceTol = null, this._isDeleted = null, this._angleOrientation = D.COUNTERCLOCKWISE;
        var t = arguments[0];
        this._inputLine = t;
      }
    }, {
      key: "simplify",
      value: function simplify(t, e) {
        return new _i(t).simplify(e);
      }
    }]);

    return _i;
  }();

  _i.INIT = 0, _i.DELETE = 1, _i.KEEP = 1, _i.NUM_PTS_TO_CHECK = 10;

  var pi = /*#__PURE__*/function () {
    function pi() {
      _classCallCheck(this, pi);

      pi.constructor_.apply(this, arguments);
    }

    _createClass(pi, [{
      key: "getCoordinates",
      value: function getCoordinates() {
        return this._ptList.toArray(pi.COORDINATE_ARRAY_TYPE);
      }
    }, {
      key: "setPrecisionModel",
      value: function setPrecisionModel(t) {
        this._precisionModel = t;
      }
    }, {
      key: "addPt",
      value: function addPt(t) {
        var e = new m(t);
        if (this._precisionModel.makePrecise(e), this.isRedundant(e)) return null;

        this._ptList.add(e);
      }
    }, {
      key: "reverse",
      value: function reverse() {}
    }, {
      key: "addPts",
      value: function addPts(t, e) {
        if (e) for (var _e438 = 0; _e438 < t.length; _e438++) {
          this.addPt(t[_e438]);
        } else for (var _e439 = t.length - 1; _e439 >= 0; _e439--) {
          this.addPt(t[_e439]);
        }
      }
    }, {
      key: "isRedundant",
      value: function isRedundant(t) {
        if (this._ptList.size() < 1) return !1;

        var e = this._ptList.get(this._ptList.size() - 1);

        return t.distance(e) < this._minimimVertexDistance;
      }
    }, {
      key: "toString",
      value: function toString() {
        return new Ct().createLineString(this.getCoordinates()).toString();
      }
    }, {
      key: "closeRing",
      value: function closeRing() {
        if (this._ptList.size() < 1) return null;

        var t = new m(this._ptList.get(0)),
            e = this._ptList.get(this._ptList.size() - 1);

        if (t.equals(e)) return null;

        this._ptList.add(t);
      }
    }, {
      key: "setMinimumVertexDistance",
      value: function setMinimumVertexDistance(t) {
        this._minimimVertexDistance = t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new S();
      }
    }]);

    return pi;
  }();

  pi.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);

  var mi = /*#__PURE__*/function () {
    function mi() {
      _classCallCheck(this, mi);

      mi.constructor_.apply(this, arguments);
    }

    _createClass(mi, [{
      key: "addNextSegment",
      value: function addNextSegment(t, e) {
        if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;
        var n = D.index(this._s0, this._s1, this._s2),
            s = n === D.CLOCKWISE && this._side === vn.LEFT || n === D.COUNTERCLOCKWISE && this._side === vn.RIGHT;
        0 === n ? this.addCollinear(e) : s ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e);
      }
    }, {
      key: "addLineEndCap",
      value: function addLineEndCap(t, e) {
        var n = new jt(t, e),
            s = new jt();
        this.computeOffsetSegment(n, vn.LEFT, this._distance, s);
        var i = new jt();
        this.computeOffsetSegment(n, vn.RIGHT, this._distance, i);
        var r = e.x - t.x,
            o = e.y - t.y,
            l = Math.atan2(o, r);

        switch (this._bufParams.getEndCapStyle()) {
          case oi.CAP_ROUND:
            this._segList.addPt(s.p1), this.addDirectedFillet(e, l + Math.PI / 2, l - Math.PI / 2, D.CLOCKWISE, this._distance), this._segList.addPt(i.p1);
            break;

          case oi.CAP_FLAT:
            this._segList.addPt(s.p1), this._segList.addPt(i.p1);
            break;

          case oi.CAP_SQUARE:
            var _t553 = new m();

            _t553.x = Math.abs(this._distance) * Math.cos(l), _t553.y = Math.abs(this._distance) * Math.sin(l);

            var _n317 = new m(s.p1.x + _t553.x, s.p1.y + _t553.y),
                _r51 = new m(i.p1.x + _t553.x, i.p1.y + _t553.y);

            this._segList.addPt(_n317), this._segList.addPt(_r51);
        }
      }
    }, {
      key: "getCoordinates",
      value: function getCoordinates() {
        return this._segList.getCoordinates();
      }
    }, {
      key: "addMitreJoin",
      value: function addMitreJoin(t, e, n, s) {
        var i = A.intersection(e.p0, e.p1, n.p0, n.p1);

        if (null !== i) {
          if ((s <= 0 ? 1 : i.distance(t) / Math.abs(s)) <= this._bufParams.getMitreLimit()) return this._segList.addPt(i), null;
        }

        this.addLimitedMitreJoin(e, n, s, this._bufParams.getMitreLimit());
      }
    }, {
      key: "addOutsideTurn",
      value: function addOutsideTurn(t, e) {
        if (this._offset0.p1.distance(this._offset1.p0) < this._distance * mi.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;
        this._bufParams.getJoinStyle() === oi.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === oi.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (e && this._segList.addPt(this._offset0.p1), this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, t, this._distance), this._segList.addPt(this._offset1.p0));
      }
    }, {
      key: "createSquare",
      value: function createSquare(t) {
        this._segList.addPt(new m(t.x + this._distance, t.y + this._distance)), this._segList.addPt(new m(t.x + this._distance, t.y - this._distance)), this._segList.addPt(new m(t.x - this._distance, t.y - this._distance)), this._segList.addPt(new m(t.x - this._distance, t.y + this._distance)), this._segList.closeRing();
      }
    }, {
      key: "addSegments",
      value: function addSegments(t, e) {
        this._segList.addPts(t, e);
      }
    }, {
      key: "addFirstSegment",
      value: function addFirstSegment() {
        this._segList.addPt(this._offset1.p0);
      }
    }, {
      key: "addCornerFillet",
      value: function addCornerFillet(t, e, n, s, i) {
        var r = e.x - t.x,
            o = e.y - t.y;
        var l = Math.atan2(o, r);
        var a = n.x - t.x,
            c = n.y - t.y,
            h = Math.atan2(c, a);
        s === D.CLOCKWISE ? l <= h && (l += 2 * Math.PI) : l >= h && (l -= 2 * Math.PI), this._segList.addPt(e), this.addDirectedFillet(t, l, h, s, i), this._segList.addPt(n);
      }
    }, {
      key: "addLastSegment",
      value: function addLastSegment() {
        this._segList.addPt(this._offset1.p1);
      }
    }, {
      key: "initSideSegments",
      value: function initSideSegments(t, e, n) {
        this._s1 = t, this._s2 = e, this._side = n, this._seg1.setCoordinates(t, e), this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1);
      }
    }, {
      key: "addLimitedMitreJoin",
      value: function addLimitedMitreJoin(t, e, n, s) {
        var i = this._seg0.p1,
            r = Jt.angle(i, this._seg0.p0),
            o = Jt.angleBetweenOriented(this._seg0.p0, i, this._seg1.p1) / 2,
            l = Jt.normalize(r + o),
            a = Jt.normalize(l + Math.PI),
            c = s * n,
            h = n - c * Math.abs(Math.sin(o)),
            u = i.x + c * Math.cos(a),
            g = i.y + c * Math.sin(a),
            d = new m(u, g),
            _ = new jt(i, d),
            p = _.pointAlongOffset(1, h),
            f = _.pointAlongOffset(1, -h);

        this._side === vn.LEFT ? (this._segList.addPt(p), this._segList.addPt(f)) : (this._segList.addPt(f), this._segList.addPt(p));
      }
    }, {
      key: "addDirectedFillet",
      value: function addDirectedFillet(t, e, n, s, i) {
        var r = s === D.CLOCKWISE ? -1 : 1,
            o = Math.abs(e - n),
            l = Math.trunc(o / this._filletAngleQuantum + .5);
        if (l < 1) return null;
        var a = o / l,
            c = new m();

        for (var _n318 = 0; _n318 < l; _n318++) {
          var _s188 = e + r * _n318 * a;

          c.x = t.x + i * Math.cos(_s188), c.y = t.y + i * Math.sin(_s188), this._segList.addPt(c);
        }
      }
    }, {
      key: "computeOffsetSegment",
      value: function computeOffsetSegment(t, e, n, s) {
        var i = e === vn.LEFT ? 1 : -1,
            r = t.p1.x - t.p0.x,
            o = t.p1.y - t.p0.y,
            l = Math.sqrt(r * r + o * o),
            a = i * n * r / l,
            c = i * n * o / l;
        s.p0.x = t.p0.x - c, s.p0.y = t.p0.y + a, s.p1.x = t.p1.x - c, s.p1.y = t.p1.y + a;
      }
    }, {
      key: "addInsideTurn",
      value: function addInsideTurn(t, e) {
        if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * mi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);else {
          if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
            var _t554 = new m((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));

            this._segList.addPt(_t554);

            var _e440 = new m((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));

            this._segList.addPt(_e440);
          } else this._segList.addPt(this._s1);

          this._segList.addPt(this._offset1.p0);
        }
      }
    }, {
      key: "createCircle",
      value: function createCircle(t) {
        var e = new m(t.x + this._distance, t.y);
        this._segList.addPt(e), this.addDirectedFillet(t, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
      }
    }, {
      key: "addBevelJoin",
      value: function addBevelJoin(t, e) {
        this._segList.addPt(t.p1), this._segList.addPt(e.p0);
      }
    }, {
      key: "init",
      value: function init(t) {
        this._distance = t, this._maxCurveSegmentError = t * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new pi(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t * mi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
      }
    }, {
      key: "addCollinear",
      value: function addCollinear(t) {
        this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);

        this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === oi.JOIN_BEVEL || this._bufParams.getJoinStyle() === oi.JOIN_MITRE ? (t && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, D.CLOCKWISE, this._distance));
      }
    }, {
      key: "closeRing",
      value: function closeRing() {
        this._segList.closeRing();
      }
    }, {
      key: "hasNarrowConcaveAngle",
      value: function hasNarrowConcaveAngle() {
        return this._hasNarrowConcaveAngle;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new jt(), this._seg1 = new jt(), this._offset0 = new jt(), this._offset1 = new jt(), this._side = 0, this._hasNarrowConcaveAngle = !1;
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2];
        this._precisionModel = t, this._bufParams = e, this._li = new Zt(), this._filletAngleQuantum = Math.PI / 2 / e.getQuadrantSegments(), e.getQuadrantSegments() >= 8 && e.getJoinStyle() === oi.JOIN_ROUND && (this._closingSegLengthFactor = mi.MAX_CLOSING_SEG_LEN_FACTOR), this.init(n);
      }
    }]);

    return mi;
  }();

  mi.OFFSET_SEGMENT_SEPARATION_FACTOR = .001, mi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = .001, mi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, mi.MAX_CLOSING_SEG_LEN_FACTOR = 80;

  var fi = /*#__PURE__*/function () {
    function fi() {
      _classCallCheck(this, fi);

      fi.constructor_.apply(this, arguments);
    }

    _createClass(fi, [{
      key: "getOffsetCurve",
      value: function getOffsetCurve(t, e) {
        if (this._distance = e, 0 === e) return null;
        var n = e < 0,
            s = Math.abs(e),
            i = this.getSegGen(s);
        t.length <= 1 ? this.computePointCurve(t[0], i) : this.computeOffsetCurve(t, n, i);
        var r = i.getCoordinates();
        return n && dt.reverse(r), r;
      }
    }, {
      key: "computeSingleSidedBufferCurve",
      value: function computeSingleSidedBufferCurve(t, e, n) {
        var s = this.simplifyTolerance(this._distance);

        if (e) {
          n.addSegments(t, !0);

          var _e441 = _i.simplify(t, -s),
              _i97 = _e441.length - 1;

          n.initSideSegments(_e441[_i97], _e441[_i97 - 1], vn.LEFT), n.addFirstSegment();

          for (var _t555 = _i97 - 2; _t555 >= 0; _t555--) {
            n.addNextSegment(_e441[_t555], !0);
          }
        } else {
          n.addSegments(t, !1);

          var _e442 = _i.simplify(t, s),
              _i98 = _e442.length - 1;

          n.initSideSegments(_e442[0], _e442[1], vn.LEFT), n.addFirstSegment();

          for (var _t556 = 2; _t556 <= _i98; _t556++) {
            n.addNextSegment(_e442[_t556], !0);
          }
        }

        n.addLastSegment(), n.closeRing();
      }
    }, {
      key: "computeRingBufferCurve",
      value: function computeRingBufferCurve(t, e, n) {
        var s = this.simplifyTolerance(this._distance);
        e === vn.RIGHT && (s = -s);

        var i = _i.simplify(t, s),
            r = i.length - 1;

        n.initSideSegments(i[r - 1], i[0], e);

        for (var _t557 = 1; _t557 <= r; _t557++) {
          var _e443 = 1 !== _t557;

          n.addNextSegment(i[_t557], _e443);
        }

        n.closeRing();
      }
    }, {
      key: "computeLineBufferCurve",
      value: function computeLineBufferCurve(t, e) {
        var n = this.simplifyTolerance(this._distance),
            s = _i.simplify(t, n),
            i = s.length - 1;

        e.initSideSegments(s[0], s[1], vn.LEFT);

        for (var _t558 = 2; _t558 <= i; _t558++) {
          e.addNextSegment(s[_t558], !0);
        }

        e.addLastSegment(), e.addLineEndCap(s[i - 1], s[i]);

        var r = _i.simplify(t, -n),
            o = r.length - 1;

        e.initSideSegments(r[o], r[o - 1], vn.LEFT);

        for (var _t559 = o - 2; _t559 >= 0; _t559--) {
          e.addNextSegment(r[_t559], !0);
        }

        e.addLastSegment(), e.addLineEndCap(r[1], r[0]), e.closeRing();
      }
    }, {
      key: "computePointCurve",
      value: function computePointCurve(t, e) {
        switch (this._bufParams.getEndCapStyle()) {
          case oi.CAP_ROUND:
            e.createCircle(t);
            break;

          case oi.CAP_SQUARE:
            e.createSquare(t);
        }
      }
    }, {
      key: "getLineCurve",
      value: function getLineCurve(t, e) {
        if (this._distance = e, this.isLineOffsetEmpty(e)) return null;
        var n = Math.abs(e),
            s = this.getSegGen(n);
        if (t.length <= 1) this.computePointCurve(t[0], s);else if (this._bufParams.isSingleSided()) {
          var _n319 = e < 0;

          this.computeSingleSidedBufferCurve(t, _n319, s);
        } else this.computeLineBufferCurve(t, s);
        return s.getCoordinates();
      }
    }, {
      key: "getBufferParameters",
      value: function getBufferParameters() {
        return this._bufParams;
      }
    }, {
      key: "simplifyTolerance",
      value: function simplifyTolerance(t) {
        return t * this._bufParams.getSimplifyFactor();
      }
    }, {
      key: "getRingCurve",
      value: function getRingCurve(t, e, n) {
        if (this._distance = n, t.length <= 2) return this.getLineCurve(t, n);
        if (0 === n) return fi.copyCoordinates(t);
        var s = this.getSegGen(n);
        return this.computeRingBufferCurve(t, e, s), s.getCoordinates();
      }
    }, {
      key: "computeOffsetCurve",
      value: function computeOffsetCurve(t, e, n) {
        var s = this.simplifyTolerance(this._distance);

        if (e) {
          var _e444 = _i.simplify(t, -s),
              _i99 = _e444.length - 1;

          n.initSideSegments(_e444[_i99], _e444[_i99 - 1], vn.LEFT), n.addFirstSegment();

          for (var _t560 = _i99 - 2; _t560 >= 0; _t560--) {
            n.addNextSegment(_e444[_t560], !0);
          }
        } else {
          var _e445 = _i.simplify(t, s),
              _i100 = _e445.length - 1;

          n.initSideSegments(_e445[0], _e445[1], vn.LEFT), n.addFirstSegment();

          for (var _t561 = 2; _t561 <= _i100; _t561++) {
            n.addNextSegment(_e445[_t561], !0);
          }
        }

        n.addLastSegment();
      }
    }, {
      key: "isLineOffsetEmpty",
      value: function isLineOffsetEmpty(t) {
        return 0 === t || t < 0 && !this._bufParams.isSingleSided();
      }
    }, {
      key: "getSegGen",
      value: function getSegGen(t) {
        return new mi(this._precisionModel, this._bufParams, t);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._distance = 0, this._precisionModel = null, this._bufParams = null;
        var t = arguments[0],
            e = arguments[1];
        this._precisionModel = t, this._bufParams = e;
      }
    }, {
      key: "copyCoordinates",
      value: function copyCoordinates(t) {
        var e = new Array(t.length).fill(null);

        for (var _n320 = 0; _n320 < e.length; _n320++) {
          e[_n320] = new m(t[_n320]);
        }

        return e;
      }
    }]);

    return fi;
  }();

  var yi = /*#__PURE__*/function () {
    function yi() {
      _classCallCheck(this, yi);

      yi.constructor_.apply(this, arguments);
    }

    _createClass(yi, [{
      key: "findStabbedSegments",
      value: function findStabbedSegments() {
        if (1 === arguments.length) {
          var _t562 = arguments[0],
              _e446 = new S();

          for (var _n321 = this._subgraphs.iterator(); _n321.hasNext();) {
            var _s189 = _n321.next(),
                _i101 = _s189.getEnvelope();

            _t562.y < _i101.getMinY() || _t562.y > _i101.getMaxY() || this.findStabbedSegments(_t562, _s189.getDirectedEdges(), _e446);
          }

          return _e446;
        }

        if (3 === arguments.length) if (y(arguments[2], I) && arguments[0] instanceof m && arguments[1] instanceof ss) {
          var _t563 = arguments[0],
              _e447 = arguments[1],
              _n322 = arguments[2],
              _s190 = _e447.getEdge().getCoordinates();

          for (var _i102 = 0; _i102 < _s190.length - 1; _i102++) {
            this._seg.p0 = _s190[_i102], this._seg.p1 = _s190[_i102 + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse();
            if (Math.max(this._seg.p0.x, this._seg.p1.x) < _t563.x) continue;
            if (this._seg.isHorizontal()) continue;
            if (_t563.y < this._seg.p0.y || _t563.y > this._seg.p1.y) continue;
            if (D.index(this._seg.p0, this._seg.p1, _t563) === D.RIGHT) continue;

            var _r52 = _e447.getDepth(vn.LEFT);

            this._seg.p0.equals(_s190[_i102]) || (_r52 = _e447.getDepth(vn.RIGHT));

            var _o31 = new xi(this._seg, _r52);

            _n322.add(_o31);
          }
        } else if (y(arguments[2], I) && arguments[0] instanceof m && y(arguments[1], I)) {
          var _t564 = arguments[0],
              _e448 = arguments[2];

          for (var _n323 = arguments[1].iterator(); _n323.hasNext();) {
            var _s191 = _n323.next();

            _s191.isForward() && this.findStabbedSegments(_t564, _s191, _e448);
          }
        }
      }
    }, {
      key: "getDepth",
      value: function getDepth(t) {
        var e = this.findStabbedSegments(t);
        if (0 === e.size()) return 0;
        return ye.min(e)._leftDepth;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._subgraphs = null, this._seg = new jt();
        var t = arguments[0];
        this._subgraphs = t;
      }
    }]);

    return yi;
  }();

  var xi = /*#__PURE__*/function () {
    function xi() {
      _classCallCheck(this, xi);

      xi.constructor_.apply(this, arguments);
    }

    _createClass(xi, [{
      key: "compareTo",
      value: function compareTo(t) {
        var e = t;
        if (this._upwardSeg.minX() >= e._upwardSeg.maxX()) return 1;
        if (this._upwardSeg.maxX() <= e._upwardSeg.minX()) return -1;

        var n = this._upwardSeg.orientationIndex(e._upwardSeg);

        return 0 !== n ? n : (n = -1 * e._upwardSeg.orientationIndex(this._upwardSeg), 0 !== n ? n : this._upwardSeg.compareTo(e._upwardSeg));
      }
    }, {
      key: "compareX",
      value: function compareX(t, e) {
        var n = t.p0.compareTo(e.p0);
        return 0 !== n ? n : t.p1.compareTo(e.p1);
      }
    }, {
      key: "toString",
      value: function toString() {
        return this._upwardSeg.toString();
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [o];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._upwardSeg = null, this._leftDepth = null;
        var t = arguments[0],
            e = arguments[1];
        this._upwardSeg = new jt(t), this._leftDepth = e;
      }
    }]);

    return xi;
  }();

  yi.DepthSegment = xi;

  var Ei = /*#__PURE__*/function () {
    function Ei() {
      _classCallCheck(this, Ei);

      Ei.constructor_.apply(this, arguments);
    }

    _createClass(Ei, [{
      key: "addRingSide",
      value: function addRingSide(t, e, n, s, i) {
        if (0 === e && t.length < at.MINIMUM_VALID_SIZE) return null;
        var r = s,
            o = i;
        t.length >= at.MINIMUM_VALID_SIZE && D.isCCW(t) && (r = i, o = s, n = vn.opposite(n));

        var l = this._curveBuilder.getRingCurve(t, n, e);

        this.addCurve(l, r, o);
      }
    }, {
      key: "addRingBothSides",
      value: function addRingBothSides(t, e) {
        this.addRingSide(t, e, vn.LEFT, Kt.EXTERIOR, Kt.INTERIOR), this.addRingSide(t, e, vn.RIGHT, Kt.INTERIOR, Kt.EXTERIOR);
      }
    }, {
      key: "addPoint",
      value: function addPoint(t) {
        if (this._distance <= 0) return null;

        var e = t.getCoordinates(),
            n = this._curveBuilder.getLineCurve(e, this._distance);

        this.addCurve(n, Kt.EXTERIOR, Kt.INTERIOR);
      }
    }, {
      key: "addPolygon",
      value: function addPolygon(t) {
        var e = this._distance,
            n = vn.LEFT;
        this._distance < 0 && (e = -this._distance, n = vn.RIGHT);
        var s = t.getExteriorRing(),
            i = dt.removeRepeatedPoints(s.getCoordinates());
        if (this._distance < 0 && this.isErodedCompletely(s, this._distance)) return null;
        if (this._distance <= 0 && i.length < 3) return null;
        this.addRingSide(i, e, n, Kt.EXTERIOR, Kt.INTERIOR);

        for (var _s192 = 0; _s192 < t.getNumInteriorRing(); _s192++) {
          var _i103 = t.getInteriorRingN(_s192),
              _r53 = dt.removeRepeatedPoints(_i103.getCoordinates());

          this._distance > 0 && this.isErodedCompletely(_i103, -this._distance) || this.addRingSide(_r53, e, vn.opposite(n), Kt.INTERIOR, Kt.EXTERIOR);
        }
      }
    }, {
      key: "isTriangleErodedCompletely",
      value: function isTriangleErodedCompletely(t, e) {
        var n = new ee(t[0], t[1], t[2]),
            s = n.inCentre();
        return q.pointToSegment(s, n.p0, n.p1) < Math.abs(e);
      }
    }, {
      key: "addLineString",
      value: function addLineString(t) {
        if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null;
        var e = dt.removeRepeatedPoints(t.getCoordinates());
        if (dt.isRing(e) && !this._curveBuilder.getBufferParameters().isSingleSided()) this.addRingBothSides(e, this._distance);else {
          var _t565 = this._curveBuilder.getLineCurve(e, this._distance);

          this.addCurve(_t565, Kt.EXTERIOR, Kt.INTERIOR);
        }
      }
    }, {
      key: "addCurve",
      value: function addCurve(t, e, n) {
        if (null === t || t.length < 2) return null;
        var s = new Hs(t, new Gn(0, Kt.BOUNDARY, e, n));

        this._curveList.add(s);
      }
    }, {
      key: "getCurves",
      value: function getCurves() {
        return this.add(this._inputGeom), this._curveList;
      }
    }, {
      key: "add",
      value: function add(t) {
        if (t.isEmpty()) return null;
        if (t instanceof et) this.addPolygon(t);else if (t instanceof j) this.addLineString(t);else if (t instanceof Q) this.addPoint(t);else if (t instanceof lt) this.addCollection(t);else if (t instanceof wt) this.addCollection(t);else if (t instanceof ft) this.addCollection(t);else {
          if (!(t instanceof ot)) throw new H(t.getGeometryType());
          this.addCollection(t);
        }
      }
    }, {
      key: "isErodedCompletely",
      value: function isErodedCompletely(t, e) {
        var n = t.getCoordinates();
        if (n.length < 4) return e < 0;
        if (4 === n.length) return this.isTriangleErodedCompletely(n, e);
        var s = t.getEnvelopeInternal(),
            i = Math.min(s.getHeight(), s.getWidth());
        return e < 0 && 2 * Math.abs(e) > i;
      }
    }, {
      key: "addCollection",
      value: function addCollection(t) {
        for (var _e449 = 0; _e449 < t.getNumGeometries(); _e449++) {
          var _n324 = t.getGeometryN(_e449);

          this.add(_n324);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new S();
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2];
        this._inputGeom = t, this._distance = e, this._curveBuilder = n;
      }
    }]);

    return Ei;
  }();

  var Ii = /*#__PURE__*/function () {
    function Ii() {
      _classCallCheck(this, Ii);

      Ii.constructor_.apply(this, arguments);
    }

    _createClass(Ii, [{
      key: "getNextCW",
      value: function getNextCW(t) {
        this.getEdges();

        var e = this._edgeList.indexOf(t);

        var n = e - 1;
        return 0 === e && (n = this._edgeList.size() - 1), this._edgeList.get(n);
      }
    }, {
      key: "propagateSideLabels",
      value: function propagateSideLabels(t) {
        var e = Kt.NONE;

        for (var _n325 = this.iterator(); _n325.hasNext();) {
          var _s193 = _n325.next().getLabel();

          _s193.isArea(t) && _s193.getLocation(t, vn.LEFT) !== Kt.NONE && (e = _s193.getLocation(t, vn.LEFT));
        }

        if (e === Kt.NONE) return null;
        var n = e;

        for (var _e450 = this.iterator(); _e450.hasNext();) {
          var _s194 = _e450.next(),
              _i104 = _s194.getLabel();

          if (_i104.getLocation(t, vn.ON) === Kt.NONE && _i104.setLocation(t, vn.ON, n), _i104.isArea(t)) {
            var _e451 = _i104.getLocation(t, vn.LEFT),
                _r54 = _i104.getLocation(t, vn.RIGHT);

            if (_r54 !== Kt.NONE) {
              if (_r54 !== n) throw new ns("side location conflict", _s194.getCoordinate());
              _e451 === Kt.NONE && g.shouldNeverReachHere("found single null side (at " + _s194.getCoordinate() + ")"), n = _e451;
            } else g.isTrue(_i104.getLocation(t, vn.LEFT) === Kt.NONE, "found single null side"), _i104.setLocation(t, vn.RIGHT, n), _i104.setLocation(t, vn.LEFT, n);
          }
        }
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        var t = this.iterator();
        if (!t.hasNext()) return null;
        return t.next().getCoordinate();
      }
    }, {
      key: "print",
      value: function print(t) {
        F.out.println("EdgeEndStar:   " + this.getCoordinate());

        for (var _e452 = this.iterator(); _e452.hasNext();) {
          _e452.next().print(t);
        }
      }
    }, {
      key: "isAreaLabelsConsistent",
      value: function isAreaLabelsConsistent(t) {
        return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
      }
    }, {
      key: "checkAreaLabelsConsistent",
      value: function checkAreaLabelsConsistent(t) {
        var e = this.getEdges();
        if (e.size() <= 0) return !0;
        var n = e.size() - 1,
            s = e.get(n).getLabel().getLocation(t, vn.LEFT);
        g.isTrue(s !== Kt.NONE, "Found unlabelled area edge");
        var i = s;

        for (var _e453 = this.iterator(); _e453.hasNext();) {
          var _n326 = _e453.next().getLabel();

          g.isTrue(_n326.isArea(t), "Found non-area edge");

          var _s195 = _n326.getLocation(t, vn.LEFT),
              _r55 = _n326.getLocation(t, vn.RIGHT);

          if (_s195 === _r55) return !1;
          if (_r55 !== i) return !1;
          i = _s195;
        }

        return !0;
      }
    }, {
      key: "findIndex",
      value: function findIndex(t) {
        this.iterator();

        for (var _e454 = 0; _e454 < this._edgeList.size(); _e454++) {
          if (this._edgeList.get(_e454) === t) return _e454;
        }

        return -1;
      }
    }, {
      key: "iterator",
      value: function iterator() {
        return this.getEdges().iterator();
      }
    }, {
      key: "getEdges",
      value: function getEdges() {
        return null === this._edgeList && (this._edgeList = new S(this._edgeMap.values())), this._edgeList;
      }
    }, {
      key: "getLocation",
      value: function getLocation(t, e, n) {
        return this._ptInAreaLocation[t] === Kt.NONE && (this._ptInAreaLocation[t] = We.locate(e, n[t].getGeometry())), this._ptInAreaLocation[t];
      }
    }, {
      key: "toString",
      value: function toString() {
        var t = new R();
        t.append("EdgeEndStar:   " + this.getCoordinate()), t.append("\n");

        for (var _e455 = this.iterator(); _e455.hasNext();) {
          var _n327 = _e455.next();

          t.append(_n327), t.append("\n");
        }

        return t.toString();
      }
    }, {
      key: "computeEdgeEndLabels",
      value: function computeEdgeEndLabels(t) {
        for (var _e456 = this.iterator(); _e456.hasNext();) {
          _e456.next().computeLabel(t);
        }
      }
    }, {
      key: "computeLabelling",
      value: function computeLabelling(t) {
        this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
        var e = [!1, !1];

        for (var _t566 = this.iterator(); _t566.hasNext();) {
          var _n328 = _t566.next().getLabel();

          for (var _t567 = 0; _t567 < 2; _t567++) {
            _n328.isLine(_t567) && _n328.getLocation(_t567) === Kt.BOUNDARY && (e[_t567] = !0);
          }
        }

        for (var _n329 = this.iterator(); _n329.hasNext();) {
          var _s196 = _n329.next(),
              _i105 = _s196.getLabel();

          for (var _n330 = 0; _n330 < 2; _n330++) {
            if (_i105.isAnyNull(_n330)) {
              var _r56 = Kt.NONE;
              if (e[_n330]) _r56 = Kt.EXTERIOR;else {
                var _e457 = _s196.getCoordinate();

                _r56 = this.getLocation(_n330, _e457, t);
              }

              _i105.setAllLocationsIfNull(_n330, _r56);
            }
          }
        }
      }
    }, {
      key: "getDegree",
      value: function getDegree() {
        return this._edgeMap.size();
      }
    }, {
      key: "insertEdgeEnd",
      value: function insertEdgeEnd(t, e) {
        this._edgeMap.put(t, e), this._edgeList = null;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._edgeMap = new Un(), this._edgeList = null, this._ptInAreaLocation = [Kt.NONE, Kt.NONE];
      }
    }]);

    return Ii;
  }();

  var Ni = /*#__PURE__*/function (_Ii) {
    _inherits(Ni, _Ii);

    var _super54 = _createSuper(Ni);

    function Ni() {
      var _this41;

      _classCallCheck(this, Ni);

      _this41 = _super54.call(this), Ni.constructor_.apply(_assertThisInitialized(_this41), arguments);
      return _this41;
    }

    _createClass(Ni, [{
      key: "linkResultDirectedEdges",
      value: function linkResultDirectedEdges() {
        this.getResultAreaEdges();
        var t = null,
            e = null,
            n = this._SCANNING_FOR_INCOMING;

        for (var _s197 = 0; _s197 < this._resultAreaEdgeList.size(); _s197++) {
          var _i106 = this._resultAreaEdgeList.get(_s197),
              _r57 = _i106.getSym();

          if (_i106.getLabel().isArea()) switch (null === t && _i106.isInResult() && (t = _i106), n) {
            case this._SCANNING_FOR_INCOMING:
              if (!_r57.isInResult()) continue;
              e = _r57, n = this._LINKING_TO_OUTGOING;
              break;

            case this._LINKING_TO_OUTGOING:
              if (!_i106.isInResult()) continue;
              e.setNext(_i106), n = this._SCANNING_FOR_INCOMING;
          }
        }

        if (n === this._LINKING_TO_OUTGOING) {
          if (null === t) throw new ns("no outgoing dirEdge found", this.getCoordinate());
          g.isTrue(t.isInResult(), "unable to link last incoming dirEdge"), e.setNext(t);
        }
      }
    }, {
      key: "insert",
      value: function insert(t) {
        var e = t;
        this.insertEdgeEnd(e, e);
      }
    }, {
      key: "getRightmostEdge",
      value: function getRightmostEdge() {
        var t = this.getEdges(),
            e = t.size();
        if (e < 1) return null;
        var n = t.get(0);
        if (1 === e) return n;
        var s = t.get(e - 1),
            i = n.getQuadrant(),
            r = s.getQuadrant();
        return Sn.isNorthern(i) && Sn.isNorthern(r) ? n : Sn.isNorthern(i) || Sn.isNorthern(r) ? 0 !== n.getDy() ? n : 0 !== s.getDy() ? s : (g.shouldNeverReachHere("found two horizontal edges incident on node"), null) : s;
      }
    }, {
      key: "print",
      value: function print(t) {
        F.out.println("DirectedEdgeStar: " + this.getCoordinate());

        for (var _e458 = this.iterator(); _e458.hasNext();) {
          var _n331 = _e458.next();

          t.print("out "), _n331.print(t), t.println(), t.print("in "), _n331.getSym().print(t), t.println();
        }
      }
    }, {
      key: "getResultAreaEdges",
      value: function getResultAreaEdges() {
        if (null !== this._resultAreaEdgeList) return this._resultAreaEdgeList;
        this._resultAreaEdgeList = new S();

        for (var _t568 = this.iterator(); _t568.hasNext();) {
          var _e459 = _t568.next();

          (_e459.isInResult() || _e459.getSym().isInResult()) && this._resultAreaEdgeList.add(_e459);
        }

        return this._resultAreaEdgeList;
      }
    }, {
      key: "updateLabelling",
      value: function updateLabelling(t) {
        for (var _e460 = this.iterator(); _e460.hasNext();) {
          var _n332 = _e460.next().getLabel();

          _n332.setAllLocationsIfNull(0, t.getLocation(0)), _n332.setAllLocationsIfNull(1, t.getLocation(1));
        }
      }
    }, {
      key: "linkAllDirectedEdges",
      value: function linkAllDirectedEdges() {
        this.getEdges();
        var t = null,
            e = null;

        for (var _n333 = this._edgeList.size() - 1; _n333 >= 0; _n333--) {
          var _s198 = this._edgeList.get(_n333),
              _i107 = _s198.getSym();

          null === e && (e = _i107), null !== t && _i107.setNext(t), t = _s198;
        }

        e.setNext(t);
      }
    }, {
      key: "computeDepths",
      value: function computeDepths() {
        if (1 === arguments.length) {
          var _t569 = arguments[0],
              _e461 = this.findIndex(_t569),
              _n334 = _t569.getDepth(vn.LEFT),
              _s199 = _t569.getDepth(vn.RIGHT),
              _i108 = this.computeDepths(_e461 + 1, this._edgeList.size(), _n334);

          if (this.computeDepths(0, _e461, _i108) !== _s199) throw new ns("depth mismatch at " + _t569.getCoordinate());
        } else if (3 === arguments.length) {
          var _t570 = arguments[1];
          var _e462 = arguments[2];

          for (var _n335 = arguments[0]; _n335 < _t570; _n335++) {
            var _t571 = this._edgeList.get(_n335);

            _t571.setEdgeDepths(vn.RIGHT, _e462), _e462 = _t571.getDepth(vn.LEFT);
          }

          return _e462;
        }
      }
    }, {
      key: "mergeSymLabels",
      value: function mergeSymLabels() {
        for (var _t572 = this.iterator(); _t572.hasNext();) {
          var _e463 = _t572.next();

          _e463.getLabel().merge(_e463.getSym().getLabel());
        }
      }
    }, {
      key: "linkMinimalDirectedEdges",
      value: function linkMinimalDirectedEdges(t) {
        var e = null,
            n = null,
            s = this._SCANNING_FOR_INCOMING;

        for (var _i109 = this._resultAreaEdgeList.size() - 1; _i109 >= 0; _i109--) {
          var _r58 = this._resultAreaEdgeList.get(_i109),
              _o32 = _r58.getSym();

          switch (null === e && _r58.getEdgeRing() === t && (e = _r58), s) {
            case this._SCANNING_FOR_INCOMING:
              if (_o32.getEdgeRing() !== t) continue;
              n = _o32, s = this._LINKING_TO_OUTGOING;
              break;

            case this._LINKING_TO_OUTGOING:
              if (_r58.getEdgeRing() !== t) continue;
              n.setNextMin(_r58), s = this._SCANNING_FOR_INCOMING;
          }
        }

        s === this._LINKING_TO_OUTGOING && (g.isTrue(null !== e, "found null for first outgoing dirEdge"), g.isTrue(e.getEdgeRing() === t, "unable to link last incoming dirEdge"), n.setNextMin(e));
      }
    }, {
      key: "getOutgoingDegree",
      value: function getOutgoingDegree() {
        if (0 === arguments.length) {
          var _t573 = 0;

          for (var _e464 = this.iterator(); _e464.hasNext();) {
            _e464.next().isInResult() && _t573++;
          }

          return _t573;
        }

        if (1 === arguments.length) {
          var _t574 = arguments[0];
          var _e465 = 0;

          for (var _n336 = this.iterator(); _n336.hasNext();) {
            _n336.next().getEdgeRing() === _t574 && _e465++;
          }

          return _e465;
        }
      }
    }, {
      key: "getLabel",
      value: function getLabel() {
        return this._label;
      }
    }, {
      key: "findCoveredLineEdges",
      value: function findCoveredLineEdges() {
        var t = Kt.NONE;

        for (var _e466 = this.iterator(); _e466.hasNext();) {
          var _n337 = _e466.next(),
              _s200 = _n337.getSym();

          if (!_n337.isLineEdge()) {
            if (_n337.isInResult()) {
              t = Kt.INTERIOR;
              break;
            }

            if (_s200.isInResult()) {
              t = Kt.EXTERIOR;
              break;
            }
          }
        }

        if (t === Kt.NONE) return null;
        var e = t;

        for (var _t575 = this.iterator(); _t575.hasNext();) {
          var _n338 = _t575.next(),
              _s201 = _n338.getSym();

          _n338.isLineEdge() ? _n338.getEdge().setCovered(e === Kt.INTERIOR) : (_n338.isInResult() && (e = Kt.EXTERIOR), _s201.isInResult() && (e = Kt.INTERIOR));
        }
      }
    }, {
      key: "computeLabelling",
      value: function computeLabelling(t) {
        _get(_getPrototypeOf(Ni.prototype), "computeLabelling", this).call(this, t), this._label = new Gn(Kt.NONE);

        for (var _t576 = this.iterator(); _t576.hasNext();) {
          var _e467 = _t576.next().getEdge().getLabel();

          for (var _t577 = 0; _t577 < 2; _t577++) {
            var _n339 = _e467.getLocation(_t577);

            _n339 !== Kt.INTERIOR && _n339 !== Kt.BOUNDARY || this._label.setLocation(_t577, Kt.INTERIOR);
          }
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
      }
    }]);

    return Ni;
  }(Ii);

  var Si = /*#__PURE__*/function (_is) {
    _inherits(Si, _is);

    var _super55 = _createSuper(Si);

    function Si() {
      _classCallCheck(this, Si);

      return _super55.call(this);
    }

    _createClass(Si, [{
      key: "createNode",
      value: function createNode(t) {
        return new $n(t, new Ni());
      }
    }]);

    return Si;
  }(is);

  var wi = /*#__PURE__*/function () {
    function wi() {
      _classCallCheck(this, wi);

      wi.constructor_.apply(this, arguments);
    }

    _createClass(wi, [{
      key: "compareTo",
      value: function compareTo(t) {
        var e = t;
        return wi.compareOriented(this._pts, this._orientation, e._pts, e._orientation);
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [o];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._pts = null, this._orientation = null;
        var t = arguments[0];
        this._pts = t, this._orientation = wi.orientation(t);
      }
    }, {
      key: "orientation",
      value: function orientation(t) {
        return 1 === dt.increasingDirection(t);
      }
    }, {
      key: "compareOriented",
      value: function compareOriented(t, e, n, s) {
        var i = e ? 1 : -1,
            r = s ? 1 : -1,
            o = e ? t.length : -1,
            l = s ? n.length : -1;
        var a = e ? 0 : t.length - 1,
            c = s ? 0 : n.length - 1;

        for (;;) {
          var _e468 = t[a].compareTo(n[c]);

          if (0 !== _e468) return _e468;
          a += i, c += r;

          var _s202 = a === o,
              _h9 = c === l;

          if (_s202 && !_h9) return -1;
          if (!_s202 && _h9) return 1;
          if (_s202 && _h9) return 0;
        }
      }
    }]);

    return wi;
  }();

  var Ci = /*#__PURE__*/function () {
    function Ci() {
      _classCallCheck(this, Ci);

      Ci.constructor_.apply(this, arguments);
    }

    _createClass(Ci, [{
      key: "print",
      value: function print(t) {
        t.print("MULTILINESTRING ( ");

        for (var _e469 = 0; _e469 < this._edges.size(); _e469++) {
          var _n340 = this._edges.get(_e469);

          _e469 > 0 && t.print(","), t.print("(");

          var _s203 = _n340.getCoordinates();

          for (var _e470 = 0; _e470 < _s203.length; _e470++) {
            _e470 > 0 && t.print(","), t.print(_s203[_e470].x + " " + _s203[_e470].y);
          }

          t.println(")");
        }

        t.print(")  ");
      }
    }, {
      key: "addAll",
      value: function addAll(t) {
        for (var _e471 = t.iterator(); _e471.hasNext();) {
          this.add(_e471.next());
        }
      }
    }, {
      key: "findEdgeIndex",
      value: function findEdgeIndex(t) {
        for (var _e472 = 0; _e472 < this._edges.size(); _e472++) {
          if (this._edges.get(_e472).equals(t)) return _e472;
        }

        return -1;
      }
    }, {
      key: "iterator",
      value: function iterator() {
        return this._edges.iterator();
      }
    }, {
      key: "getEdges",
      value: function getEdges() {
        return this._edges;
      }
    }, {
      key: "get",
      value: function get(t) {
        return this._edges.get(t);
      }
    }, {
      key: "findEqualEdge",
      value: function findEqualEdge(t) {
        var e = new wi(t.getCoordinates());
        return this._ocaMap.get(e);
      }
    }, {
      key: "add",
      value: function add(t) {
        this._edges.add(t);

        var e = new wi(t.getCoordinates());

        this._ocaMap.put(e, t);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._edges = new S(), this._ocaMap = new Un();
      }
    }]);

    return Ci;
  }();

  var Li = /*#__PURE__*/function () {
    function Li() {
      _classCallCheck(this, Li);
    }

    _createClass(Li, [{
      key: "processIntersections",
      value: function processIntersections(t, e, n, s) {}
    }, {
      key: "isDone",
      value: function isDone() {}
    }]);

    return Li;
  }();

  var Ti = /*#__PURE__*/function () {
    function Ti() {
      _classCallCheck(this, Ti);

      Ti.constructor_.apply(this, arguments);
    }

    _createClass(Ti, [{
      key: "isTrivialIntersection",
      value: function isTrivialIntersection(t, e, n, s) {
        if (t === n && 1 === this._li.getIntersectionNum()) {
          if (Ti.isAdjacentSegments(e, s)) return !0;

          if (t.isClosed()) {
            var _n341 = t.size() - 1;

            if (0 === e && s === _n341 || 0 === s && e === _n341) return !0;
          }
        }

        return !1;
      }
    }, {
      key: "getProperIntersectionPoint",
      value: function getProperIntersectionPoint() {
        return this._properIntersectionPoint;
      }
    }, {
      key: "hasProperInteriorIntersection",
      value: function hasProperInteriorIntersection() {
        return this._hasProperInterior;
      }
    }, {
      key: "getLineIntersector",
      value: function getLineIntersector() {
        return this._li;
      }
    }, {
      key: "hasProperIntersection",
      value: function hasProperIntersection() {
        return this._hasProper;
      }
    }, {
      key: "processIntersections",
      value: function processIntersections(t, e, n, s) {
        if (t === n && e === s) return null;
        this.numTests++;
        var i = t.getCoordinates()[e],
            r = t.getCoordinates()[e + 1],
            o = n.getCoordinates()[s],
            l = n.getCoordinates()[s + 1];
        this._li.computeIntersection(i, r, o, l), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(t, e, n, s) || (this._hasIntersection = !0, t.addIntersections(this._li, e, 0), n.addIntersections(this._li, s, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)));
      }
    }, {
      key: "hasIntersection",
      value: function hasIntersection() {
        return this._hasIntersection;
      }
    }, {
      key: "isDone",
      value: function isDone() {
        return !1;
      }
    }, {
      key: "hasInteriorIntersection",
      value: function hasInteriorIntersection() {
        return this._hasInterior;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Li];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
        var t = arguments[0];
        this._li = t;
      }
    }, {
      key: "isAdjacentSegments",
      value: function isAdjacentSegments(t, e) {
        return 1 === Math.abs(t - e);
      }
    }]);

    return Ti;
  }();

  var Ri = /*#__PURE__*/function () {
    function Ri() {
      _classCallCheck(this, Ri);

      Ri.constructor_.apply(this, arguments);
    }

    _createClass(Ri, [{
      key: "setWorkingPrecisionModel",
      value: function setWorkingPrecisionModel(t) {
        this._workingPrecisionModel = t;
      }
    }, {
      key: "insertUniqueEdge",
      value: function insertUniqueEdge(t) {
        var e = this._edgeList.findEqualEdge(t);

        if (null !== e) {
          var _n342 = e.getLabel();

          var _s204 = t.getLabel();

          e.isPointwiseEqual(t) || (_s204 = new Gn(t.getLabel()), _s204.flip()), _n342.merge(_s204);

          var _i110 = Ri.depthDelta(_s204),
              _r59 = e.getDepthDelta() + _i110;

          e.setDepthDelta(_r59);
        } else this._edgeList.add(t), t.setDepthDelta(Ri.depthDelta(t.getLabel()));
      }
    }, {
      key: "buildSubgraphs",
      value: function buildSubgraphs(t, e) {
        var n = new S();

        for (var _s205 = t.iterator(); _s205.hasNext();) {
          var _t578 = _s205.next(),
              _i111 = _t578.getRightmostCoordinate(),
              _r60 = new yi(n).getDepth(_i111);

          _t578.computeDepth(_r60), _t578.findResultEdges(), n.add(_t578), e.add(_t578.getDirectedEdges(), _t578.getNodes());
        }
      }
    }, {
      key: "createSubgraphs",
      value: function createSubgraphs(t) {
        var e = new S();

        for (var _n343 = t.getNodes().iterator(); _n343.hasNext();) {
          var _t579 = _n343.next();

          if (!_t579.isVisited()) {
            var _n344 = new ci();

            _n344.create(_t579), e.add(_n344);
          }
        }

        return ye.sort(e, ye.reverseOrder()), e;
      }
    }, {
      key: "createEmptyResultGeometry",
      value: function createEmptyResultGeometry() {
        return this._geomFact.createPolygon();
      }
    }, {
      key: "getNoder",
      value: function getNoder(t) {
        if (null !== this._workingNoder) return this._workingNoder;
        var e = new Js(),
            n = new Zt();
        return n.setPrecisionModel(t), e.setSegmentIntersector(new Ti(n)), e;
      }
    }, {
      key: "buffer",
      value: function buffer(t, e) {
        var n = this._workingPrecisionModel;
        null === n && (n = t.getPrecisionModel()), this._geomFact = t.getFactory();
        var s = new fi(n, this._bufParams),
            i = new Ei(t, e, s).getCurves();
        if (i.size() <= 0) return this.createEmptyResultGeometry();
        this.computeNodedEdges(i, n), this._graph = new rs(new Si()), this._graph.addEdges(this._edgeList.getEdges());
        var r = this.createSubgraphs(this._graph),
            o = new di(this._geomFact);
        this.buildSubgraphs(r, o);
        var l = o.getPolygons();
        if (l.size() <= 0) return this.createEmptyResultGeometry();
        return this._geomFact.buildGeometry(l);
      }
    }, {
      key: "computeNodedEdges",
      value: function computeNodedEdges(t, e) {
        var n = this.getNoder(e);
        n.computeNodes(t);

        for (var _t580 = n.getNodedSubstrings().iterator(); _t580.hasNext();) {
          var _e473 = _t580.next(),
              _n345 = _e473.getCoordinates();

          if (2 === _n345.length && _n345[0].equals2D(_n345[1])) continue;

          var _s206 = _e473.getData(),
              _i112 = new Jn(_e473.getCoordinates(), new Gn(_s206));

          this.insertUniqueEdge(_i112);
        }
      }
    }, {
      key: "setNoder",
      value: function setNoder(t) {
        this._workingNoder = t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._bufParams = null, this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Ci();
        var t = arguments[0];
        this._bufParams = t;
      }
    }, {
      key: "depthDelta",
      value: function depthDelta(t) {
        var e = t.getLocation(0, vn.LEFT),
            n = t.getLocation(0, vn.RIGHT);
        return e === Kt.INTERIOR && n === Kt.EXTERIOR ? 1 : e === Kt.EXTERIOR && n === Kt.INTERIOR ? -1 : 0;
      }
    }, {
      key: "convertSegStrings",
      value: function convertSegStrings(t) {
        var e = new Ct(),
            n = new S();

        for (; t.hasNext();) {
          var _s207 = t.next(),
              _i113 = e.createLineString(_s207.getCoordinates());

          n.add(_i113);
        }

        return e.buildGeometry(n);
      }
    }]);

    return Ri;
  }();

  var Pi = /*#__PURE__*/function () {
    function Pi() {
      _classCallCheck(this, Pi);

      Pi.constructor_.apply(this, arguments);
    }

    _createClass(Pi, [{
      key: "checkEndPtVertexIntersections",
      value: function checkEndPtVertexIntersections() {
        if (0 === arguments.length) for (var _t581 = this._segStrings.iterator(); _t581.hasNext();) {
          var _e474 = _t581.next().getCoordinates();

          this.checkEndPtVertexIntersections(_e474[0], this._segStrings), this.checkEndPtVertexIntersections(_e474[_e474.length - 1], this._segStrings);
        } else if (2 === arguments.length) {
          var _t582 = arguments[0];

          for (var _e475 = arguments[1].iterator(); _e475.hasNext();) {
            var _n346 = _e475.next().getCoordinates();

            for (var _e476 = 1; _e476 < _n346.length - 1; _e476++) {
              if (_n346[_e476].equals(_t582)) throw new h("found endpt/interior pt intersection at index " + _e476 + " :pt " + _t582);
            }
          }
        }
      }
    }, {
      key: "checkInteriorIntersections",
      value: function checkInteriorIntersections() {
        if (0 === arguments.length) for (var _t583 = this._segStrings.iterator(); _t583.hasNext();) {
          var _e477 = _t583.next();

          for (var _t584 = this._segStrings.iterator(); _t584.hasNext();) {
            var _n347 = _t584.next();

            this.checkInteriorIntersections(_e477, _n347);
          }
        } else if (2 === arguments.length) {
          var _t585 = arguments[0],
              _e478 = arguments[1],
              _n348 = _t585.getCoordinates(),
              _s208 = _e478.getCoordinates();

          for (var _i114 = 0; _i114 < _n348.length - 1; _i114++) {
            for (var _n349 = 0; _n349 < _s208.length - 1; _n349++) {
              this.checkInteriorIntersections(_t585, _i114, _e478, _n349);
            }
          }
        } else if (4 === arguments.length) {
          var _t586 = arguments[0],
              _e479 = arguments[1],
              _n350 = arguments[2],
              _s209 = arguments[3];
          if (_t586 === _n350 && _e479 === _s209) return null;

          var _i115 = _t586.getCoordinates()[_e479],
              _r61 = _t586.getCoordinates()[_e479 + 1],
              _o33 = _n350.getCoordinates()[_s209],
              _l28 = _n350.getCoordinates()[_s209 + 1];

          if (this._li.computeIntersection(_i115, _r61, _o33, _l28), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, _i115, _r61) || this.hasInteriorIntersection(this._li, _o33, _l28))) throw new h("found non-noded intersection at " + _i115 + "-" + _r61 + " and " + _o33 + "-" + _l28);
        }
      }
    }, {
      key: "checkValid",
      value: function checkValid() {
        this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
      }
    }, {
      key: "checkCollapses",
      value: function checkCollapses() {
        if (0 === arguments.length) for (var _t587 = this._segStrings.iterator(); _t587.hasNext();) {
          var _e480 = _t587.next();

          this.checkCollapses(_e480);
        } else if (1 === arguments.length) {
          var _t588 = arguments[0].getCoordinates();

          for (var _e481 = 0; _e481 < _t588.length - 2; _e481++) {
            this.checkCollapse(_t588[_e481], _t588[_e481 + 1], _t588[_e481 + 2]);
          }
        }
      }
    }, {
      key: "hasInteriorIntersection",
      value: function hasInteriorIntersection(t, e, n) {
        for (var _s210 = 0; _s210 < t.getIntersectionNum(); _s210++) {
          var _i116 = t.getIntersection(_s210);

          if (!_i116.equals(e) && !_i116.equals(n)) return !0;
        }

        return !1;
      }
    }, {
      key: "checkCollapse",
      value: function checkCollapse(t, e, n) {
        if (t.equals(n)) throw new h("found non-noded collapse at " + Pi.fact.createLineString([t, e, n]));
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._li = new Zt(), this._segStrings = null;
        var t = arguments[0];
        this._segStrings = t;
      }
    }]);

    return Pi;
  }();

  Pi.fact = new Ct();

  var Oi = /*#__PURE__*/function () {
    function Oi() {
      _classCallCheck(this, Oi);

      Oi.constructor_.apply(this, arguments);
    }

    _createClass(Oi, [{
      key: "intersectsScaled",
      value: function intersectsScaled(t, e) {
        var n = Math.min(t.x, e.x),
            s = Math.max(t.x, e.x),
            i = Math.min(t.y, e.y),
            r = Math.max(t.y, e.y),
            o = this._maxx < n || this._minx > s || this._maxy < i || this._miny > r;
        if (o) return !1;
        var l = this.intersectsToleranceSquare(t, e);
        return g.isTrue(!(o && l), "Found bad envelope test"), l;
      }
    }, {
      key: "initCorners",
      value: function initCorners(t) {
        this._minx = t.x - .5, this._maxx = t.x + .5, this._miny = t.y - .5, this._maxy = t.y + .5, this._corner[0] = new m(this._maxx, this._maxy), this._corner[1] = new m(this._minx, this._maxy), this._corner[2] = new m(this._minx, this._miny), this._corner[3] = new m(this._maxx, this._miny);
      }
    }, {
      key: "intersects",
      value: function intersects(t, e) {
        return 1 === this._scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this._p0Scaled), this.copyScaled(e, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
      }
    }, {
      key: "scale",
      value: function scale(t) {
        return Math.round(t * this._scaleFactor);
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        return this._originalPt;
      }
    }, {
      key: "copyScaled",
      value: function copyScaled(t, e) {
        e.x = this.scale(t.x), e.y = this.scale(t.y);
      }
    }, {
      key: "getSafeEnvelope",
      value: function getSafeEnvelope() {
        if (null === this._safeEnv) {
          var _t589 = Oi.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;

          this._safeEnv = new T(this._originalPt.x - _t589, this._originalPt.x + _t589, this._originalPt.y - _t589, this._originalPt.y + _t589);
        }

        return this._safeEnv;
      }
    }, {
      key: "intersectsPixelClosure",
      value: function intersectsPixelClosure(t, e) {
        return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));
      }
    }, {
      key: "intersectsToleranceSquare",
      value: function intersectsToleranceSquare(t, e) {
        var n = !1,
            s = !1;
        return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (n = !0), this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (s = !0), this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), !!this._li.isProper() || !(!n || !s) || !!t.equals(this._pt) || !!e.equals(this._pt))));
      }
    }, {
      key: "addSnappedNode",
      value: function addSnappedNode(t, e) {
        var n = t.getCoordinate(e),
            s = t.getCoordinate(e + 1);
        return !!this.intersects(n, s) && (t.addIntersection(this.getCoordinate(), e), !0);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2];
        if (this._originalPt = t, this._pt = t, this._scaleFactor = e, this._li = n, e <= 0) throw new s("Scale factor must be non-zero");
        1 !== e && (this._pt = new m(this.scale(t.x), this.scale(t.y)), this._p0Scaled = new m(), this._p1Scaled = new m()), this.initCorners(this._pt);
      }
    }]);

    return Oi;
  }();

  Oi.SAFE_ENV_EXPANSION_FACTOR = .75;

  var vi = /*#__PURE__*/function () {
    function vi() {
      _classCallCheck(this, vi);

      vi.constructor_.apply(this, arguments);
    }

    _createClass(vi, [{
      key: "select",
      value: function select() {
        if (1 === arguments.length) ;else if (2 === arguments.length) {
          var _t590 = arguments[1];
          arguments[0].getLineSegment(_t590, this.selectedSegment), this.select(this.selectedSegment);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this.selectedSegment = new jt();
      }
    }]);

    return vi;
  }();

  var Mi = /*#__PURE__*/function () {
    function Mi() {
      _classCallCheck(this, Mi);

      Mi.constructor_.apply(this, arguments);
    }

    _createClass(Mi, [{
      key: "snap",
      value: function snap() {
        if (1 === arguments.length) {
          var _t591 = arguments[0];
          return this.snap(_t591, null, -1);
        }

        if (3 === arguments.length) {
          var _t592 = arguments[0],
              _e482 = arguments[1],
              _n351 = arguments[2],
              _s211 = _t592.getSafeEnvelope(),
              _i117 = new bi(_t592, _e482, _n351);

          return this._index.query(_s211, new ( /*#__PURE__*/function () {
            function _class13() {
              _classCallCheck(this, _class13);
            }

            _createClass(_class13, [{
              key: "visitItem",
              value: function visitItem(t) {
                t.select(_s211, _i117);
              }
            }, {
              key: "interfaces_",
              get: function get() {
                return [be];
              }
            }]);

            return _class13;
          }())()), _i117.isNodeAdded();
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._index = null;
        var t = arguments[0];
        this._index = t;
      }
    }]);

    return Mi;
  }();

  var bi = /*#__PURE__*/function (_vi) {
    _inherits(bi, _vi);

    var _super56 = _createSuper(bi);

    function bi() {
      var _this42;

      _classCallCheck(this, bi);

      _this42 = _super56.call(this), bi.constructor_.apply(_assertThisInitialized(_this42), arguments);
      return _this42;
    }

    _createClass(bi, [{
      key: "isNodeAdded",
      value: function isNodeAdded() {
        return this._isNodeAdded;
      }
    }, {
      key: "select",
      value: function select() {
        if (!(2 === arguments.length && Number.isInteger(arguments[1]) && arguments[0] instanceof Zs)) return _get(_getPrototypeOf(bi.prototype), "select", this).apply(this, arguments);
        {
          var _t593 = arguments[1],
              _e483 = arguments[0].getContext();

          if (this._parentEdge === _e483 && (_t593 === this._hotPixelVertexIndex || _t593 + 1 === this._hotPixelVertexIndex)) return null;
          this._isNodeAdded |= this._hotPixel.addSnappedNode(_e483, _t593);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1;
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2];
        this._hotPixel = t, this._parentEdge = e, this._hotPixelVertexIndex = n;
      }
    }]);

    return bi;
  }(vi);

  Mi.HotPixelSnapAction = bi;

  var Di = /*#__PURE__*/function () {
    function Di() {
      _classCallCheck(this, Di);

      Di.constructor_.apply(this, arguments);
    }

    _createClass(Di, [{
      key: "processIntersections",
      value: function processIntersections(t, e, n, s) {
        if (t === n && e === s) return null;
        var i = t.getCoordinates()[e],
            r = t.getCoordinates()[e + 1],
            o = n.getCoordinates()[s],
            l = n.getCoordinates()[s + 1];

        if (this._li.computeIntersection(i, r, o, l), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
          for (var _t594 = 0; _t594 < this._li.getIntersectionNum(); _t594++) {
            this._interiorIntersections.add(this._li.getIntersection(_t594));
          }

          t.addIntersections(this._li, e, 0), n.addIntersections(this._li, s, 1);
        }
      }
    }, {
      key: "isDone",
      value: function isDone() {
        return !1;
      }
    }, {
      key: "getInteriorIntersections",
      value: function getInteriorIntersections() {
        return this._interiorIntersections;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Li];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._li = null, this._interiorIntersections = null;
        var t = arguments[0];
        this._li = t, this._interiorIntersections = new S();
      }
    }]);

    return Di;
  }();

  var Ai = /*#__PURE__*/function () {
    function Ai() {
      _classCallCheck(this, Ai);

      Ai.constructor_.apply(this, arguments);
    }

    _createClass(Ai, [{
      key: "checkCorrectness",
      value: function checkCorrectness(t) {
        var e = Hs.getNodedSubstrings(t),
            s = new Pi(e);

        try {
          s.checkValid();
        } catch (t) {
          if (!(t instanceof n)) throw t;
          t.printStackTrace();
        }
      }
    }, {
      key: "getNodedSubstrings",
      value: function getNodedSubstrings() {
        return Hs.getNodedSubstrings(this._nodedSegStrings);
      }
    }, {
      key: "snapRound",
      value: function snapRound(t, e) {
        var n = this.findInteriorIntersections(t, e);
        this.computeIntersectionSnaps(n), this.computeVertexSnaps(t);
      }
    }, {
      key: "findInteriorIntersections",
      value: function findInteriorIntersections(t, e) {
        var n = new Di(e);
        return this._noder.setSegmentIntersector(n), this._noder.computeNodes(t), n.getInteriorIntersections();
      }
    }, {
      key: "computeVertexSnaps",
      value: function computeVertexSnaps() {
        if (y(arguments[0], x)) {
          for (var _t595 = arguments[0].iterator(); _t595.hasNext();) {
            var _e484 = _t595.next();

            this.computeVertexSnaps(_e484);
          }
        } else if (arguments[0] instanceof Hs) {
          var _t596 = arguments[0],
              _e485 = _t596.getCoordinates();

          for (var _n352 = 0; _n352 < _e485.length; _n352++) {
            var _s212 = new Oi(_e485[_n352], this._scaleFactor, this._li);

            this._pointSnapper.snap(_s212, _t596, _n352) && _t596.addIntersection(_e485[_n352], _n352);
          }
        }
      }
    }, {
      key: "computeNodes",
      value: function computeNodes(t) {
        this._nodedSegStrings = t, this._noder = new Js(), this._pointSnapper = new Mi(this._noder.getIndex()), this.snapRound(t, this._li);
      }
    }, {
      key: "computeIntersectionSnaps",
      value: function computeIntersectionSnaps(t) {
        for (var _e486 = t.iterator(); _e486.hasNext();) {
          var _t597 = _e486.next(),
              _n353 = new Oi(_t597, this._scaleFactor, this._li);

          this._pointSnapper.snap(_n353);
        }
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Ks];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
        var t = arguments[0];
        this._pm = t, this._li = new Zt(), this._li.setPrecisionModel(t), this._scaleFactor = t.getScale();
      }
    }]);

    return Ai;
  }();

  var Fi = /*#__PURE__*/function () {
    function Fi() {
      _classCallCheck(this, Fi);

      Fi.constructor_.apply(this, arguments);
    }

    _createClass(Fi, [{
      key: "bufferFixedPrecision",
      value: function bufferFixedPrecision(t) {
        var e = new ti(new Ai(new Nt(1)), t.getScale()),
            n = new Ri(this._bufParams);
        n.setWorkingPrecisionModel(t), n.setNoder(e), this._resultGeometry = n.buffer(this._argGeom, this._distance);
      }
    }, {
      key: "bufferReducedPrecision",
      value: function bufferReducedPrecision() {
        if (0 === arguments.length) {
          for (var _t598 = Fi.MAX_PRECISION_DIGITS; _t598 >= 0; _t598--) {
            try {
              this.bufferReducedPrecision(_t598);
            } catch (t) {
              if (!(t instanceof ns)) throw t;
              this._saveException = t;
            }

            if (null !== this._resultGeometry) return null;
          }

          throw this._saveException;
        }

        if (1 === arguments.length) {
          var _t599 = arguments[0],
              _e487 = Fi.precisionScaleFactor(this._argGeom, this._distance, _t599),
              _n354 = new Nt(_e487);

          this.bufferFixedPrecision(_n354);
        }
      }
    }, {
      key: "computeGeometry",
      value: function computeGeometry() {
        if (this.bufferOriginalPrecision(), null !== this._resultGeometry) return null;

        var t = this._argGeom.getFactory().getPrecisionModel();

        t.getType() === Nt.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision();
      }
    }, {
      key: "setQuadrantSegments",
      value: function setQuadrantSegments(t) {
        this._bufParams.setQuadrantSegments(t);
      }
    }, {
      key: "bufferOriginalPrecision",
      value: function bufferOriginalPrecision() {
        try {
          var _t600 = new Ri(this._bufParams);

          this._resultGeometry = _t600.buffer(this._argGeom, this._distance);
        } catch (t) {
          if (!(t instanceof h)) throw t;
          this._saveException = t;
        }
      }
    }, {
      key: "getResultGeometry",
      value: function getResultGeometry(t) {
        return this._distance = t, this.computeGeometry(), this._resultGeometry;
      }
    }, {
      key: "setEndCapStyle",
      value: function setEndCapStyle(t) {
        this._bufParams.setEndCapStyle(t);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._argGeom = null, this._distance = null, this._bufParams = new oi(), this._resultGeometry = null, this._saveException = null, 1 === arguments.length) {
          var _t601 = arguments[0];
          this._argGeom = _t601;
        } else if (2 === arguments.length) {
          var _t602 = arguments[0],
              _e488 = arguments[1];
          this._argGeom = _t602, this._bufParams = _e488;
        }
      }
    }, {
      key: "bufferOp",
      value: function bufferOp() {
        if (2 === arguments.length) {
          var _t603 = arguments[1];
          return new Fi(arguments[0]).getResultGeometry(_t603);
        }

        if (3 === arguments.length) {
          if (Number.isInteger(arguments[2]) && arguments[0] instanceof V && "number" == typeof arguments[1]) {
            var _t604 = arguments[1],
                _e489 = arguments[2],
                _n355 = new Fi(arguments[0]);

            _n355.setQuadrantSegments(_e489);

            return _n355.getResultGeometry(_t604);
          }

          if (arguments[2] instanceof oi && arguments[0] instanceof V && "number" == typeof arguments[1]) {
            var _t605 = arguments[1];
            return new Fi(arguments[0], arguments[2]).getResultGeometry(_t605);
          }
        } else if (4 === arguments.length) {
          var _t606 = arguments[1],
              _e490 = arguments[2],
              _n356 = arguments[3],
              _s213 = new Fi(arguments[0]);

          _s213.setQuadrantSegments(_e490), _s213.setEndCapStyle(_n356);
          return _s213.getResultGeometry(_t606);
        }
      }
    }, {
      key: "precisionScaleFactor",
      value: function precisionScaleFactor(t, e, n) {
        var s = t.getEnvelopeInternal(),
            i = G.max(Math.abs(s.getMaxX()), Math.abs(s.getMaxY()), Math.abs(s.getMinX()), Math.abs(s.getMinY())) + 2 * (e > 0 ? e : 0),
            r = n - Math.trunc(Math.log(i) / Math.log(10) + 1);
        return Math.pow(10, r);
      }
    }]);

    return Fi;
  }();

  Fi.CAP_ROUND = oi.CAP_ROUND, Fi.CAP_BUTT = oi.CAP_FLAT, Fi.CAP_FLAT = oi.CAP_FLAT, Fi.CAP_SQUARE = oi.CAP_SQUARE, Fi.MAX_PRECISION_DIGITS = 12;
  var Gi = Object.freeze({
    __proto__: null,
    BufferOp: Fi,
    BufferParameters: oi
  });

  var qi = /*#__PURE__*/function () {
    function qi() {
      _classCallCheck(this, qi);

      qi.constructor_.apply(this, arguments);
    }

    _createClass(qi, [{
      key: "getSegmentIndex",
      value: function getSegmentIndex() {
        return this._segIndex;
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        return this._pt;
      }
    }, {
      key: "isInsideArea",
      value: function isInsideArea() {
        return this._segIndex === qi.INSIDE_AREA;
      }
    }, {
      key: "toString",
      value: function toString() {
        return this._component.getGeometryType() + "[" + this._segIndex + "]-" + Ht.toPoint(this._pt);
      }
    }, {
      key: "getGeometryComponent",
      value: function getGeometryComponent() {
        return this._component;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._component = null, this._segIndex = null, this._pt = null, 2 === arguments.length) {
          var _t607 = arguments[0],
              _e491 = arguments[1];
          qi.constructor_.call(this, _t607, qi.INSIDE_AREA, _e491);
        } else if (3 === arguments.length) {
          var _t608 = arguments[0],
              _e492 = arguments[1],
              _n357 = arguments[2];
          this._component = _t608, this._segIndex = _e492, this._pt = _n357;
        }
      }
    }]);

    return qi;
  }();

  qi.INSIDE_AREA = -1;

  var Bi = /*#__PURE__*/function () {
    function Bi() {
      _classCallCheck(this, Bi);

      Bi.constructor_.apply(this, arguments);
    }

    _createClass(Bi, [{
      key: "filter",
      value: function filter(t) {
        if (t.isEmpty()) return null;
        (t instanceof Q || t instanceof j || t instanceof et) && this._locations.add(new qi(t, 0, t.getCoordinate()));
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Z];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._locations = null;
        var t = arguments[0];
        this._locations = t;
      }
    }, {
      key: "getLocations",
      value: function getLocations(t) {
        var e = new S();
        return t.apply(new Bi(e)), e;
      }
    }]);

    return Bi;
  }();

  var Yi = /*#__PURE__*/function () {
    function Yi() {
      _classCallCheck(this, Yi);

      Yi.constructor_.apply(this, arguments);
    }

    _createClass(Yi, [{
      key: "computeContainmentDistance",
      value: function computeContainmentDistance() {
        if (0 === arguments.length) {
          var _t609 = new Array(2).fill(null);

          if (this.computeContainmentDistance(0, _t609), this._minDistance <= this._terminateDistance) return null;
          this.computeContainmentDistance(1, _t609);
        } else if (2 === arguments.length) {
          var _t610 = arguments[0],
              _e493 = arguments[1],
              _n358 = this._geom[_t610];
          if (_n358.getDimension() < 2) return null;

          var _s214 = 1 - _t610,
              _i118 = Ee.getPolygons(_n358);

          if (_i118.size() > 0) {
            var _n359 = Bi.getLocations(this._geom[_s214]);

            if (this.computeContainmentDistance(_n359, _i118, _e493), this._minDistance <= this._terminateDistance) return this._minDistanceLocation[_s214] = _e493[0], this._minDistanceLocation[_t610] = _e493[1], null;
          }
        } else if (3 === arguments.length) if (arguments[2] instanceof Array && y(arguments[0], I) && y(arguments[1], I)) {
          var _t611 = arguments[0],
              _e494 = arguments[1],
              _n360 = arguments[2];

          for (var _s215 = 0; _s215 < _t611.size(); _s215++) {
            var _i119 = _t611.get(_s215);

            for (var _t612 = 0; _t612 < _e494.size(); _t612++) {
              if (this.computeContainmentDistance(_i119, _e494.get(_t612), _n360), this._minDistance <= this._terminateDistance) return null;
            }
          }
        } else if (arguments[2] instanceof Array && arguments[0] instanceof qi && arguments[1] instanceof et) {
          var _t613 = arguments[0],
              _e495 = arguments[1],
              _n361 = arguments[2],
              _s216 = _t613.getCoordinate();

          if (Kt.EXTERIOR !== this._ptLocator.locate(_s216, _e495)) return this._minDistance = 0, _n361[0] = _t613, _n361[1] = new qi(_e495, _s216), null;
        }
      }
    }, {
      key: "computeMinDistanceLinesPoints",
      value: function computeMinDistanceLinesPoints(t, e, n) {
        for (var _s217 = 0; _s217 < t.size(); _s217++) {
          var _i120 = t.get(_s217);

          for (var _t614 = 0; _t614 < e.size(); _t614++) {
            var _s218 = e.get(_t614);

            if (this.computeMinDistance(_i120, _s218, n), this._minDistance <= this._terminateDistance) return null;
          }
        }
      }
    }, {
      key: "computeFacetDistance",
      value: function computeFacetDistance() {
        var t = new Array(2).fill(null),
            e = fe.getLines(this._geom[0]),
            n = fe.getLines(this._geom[1]),
            s = xe.getPoints(this._geom[0]),
            i = xe.getPoints(this._geom[1]);
        return this.computeMinDistanceLines(e, n, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(e, i, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(n, s, t), this.updateMinDistance(t, !0), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistancePoints(s, i, t), void this.updateMinDistance(t, !1))));
      }
    }, {
      key: "nearestLocations",
      value: function nearestLocations() {
        return this.computeMinDistance(), this._minDistanceLocation;
      }
    }, {
      key: "updateMinDistance",
      value: function updateMinDistance(t, e) {
        if (null === t[0]) return null;
        e ? (this._minDistanceLocation[0] = t[1], this._minDistanceLocation[1] = t[0]) : (this._minDistanceLocation[0] = t[0], this._minDistanceLocation[1] = t[1]);
      }
    }, {
      key: "nearestPoints",
      value: function nearestPoints() {
        this.computeMinDistance();
        return [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
      }
    }, {
      key: "computeMinDistance",
      value: function computeMinDistance() {
        if (0 === arguments.length) {
          if (null !== this._minDistanceLocation) return null;
          if (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance) return null;
          this.computeFacetDistance();
        } else if (3 === arguments.length) if (arguments[2] instanceof Array && arguments[0] instanceof j && arguments[1] instanceof Q) {
          var _t615 = arguments[0],
              _e496 = arguments[1],
              _n362 = arguments[2];
          if (_t615.getEnvelopeInternal().distance(_e496.getEnvelopeInternal()) > this._minDistance) return null;

          var _s219 = _t615.getCoordinates(),
              _i121 = _e496.getCoordinate();

          for (var _r62 = 0; _r62 < _s219.length - 1; _r62++) {
            var _o34 = q.pointToSegment(_i121, _s219[_r62], _s219[_r62 + 1]);

            if (_o34 < this._minDistance) {
              this._minDistance = _o34;

              var _l29 = new jt(_s219[_r62], _s219[_r62 + 1]).closestPoint(_i121);

              _n362[0] = new qi(_t615, _r62, _l29), _n362[1] = new qi(_e496, 0, _i121);
            }

            if (this._minDistance <= this._terminateDistance) return null;
          }
        } else if (arguments[2] instanceof Array && arguments[0] instanceof j && arguments[1] instanceof j) {
          var _t616 = arguments[0],
              _e497 = arguments[1],
              _n363 = arguments[2];
          if (_t616.getEnvelopeInternal().distance(_e497.getEnvelopeInternal()) > this._minDistance) return null;

          var _s220 = _t616.getCoordinates(),
              _i122 = _e497.getCoordinates();

          for (var _r63 = 0; _r63 < _s220.length - 1; _r63++) {
            var _o35 = new T(_s220[_r63], _s220[_r63 + 1]);

            if (!(_o35.distance(_e497.getEnvelopeInternal()) > this._minDistance)) for (var _l30 = 0; _l30 < _i122.length - 1; _l30++) {
              var _a17 = new T(_i122[_l30], _i122[_l30 + 1]);

              if (_o35.distance(_a17) > this._minDistance) continue;

              var _c14 = q.segmentToSegment(_s220[_r63], _s220[_r63 + 1], _i122[_l30], _i122[_l30 + 1]);

              if (_c14 < this._minDistance) {
                this._minDistance = _c14;

                var _o36 = new jt(_s220[_r63], _s220[_r63 + 1]),
                    _a18 = new jt(_i122[_l30], _i122[_l30 + 1]),
                    _h10 = _o36.closestPoints(_a18);

                _n363[0] = new qi(_t616, _r63, _h10[0]), _n363[1] = new qi(_e497, _l30, _h10[1]);
              }

              if (this._minDistance <= this._terminateDistance) return null;
            }
          }
        }
      }
    }, {
      key: "computeMinDistancePoints",
      value: function computeMinDistancePoints(t, e, n) {
        for (var _s221 = 0; _s221 < t.size(); _s221++) {
          var _i123 = t.get(_s221);

          for (var _t617 = 0; _t617 < e.size(); _t617++) {
            var _s222 = e.get(_t617),
                _r64 = _i123.getCoordinate().distance(_s222.getCoordinate());

            if (_r64 < this._minDistance && (this._minDistance = _r64, n[0] = new qi(_i123, 0, _i123.getCoordinate()), n[1] = new qi(_s222, 0, _s222.getCoordinate())), this._minDistance <= this._terminateDistance) return null;
          }
        }
      }
    }, {
      key: "distance",
      value: function distance() {
        if (null === this._geom[0] || null === this._geom[1]) throw new s("null geometries are not supported");
        return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance);
      }
    }, {
      key: "computeMinDistanceLines",
      value: function computeMinDistanceLines(t, e, n) {
        for (var _s223 = 0; _s223 < t.size(); _s223++) {
          var _i124 = t.get(_s223);

          for (var _t618 = 0; _t618 < e.size(); _t618++) {
            var _s224 = e.get(_t618);

            if (this.computeMinDistance(_i124, _s224, n), this._minDistance <= this._terminateDistance) return null;
          }
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new mn(), this._minDistanceLocation = null, this._minDistance = r.MAX_VALUE, 2 === arguments.length) {
          var _t619 = arguments[0],
              _e498 = arguments[1];
          Yi.constructor_.call(this, _t619, _e498, 0);
        } else if (3 === arguments.length) {
          var _t620 = arguments[0],
              _e499 = arguments[1],
              _n364 = arguments[2];
          this._geom = new Array(2).fill(null), this._geom[0] = _t620, this._geom[1] = _e499, this._terminateDistance = _n364;
        }
      }
    }, {
      key: "distance",
      value: function distance(t, e) {
        return new Yi(t, e).distance();
      }
    }, {
      key: "isWithinDistance",
      value: function isWithinDistance(t, e, n) {
        if (t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > n) return !1;
        return new Yi(t, e, n).distance() <= n;
      }
    }, {
      key: "nearestPoints",
      value: function nearestPoints(t, e) {
        return new Yi(t, e).nearestPoints();
      }
    }]);

    return Yi;
  }();

  var Vi = Object.freeze({
    __proto__: null,
    DistanceOp: Yi
  });

  var zi = /*#__PURE__*/function () {
    function zi() {
      _classCallCheck(this, zi);

      zi.constructor_.apply(this, arguments);
    }

    _createClass(zi, [{
      key: "getCoordinates",
      value: function getCoordinates() {
        if (null === this._coordinates) {
          var _t621 = 0,
              _e500 = 0;

          var _n365 = new C();

          for (var _s225 = this._directedEdges.iterator(); _s225.hasNext();) {
            var _i125 = _s225.next();

            _i125.getEdgeDirection() ? _t621++ : _e500++, _n365.add(_i125.getEdge().getLine().getCoordinates(), !1, _i125.getEdgeDirection());
          }

          this._coordinates = _n365.toCoordinateArray(), _e500 > _t621 && dt.reverse(this._coordinates);
        }

        return this._coordinates;
      }
    }, {
      key: "toLineString",
      value: function toLineString() {
        return this._factory.createLineString(this.getCoordinates());
      }
    }, {
      key: "add",
      value: function add(t) {
        this._directedEdges.add(t);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._factory = null, this._directedEdges = new S(), this._coordinates = null;
        var t = arguments[0];
        this._factory = t;
      }
    }]);

    return zi;
  }();

  var Xi = /*#__PURE__*/function () {
    function Xi() {
      _classCallCheck(this, Xi);

      Xi.constructor_.apply(this, arguments);
    }

    _createClass(Xi, [{
      key: "setVisited",
      value: function setVisited(t) {
        this._isVisited = t;
      }
    }, {
      key: "isMarked",
      value: function isMarked() {
        return this._isMarked;
      }
    }, {
      key: "setData",
      value: function setData(t) {
        this._data = t;
      }
    }, {
      key: "getData",
      value: function getData() {
        return this._data;
      }
    }, {
      key: "setMarked",
      value: function setMarked(t) {
        this._isMarked = t;
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return this._data;
      }
    }, {
      key: "isVisited",
      value: function isVisited() {
        return this._isVisited;
      }
    }, {
      key: "setContext",
      value: function setContext(t) {
        this._data = t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._isMarked = !1, this._isVisited = !1, this._data = null;
      }
    }, {
      key: "getComponentWithVisitedState",
      value: function getComponentWithVisitedState(t, e) {
        for (; t.hasNext();) {
          var _n366 = t.next();

          if (_n366.isVisited() === e) return _n366;
        }

        return null;
      }
    }, {
      key: "setVisited",
      value: function setVisited(t, e) {
        for (; t.hasNext();) {
          t.next().setVisited(e);
        }
      }
    }, {
      key: "setMarked",
      value: function setMarked(t, e) {
        for (; t.hasNext();) {
          t.next().setMarked(e);
        }
      }
    }]);

    return Xi;
  }();

  var ki = /*#__PURE__*/function (_Xi) {
    _inherits(ki, _Xi);

    var _super57 = _createSuper(ki);

    function ki() {
      var _this43;

      _classCallCheck(this, ki);

      _this43 = _super57.call(this), ki.constructor_.apply(_assertThisInitialized(_this43), arguments);
      return _this43;
    }

    _createClass(ki, [{
      key: "isRemoved",
      value: function isRemoved() {
        return null === this._parentEdge;
      }
    }, {
      key: "compareDirection",
      value: function compareDirection(t) {
        return this._quadrant > t._quadrant ? 1 : this._quadrant < t._quadrant ? -1 : D.index(t._p0, t._p1, this._p1);
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        return this._from.getCoordinate();
      }
    }, {
      key: "print",
      value: function print(t) {
        var e = this.getClass().getName(),
            n = e.lastIndexOf("."),
            s = e.substring(n + 1);
        t.print("  " + s + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + this._angle);
      }
    }, {
      key: "getDirectionPt",
      value: function getDirectionPt() {
        return this._p1;
      }
    }, {
      key: "getAngle",
      value: function getAngle() {
        return this._angle;
      }
    }, {
      key: "compareTo",
      value: function compareTo(t) {
        var e = t;
        return this.compareDirection(e);
      }
    }, {
      key: "getFromNode",
      value: function getFromNode() {
        return this._from;
      }
    }, {
      key: "getSym",
      value: function getSym() {
        return this._sym;
      }
    }, {
      key: "setEdge",
      value: function setEdge(t) {
        this._parentEdge = t;
      }
    }, {
      key: "remove",
      value: function remove() {
        this._sym = null, this._parentEdge = null;
      }
    }, {
      key: "getEdge",
      value: function getEdge() {
        return this._parentEdge;
      }
    }, {
      key: "getQuadrant",
      value: function getQuadrant() {
        return this._quadrant;
      }
    }, {
      key: "setSym",
      value: function setSym(t) {
        this._sym = t;
      }
    }, {
      key: "getToNode",
      value: function getToNode() {
        return this._to;
      }
    }, {
      key: "getEdgeDirection",
      value: function getEdgeDirection() {
        return this._edgeDirection;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [o];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._parentEdge = null, this._from = null, this._to = null, this._p0 = null, this._p1 = null, this._sym = null, this._edgeDirection = null, this._quadrant = null, this._angle = null, 0 === arguments.length) ;else if (4 === arguments.length) {
          var _t622 = arguments[0],
              _e501 = arguments[1],
              _n367 = arguments[2],
              _s226 = arguments[3];
          this._from = _t622, this._to = _e501, this._edgeDirection = _s226, this._p0 = _t622.getCoordinate(), this._p1 = _n367;

          var _i126 = this._p1.x - this._p0.x,
              _r65 = this._p1.y - this._p0.y;

          this._quadrant = Sn.quadrant(_i126, _r65), this._angle = Math.atan2(_r65, _i126);
        }
      }
    }, {
      key: "toEdges",
      value: function toEdges(t) {
        var e = new S();

        for (var _n368 = t.iterator(); _n368.hasNext();) {
          e.add(_n368.next()._parentEdge);
        }

        return e;
      }
    }]);

    return ki;
  }(Xi);

  var Ui = /*#__PURE__*/function (_ki) {
    _inherits(Ui, _ki);

    var _super58 = _createSuper(Ui);

    function Ui() {
      var _this44;

      _classCallCheck(this, Ui);

      _this44 = _super58.call(this), Ui.constructor_.apply(_assertThisInitialized(_this44), arguments);
      return _this44;
    }

    _createClass(Ui, [{
      key: "getNext",
      value: function getNext() {
        return 2 !== this.getToNode().getDegree() ? null : this.getToNode().getOutEdges().getEdges().get(0) === this.getSym() ? this.getToNode().getOutEdges().getEdges().get(1) : (g.isTrue(this.getToNode().getOutEdges().getEdges().get(1) === this.getSym()), this.getToNode().getOutEdges().getEdges().get(0));
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2],
            s = arguments[3];
        ki.constructor_.call(this, t, e, n, s);
      }
    }]);

    return Ui;
  }(ki);

  var Hi = /*#__PURE__*/function (_Xi2) {
    _inherits(Hi, _Xi2);

    var _super59 = _createSuper(Hi);

    function Hi() {
      var _this45;

      _classCallCheck(this, Hi);

      _this45 = _super59.call(this), Hi.constructor_.apply(_assertThisInitialized(_this45), arguments);
      return _this45;
    }

    _createClass(Hi, [{
      key: "isRemoved",
      value: function isRemoved() {
        return null === this._dirEdge;
      }
    }, {
      key: "setDirectedEdges",
      value: function setDirectedEdges(t, e) {
        this._dirEdge = [t, e], t.setEdge(this), e.setEdge(this), t.setSym(e), e.setSym(t), t.getFromNode().addOutEdge(t), e.getFromNode().addOutEdge(e);
      }
    }, {
      key: "getDirEdge",
      value: function getDirEdge() {
        if (Number.isInteger(arguments[0])) {
          var _t623 = arguments[0];
          return this._dirEdge[_t623];
        }

        if (arguments[0] instanceof Zi) {
          var _t624 = arguments[0];
          return this._dirEdge[0].getFromNode() === _t624 ? this._dirEdge[0] : this._dirEdge[1].getFromNode() === _t624 ? this._dirEdge[1] : null;
        }
      }
    }, {
      key: "remove",
      value: function remove() {
        this._dirEdge = null;
      }
    }, {
      key: "getOppositeNode",
      value: function getOppositeNode(t) {
        return this._dirEdge[0].getFromNode() === t ? this._dirEdge[0].getToNode() : this._dirEdge[1].getFromNode() === t ? this._dirEdge[1].getToNode() : null;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._dirEdge = null, 0 === arguments.length) ;else if (2 === arguments.length) {
          var _t625 = arguments[0],
              _e502 = arguments[1];
          this.setDirectedEdges(_t625, _e502);
        }
      }
    }]);

    return Hi;
  }(Xi);

  var Wi = /*#__PURE__*/function () {
    function Wi() {
      _classCallCheck(this, Wi);

      Wi.constructor_.apply(this, arguments);
    }

    _createClass(Wi, [{
      key: "getNextEdge",
      value: function getNextEdge(t) {
        var e = this.getIndex(t);
        return this._outEdges.get(this.getIndex(e + 1));
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        var t = this.iterator();
        if (!t.hasNext()) return null;
        return t.next().getCoordinate();
      }
    }, {
      key: "iterator",
      value: function iterator() {
        return this.sortEdges(), this._outEdges.iterator();
      }
    }, {
      key: "sortEdges",
      value: function sortEdges() {
        this._sorted || (ye.sort(this._outEdges), this._sorted = !0);
      }
    }, {
      key: "remove",
      value: function remove(t) {
        this._outEdges.remove(t);
      }
    }, {
      key: "getEdges",
      value: function getEdges() {
        return this.sortEdges(), this._outEdges;
      }
    }, {
      key: "getNextCWEdge",
      value: function getNextCWEdge(t) {
        var e = this.getIndex(t);
        return this._outEdges.get(this.getIndex(e - 1));
      }
    }, {
      key: "getIndex",
      value: function getIndex() {
        if (arguments[0] instanceof Hi) {
          var _t626 = arguments[0];
          this.sortEdges();

          for (var _e503 = 0; _e503 < this._outEdges.size(); _e503++) {
            if (this._outEdges.get(_e503).getEdge() === _t626) return _e503;
          }

          return -1;
        }

        if (arguments[0] instanceof ki) {
          var _t627 = arguments[0];
          this.sortEdges();

          for (var _e504 = 0; _e504 < this._outEdges.size(); _e504++) {
            if (this._outEdges.get(_e504) === _t627) return _e504;
          }

          return -1;
        }

        if (Number.isInteger(arguments[0])) {
          var _t628 = arguments[0] % this._outEdges.size();

          return _t628 < 0 && (_t628 += this._outEdges.size()), _t628;
        }
      }
    }, {
      key: "add",
      value: function add(t) {
        this._outEdges.add(t), this._sorted = !1;
      }
    }, {
      key: "getDegree",
      value: function getDegree() {
        return this._outEdges.size();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._outEdges = new S(), this._sorted = !1;
      }
    }]);

    return Wi;
  }();

  var Zi = /*#__PURE__*/function (_Xi3) {
    _inherits(Zi, _Xi3);

    var _super60 = _createSuper(Zi);

    function Zi() {
      var _this46;

      _classCallCheck(this, Zi);

      _this46 = _super60.call(this), Zi.constructor_.apply(_assertThisInitialized(_this46), arguments);
      return _this46;
    }

    _createClass(Zi, [{
      key: "isRemoved",
      value: function isRemoved() {
        return null === this._pt;
      }
    }, {
      key: "addOutEdge",
      value: function addOutEdge(t) {
        this._deStar.add(t);
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        return this._pt;
      }
    }, {
      key: "getOutEdges",
      value: function getOutEdges() {
        return this._deStar;
      }
    }, {
      key: "remove",
      value: function remove() {
        if (0 === arguments.length) this._pt = null;else if (1 === arguments.length) {
          var _t629 = arguments[0];

          this._deStar.remove(_t629);
        }
      }
    }, {
      key: "getIndex",
      value: function getIndex(t) {
        return this._deStar.getIndex(t);
      }
    }, {
      key: "getDegree",
      value: function getDegree() {
        return this._deStar.getDegree();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._pt = null, this._deStar = null, 1 === arguments.length) {
          var _t630 = arguments[0];
          Zi.constructor_.call(this, _t630, new Wi());
        } else if (2 === arguments.length) {
          var _t631 = arguments[0],
              _e505 = arguments[1];
          this._pt = _t631, this._deStar = _e505;
        }
      }
    }, {
      key: "getEdgesBetween",
      value: function getEdgesBetween(t, e) {
        var n = ki.toEdges(t.getOutEdges().getEdges()),
            s = new xt(n),
            i = ki.toEdges(e.getOutEdges().getEdges());
        return s.retainAll(i), s;
      }
    }]);

    return Zi;
  }(Xi);

  var ji = /*#__PURE__*/function (_Hi) {
    _inherits(ji, _Hi);

    var _super61 = _createSuper(ji);

    function ji() {
      var _this47;

      _classCallCheck(this, ji);

      _this47 = _super61.call(this), ji.constructor_.apply(_assertThisInitialized(_this47), arguments);
      return _this47;
    }

    _createClass(ji, [{
      key: "getLine",
      value: function getLine() {
        return this._line;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._line = null;
        var t = arguments[0];
        this._line = t;
      }
    }]);

    return ji;
  }(Hi);

  var Ki = /*#__PURE__*/function () {
    function Ki() {
      _classCallCheck(this, Ki);

      Ki.constructor_.apply(this, arguments);
    }

    _createClass(Ki, [{
      key: "find",
      value: function find(t) {
        return this._nodeMap.get(t);
      }
    }, {
      key: "iterator",
      value: function iterator() {
        return this._nodeMap.values().iterator();
      }
    }, {
      key: "remove",
      value: function remove(t) {
        return this._nodeMap.remove(t);
      }
    }, {
      key: "values",
      value: function values() {
        return this._nodeMap.values();
      }
    }, {
      key: "add",
      value: function add(t) {
        return this._nodeMap.put(t.getCoordinate(), t), t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._nodeMap = new Un();
      }
    }]);

    return Ki;
  }();

  var Qi = /*#__PURE__*/function () {
    function Qi() {
      _classCallCheck(this, Qi);

      Qi.constructor_.apply(this, arguments);
    }

    _createClass(Qi, [{
      key: "findNodesOfDegree",
      value: function findNodesOfDegree(t) {
        var e = new S();

        for (var _n369 = this.nodeIterator(); _n369.hasNext();) {
          var _s227 = _n369.next();

          _s227.getDegree() === t && e.add(_s227);
        }

        return e;
      }
    }, {
      key: "dirEdgeIterator",
      value: function dirEdgeIterator() {
        return this._dirEdges.iterator();
      }
    }, {
      key: "edgeIterator",
      value: function edgeIterator() {
        return this._edges.iterator();
      }
    }, {
      key: "remove",
      value: function remove() {
        if (arguments[0] instanceof Hi) {
          var _t632 = arguments[0];
          this.remove(_t632.getDirEdge(0)), this.remove(_t632.getDirEdge(1)), this._edges.remove(_t632), _t632.remove();
        } else if (arguments[0] instanceof ki) {
          var _t633 = arguments[0],
              _e506 = _t633.getSym();

          null !== _e506 && _e506.setSym(null), _t633.getFromNode().remove(_t633), _t633.remove(), this._dirEdges.remove(_t633);
        } else if (arguments[0] instanceof Zi) {
          var _t634 = arguments[0];

          for (var _e507 = _t634.getOutEdges().getEdges().iterator(); _e507.hasNext();) {
            var _t635 = _e507.next(),
                _n370 = _t635.getSym();

            null !== _n370 && this.remove(_n370), this._dirEdges.remove(_t635);

            var _s228 = _t635.getEdge();

            null !== _s228 && this._edges.remove(_s228);
          }

          this._nodeMap.remove(_t634.getCoordinate()), _t634.remove();
        }
      }
    }, {
      key: "findNode",
      value: function findNode(t) {
        return this._nodeMap.find(t);
      }
    }, {
      key: "getEdges",
      value: function getEdges() {
        return this._edges;
      }
    }, {
      key: "nodeIterator",
      value: function nodeIterator() {
        return this._nodeMap.iterator();
      }
    }, {
      key: "contains",
      value: function contains() {
        if (arguments[0] instanceof Hi) {
          var _t636 = arguments[0];
          return this._edges.contains(_t636);
        }

        if (arguments[0] instanceof ki) {
          var _t637 = arguments[0];
          return this._dirEdges.contains(_t637);
        }
      }
    }, {
      key: "add",
      value: function add() {
        if (arguments[0] instanceof Zi) {
          var _t638 = arguments[0];

          this._nodeMap.add(_t638);
        } else if (arguments[0] instanceof Hi) {
          var _t639 = arguments[0];
          this._edges.add(_t639), this.add(_t639.getDirEdge(0)), this.add(_t639.getDirEdge(1));
        } else if (arguments[0] instanceof ki) {
          var _t640 = arguments[0];

          this._dirEdges.add(_t640);
        }
      }
    }, {
      key: "getNodes",
      value: function getNodes() {
        return this._nodeMap.values();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._edges = new xt(), this._dirEdges = new xt(), this._nodeMap = new Ki();
      }
    }]);

    return Qi;
  }();

  var Ji = /*#__PURE__*/function (_Qi) {
    _inherits(Ji, _Qi);

    var _super62 = _createSuper(Ji);

    function Ji() {
      _classCallCheck(this, Ji);

      return _super62.call(this);
    }

    _createClass(Ji, [{
      key: "addEdge",
      value: function addEdge(t) {
        if (t.isEmpty()) return null;
        var e = dt.removeRepeatedPoints(t.getCoordinates());
        if (e.length <= 1) return null;
        var n = e[0],
            s = e[e.length - 1],
            i = this.getNode(n),
            r = this.getNode(s),
            o = new Ui(i, r, e[1], !0),
            l = new Ui(r, i, e[e.length - 2], !1),
            a = new ji(t);
        a.setDirectedEdges(o, l), this.add(a);
      }
    }, {
      key: "getNode",
      value: function getNode(t) {
        var e = this.findNode(t);
        return null === e && (e = new Zi(t), this.add(e)), e;
      }
    }]);

    return Ji;
  }(Qi);

  var $i = /*#__PURE__*/function () {
    function $i() {
      _classCallCheck(this, $i);

      $i.constructor_.apply(this, arguments);
    }

    _createClass($i, [{
      key: "buildEdgeStringsForUnprocessedNodes",
      value: function buildEdgeStringsForUnprocessedNodes() {
        for (var _t641 = this._graph.getNodes().iterator(); _t641.hasNext();) {
          var _e508 = _t641.next();

          _e508.isMarked() || (g.isTrue(2 === _e508.getDegree()), this.buildEdgeStringsStartingAt(_e508), _e508.setMarked(!0));
        }
      }
    }, {
      key: "buildEdgeStringsForNonDegree2Nodes",
      value: function buildEdgeStringsForNonDegree2Nodes() {
        for (var _t642 = this._graph.getNodes().iterator(); _t642.hasNext();) {
          var _e509 = _t642.next();

          2 !== _e509.getDegree() && (this.buildEdgeStringsStartingAt(_e509), _e509.setMarked(!0));
        }
      }
    }, {
      key: "buildEdgeStringsForObviousStartNodes",
      value: function buildEdgeStringsForObviousStartNodes() {
        this.buildEdgeStringsForNonDegree2Nodes();
      }
    }, {
      key: "getMergedLineStrings",
      value: function getMergedLineStrings() {
        return this.merge(), this._mergedLineStrings;
      }
    }, {
      key: "buildEdgeStringsStartingAt",
      value: function buildEdgeStringsStartingAt(t) {
        for (var _e510 = t.getOutEdges().iterator(); _e510.hasNext();) {
          var _t643 = _e510.next();

          _t643.getEdge().isMarked() || this._edgeStrings.add(this.buildEdgeStringStartingWith(_t643));
        }
      }
    }, {
      key: "merge",
      value: function merge() {
        if (null !== this._mergedLineStrings) return null;
        Xi.setMarked(this._graph.nodeIterator(), !1), Xi.setMarked(this._graph.edgeIterator(), !1), this._edgeStrings = new S(), this.buildEdgeStringsForObviousStartNodes(), this.buildEdgeStringsForIsolatedLoops(), this._mergedLineStrings = new S();

        for (var _t644 = this._edgeStrings.iterator(); _t644.hasNext();) {
          var _e511 = _t644.next();

          this._mergedLineStrings.add(_e511.toLineString());
        }
      }
    }, {
      key: "addLineString",
      value: function addLineString(t) {
        null === this._factory && (this._factory = t.getFactory()), this._graph.addEdge(t);
      }
    }, {
      key: "buildEdgeStringStartingWith",
      value: function buildEdgeStringStartingWith(t) {
        var e = new zi(this._factory);
        var n = t;

        do {
          e.add(n), n.getEdge().setMarked(!0), n = n.getNext();
        } while (null !== n && n !== t);

        return e;
      }
    }, {
      key: "add",
      value: function add() {
        if (arguments[0] instanceof V) {
          var _t645 = arguments[0];

          for (var _e512 = 0; _e512 < _t645.getNumGeometries(); _e512++) {
            var _n371 = _t645.getGeometryN(_e512);

            _n371 instanceof j && this.addLineString(_n371);
          }
        } else if (y(arguments[0], x)) {
          var _t646 = arguments[0];
          this._mergedLineStrings = null;

          for (var _e513 = _t646.iterator(); _e513.hasNext();) {
            var _t647 = _e513.next();

            this.add(_t647);
          }
        }
      }
    }, {
      key: "buildEdgeStringsForIsolatedLoops",
      value: function buildEdgeStringsForIsolatedLoops() {
        this.buildEdgeStringsForUnprocessedNodes();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._graph = new Ji(), this._mergedLineStrings = null, this._factory = null, this._edgeStrings = null;
      }
    }]);

    return $i;
  }();

  var tr = /*#__PURE__*/function () {
    function tr() {
      _classCallCheck(this, tr);

      tr.constructor_.apply(this, arguments);
    }

    _createClass(tr, [{
      key: "dirEdgeIterator",
      value: function dirEdgeIterator() {
        return this._dirEdges.iterator();
      }
    }, {
      key: "edgeIterator",
      value: function edgeIterator() {
        return this._edges.iterator();
      }
    }, {
      key: "getParent",
      value: function getParent() {
        return this._parentGraph;
      }
    }, {
      key: "nodeIterator",
      value: function nodeIterator() {
        return this._nodeMap.iterator();
      }
    }, {
      key: "contains",
      value: function contains(t) {
        return this._edges.contains(t);
      }
    }, {
      key: "add",
      value: function add(t) {
        if (this._edges.contains(t)) return null;
        this._edges.add(t), this._dirEdges.add(t.getDirEdge(0)), this._dirEdges.add(t.getDirEdge(1)), this._nodeMap.add(t.getDirEdge(0).getFromNode()), this._nodeMap.add(t.getDirEdge(1).getFromNode());
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._parentGraph = null, this._edges = new xt(), this._dirEdges = new S(), this._nodeMap = new Ki();
        var t = arguments[0];
        this._parentGraph = t;
      }
    }]);

    return tr;
  }();

  var er = /*#__PURE__*/function () {
    function er() {
      _classCallCheck(this, er);

      er.constructor_.apply(this, arguments);
    }

    _createClass(er, [{
      key: "addReachable",
      value: function addReachable(t, e) {
        var n = new tn();

        for (n.add(t); !n.empty();) {
          var _t648 = n.pop();

          this.addEdges(_t648, n, e);
        }
      }
    }, {
      key: "findSubgraph",
      value: function findSubgraph(t) {
        var e = new tr(this._graph);
        return this.addReachable(t, e), e;
      }
    }, {
      key: "getConnectedSubgraphs",
      value: function getConnectedSubgraphs() {
        var t = new S();
        Xi.setVisited(this._graph.nodeIterator(), !1);

        for (var _e514 = this._graph.edgeIterator(); _e514.hasNext();) {
          var _n372 = _e514.next().getDirEdge(0).getFromNode();

          _n372.isVisited() || t.add(this.findSubgraph(_n372));
        }

        return t;
      }
    }, {
      key: "addEdges",
      value: function addEdges(t, e, n) {
        t.setVisited(!0);

        for (var _s229 = t.getOutEdges().iterator(); _s229.hasNext();) {
          var _t649 = _s229.next();

          n.add(_t649.getEdge());

          var _i127 = _t649.getToNode();

          _i127.isVisited() || e.push(_i127);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._graph = null;
        var t = arguments[0];
        this._graph = t;
      }
    }]);

    return er;
  }();

  var nr = /*#__PURE__*/function () {
    function nr() {
      _classCallCheck(this, nr);

      nr.constructor_.apply(this, arguments);
    }

    _createClass(nr, [{
      key: "addLine",
      value: function addLine(t) {
        null === this._factory && (this._factory = t.getFactory()), this._graph.addEdge(t), this._lineCount++;
      }
    }, {
      key: "hasSequence",
      value: function hasSequence(t) {
        var e = 0;

        for (var _n373 = t.nodeIterator(); _n373.hasNext();) {
          _n373.next().getDegree() % 2 == 1 && e++;
        }

        return e <= 2;
      }
    }, {
      key: "computeSequence",
      value: function computeSequence() {
        if (this._isRun) return null;
        this._isRun = !0;
        var t = this.findSequences();
        if (null === t) return null;
        this._sequencedGeometry = this.buildSequencedGeometry(t), this._isSequenceable = !0;

        var e = this._sequencedGeometry.getNumGeometries();

        g.isTrue(this._lineCount === e, "Lines were missing from result"), g.isTrue(this._sequencedGeometry instanceof j || this._sequencedGeometry instanceof wt, "Result is not lineal");
      }
    }, {
      key: "findSequences",
      value: function findSequences() {
        var t = new S();

        for (var _e515 = new er(this._graph).getConnectedSubgraphs().iterator(); _e515.hasNext();) {
          var _n374 = _e515.next();

          if (!this.hasSequence(_n374)) return null;
          {
            var _e516 = this.findSequence(_n374);

            t.add(_e516);
          }
        }

        return t;
      }
    }, {
      key: "addReverseSubpath",
      value: function addReverseSubpath(t, e, n) {
        var s = t.getToNode();
        var i = null;

        for (;;) {
          e.add(t.getSym()), t.getEdge().setVisited(!0), i = t.getFromNode();

          var _n375 = nr.findUnvisitedBestOrientedDE(i);

          if (null === _n375) break;
          t = _n375.getSym();
        }

        n && g.isTrue(i === s, "path not contiguous");
      }
    }, {
      key: "findSequence",
      value: function findSequence(t) {
        Xi.setVisited(t.edgeIterator(), !1);
        var e = nr.findLowestDegreeNode(t).getOutEdges().iterator().next().getSym(),
            n = new ai(),
            s = n.listIterator();

        for (this.addReverseSubpath(e, s, !1); s.hasPrevious();) {
          var _t650 = s.previous(),
              _e517 = nr.findUnvisitedBestOrientedDE(_t650.getFromNode());

          null !== _e517 && this.addReverseSubpath(_e517.getSym(), s, !0);
        }

        return this.orient(n);
      }
    }, {
      key: "reverse",
      value: function reverse(t) {
        var e = new ai();

        for (var _n376 = t.iterator(); _n376.hasNext();) {
          var _t651 = _n376.next();

          e.addFirst(_t651.getSym());
        }

        return e;
      }
    }, {
      key: "orient",
      value: function orient(t) {
        var e = t.get(0),
            n = t.get(t.size() - 1),
            s = e.getFromNode(),
            i = n.getToNode();
        var r = !1;

        if (1 === s.getDegree() || 1 === i.getDegree()) {
          var _t652 = !1;

          1 === n.getToNode().getDegree() && !1 === n.getEdgeDirection() && (_t652 = !0, r = !0), 1 === e.getFromNode().getDegree() && !0 === e.getEdgeDirection() && (_t652 = !0, r = !1), _t652 || 1 === e.getFromNode().getDegree() && (r = !0);
        }

        return r ? this.reverse(t) : t;
      }
    }, {
      key: "buildSequencedGeometry",
      value: function buildSequencedGeometry(t) {
        var e = new S();

        for (var _n377 = t.iterator(); _n377.hasNext();) {
          for (var _t653 = _n377.next().iterator(); _t653.hasNext();) {
            var _n378 = _t653.next(),
                _s230 = _n378.getEdge().getLine();

            var _i128 = _s230;
            _n378.getEdgeDirection() || _s230.isClosed() || (_i128 = nr.reverse(_s230)), e.add(_i128);
          }
        }

        return 0 === e.size() ? this._factory.createMultiLineString(new Array(0).fill(null)) : this._factory.buildGeometry(e);
      }
    }, {
      key: "getSequencedLineStrings",
      value: function getSequencedLineStrings() {
        return this.computeSequence(), this._sequencedGeometry;
      }
    }, {
      key: "isSequenceable",
      value: function isSequenceable() {
        return this.computeSequence(), this._isSequenceable;
      }
    }, {
      key: "add",
      value: function add() {
        if (y(arguments[0], x)) {
          for (var _t654 = arguments[0].iterator(); _t654.hasNext();) {
            var _e518 = _t654.next();

            this.add(_e518);
          }
        } else if (arguments[0] instanceof V) {
          arguments[0].apply(new ( /*#__PURE__*/function () {
            function _class14() {
              _classCallCheck(this, _class14);
            }

            _createClass(_class14, [{
              key: "filter",
              value: function filter(t) {
                t instanceof j && this.addLine(t);
              }
            }, {
              key: "interfaces_",
              get: function get() {
                return [Y];
              }
            }]);

            return _class14;
          }())());
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._graph = new Ji(), this._factory = new Ct(), this._lineCount = 0, this._isRun = !1, this._sequencedGeometry = null, this._isSequenceable = !1;
      }
    }, {
      key: "findUnvisitedBestOrientedDE",
      value: function findUnvisitedBestOrientedDE(t) {
        var e = null,
            n = null;

        for (var _s231 = t.getOutEdges().iterator(); _s231.hasNext();) {
          var _t655 = _s231.next();

          _t655.getEdge().isVisited() || (n = _t655, _t655.getEdgeDirection() && (e = _t655));
        }

        return null !== e ? e : n;
      }
    }, {
      key: "findLowestDegreeNode",
      value: function findLowestDegreeNode(t) {
        var e = P.MAX_VALUE,
            n = null;

        for (var _s232 = t.nodeIterator(); _s232.hasNext();) {
          var _t656 = _s232.next();

          (null === n || _t656.getDegree() < e) && (e = _t656.getDegree(), n = _t656);
        }

        return n;
      }
    }, {
      key: "isSequenced",
      value: function isSequenced(t) {
        if (!(t instanceof wt)) return !0;
        var e = t,
            n = new it();
        var s = null;
        var i = new S();

        for (var _t657 = 0; _t657 < e.getNumGeometries(); _t657++) {
          var _r66 = e.getGeometryN(_t657),
              _o37 = _r66.getCoordinateN(0),
              _l31 = _r66.getCoordinateN(_r66.getNumPoints() - 1);

          if (n.contains(_o37)) return !1;
          if (n.contains(_l31)) return !1;
          null !== s && (_o37.equals(s) || (n.addAll(i), i.clear())), i.add(_o37), i.add(_l31), s = _l31;
        }

        return !0;
      }
    }, {
      key: "reverse",
      value: function reverse(t) {
        var e = t.getCoordinates(),
            n = new Array(e.length).fill(null),
            s = e.length;

        for (var _t658 = 0; _t658 < s; _t658++) {
          n[s - 1 - _t658] = new m(e[_t658]);
        }

        return t.getFactory().createLineString(n);
      }
    }, {
      key: "sequence",
      value: function sequence(t) {
        var e = new nr();
        return e.add(t), e.getSequencedLineStrings();
      }
    }]);

    return nr;
  }();

  var sr = Object.freeze({
    __proto__: null,
    LineMerger: $i,
    LineSequencer: nr
  });

  var ir = /*#__PURE__*/function () {
    function ir() {
      _classCallCheck(this, ir);

      ir.constructor_.apply(this, arguments);
    }

    _createClass(ir, [{
      key: "snapVertices",
      value: function snapVertices(t, e) {
        var n = this._isClosed ? t.size() - 1 : t.size();

        for (var _s233 = 0; _s233 < n; _s233++) {
          var _n379 = t.get(_s233),
              _i129 = this.findSnapForVertex(_n379, e);

          null !== _i129 && (t.set(_s233, new m(_i129)), 0 === _s233 && this._isClosed && t.set(t.size() - 1, new m(_i129)));
        }
      }
    }, {
      key: "findSnapForVertex",
      value: function findSnapForVertex(t, e) {
        for (var _n380 = 0; _n380 < e.length; _n380++) {
          if (t.equals2D(e[_n380])) return null;
          if (t.distance(e[_n380]) < this._snapTolerance) return e[_n380];
        }

        return null;
      }
    }, {
      key: "snapTo",
      value: function snapTo(t) {
        var e = new C(this._srcPts);
        this.snapVertices(e, t), this.snapSegments(e, t);
        return e.toCoordinateArray();
      }
    }, {
      key: "snapSegments",
      value: function snapSegments(t, e) {
        if (0 === e.length) return null;
        var n = e.length;
        e[0].equals2D(e[e.length - 1]) && (n = e.length - 1);

        for (var _s234 = 0; _s234 < n; _s234++) {
          var _n381 = e[_s234],
              _i130 = this.findSegmentIndexToSnap(_n381, t);

          _i130 >= 0 && t.add(_i130 + 1, new m(_n381), !1);
        }
      }
    }, {
      key: "findSegmentIndexToSnap",
      value: function findSegmentIndexToSnap(t, e) {
        var n = r.MAX_VALUE,
            s = -1;

        for (var _i131 = 0; _i131 < e.size() - 1; _i131++) {
          if (this._seg.p0 = e.get(_i131), this._seg.p1 = e.get(_i131 + 1), this._seg.p0.equals2D(t) || this._seg.p1.equals2D(t)) {
            if (this._allowSnappingToSourceVertices) continue;
            return -1;
          }

          var _r67 = this._seg.distance(t);

          _r67 < this._snapTolerance && _r67 < n && (n = _r67, s = _i131);
        }

        return s;
      }
    }, {
      key: "setAllowSnappingToSourceVertices",
      value: function setAllowSnappingToSourceVertices(t) {
        this._allowSnappingToSourceVertices = t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._snapTolerance = 0, this._srcPts = null, this._seg = new jt(), this._allowSnappingToSourceVertices = !1, this._isClosed = !1, arguments[0] instanceof j && "number" == typeof arguments[1]) {
          var _t659 = arguments[0],
              _e519 = arguments[1];
          ir.constructor_.call(this, _t659.getCoordinates(), _e519);
        } else if (arguments[0] instanceof Array && "number" == typeof arguments[1]) {
          var _t660 = arguments[0],
              _e520 = arguments[1];
          this._srcPts = _t660, this._isClosed = ir.isClosed(_t660), this._snapTolerance = _e520;
        }
      }
    }, {
      key: "isClosed",
      value: function isClosed(t) {
        return !(t.length <= 1) && t[0].equals2D(t[t.length - 1]);
      }
    }]);

    return ir;
  }();

  var rr = /*#__PURE__*/function () {
    function rr() {
      _classCallCheck(this, rr);

      rr.constructor_.apply(this, arguments);
    }

    _createClass(rr, [{
      key: "snapTo",
      value: function snapTo(t, e) {
        var n = this.extractTargetCoordinates(t);
        return new or(e, n).transform(this._srcGeom);
      }
    }, {
      key: "snapToSelf",
      value: function snapToSelf(t, e) {
        var n = this.extractTargetCoordinates(this._srcGeom),
            s = new or(t, n, !0).transform(this._srcGeom);
        var i = s;
        return e && y(i, tt) && (i = s.buffer(0)), i;
      }
    }, {
      key: "computeSnapTolerance",
      value: function computeSnapTolerance(t) {
        return this.computeMinimumSegmentLength(t) / 10;
      }
    }, {
      key: "extractTargetCoordinates",
      value: function extractTargetCoordinates(t) {
        var e = new it(),
            n = t.getCoordinates();

        for (var _t661 = 0; _t661 < n.length; _t661++) {
          e.add(n[_t661]);
        }

        return e.toArray(new Array(0).fill(null));
      }
    }, {
      key: "computeMinimumSegmentLength",
      value: function computeMinimumSegmentLength(t) {
        var e = r.MAX_VALUE;

        for (var _n382 = 0; _n382 < t.length - 1; _n382++) {
          var _s235 = t[_n382].distance(t[_n382 + 1]);

          _s235 < e && (e = _s235);
        }

        return e;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._srcGeom = null;
        var t = arguments[0];
        this._srcGeom = t;
      }
    }, {
      key: "snap",
      value: function snap(t, e, n) {
        var s = new Array(2).fill(null),
            i = new rr(t);
        s[0] = i.snapTo(e, n);
        var r = new rr(e);
        return s[1] = r.snapTo(s[0], n), s;
      }
    }, {
      key: "computeOverlaySnapTolerance",
      value: function computeOverlaySnapTolerance() {
        if (1 === arguments.length) {
          var _t662 = arguments[0];

          var _e521 = rr.computeSizeBasedSnapTolerance(_t662);

          var _n383 = _t662.getPrecisionModel();

          if (_n383.getType() === Nt.FIXED) {
            var _t663 = 1 / _n383.getScale() * 2 / 1.415;

            _t663 > _e521 && (_e521 = _t663);
          }

          return _e521;
        }

        if (2 === arguments.length) {
          var _t664 = arguments[0],
              _e522 = arguments[1];
          return Math.min(rr.computeOverlaySnapTolerance(_t664), rr.computeOverlaySnapTolerance(_e522));
        }
      }
    }, {
      key: "computeSizeBasedSnapTolerance",
      value: function computeSizeBasedSnapTolerance(t) {
        var e = t.getEnvelopeInternal();
        return Math.min(e.getHeight(), e.getWidth()) * rr.SNAP_PRECISION_FACTOR;
      }
    }, {
      key: "snapToSelf",
      value: function snapToSelf(t, e, n) {
        return new rr(t).snapToSelf(e, n);
      }
    }]);

    return rr;
  }();

  rr.SNAP_PRECISION_FACTOR = 1e-9;

  var or = /*#__PURE__*/function (_pe2) {
    _inherits(or, _pe2);

    var _super63 = _createSuper(or);

    function or() {
      var _this48;

      _classCallCheck(this, or);

      _this48 = _super63.call(this), or.constructor_.apply(_assertThisInitialized(_this48), arguments);
      return _this48;
    }

    _createClass(or, [{
      key: "snapLine",
      value: function snapLine(t, e) {
        var n = new ir(t, this._snapTolerance);
        return n.setAllowSnappingToSourceVertices(this._isSelfSnap), n.snapTo(e);
      }
    }, {
      key: "transformCoordinates",
      value: function transformCoordinates(t, e) {
        var n = t.toCoordinateArray(),
            s = this.snapLine(n, this._snapPts);
        return this._factory.getCoordinateSequenceFactory().create(s);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._snapTolerance = null, this._snapPts = null, this._isSelfSnap = !1, 2 === arguments.length) {
          var _t665 = arguments[0],
              _e523 = arguments[1];
          this._snapTolerance = _t665, this._snapPts = _e523;
        } else if (3 === arguments.length) {
          var _t666 = arguments[0],
              _e524 = arguments[1],
              _n384 = arguments[2];
          this._snapTolerance = _t666, this._snapPts = _e524, this._isSelfSnap = _n384;
        }
      }
    }]);

    return or;
  }(pe);

  var lr = Object.freeze({
    __proto__: null,
    GeometrySnapper: rr,
    LineStringSnapper: ir
  });

  var ar = /*#__PURE__*/function () {
    function ar() {
      _classCallCheck(this, ar);

      ar.constructor_.apply(this, arguments);
    }

    _createClass(ar, [{
      key: "getCoordinates",
      value: function getCoordinates() {
        return this._pts;
      }
    }, {
      key: "size",
      value: function size() {
        return this._pts.length;
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate(t) {
        return this._pts[t];
      }
    }, {
      key: "isClosed",
      value: function isClosed() {
        return this._pts[0].equals(this._pts[this._pts.length - 1]);
      }
    }, {
      key: "getSegmentOctant",
      value: function getSegmentOctant(t) {
        return t === this._pts.length - 1 ? -1 : Xs.octant(this.getCoordinate(t), this.getCoordinate(t + 1));
      }
    }, {
      key: "setData",
      value: function setData(t) {
        this._data = t;
      }
    }, {
      key: "getData",
      value: function getData() {
        return this._data;
      }
    }, {
      key: "toString",
      value: function toString() {
        return Ht.toLineString(new pt(this._pts));
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [ks];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._pts = null, this._data = null;
        var t = arguments[0],
            e = arguments[1];
        this._pts = t, this._data = e;
      }
    }]);

    return ar;
  }();

  var cr = /*#__PURE__*/function () {
    function cr() {
      _classCallCheck(this, cr);

      cr.constructor_.apply(this, arguments);
    }

    _createClass(cr, [{
      key: "setCheckEndSegmentsOnly",
      value: function setCheckEndSegmentsOnly(t) {
        this._isCheckEndSegmentsOnly = t;
      }
    }, {
      key: "getIntersectionSegments",
      value: function getIntersectionSegments() {
        return this._intSegments;
      }
    }, {
      key: "count",
      value: function count() {
        return this._intersectionCount;
      }
    }, {
      key: "getIntersections",
      value: function getIntersections() {
        return this._intersections;
      }
    }, {
      key: "setFindAllIntersections",
      value: function setFindAllIntersections(t) {
        this._findAllIntersections = t;
      }
    }, {
      key: "setKeepIntersections",
      value: function setKeepIntersections(t) {
        this._keepIntersections = t;
      }
    }, {
      key: "getIntersection",
      value: function getIntersection() {
        return this._interiorIntersection;
      }
    }, {
      key: "processIntersections",
      value: function processIntersections(t, e, n, s) {
        if (!this._findAllIntersections && this.hasIntersection()) return null;
        var i = t === n;
        if (i && e === s) return null;

        if (this._isCheckEndSegmentsOnly) {
          if (!(cr.isEndSegment(t, e) || cr.isEndSegment(n, s))) return null;
        }

        var r = t.getCoordinate(e),
            o = t.getCoordinate(e + 1),
            l = n.getCoordinate(s),
            a = n.getCoordinate(s + 1),
            c = 0 === e,
            h = e + 2 === t.size(),
            u = 0 === s,
            g = s + 2 === n.size();

        this._li.computeIntersection(r, o, l, a);

        var d = this._li.hasIntersection() && this._li.isInteriorIntersection();

        var _ = !1;

        if (!this._isInteriorIntersectionsOnly) {
          _ = !(i && Math.abs(s - e) <= 1) && cr.isInteriorVertexIntersection(r, o, l, a, c, h, u, g);
        }

        (d || _) && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = r, this._intSegments[1] = o, this._intSegments[2] = l, this._intSegments[3] = a, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++);
      }
    }, {
      key: "hasIntersection",
      value: function hasIntersection() {
        return null !== this._interiorIntersection;
      }
    }, {
      key: "isDone",
      value: function isDone() {
        return !this._findAllIntersections && null !== this._interiorIntersection;
      }
    }, {
      key: "setInteriorIntersectionsOnly",
      value: function setInteriorIntersectionsOnly(t) {
        this._isInteriorIntersectionsOnly = t;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Li];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._findAllIntersections = !1, this._isCheckEndSegmentsOnly = !1, this._keepIntersections = !0, this._isInteriorIntersectionsOnly = !1, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new S(), this._intersectionCount = 0;
        var t = arguments[0];
        this._li = t, this._interiorIntersection = null;
      }
    }, {
      key: "createAllIntersectionsFinder",
      value: function createAllIntersectionsFinder(t) {
        var e = new cr(t);
        return e.setFindAllIntersections(!0), e;
      }
    }, {
      key: "isInteriorVertexIntersection",
      value: function isInteriorVertexIntersection() {
        if (4 === arguments.length) {
          var _t667 = arguments[0],
              _e525 = arguments[1],
              _n385 = arguments[3];
          return (!arguments[2] || !_n385) && !!_t667.equals2D(_e525);
        }

        if (8 === arguments.length) {
          var _t668 = arguments[0],
              _e526 = arguments[1],
              _n386 = arguments[2],
              _s236 = arguments[3],
              _i132 = arguments[4],
              _r68 = arguments[5],
              _o38 = arguments[6],
              _l32 = arguments[7];
          return !!cr.isInteriorVertexIntersection(_t668, _n386, _i132, _o38) || !!cr.isInteriorVertexIntersection(_t668, _s236, _i132, _l32) || !!cr.isInteriorVertexIntersection(_e526, _n386, _r68, _o38) || !!cr.isInteriorVertexIntersection(_e526, _s236, _r68, _l32);
        }
      }
    }, {
      key: "createInteriorIntersectionCounter",
      value: function createInteriorIntersectionCounter(t) {
        var e = new cr(t);
        return e.setInteriorIntersectionsOnly(!0), e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e;
      }
    }, {
      key: "createIntersectionCounter",
      value: function createIntersectionCounter(t) {
        var e = new cr(t);
        return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e;
      }
    }, {
      key: "isEndSegment",
      value: function isEndSegment(t, e) {
        return 0 === e || e >= t.size() - 2;
      }
    }, {
      key: "createAnyIntersectionFinder",
      value: function createAnyIntersectionFinder(t) {
        return new cr(t);
      }
    }, {
      key: "createInteriorIntersectionsFinder",
      value: function createInteriorIntersectionsFinder(t) {
        var e = new cr(t);
        return e.setFindAllIntersections(!0), e.setInteriorIntersectionsOnly(!0), e;
      }
    }]);

    return cr;
  }();

  var hr = /*#__PURE__*/function () {
    function hr() {
      _classCallCheck(this, hr);

      hr.constructor_.apply(this, arguments);
    }

    _createClass(hr, [{
      key: "execute",
      value: function execute() {
        if (null !== this._segInt) return null;
        this.checkInteriorIntersections();
      }
    }, {
      key: "getIntersections",
      value: function getIntersections() {
        return this._segInt.getIntersections();
      }
    }, {
      key: "isValid",
      value: function isValid() {
        return this.execute(), this._isValid;
      }
    }, {
      key: "setFindAllIntersections",
      value: function setFindAllIntersections(t) {
        this._findAllIntersections = t;
      }
    }, {
      key: "checkInteriorIntersections",
      value: function checkInteriorIntersections() {
        this._isValid = !0, this._segInt = new cr(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections);
        var t = new Js();
        if (t.setSegmentIntersector(this._segInt), t.computeNodes(this._segStrings), this._segInt.hasIntersection()) return this._isValid = !1, null;
      }
    }, {
      key: "checkValid",
      value: function checkValid() {
        if (this.execute(), !this._isValid) throw new ns(this.getErrorMessage(), this._segInt.getIntersection());
      }
    }, {
      key: "getErrorMessage",
      value: function getErrorMessage() {
        if (this._isValid) return "no intersections found";

        var t = this._segInt.getIntersectionSegments();

        return "found non-noded intersection between " + Ht.toLineString(t[0], t[1]) + " and " + Ht.toLineString(t[2], t[3]);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._li = new Zt(), this._segStrings = null, this._findAllIntersections = !1, this._segInt = null, this._isValid = !0;
        var t = arguments[0];
        this._segStrings = t;
      }
    }, {
      key: "computeIntersections",
      value: function computeIntersections(t) {
        var e = new hr(t);
        return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections();
      }
    }]);

    return hr;
  }();

  var ur = /*#__PURE__*/function () {
    function ur() {
      _classCallCheck(this, ur);

      ur.constructor_.apply(this, arguments);
    }

    _createClass(ur, [{
      key: "checkValid",
      value: function checkValid() {
        this._nv.checkValid();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._nv = null;
        var t = arguments[0];
        this._nv = new hr(ur.toSegmentStrings(t));
      }
    }, {
      key: "toSegmentStrings",
      value: function toSegmentStrings(t) {
        var e = new S();

        for (var _n387 = t.iterator(); _n387.hasNext();) {
          var _t669 = _n387.next();

          e.add(new ar(_t669.getCoordinates(), _t669));
        }

        return e;
      }
    }, {
      key: "checkValid",
      value: function checkValid(t) {
        new ur(t).checkValid();
      }
    }]);

    return ur;
  }();

  var gr = /*#__PURE__*/function () {
    function gr() {
      _classCallCheck(this, gr);

      gr.constructor_.apply(this, arguments);
    }

    _createClass(gr, [{
      key: "collectLines",
      value: function collectLines(t) {
        for (var _e527 = this._op.getGraph().getEdgeEnds().iterator(); _e527.hasNext();) {
          var _n388 = _e527.next();

          this.collectLineEdge(_n388, t, this._lineEdgesList), this.collectBoundaryTouchEdge(_n388, t, this._lineEdgesList);
        }
      }
    }, {
      key: "labelIsolatedLine",
      value: function labelIsolatedLine(t, e) {
        var n = this._ptLocator.locate(t.getCoordinate(), this._op.getArgGeometry(e));

        t.getLabel().setLocation(e, n);
      }
    }, {
      key: "build",
      value: function build(t) {
        return this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this._resultLineList;
      }
    }, {
      key: "collectLineEdge",
      value: function collectLineEdge(t, e, n) {
        var s = t.getLabel(),
            i = t.getEdge();
        t.isLineEdge() && (t.isVisited() || !Ir.isResultOfOp(s, e) || i.isCovered() || (n.add(i), t.setVisitedEdge(!0)));
      }
    }, {
      key: "findCoveredLineEdges",
      value: function findCoveredLineEdges() {
        for (var _t670 = this._op.getGraph().getNodes().iterator(); _t670.hasNext();) {
          _t670.next().getEdges().findCoveredLineEdges();
        }

        for (var _t671 = this._op.getGraph().getEdgeEnds().iterator(); _t671.hasNext();) {
          var _e528 = _t671.next(),
              _n389 = _e528.getEdge();

          if (_e528.isLineEdge() && !_n389.isCoveredSet()) {
            var _t672 = this._op.isCoveredByA(_e528.getCoordinate());

            _n389.setCovered(_t672);
          }
        }
      }
    }, {
      key: "labelIsolatedLines",
      value: function labelIsolatedLines(t) {
        for (var _e529 = t.iterator(); _e529.hasNext();) {
          var _t673 = _e529.next(),
              _n390 = _t673.getLabel();

          _t673.isIsolated() && (_n390.isNull(0) ? this.labelIsolatedLine(_t673, 0) : this.labelIsolatedLine(_t673, 1));
        }
      }
    }, {
      key: "buildLines",
      value: function buildLines(t) {
        for (var _t674 = this._lineEdgesList.iterator(); _t674.hasNext();) {
          var _e530 = _t674.next(),
              _n391 = this._geometryFactory.createLineString(_e530.getCoordinates());

          this._resultLineList.add(_n391), _e530.setInResult(!0);
        }
      }
    }, {
      key: "collectBoundaryTouchEdge",
      value: function collectBoundaryTouchEdge(t, e, n) {
        var s = t.getLabel();
        return t.isLineEdge() || t.isVisited() || t.isInteriorAreaEdge() || t.getEdge().isInResult() ? null : (g.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()), void (Ir.isResultOfOp(s, e) && e === Ir.INTERSECTION && (n.add(t.getEdge()), t.setVisitedEdge(!0))));
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new S(), this._resultLineList = new S();
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2];
        this._op = t, this._geometryFactory = e, this._ptLocator = n;
      }
    }]);

    return gr;
  }();

  var dr = /*#__PURE__*/function () {
    function dr() {
      _classCallCheck(this, dr);

      dr.constructor_.apply(this, arguments);
    }

    _createClass(dr, [{
      key: "filterCoveredNodeToPoint",
      value: function filterCoveredNodeToPoint(t) {
        var e = t.getCoordinate();

        if (!this._op.isCoveredByLA(e)) {
          var _t675 = this._geometryFactory.createPoint(e);

          this._resultPointList.add(_t675);
        }
      }
    }, {
      key: "extractNonCoveredResultNodes",
      value: function extractNonCoveredResultNodes(t) {
        for (var _e531 = this._op.getGraph().getNodes().iterator(); _e531.hasNext();) {
          var _n392 = _e531.next();

          if (!_n392.isInResult() && !_n392.isIncidentEdgeInResult() && (0 === _n392.getEdges().getDegree() || t === Ir.INTERSECTION)) {
            var _e532 = _n392.getLabel();

            Ir.isResultOfOp(_e532, t) && this.filterCoveredNodeToPoint(_n392);
          }
        }
      }
    }, {
      key: "build",
      value: function build(t) {
        return this.extractNonCoveredResultNodes(t), this._resultPointList;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._op = null, this._geometryFactory = null, this._resultPointList = new S();
        var t = arguments[0],
            e = arguments[1];
        this._op = t, this._geometryFactory = e;
      }
    }]);

    return dr;
  }();

  var _r = /*#__PURE__*/function () {
    function _r() {
      _classCallCheck(this, _r);

      this._isFirst = !0, this._commonMantissaBitsCount = 53, this._commonBits = new i(), this._commonSignExp = null;
    }

    _createClass(_r, [{
      key: "getCommon",
      value: function getCommon() {
        return r.longBitsToDouble(this._commonBits);
      }
    }, {
      key: "add",
      value: function add(t) {
        var e = r.doubleToLongBits(t);
        if (this._isFirst) return this._commonBits = e, this._commonSignExp = _r.signExpBits(this._commonBits), this._isFirst = !1, null;
        if (_r.signExpBits(e) !== this._commonSignExp) return this._commonBits.high = 0, this._commonBits.low = 0, null;
        this._commonMantissaBitsCount = _r.numCommonMostSigMantissaBits(this._commonBits, e), this._commonBits = _r.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
      }
    }, {
      key: "toString",
      value: function toString() {
        if (1 === arguments.length) {
          var _t676 = arguments[0],
              _e533 = r.longBitsToDouble(_t676),
              _n393 = "0000000000000000000000000000000000000000000000000000000000000000" + i.toBinaryString(_t676),
              _s237 = _n393.substring(_n393.length - 64);

          return _s237.substring(0, 1) + "  " + _s237.substring(1, 12) + "(exp) " + _s237.substring(12) + " [ " + _e533 + " ]";
        }
      }
    }, {
      key: "getClass",
      value: function getClass() {
        return _r;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [];
      }
    }], [{
      key: "getBit",
      value: function getBit(t, e) {
        var n = 1 << e % 32;
        return e < 32 ? 0 != (t.low & n) ? 1 : 0 : 0 != (t.high & n) ? 1 : 0;
      }
    }, {
      key: "signExpBits",
      value: function signExpBits(t) {
        return t.high >>> 20;
      }
    }, {
      key: "zeroLowerBits",
      value: function zeroLowerBits(t, e) {
        var n = "low";

        if (e > 32 && (t.low = 0, e %= 32, n = "high"), e > 0) {
          var _s238 = e < 32 ? ~((1 << e) - 1) : 0;

          t[n] &= _s238;
        }

        return t;
      }
    }, {
      key: "numCommonMostSigMantissaBits",
      value: function numCommonMostSigMantissaBits(t, e) {
        var n = 0;

        for (var _s239 = 52; _s239 >= 0; _s239--) {
          if (_r.getBit(t, _s239) !== _r.getBit(e, _s239)) return n;
          n++;
        }

        return 52;
      }
    }]);

    return _r;
  }();

  var pr = /*#__PURE__*/function () {
    function pr() {
      _classCallCheck(this, pr);

      pr.constructor_.apply(this, arguments);
    }

    _createClass(pr, [{
      key: "addCommonBits",
      value: function addCommonBits(t) {
        var e = new fr(this._commonCoord);
        t.apply(e), t.geometryChanged();
      }
    }, {
      key: "removeCommonBits",
      value: function removeCommonBits(t) {
        if (0 === this._commonCoord.x && 0 === this._commonCoord.y) return t;
        var e = new m(this._commonCoord);
        e.x = -e.x, e.y = -e.y;
        var n = new fr(e);
        return t.apply(n), t.geometryChanged(), t;
      }
    }, {
      key: "getCommonCoordinate",
      value: function getCommonCoordinate() {
        return this._commonCoord;
      }
    }, {
      key: "add",
      value: function add(t) {
        t.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._commonCoord = null, this._ccFilter = new mr();
      }
    }]);

    return pr;
  }();

  var mr = /*#__PURE__*/function () {
    function mr() {
      _classCallCheck(this, mr);

      mr.constructor_.apply(this, arguments);
    }

    _createClass(mr, [{
      key: "filter",
      value: function filter(t) {
        this._commonBitsX.add(t.x), this._commonBitsY.add(t.y);
      }
    }, {
      key: "getCommonCoordinate",
      value: function getCommonCoordinate() {
        return new m(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [z];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._commonBitsX = new _r(), this._commonBitsY = new _r();
      }
    }]);

    return mr;
  }();

  var fr = /*#__PURE__*/function () {
    function fr() {
      _classCallCheck(this, fr);

      fr.constructor_.apply(this, arguments);
    }

    _createClass(fr, [{
      key: "filter",
      value: function filter(t, e) {
        var n = t.getOrdinate(e, 0) + this.trans.x,
            s = t.getOrdinate(e, 1) + this.trans.y;
        t.setOrdinate(e, 0, n), t.setOrdinate(e, 1, s);
      }
    }, {
      key: "isDone",
      value: function isDone() {
        return !1;
      }
    }, {
      key: "isGeometryChanged",
      value: function isGeometryChanged() {
        return !0;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [L];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this.trans = null;
        var t = arguments[0];
        this.trans = t;
      }
    }]);

    return fr;
  }();

  pr.CommonCoordinateFilter = mr, pr.Translater = fr;

  var yr = /*#__PURE__*/function () {
    function yr() {
      _classCallCheck(this, yr);

      yr.constructor_.apply(this, arguments);
    }

    _createClass(yr, [{
      key: "selfSnap",
      value: function selfSnap(t) {
        return new rr(t).snapTo(t, this._snapTolerance);
      }
    }, {
      key: "removeCommonBits",
      value: function removeCommonBits(t) {
        this._cbr = new pr(), this._cbr.add(t[0]), this._cbr.add(t[1]);
        var e = new Array(2).fill(null);
        return e[0] = this._cbr.removeCommonBits(t[0].copy()), e[1] = this._cbr.removeCommonBits(t[1].copy()), e;
      }
    }, {
      key: "prepareResult",
      value: function prepareResult(t) {
        return this._cbr.addCommonBits(t), t;
      }
    }, {
      key: "getResultGeometry",
      value: function getResultGeometry(t) {
        var e = this.snap(this._geom),
            n = Ir.overlayOp(e[0], e[1], t);
        return this.prepareResult(n);
      }
    }, {
      key: "checkValid",
      value: function checkValid(t) {
        t.isValid() || F.out.println("Snapped geometry is invalid");
      }
    }, {
      key: "computeSnapTolerance",
      value: function computeSnapTolerance() {
        this._snapTolerance = rr.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
      }
    }, {
      key: "snap",
      value: function snap(t) {
        var e = this.removeCommonBits(t);
        return rr.snap(e[0], e[1], this._snapTolerance);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null;
        var t = arguments[0],
            e = arguments[1];
        this._geom[0] = t, this._geom[1] = e, this.computeSnapTolerance();
      }
    }, {
      key: "overlayOp",
      value: function overlayOp(t, e, n) {
        return new yr(t, e).getResultGeometry(n);
      }
    }, {
      key: "union",
      value: function union(t, e) {
        return yr.overlayOp(t, e, Ir.UNION);
      }
    }, {
      key: "intersection",
      value: function intersection(t, e) {
        return yr.overlayOp(t, e, Ir.INTERSECTION);
      }
    }, {
      key: "symDifference",
      value: function symDifference(t, e) {
        return yr.overlayOp(t, e, Ir.SYMDIFFERENCE);
      }
    }, {
      key: "difference",
      value: function difference(t, e) {
        return yr.overlayOp(t, e, Ir.DIFFERENCE);
      }
    }]);

    return yr;
  }();

  var xr = /*#__PURE__*/function () {
    function xr() {
      _classCallCheck(this, xr);

      xr.constructor_.apply(this, arguments);
    }

    _createClass(xr, [{
      key: "getResultGeometry",
      value: function getResultGeometry(t) {
        var e = null,
            n = !1,
            s = null;

        try {
          e = Ir.overlayOp(this._geom[0], this._geom[1], t);
          !0 && (n = !0);
        } catch (t) {
          if (!(t instanceof h)) throw t;
          s = t;
        }

        if (!n) try {
          e = yr.overlayOp(this._geom[0], this._geom[1], t);
        } catch (t) {
          throw t instanceof h ? s : t;
        }
        return e;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._geom = new Array(2).fill(null);
        var t = arguments[0],
            e = arguments[1];
        this._geom[0] = t, this._geom[1] = e;
      }
    }, {
      key: "overlayOp",
      value: function overlayOp(t, e, n) {
        return new xr(t, e).getResultGeometry(n);
      }
    }, {
      key: "union",
      value: function union(t, e) {
        return xr.overlayOp(t, e, Ir.UNION);
      }
    }, {
      key: "intersection",
      value: function intersection(t, e) {
        return xr.overlayOp(t, e, Ir.INTERSECTION);
      }
    }, {
      key: "symDifference",
      value: function symDifference(t, e) {
        return xr.overlayOp(t, e, Ir.SYMDIFFERENCE);
      }
    }, {
      key: "difference",
      value: function difference(t, e) {
        return xr.overlayOp(t, e, Ir.DIFFERENCE);
      }
    }]);

    return xr;
  }();

  var Er = /*#__PURE__*/function () {
    function Er() {
      _classCallCheck(this, Er);

      Er.constructor_.apply(this, arguments);
    }

    _createClass(Er, [{
      key: "getArgGeometry",
      value: function getArgGeometry(t) {
        return this._arg[t].getGeometry();
      }
    }, {
      key: "setComputationPrecision",
      value: function setComputationPrecision(t) {
        this._resultPrecisionModel = t, this._li.setPrecisionModel(this._resultPrecisionModel);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._li = new Zt(), this._resultPrecisionModel = null, this._arg = null, 1 === arguments.length) {
          var _t677 = arguments[0];
          this.setComputationPrecision(_t677.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new os(0, _t677);
        } else if (2 === arguments.length) {
          var _t678 = arguments[0],
              _e534 = arguments[1];
          Er.constructor_.call(this, _t678, _e534, un.OGC_SFS_BOUNDARY_RULE);
        } else if (3 === arguments.length) {
          var _t679 = arguments[0],
              _e535 = arguments[1],
              _n394 = arguments[2];
          _t679.getPrecisionModel().compareTo(_e535.getPrecisionModel()) >= 0 ? this.setComputationPrecision(_t679.getPrecisionModel()) : this.setComputationPrecision(_e535.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new os(0, _t679, _n394), this._arg[1] = new os(1, _e535, _n394);
        }
      }
    }]);

    return Er;
  }();

  var Ir = /*#__PURE__*/function (_Er) {
    _inherits(Ir, _Er);

    var _super64 = _createSuper(Ir);

    function Ir() {
      var _this49;

      _classCallCheck(this, Ir);

      _this49 = _super64.call(this), Ir.constructor_.apply(_assertThisInitialized(_this49), arguments);
      return _this49;
    }

    _createClass(Ir, [{
      key: "insertUniqueEdge",
      value: function insertUniqueEdge(t) {
        var e = this._edgeList.findEqualEdge(t);

        if (null !== e) {
          var _n395 = e.getLabel();

          var _s240 = t.getLabel();

          e.isPointwiseEqual(t) || (_s240 = new Gn(t.getLabel()), _s240.flip());

          var _i133 = e.getDepth();

          _i133.isNull() && _i133.add(_n395), _i133.add(_s240), _n395.merge(_s240);
        } else this._edgeList.add(t);
      }
    }, {
      key: "getGraph",
      value: function getGraph() {
        return this._graph;
      }
    }, {
      key: "cancelDuplicateResultEdges",
      value: function cancelDuplicateResultEdges() {
        for (var _t680 = this._graph.getEdgeEnds().iterator(); _t680.hasNext();) {
          var _e536 = _t680.next(),
              _n396 = _e536.getSym();

          _e536.isInResult() && _n396.isInResult() && (_e536.setInResult(!1), _n396.setInResult(!1));
        }
      }
    }, {
      key: "isCoveredByLA",
      value: function isCoveredByLA(t) {
        return !!this.isCovered(t, this._resultLineList) || !!this.isCovered(t, this._resultPolyList);
      }
    }, {
      key: "computeGeometry",
      value: function computeGeometry(t, e, n, s) {
        var i = new S();
        return i.addAll(t), i.addAll(e), i.addAll(n), i.isEmpty() ? Ir.createEmptyResult(s, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(i);
      }
    }, {
      key: "mergeSymLabels",
      value: function mergeSymLabels() {
        for (var _t681 = this._graph.getNodes().iterator(); _t681.hasNext();) {
          _t681.next().getEdges().mergeSymLabels();
        }
      }
    }, {
      key: "isCovered",
      value: function isCovered(t, e) {
        for (var _n397 = e.iterator(); _n397.hasNext();) {
          var _e537 = _n397.next();

          if (this._ptLocator.locate(t, _e537) !== Kt.EXTERIOR) return !0;
        }

        return !1;
      }
    }, {
      key: "replaceCollapsedEdges",
      value: function replaceCollapsedEdges() {
        var t = new S();

        for (var _e538 = this._edgeList.iterator(); _e538.hasNext();) {
          var _n398 = _e538.next();

          _n398.isCollapsed() && (_e538.remove(), t.add(_n398.getCollapsedEdge()));
        }

        this._edgeList.addAll(t);
      }
    }, {
      key: "updateNodeLabelling",
      value: function updateNodeLabelling() {
        for (var _t682 = this._graph.getNodes().iterator(); _t682.hasNext();) {
          var _e539 = _t682.next(),
              _n399 = _e539.getEdges().getLabel();

          _e539.getLabel().merge(_n399);
        }
      }
    }, {
      key: "getResultGeometry",
      value: function getResultGeometry(t) {
        return this.computeOverlay(t), this._resultGeom;
      }
    }, {
      key: "insertUniqueEdges",
      value: function insertUniqueEdges(t) {
        for (var _e540 = t.iterator(); _e540.hasNext();) {
          var _t683 = _e540.next();

          this.insertUniqueEdge(_t683);
        }
      }
    }, {
      key: "computeOverlay",
      value: function computeOverlay(t) {
        this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, !1), this._arg[1].computeSelfNodes(this._li, !1), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, !0);
        var e = new S();
        this._arg[0].computeSplitEdges(e), this._arg[1].computeSplitEdges(e), this.insertUniqueEdges(e), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), ur.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t), this.cancelDuplicateResultEdges();
        var n = new di(this._geomFact);
        n.add(this._graph), this._resultPolyList = n.getPolygons();
        var s = new gr(this, this._geomFact, this._ptLocator);
        this._resultLineList = s.build(t);
        var i = new dr(this, this._geomFact, this._ptLocator);
        this._resultPointList = i.build(t), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, t);
      }
    }, {
      key: "labelIncompleteNode",
      value: function labelIncompleteNode(t, e) {
        var n = this._ptLocator.locate(t.getCoordinate(), this._arg[e].getGeometry());

        t.getLabel().setLocation(e, n);
      }
    }, {
      key: "copyPoints",
      value: function copyPoints(t) {
        for (var _e541 = this._arg[t].getNodeIterator(); _e541.hasNext();) {
          var _n400 = _e541.next();

          this._graph.addNode(_n400.getCoordinate()).setLabel(t, _n400.getLabel().getLocation(t));
        }
      }
    }, {
      key: "findResultAreaEdges",
      value: function findResultAreaEdges(t) {
        for (var _e542 = this._graph.getEdgeEnds().iterator(); _e542.hasNext();) {
          var _n401 = _e542.next(),
              _s241 = _n401.getLabel();

          _s241.isArea() && !_n401.isInteriorAreaEdge() && Ir.isResultOfOp(_s241.getLocation(0, vn.RIGHT), _s241.getLocation(1, vn.RIGHT), t) && _n401.setInResult(!0);
        }
      }
    }, {
      key: "computeLabelsFromDepths",
      value: function computeLabelsFromDepths() {
        for (var _t684 = this._edgeList.iterator(); _t684.hasNext();) {
          var _e543 = _t684.next(),
              _n402 = _e543.getLabel(),
              _s242 = _e543.getDepth();

          if (!_s242.isNull()) {
            _s242.normalize();

            for (var _t685 = 0; _t685 < 2; _t685++) {
              _n402.isNull(_t685) || !_n402.isArea() || _s242.isNull(_t685) || (0 === _s242.getDelta(_t685) ? _n402.toLine(_t685) : (g.isTrue(!_s242.isNull(_t685, vn.LEFT), "depth of LEFT side has not been initialized"), _n402.setLocation(_t685, vn.LEFT, _s242.getLocation(_t685, vn.LEFT)), g.isTrue(!_s242.isNull(_t685, vn.RIGHT), "depth of RIGHT side has not been initialized"), _n402.setLocation(_t685, vn.RIGHT, _s242.getLocation(_t685, vn.RIGHT))));
            }
          }
        }
      }
    }, {
      key: "computeLabelling",
      value: function computeLabelling() {
        for (var _t686 = this._graph.getNodes().iterator(); _t686.hasNext();) {
          _t686.next().getEdges().computeLabelling(this._arg);
        }

        this.mergeSymLabels(), this.updateNodeLabelling();
      }
    }, {
      key: "labelIncompleteNodes",
      value: function labelIncompleteNodes() {
        for (var _t687 = this._graph.getNodes().iterator(); _t687.hasNext();) {
          var _e544 = _t687.next(),
              _n403 = _e544.getLabel();

          _e544.isIsolated() && (_n403.isNull(0) ? this.labelIncompleteNode(_e544, 0) : this.labelIncompleteNode(_e544, 1)), _e544.getEdges().updateLabelling(_n403);
        }
      }
    }, {
      key: "isCoveredByA",
      value: function isCoveredByA(t) {
        return !!this.isCovered(t, this._resultPolyList);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._ptLocator = new mn(), this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new Ci(), this._resultPolyList = new S(), this._resultLineList = new S(), this._resultPointList = new S();
        var t = arguments[0],
            e = arguments[1];
        Er.constructor_.call(this, t, e), this._graph = new rs(new Si()), this._geomFact = t.getFactory();
      }
    }, {
      key: "overlayOp",
      value: function overlayOp(t, e, n) {
        return new Ir(t, e).getResultGeometry(n);
      }
    }, {
      key: "union",
      value: function union(t, e) {
        if (t.isEmpty() || e.isEmpty()) {
          if (t.isEmpty() && e.isEmpty()) return Ir.createEmptyResult(Ir.UNION, t, e, t.getFactory());
          if (t.isEmpty()) return e.copy();
          if (e.isEmpty()) return t.copy();
        }

        if (t.isGeometryCollection() || e.isGeometryCollection()) throw new s("This method does not support GeometryCollection arguments");
        return xr.overlayOp(t, e, Ir.UNION);
      }
    }, {
      key: "intersection",
      value: function intersection(t, e) {
        if (t.isEmpty() || e.isEmpty()) return Ir.createEmptyResult(Ir.INTERSECTION, t, e, t.getFactory());

        if (t.isGeometryCollection()) {
          var _n404 = e;
          return ae.map(t, new ( /*#__PURE__*/function () {
            function _class15() {
              _classCallCheck(this, _class15);
            }

            _createClass(_class15, [{
              key: "map",
              value: function map(t) {
                return Ir.intersection(t, _n404);
              }
            }, {
              key: "interfaces_",
              get: function get() {
                return [MapOp];
              }
            }]);

            return _class15;
          }())());
        }

        return xr.overlayOp(t, e, Ir.INTERSECTION);
      }
    }, {
      key: "symDifference",
      value: function symDifference(t, e) {
        if (t.isEmpty() || e.isEmpty()) {
          if (t.isEmpty() && e.isEmpty()) return Ir.createEmptyResult(Ir.SYMDIFFERENCE, t, e, t.getFactory());
          if (t.isEmpty()) return e.copy();
          if (e.isEmpty()) return t.copy();
        }

        if (t.isGeometryCollection() || e.isGeometryCollection()) throw new s("This method does not support GeometryCollection arguments");
        return xr.overlayOp(t, e, Ir.SYMDIFFERENCE);
      }
    }, {
      key: "resultDimension",
      value: function resultDimension(t, e, n) {
        var s = e.getDimension(),
            i = n.getDimension();
        var r = -1;

        switch (t) {
          case Ir.INTERSECTION:
            r = Math.min(s, i);
            break;

          case Ir.UNION:
            r = Math.max(s, i);
            break;

          case Ir.DIFFERENCE:
            r = s;
            break;

          case Ir.SYMDIFFERENCE:
            r = Math.max(s, i);
        }

        return r;
      }
    }, {
      key: "createEmptyResult",
      value: function createEmptyResult(t, e, n, s) {
        var i = Ir.resultDimension(t, e, n);
        return s.createEmpty(i);
      }
    }, {
      key: "difference",
      value: function difference(t, e) {
        if (t.isEmpty()) return Ir.createEmptyResult(Ir.DIFFERENCE, t, e, t.getFactory());
        if (e.isEmpty()) return t.copy();
        if (t.isGeometryCollection() || e.isGeometryCollection()) throw new s("This method does not support GeometryCollection arguments");
        return xr.overlayOp(t, e, Ir.DIFFERENCE);
      }
    }, {
      key: "isResultOfOp",
      value: function isResultOfOp() {
        if (2 === arguments.length) {
          var _t688 = arguments[0],
              _e545 = arguments[1],
              _n405 = _t688.getLocation(0),
              _s243 = _t688.getLocation(1);

          return Ir.isResultOfOp(_n405, _s243, _e545);
        }

        if (3 === arguments.length) {
          var _t689 = arguments[0],
              _e546 = arguments[1],
              _n406 = arguments[2];

          switch (_t689 === Kt.BOUNDARY && (_t689 = Kt.INTERIOR), _e546 === Kt.BOUNDARY && (_e546 = Kt.INTERIOR), _n406) {
            case Ir.INTERSECTION:
              return _t689 === Kt.INTERIOR && _e546 === Kt.INTERIOR;

            case Ir.UNION:
              return _t689 === Kt.INTERIOR || _e546 === Kt.INTERIOR;

            case Ir.DIFFERENCE:
              return _t689 === Kt.INTERIOR && _e546 !== Kt.INTERIOR;

            case Ir.SYMDIFFERENCE:
              return _t689 === Kt.INTERIOR && _e546 !== Kt.INTERIOR || _t689 !== Kt.INTERIOR && _e546 === Kt.INTERIOR;
          }

          return !1;
        }
      }
    }]);

    return Ir;
  }(Er);

  Ir.INTERSECTION = 1, Ir.UNION = 2, Ir.DIFFERENCE = 3, Ir.SYMDIFFERENCE = 4;
  var Nr = Object.freeze({
    __proto__: null,
    snap: lr,
    OverlayOp: Ir
  });

  var Sr = /*#__PURE__*/function (_ki2) {
    _inherits(Sr, _ki2);

    var _super65 = _createSuper(Sr);

    function Sr() {
      var _this50;

      _classCallCheck(this, Sr);

      _this50 = _super65.call(this), Sr.constructor_.apply(_assertThisInitialized(_this50), arguments);
      return _this50;
    }

    _createClass(Sr, [{
      key: "getNext",
      value: function getNext() {
        return this._next;
      }
    }, {
      key: "isInRing",
      value: function isInRing() {
        return null !== this._edgeRing;
      }
    }, {
      key: "setRing",
      value: function setRing(t) {
        this._edgeRing = t;
      }
    }, {
      key: "setLabel",
      value: function setLabel(t) {
        this._label = t;
      }
    }, {
      key: "getLabel",
      value: function getLabel() {
        return this._label;
      }
    }, {
      key: "setNext",
      value: function setNext(t) {
        this._next = t;
      }
    }, {
      key: "getRing",
      value: function getRing() {
        return this._edgeRing;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._edgeRing = null, this._next = null, this._label = -1;
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2],
            s = arguments[3];
        ki.constructor_.call(this, t, e, n, s);
      }
    }]);

    return Sr;
  }(ki);

  var wr = /*#__PURE__*/function (_Hi2) {
    _inherits(wr, _Hi2);

    var _super66 = _createSuper(wr);

    function wr() {
      var _this51;

      _classCallCheck(this, wr);

      _this51 = _super66.call(this), wr.constructor_.apply(_assertThisInitialized(_this51), arguments);
      return _this51;
    }

    _createClass(wr, [{
      key: "getLine",
      value: function getLine() {
        return this._line;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._line = null;
        var t = arguments[0];
        this._line = t;
      }
    }]);

    return wr;
  }(Hi);

  var Cr = /*#__PURE__*/function () {
    function Cr() {
      _classCallCheck(this, Cr);

      Cr.constructor_.apply(this, arguments);
    }

    _createClass(Cr, [{
      key: "visitInteriorRing",
      value: function visitInteriorRing(t, e) {
        if (t.isEmpty()) return null;
        var n = t.getCoordinates(),
            s = n[0],
            i = Cr.findDifferentPoint(n, s),
            r = e.findEdgeInSameDirection(s, i),
            o = e.findEdgeEnd(r);
        var l = null;
        o.getLabel().getLocation(0, vn.RIGHT) === Kt.INTERIOR ? l = o : o.getSym().getLabel().getLocation(0, vn.RIGHT) === Kt.INTERIOR && (l = o.getSym()), g.isTrue(null !== l, "unable to find dirEdge with Interior on RHS"), this.visitLinkedDirectedEdges(l);
      }
    }, {
      key: "visitShellInteriors",
      value: function visitShellInteriors(t, e) {
        if (t instanceof et) {
          var _n407 = t;
          this.visitInteriorRing(_n407.getExteriorRing(), e);
        }

        if (t instanceof ft) {
          var _n408 = t;

          for (var _t690 = 0; _t690 < _n408.getNumGeometries(); _t690++) {
            var _s244 = _n408.getGeometryN(_t690);

            this.visitInteriorRing(_s244.getExteriorRing(), e);
          }
        }
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        return this._disconnectedRingcoord;
      }
    }, {
      key: "setInteriorEdgesInResult",
      value: function setInteriorEdgesInResult(t) {
        for (var _e547 = t.getEdgeEnds().iterator(); _e547.hasNext();) {
          var _t691 = _e547.next();

          _t691.getLabel().getLocation(0, vn.RIGHT) === Kt.INTERIOR && _t691.setInResult(!0);
        }
      }
    }, {
      key: "visitLinkedDirectedEdges",
      value: function visitLinkedDirectedEdges(t) {
        var e = t;
        var n = t;

        do {
          g.isTrue(null !== n, "found null Directed Edge"), n.setVisited(!0), n = n.getNext();
        } while (n !== e);
      }
    }, {
      key: "buildEdgeRings",
      value: function buildEdgeRings(t) {
        var e = new S();

        for (var _n409 = t.iterator(); _n409.hasNext();) {
          var _t692 = _n409.next();

          if (_t692.isInResult() && null === _t692.getEdgeRing()) {
            var _n410 = new gi(_t692, this._geometryFactory);

            _n410.linkDirectedEdgesForMinimalEdgeRings();

            var _s245 = _n410.buildMinimalRings();

            e.addAll(_s245);
          }
        }

        return e;
      }
    }, {
      key: "hasUnvisitedShellEdge",
      value: function hasUnvisitedShellEdge(t) {
        for (var _e548 = 0; _e548 < t.size(); _e548++) {
          var _n411 = t.get(_e548);

          if (_n411.isHole()) continue;

          var _s246 = _n411.getEdges();

          var _i134 = _s246.get(0);

          if (_i134.getLabel().getLocation(0, vn.RIGHT) === Kt.INTERIOR) for (var _t693 = 0; _t693 < _s246.size(); _t693++) {
            if (_i134 = _s246.get(_t693), !_i134.isVisited()) return this._disconnectedRingcoord = _i134.getCoordinate(), !0;
          }
        }

        return !1;
      }
    }, {
      key: "isInteriorsConnected",
      value: function isInteriorsConnected() {
        var t = new S();

        this._geomGraph.computeSplitEdges(t);

        var e = new rs(new Si());
        e.addEdges(t), this.setInteriorEdgesInResult(e), e.linkResultDirectedEdges();
        var n = this.buildEdgeRings(e.getEdgeEnds());
        return this.visitShellInteriors(this._geomGraph.getGeometry(), e), !this.hasUnvisitedShellEdge(n);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._geometryFactory = new Ct(), this._geomGraph = null, this._disconnectedRingcoord = null;
        var t = arguments[0];
        this._geomGraph = t;
      }
    }, {
      key: "findDifferentPoint",
      value: function findDifferentPoint(t, e) {
        for (var _n412 = 0; _n412 < t.length; _n412++) {
          if (!t[_n412].equals(e)) return t[_n412];
        }

        return null;
      }
    }]);

    return Cr;
  }();

  var Lr = /*#__PURE__*/function () {
    function Lr() {
      _classCallCheck(this, Lr);
    }

    _createClass(Lr, [{
      key: "createEdgeEndForNext",
      value: function createEdgeEndForNext(t, e, n, s) {
        var i = n.segmentIndex + 1;
        if (i >= t.getNumPoints() && null === s) return null;
        var r = t.getCoordinate(i);
        null !== s && s.segmentIndex === n.segmentIndex && (r = s.coord);
        var o = new es(t, n.coord, r, new Gn(t.getLabel()));
        e.add(o);
      }
    }, {
      key: "createEdgeEndForPrev",
      value: function createEdgeEndForPrev(t, e, n, s) {
        var i = n.segmentIndex;

        if (0 === n.dist) {
          if (0 === i) return null;
          i--;
        }

        var r = t.getCoordinate(i);
        null !== s && s.segmentIndex >= i && (r = s.coord);
        var o = new Gn(t.getLabel());
        o.flip();
        var l = new es(t, n.coord, r, o);
        e.add(l);
      }
    }, {
      key: "computeEdgeEnds",
      value: function computeEdgeEnds() {
        if (1 === arguments.length) {
          var _t694 = arguments[0],
              _e549 = new S();

          for (var _n413 = _t694; _n413.hasNext();) {
            var _t695 = _n413.next();

            this.computeEdgeEnds(_t695, _e549);
          }

          return _e549;
        }

        if (2 === arguments.length) {
          var _t696 = arguments[0],
              _e550 = arguments[1],
              _n414 = _t696.getEdgeIntersectionList();

          _n414.addEndpoints();

          var _s247 = _n414.iterator();

          var _i135 = null,
              _r69 = null;
          if (!_s247.hasNext()) return null;

          var _o39 = _s247.next();

          do {
            _i135 = _r69, _r69 = _o39, _o39 = null, _s247.hasNext() && (_o39 = _s247.next()), null !== _r69 && (this.createEdgeEndForPrev(_t696, _e550, _r69, _i135), this.createEdgeEndForNext(_t696, _e550, _r69, _o39));
          } while (null !== _r69);
        }
      }
    }]);

    return Lr;
  }();

  var Tr = /*#__PURE__*/function (_es2) {
    _inherits(Tr, _es2);

    var _super67 = _createSuper(Tr);

    function Tr() {
      var _this52;

      _classCallCheck(this, Tr);

      _this52 = _super67.call(this), Tr.constructor_.apply(_assertThisInitialized(_this52), arguments);
      return _this52;
    }

    _createClass(Tr, [{
      key: "insert",
      value: function insert(t) {
        this._edgeEnds.add(t);
      }
    }, {
      key: "print",
      value: function print(t) {
        t.println("EdgeEndBundle--\x3e Label: " + this._label);

        for (var _e551 = this.iterator(); _e551.hasNext();) {
          _e551.next().print(t), t.println();
        }
      }
    }, {
      key: "iterator",
      value: function iterator() {
        return this._edgeEnds.iterator();
      }
    }, {
      key: "getEdgeEnds",
      value: function getEdgeEnds() {
        return this._edgeEnds;
      }
    }, {
      key: "computeLabelOn",
      value: function computeLabelOn(t, e) {
        var n = 0,
            s = !1;

        for (var _e552 = this.iterator(); _e552.hasNext();) {
          var _i136 = _e552.next().getLabel().getLocation(t);

          _i136 === Kt.BOUNDARY && n++, _i136 === Kt.INTERIOR && (s = !0);
        }

        var i = Kt.NONE;
        s && (i = Kt.INTERIOR), n > 0 && (i = os.determineBoundary(e, n)), this._label.setLocation(t, i);
      }
    }, {
      key: "computeLabelSide",
      value: function computeLabelSide(t, e) {
        for (var _n415 = this.iterator(); _n415.hasNext();) {
          var _s248 = _n415.next();

          if (_s248.getLabel().isArea()) {
            var _n416 = _s248.getLabel().getLocation(t, e);

            if (_n416 === Kt.INTERIOR) return this._label.setLocation(t, e, Kt.INTERIOR), null;
            _n416 === Kt.EXTERIOR && this._label.setLocation(t, e, Kt.EXTERIOR);
          }
        }
      }
    }, {
      key: "getLabel",
      value: function getLabel() {
        return this._label;
      }
    }, {
      key: "computeLabelSides",
      value: function computeLabelSides(t) {
        this.computeLabelSide(t, vn.LEFT), this.computeLabelSide(t, vn.RIGHT);
      }
    }, {
      key: "updateIM",
      value: function updateIM(t) {
        Jn.updateIM(this._label, t);
      }
    }, {
      key: "computeLabel",
      value: function computeLabel(t) {
        var e = !1;

        for (var _t697 = this.iterator(); _t697.hasNext();) {
          _t697.next().getLabel().isArea() && (e = !0);
        }

        this._label = e ? new Gn(Kt.NONE, Kt.NONE, Kt.NONE) : new Gn(Kt.NONE);

        for (var _n417 = 0; _n417 < 2; _n417++) {
          this.computeLabelOn(_n417, t), e && this.computeLabelSides(_n417);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._edgeEnds = new S(), 1 === arguments.length) {
          var _t698 = arguments[0];
          Tr.constructor_.call(this, null, _t698);
        } else if (2 === arguments.length) {
          var _t699 = arguments[1];
          es.constructor_.call(this, _t699.getEdge(), _t699.getCoordinate(), _t699.getDirectedCoordinate(), new Gn(_t699.getLabel())), this.insert(_t699);
        }
      }
    }]);

    return Tr;
  }(es);

  var Rr = /*#__PURE__*/function (_Ii2) {
    _inherits(Rr, _Ii2);

    var _super68 = _createSuper(Rr);

    function Rr() {
      _classCallCheck(this, Rr);

      return _super68.call(this);
    }

    _createClass(Rr, [{
      key: "updateIM",
      value: function updateIM(t) {
        for (var _e553 = this.iterator(); _e553.hasNext();) {
          _e553.next().updateIM(t);
        }
      }
    }, {
      key: "insert",
      value: function insert(t) {
        var e = this._edgeMap.get(t);

        null === e ? (e = new Tr(t), this.insertEdgeEnd(t, e)) : e.insert(t);
      }
    }]);

    return Rr;
  }(Ii);

  var Pr = /*#__PURE__*/function (_$n) {
    _inherits(Pr, _$n);

    var _super69 = _createSuper(Pr);

    function Pr() {
      var _this53;

      _classCallCheck(this, Pr);

      _this53 = _super69.call(this), Pr.constructor_.apply(_assertThisInitialized(_this53), arguments);
      return _this53;
    }

    _createClass(Pr, [{
      key: "updateIMFromEdges",
      value: function updateIMFromEdges(t) {
        this._edges.updateIM(t);
      }
    }, {
      key: "computeIM",
      value: function computeIM(t) {
        t.setAtLeastIfValid(this._label.getLocation(0), this._label.getLocation(1), 0);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        var t = arguments[0],
            e = arguments[1];
        $n.constructor_.call(this, t, e);
      }
    }]);

    return Pr;
  }($n);

  var Or = /*#__PURE__*/function (_is2) {
    _inherits(Or, _is2);

    var _super70 = _createSuper(Or);

    function Or() {
      _classCallCheck(this, Or);

      return _super70.call(this);
    }

    _createClass(Or, [{
      key: "createNode",
      value: function createNode(t) {
        return new Pr(t, new Rr());
      }
    }]);

    return Or;
  }(is);

  var vr = /*#__PURE__*/function () {
    function vr() {
      _classCallCheck(this, vr);

      vr.constructor_.apply(this, arguments);
    }

    _createClass(vr, [{
      key: "insertEdgeEnds",
      value: function insertEdgeEnds(t) {
        for (var _e554 = t.iterator(); _e554.hasNext();) {
          var _t700 = _e554.next();

          this._nodes.add(_t700);
        }
      }
    }, {
      key: "getNodeIterator",
      value: function getNodeIterator() {
        return this._nodes.iterator();
      }
    }, {
      key: "copyNodesAndLabels",
      value: function copyNodesAndLabels(t, e) {
        for (var _n418 = t.getNodeIterator(); _n418.hasNext();) {
          var _t701 = _n418.next();

          this._nodes.addNode(_t701.getCoordinate()).setLabel(e, _t701.getLabel().getLocation(e));
        }
      }
    }, {
      key: "build",
      value: function build(t) {
        this.computeIntersectionNodes(t, 0), this.copyNodesAndLabels(t, 0);
        var e = new Lr().computeEdgeEnds(t.getEdgeIterator());
        this.insertEdgeEnds(e);
      }
    }, {
      key: "computeIntersectionNodes",
      value: function computeIntersectionNodes(t, e) {
        for (var _n419 = t.getEdgeIterator(); _n419.hasNext();) {
          var _t702 = _n419.next(),
              _s249 = _t702.getLabel().getLocation(e);

          for (var _n420 = _t702.getEdgeIntersectionList().iterator(); _n420.hasNext();) {
            var _t703 = _n420.next(),
                _i137 = this._nodes.addNode(_t703.coord);

            _s249 === Kt.BOUNDARY ? _i137.setLabelBoundary(e) : _i137.getLabel().isNull(e) && _i137.setLabel(e, Kt.INTERIOR);
          }
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._nodes = new ts(new Or());
      }
    }]);

    return vr;
  }();

  var Mr = /*#__PURE__*/function () {
    function Mr() {
      _classCallCheck(this, Mr);

      Mr.constructor_.apply(this, arguments);
    }

    _createClass(Mr, [{
      key: "isNodeEdgeAreaLabelsConsistent",
      value: function isNodeEdgeAreaLabelsConsistent() {
        for (var _t704 = this._nodeGraph.getNodeIterator(); _t704.hasNext();) {
          var _e555 = _t704.next();

          if (!_e555.getEdges().isAreaLabelsConsistent(this._geomGraph)) return this._invalidPoint = _e555.getCoordinate().copy(), !1;
        }

        return !0;
      }
    }, {
      key: "getInvalidPoint",
      value: function getInvalidPoint() {
        return this._invalidPoint;
      }
    }, {
      key: "hasDuplicateRings",
      value: function hasDuplicateRings() {
        for (var _t705 = this._nodeGraph.getNodeIterator(); _t705.hasNext();) {
          for (var _e556 = _t705.next().getEdges().iterator(); _e556.hasNext();) {
            var _t706 = _e556.next();

            if (_t706.getEdgeEnds().size() > 1) return this._invalidPoint = _t706.getEdge().getCoordinate(0), !0;
          }
        }

        return !1;
      }
    }, {
      key: "isNodeConsistentArea",
      value: function isNodeConsistentArea() {
        var t = this._geomGraph.computeSelfNodes(this._li, !0, !0);

        return t.hasProperIntersection() ? (this._invalidPoint = t.getProperIntersectionPoint(), !1) : (this._nodeGraph.build(this._geomGraph), this.isNodeEdgeAreaLabelsConsistent());
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._li = new Zt(), this._geomGraph = null, this._nodeGraph = new vr(), this._invalidPoint = null;
        var t = arguments[0];
        this._geomGraph = t;
      }
    }]);

    return Mr;
  }();

  var br = /*#__PURE__*/function () {
    function br() {
      _classCallCheck(this, br);

      br.constructor_.apply(this, arguments);
    }

    _createClass(br, [{
      key: "buildIndex",
      value: function buildIndex() {
        this._index = new Os();

        for (var _t707 = 0; _t707 < this._rings.size(); _t707++) {
          var _e557 = this._rings.get(_t707),
              _n421 = _e557.getEnvelopeInternal();

          this._index.insert(_n421, _e557);
        }
      }
    }, {
      key: "getNestedPoint",
      value: function getNestedPoint() {
        return this._nestedPt;
      }
    }, {
      key: "isNonNested",
      value: function isNonNested() {
        this.buildIndex();

        for (var _t708 = 0; _t708 < this._rings.size(); _t708++) {
          var _e558 = this._rings.get(_t708),
              _n422 = _e558.getCoordinates(),
              _s250 = this._index.query(_e558.getEnvelopeInternal());

          for (var _t709 = 0; _t709 < _s250.size(); _t709++) {
            var _i138 = _s250.get(_t709),
                _r70 = _i138.getCoordinates();

            if (_e558 === _i138) continue;
            if (!_e558.getEnvelopeInternal().intersects(_i138.getEnvelopeInternal())) continue;

            var _o40 = Ar.findPtNotNode(_n422, _i138, this._graph);

            if (null === _o40) continue;
            if (ke.isInRing(_o40, _r70)) return this._nestedPt = _o40, !1;
          }
        }

        return !0;
      }
    }, {
      key: "add",
      value: function add(t) {
        this._rings.add(t), this._totalEnv.expandToInclude(t.getEnvelopeInternal());
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._graph = null, this._rings = new S(), this._totalEnv = new T(), this._index = null, this._nestedPt = null;
        var t = arguments[0];
        this._graph = t;
      }
    }]);

    return br;
  }();

  var Dr = /*#__PURE__*/function () {
    function Dr() {
      _classCallCheck(this, Dr);

      Dr.constructor_.apply(this, arguments);
    }

    _createClass(Dr, [{
      key: "getErrorType",
      value: function getErrorType() {
        return this._errorType;
      }
    }, {
      key: "getMessage",
      value: function getMessage() {
        return Dr.errMsg[this._errorType];
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        return this._pt;
      }
    }, {
      key: "toString",
      value: function toString() {
        var t = "";
        return null !== this._pt && (t = " at or near point " + this._pt), this.getMessage() + t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._errorType = null, this._pt = null, 1 === arguments.length) {
          var _t710 = arguments[0];
          Dr.constructor_.call(this, _t710, null);
        } else if (2 === arguments.length) {
          var _t711 = arguments[0],
              _e559 = arguments[1];
          this._errorType = _t711, null !== _e559 && (this._pt = _e559.copy());
        }
      }
    }]);

    return Dr;
  }();

  Dr.ERROR = 0, Dr.REPEATED_POINT = 1, Dr.HOLE_OUTSIDE_SHELL = 2, Dr.NESTED_HOLES = 3, Dr.DISCONNECTED_INTERIOR = 4, Dr.SELF_INTERSECTION = 5, Dr.RING_SELF_INTERSECTION = 6, Dr.NESTED_SHELLS = 7, Dr.DUPLICATE_RINGS = 8, Dr.TOO_FEW_POINTS = 9, Dr.INVALID_COORDINATE = 10, Dr.RING_NOT_CLOSED = 11, Dr.errMsg = ["Topology Validation Error", "Repeated Point", "Hole lies outside shell", "Holes are nested", "Interior is disconnected", "Self-intersection", "Ring Self-intersection", "Nested shells", "Duplicate Rings", "Too few distinct points in geometry component", "Invalid Coordinate", "Ring is not closed"];

  var Ar = /*#__PURE__*/function () {
    function Ar() {
      _classCallCheck(this, Ar);

      Ar.constructor_.apply(this, arguments);
    }

    _createClass(Ar, [{
      key: "checkInvalidCoordinates",
      value: function checkInvalidCoordinates() {
        if (arguments[0] instanceof Array) {
          var _t712 = arguments[0];

          for (var _e560 = 0; _e560 < _t712.length; _e560++) {
            if (!Ar.isValid(_t712[_e560])) return this._validErr = new Dr(Dr.INVALID_COORDINATE, _t712[_e560]), null;
          }
        } else if (arguments[0] instanceof et) {
          var _t713 = arguments[0];
          if (this.checkInvalidCoordinates(_t713.getExteriorRing().getCoordinates()), null !== this._validErr) return null;

          for (var _e561 = 0; _e561 < _t713.getNumInteriorRing(); _e561++) {
            if (this.checkInvalidCoordinates(_t713.getInteriorRingN(_e561).getCoordinates()), null !== this._validErr) return null;
          }
        }
      }
    }, {
      key: "checkHolesNotNested",
      value: function checkHolesNotNested(t, e) {
        if (t.getNumInteriorRing() <= 0) return null;
        var n = new br(e);

        for (var _e562 = 0; _e562 < t.getNumInteriorRing(); _e562++) {
          var _s251 = t.getInteriorRingN(_e562);

          _s251.isEmpty() || n.add(_s251);
        }

        n.isNonNested() || (this._validErr = new Dr(Dr.NESTED_HOLES, n.getNestedPoint()));
      }
    }, {
      key: "checkConsistentArea",
      value: function checkConsistentArea(t) {
        var e = new Mr(t);
        if (!e.isNodeConsistentArea()) return this._validErr = new Dr(Dr.SELF_INTERSECTION, e.getInvalidPoint()), null;
        e.hasDuplicateRings() && (this._validErr = new Dr(Dr.DUPLICATE_RINGS, e.getInvalidPoint()));
      }
    }, {
      key: "isValid",
      value: function isValid() {
        return this.checkValid(this._parentGeometry), null === this._validErr;
      }
    }, {
      key: "checkShellInsideHole",
      value: function checkShellInsideHole(t, e, n) {
        var s = t.getCoordinates(),
            i = e.getCoordinates(),
            r = Ar.findPtNotNode(s, e, n);

        if (null !== r) {
          if (!ke.isInRing(r, i)) return r;
        }

        var o = Ar.findPtNotNode(i, t, n);

        if (null !== o) {
          return ke.isInRing(o, s) ? o : null;
        }

        return g.shouldNeverReachHere("points in shell and hole appear to be equal"), null;
      }
    }, {
      key: "checkNoSelfIntersectingRings",
      value: function checkNoSelfIntersectingRings(t) {
        for (var _e563 = t.getEdgeIterator(); _e563.hasNext();) {
          var _t714 = _e563.next();

          if (this.checkNoSelfIntersectingRing(_t714.getEdgeIntersectionList()), null !== this._validErr) return null;
        }
      }
    }, {
      key: "checkConnectedInteriors",
      value: function checkConnectedInteriors(t) {
        var e = new Cr(t);
        e.isInteriorsConnected() || (this._validErr = new Dr(Dr.DISCONNECTED_INTERIOR, e.getCoordinate()));
      }
    }, {
      key: "checkNoSelfIntersectingRing",
      value: function checkNoSelfIntersectingRing(t) {
        var e = new it();
        var n = !0;

        for (var _s252 = t.iterator(); _s252.hasNext();) {
          var _t715 = _s252.next();

          if (n) n = !1;else {
            if (e.contains(_t715.coord)) return this._validErr = new Dr(Dr.RING_SELF_INTERSECTION, _t715.coord), null;
            e.add(_t715.coord);
          }
        }
      }
    }, {
      key: "checkHolesInShell",
      value: function checkHolesInShell(t, e) {
        if (t.getNumInteriorRing() <= 0) return null;
        var n = t.getExteriorRing(),
            s = n.isEmpty(),
            i = new Ve(n);

        for (var _r71 = 0; _r71 < t.getNumInteriorRing(); _r71++) {
          var _o41 = t.getInteriorRingN(_r71);

          var _l33 = null;
          if (_o41.isEmpty()) continue;
          if (_l33 = Ar.findPtNotNode(_o41.getCoordinates(), n, e), null === _l33) return null;
          if (s || Kt.EXTERIOR === i.locate(_l33)) return this._validErr = new Dr(Dr.HOLE_OUTSIDE_SHELL, _l33), null;
        }
      }
    }, {
      key: "checkTooFewPoints",
      value: function checkTooFewPoints(t) {
        if (t.hasTooFewPoints()) return this._validErr = new Dr(Dr.TOO_FEW_POINTS, t.getInvalidPoint()), null;
      }
    }, {
      key: "getValidationError",
      value: function getValidationError() {
        return this.checkValid(this._parentGeometry), this._validErr;
      }
    }, {
      key: "checkValid",
      value: function checkValid() {
        if (arguments[0] instanceof Q) {
          var _t716 = arguments[0];
          this.checkInvalidCoordinates(_t716.getCoordinates());
        } else if (arguments[0] instanceof lt) {
          var _t717 = arguments[0];
          this.checkInvalidCoordinates(_t717.getCoordinates());
        } else if (arguments[0] instanceof at) {
          var _t718 = arguments[0];
          if (this.checkInvalidCoordinates(_t718.getCoordinates()), null !== this._validErr) return null;
          if (this.checkClosedRing(_t718), null !== this._validErr) return null;

          var _e564 = new os(0, _t718);

          if (this.checkTooFewPoints(_e564), null !== this._validErr) return null;

          var _n423 = new Zt();

          _e564.computeSelfNodes(_n423, !0, !0), this.checkNoSelfIntersectingRings(_e564);
        } else if (arguments[0] instanceof j) {
          var _t719 = arguments[0];
          if (this.checkInvalidCoordinates(_t719.getCoordinates()), null !== this._validErr) return null;

          var _e565 = new os(0, _t719);

          this.checkTooFewPoints(_e565);
        } else if (arguments[0] instanceof et) {
          var _t720 = arguments[0];
          if (this.checkInvalidCoordinates(_t720), null !== this._validErr) return null;
          if (this.checkClosedRings(_t720), null !== this._validErr) return null;

          var _e566 = new os(0, _t720);

          if (this.checkTooFewPoints(_e566), null !== this._validErr) return null;
          if (this.checkConsistentArea(_e566), null !== this._validErr) return null;
          if (!this._isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(_e566), null !== this._validErr)) return null;
          if (this.checkHolesInShell(_t720, _e566), null !== this._validErr) return null;
          if (this.checkHolesNotNested(_t720, _e566), null !== this._validErr) return null;
          this.checkConnectedInteriors(_e566);
        } else if (arguments[0] instanceof ft) {
          var _t721 = arguments[0];

          for (var _e568 = 0; _e568 < _t721.getNumGeometries(); _e568++) {
            var _n424 = _t721.getGeometryN(_e568);

            if (this.checkInvalidCoordinates(_n424), null !== this._validErr) return null;
            if (this.checkClosedRings(_n424), null !== this._validErr) return null;
          }

          var _e567 = new os(0, _t721);

          if (this.checkTooFewPoints(_e567), null !== this._validErr) return null;
          if (this.checkConsistentArea(_e567), null !== this._validErr) return null;
          if (!this._isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(_e567), null !== this._validErr)) return null;

          for (var _n425 = 0; _n425 < _t721.getNumGeometries(); _n425++) {
            var _s253 = _t721.getGeometryN(_n425);

            if (this.checkHolesInShell(_s253, _e567), null !== this._validErr) return null;
          }

          for (var _n426 = 0; _n426 < _t721.getNumGeometries(); _n426++) {
            var _s254 = _t721.getGeometryN(_n426);

            if (this.checkHolesNotNested(_s254, _e567), null !== this._validErr) return null;
          }

          if (this.checkShellsNotNested(_t721, _e567), null !== this._validErr) return null;
          this.checkConnectedInteriors(_e567);
        } else if (arguments[0] instanceof ot) {
          var _t722 = arguments[0];

          for (var _e569 = 0; _e569 < _t722.getNumGeometries(); _e569++) {
            var _n427 = _t722.getGeometryN(_e569);

            if (this.checkValid(_n427), null !== this._validErr) return null;
          }
        } else if (arguments[0] instanceof V) {
          var _t723 = arguments[0];
          if (this._validErr = null, _t723.isEmpty()) return null;
          if (_t723 instanceof Q) this.checkValid(_t723);else if (_t723 instanceof lt) this.checkValid(_t723);else if (_t723 instanceof at) this.checkValid(_t723);else if (_t723 instanceof j) this.checkValid(_t723);else if (_t723 instanceof et) this.checkValid(_t723);else if (_t723 instanceof ft) this.checkValid(_t723);else {
            if (!(_t723 instanceof ot)) throw new H(_t723.getGeometryType());
            this.checkValid(_t723);
          }
        }
      }
    }, {
      key: "setSelfTouchingRingFormingHoleValid",
      value: function setSelfTouchingRingFormingHoleValid(t) {
        this._isSelfTouchingRingFormingHoleValid = t;
      }
    }, {
      key: "checkShellNotNested",
      value: function checkShellNotNested(t, e, n) {
        var s = t.getCoordinates(),
            i = e.getExteriorRing();
        if (i.isEmpty()) return null;
        var r = i.getCoordinates(),
            o = Ar.findPtNotNode(s, i, n);
        if (null === o) return null;
        if (!ke.isInRing(o, r)) return null;
        if (e.getNumInteriorRing() <= 0) return this._validErr = new Dr(Dr.NESTED_SHELLS, o), null;
        var l = null;

        for (var _s255 = 0; _s255 < e.getNumInteriorRing(); _s255++) {
          var _i139 = e.getInteriorRingN(_s255);

          if (l = this.checkShellInsideHole(t, _i139, n), null === l) return null;
        }

        this._validErr = new Dr(Dr.NESTED_SHELLS, l);
      }
    }, {
      key: "checkClosedRings",
      value: function checkClosedRings(t) {
        if (this.checkClosedRing(t.getExteriorRing()), null !== this._validErr) return null;

        for (var _e570 = 0; _e570 < t.getNumInteriorRing(); _e570++) {
          if (this.checkClosedRing(t.getInteriorRingN(_e570)), null !== this._validErr) return null;
        }
      }
    }, {
      key: "checkClosedRing",
      value: function checkClosedRing(t) {
        if (t.isEmpty()) return null;

        if (!t.isClosed()) {
          var _e571 = null;
          t.getNumPoints() >= 1 && (_e571 = t.getCoordinateN(0)), this._validErr = new Dr(Dr.RING_NOT_CLOSED, _e571);
        }
      }
    }, {
      key: "checkShellsNotNested",
      value: function checkShellsNotNested(t, e) {
        for (var _n428 = 0; _n428 < t.getNumGeometries(); _n428++) {
          var _s256 = t.getGeometryN(_n428).getExteriorRing();

          for (var _i140 = 0; _i140 < t.getNumGeometries(); _i140++) {
            if (_n428 === _i140) continue;

            var _r72 = t.getGeometryN(_i140);

            if (this.checkShellNotNested(_s256, _r72, e), null !== this._validErr) return null;
          }
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._parentGeometry = null, this._isSelfTouchingRingFormingHoleValid = !1, this._validErr = null;
        var t = arguments[0];
        this._parentGeometry = t;
      }
    }, {
      key: "findPtNotNode",
      value: function findPtNotNode(t, e, n) {
        var s = n.findEdge(e).getEdgeIntersectionList();

        for (var _e572 = 0; _e572 < t.length; _e572++) {
          var _n429 = t[_e572];
          if (!s.isIntersection(_n429)) return _n429;
        }

        return null;
      }
    }, {
      key: "isValid",
      value: function isValid() {
        if (arguments[0] instanceof V) {
          return new Ar(arguments[0]).isValid();
        }

        if (arguments[0] instanceof m) {
          var _t724 = arguments[0];
          return !r.isNaN(_t724.x) && !r.isInfinite(_t724.x) && !r.isNaN(_t724.y) && !r.isInfinite(_t724.y);
        }
      }
    }]);

    return Ar;
  }();

  var Fr = /*#__PURE__*/function () {
    function Fr() {
      _classCallCheck(this, Fr);

      Fr.constructor_.apply(this, arguments);
    }

    _createClass(Fr, [{
      key: "isIncluded",
      value: function isIncluded() {
        return this._isIncluded;
      }
    }, {
      key: "getCoordinates",
      value: function getCoordinates() {
        if (null === this._ringPts) {
          var _t725 = new C();

          for (var _e573 = this._deList.iterator(); _e573.hasNext();) {
            var _n430 = _e573.next(),
                _s257 = _n430.getEdge();

            Fr.addEdge(_s257.getLine().getCoordinates(), _n430.getEdgeDirection(), _t725);
          }

          this._ringPts = _t725.toCoordinateArray();
        }

        return this._ringPts;
      }
    }, {
      key: "isIncludedSet",
      value: function isIncludedSet() {
        return this._isIncludedSet;
      }
    }, {
      key: "isValid",
      value: function isValid() {
        return this.getCoordinates(), !(this._ringPts.length <= 3) && (this.getRing(), Ar.isValid(this._ring));
      }
    }, {
      key: "build",
      value: function build(t) {
        var e = t;

        do {
          this.add(e), e.setRing(this), e = e.getNext(), g.isTrue(null !== e, "found null DE in ring"), g.isTrue(e === t || !e.isInRing(), "found DE already in ring");
        } while (e !== t);
      }
    }, {
      key: "isInRing",
      value: function isInRing(t) {
        return Kt.EXTERIOR !== this.getLocator().locate(t);
      }
    }, {
      key: "isOuterHole",
      value: function isOuterHole() {
        return !!this._isHole && !this.hasShell();
      }
    }, {
      key: "getPolygon",
      value: function getPolygon() {
        var t = null;

        if (null !== this._holes) {
          t = new Array(this._holes.size()).fill(null);

          for (var _e574 = 0; _e574 < this._holes.size(); _e574++) {
            t[_e574] = this._holes.get(_e574);
          }
        }

        return this._factory.createPolygon(this._ring, t);
      }
    }, {
      key: "isHole",
      value: function isHole() {
        return this._isHole;
      }
    }, {
      key: "isProcessed",
      value: function isProcessed() {
        return this._isProcessed;
      }
    }, {
      key: "addHole",
      value: function addHole() {
        if (arguments[0] instanceof at) {
          var _t726 = arguments[0];
          null === this._holes && (this._holes = new S()), this._holes.add(_t726);
        } else if (arguments[0] instanceof Fr) {
          var _t727 = arguments[0];

          _t727.setShell(this);

          var _e575 = _t727.getRing();

          null === this._holes && (this._holes = new S()), this._holes.add(_e575);
        }
      }
    }, {
      key: "setIncluded",
      value: function setIncluded(t) {
        this._isIncluded = t, this._isIncludedSet = !0;
      }
    }, {
      key: "getOuterHole",
      value: function getOuterHole() {
        if (this.isHole()) return null;

        for (var _t728 = 0; _t728 < this._deList.size(); _t728++) {
          var _e576 = this._deList.get(_t728).getSym().getRing();

          if (_e576.isOuterHole()) return _e576;
        }

        return null;
      }
    }, {
      key: "computeHole",
      value: function computeHole() {
        var t = this.getRing();
        this._isHole = D.isCCW(t.getCoordinates());
      }
    }, {
      key: "hasShell",
      value: function hasShell() {
        return null !== this._shell;
      }
    }, {
      key: "isOuterShell",
      value: function isOuterShell() {
        return null !== this.getOuterHole();
      }
    }, {
      key: "getLineString",
      value: function getLineString() {
        return this.getCoordinates(), this._factory.createLineString(this._ringPts);
      }
    }, {
      key: "toString",
      value: function toString() {
        return Ht.toLineString(new pt(this.getCoordinates()));
      }
    }, {
      key: "getLocator",
      value: function getLocator() {
        return null === this._locator && (this._locator = new Ve(this.getRing())), this._locator;
      }
    }, {
      key: "getShell",
      value: function getShell() {
        return this.isHole() ? this._shell : this;
      }
    }, {
      key: "add",
      value: function add(t) {
        this._deList.add(t);
      }
    }, {
      key: "getRing",
      value: function getRing() {
        if (null !== this._ring) return this._ring;
        this.getCoordinates(), this._ringPts.length < 3 && F.out.println(this._ringPts);

        try {
          this._ring = this._factory.createLinearRing(this._ringPts);
        } catch (t) {
          if (!(t instanceof n)) throw t;
          F.out.println(this._ringPts);
        }

        return this._ring;
      }
    }, {
      key: "updateIncluded",
      value: function updateIncluded() {
        if (this.isHole()) return null;

        for (var _t729 = 0; _t729 < this._deList.size(); _t729++) {
          var _e577 = this._deList.get(_t729).getSym().getRing().getShell();

          if (null !== _e577 && _e577.isIncludedSet()) return this.setIncluded(!_e577.isIncluded()), null;
        }
      }
    }, {
      key: "setShell",
      value: function setShell(t) {
        this._shell = t;
      }
    }, {
      key: "setProcessed",
      value: function setProcessed(t) {
        this._isProcessed = t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._factory = null, this._deList = new S(), this._lowestEdge = null, this._ring = null, this._locator = null, this._ringPts = null, this._holes = null, this._shell = null, this._isHole = null, this._isProcessed = !1, this._isIncludedSet = !1, this._isIncluded = !1;
        var t = arguments[0];
        this._factory = t;
      }
    }, {
      key: "findDirEdgesInRing",
      value: function findDirEdgesInRing(t) {
        var e = t;
        var n = new S();

        do {
          n.add(e), e = e.getNext(), g.isTrue(null !== e, "found null DE in ring"), g.isTrue(e === t || !e.isInRing(), "found DE already in ring");
        } while (e !== t);

        return n;
      }
    }, {
      key: "addEdge",
      value: function addEdge(t, e, n) {
        if (e) for (var _e578 = 0; _e578 < t.length; _e578++) {
          n.add(t[_e578], !1);
        } else for (var _e579 = t.length - 1; _e579 >= 0; _e579--) {
          n.add(t[_e579], !1);
        }
      }
    }, {
      key: "findEdgeRingContaining",
      value: function findEdgeRingContaining(t, e) {
        var n = t.getRing(),
            s = n.getEnvelopeInternal();
        var i = n.getCoordinateN(0),
            r = null,
            o = null;

        for (var _t730 = e.iterator(); _t730.hasNext();) {
          var _e580 = _t730.next(),
              _l34 = _e580.getRing().getEnvelopeInternal();

          if (_l34.equals(s)) continue;
          if (!_l34.contains(s)) continue;
          i = dt.ptNotInList(n.getCoordinates(), _e580.getCoordinates());
          _e580.isInRing(i) && (null === r || o.contains(_l34)) && (r = _e580, o = r.getRing().getEnvelopeInternal());
        }

        return r;
      }
    }]);

    return Fr;
  }();

  Fr.EnvelopeComparator = /*#__PURE__*/function () {
    function _class16() {
      _classCallCheck(this, _class16);
    }

    _createClass(_class16, [{
      key: "compare",
      value: function compare(t, e) {
        var n = e;
        return t.getRing().getEnvelope().compareTo(n.getRing().getEnvelope());
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [a];
      }
    }]);

    return _class16;
  }();

  var Gr = /*#__PURE__*/function (_Qi2) {
    _inherits(Gr, _Qi2);

    var _super71 = _createSuper(Gr);

    function Gr() {
      var _this54;

      _classCallCheck(this, Gr);

      _this54 = _super71.call(this), Gr.constructor_.apply(_assertThisInitialized(_this54), arguments);
      return _this54;
    }

    _createClass(Gr, [{
      key: "findEdgeRing",
      value: function findEdgeRing(t) {
        var e = new Fr(this._factory);
        return e.build(t), e;
      }
    }, {
      key: "computeDepthParity",
      value: function computeDepthParity() {
        if (0 === arguments.length) for (;;) {
          return null;
        }
      }
    }, {
      key: "computeNextCWEdges",
      value: function computeNextCWEdges() {
        for (var _t731 = this.nodeIterator(); _t731.hasNext();) {
          var _e581 = _t731.next();

          Gr.computeNextCWEdges(_e581);
        }
      }
    }, {
      key: "addEdge",
      value: function addEdge(t) {
        if (t.isEmpty()) return null;
        var e = dt.removeRepeatedPoints(t.getCoordinates());
        if (e.length < 2) return null;
        var n = e[0],
            s = e[e.length - 1],
            i = this.getNode(n),
            r = this.getNode(s),
            o = new Sr(i, r, e[1], !0),
            l = new Sr(r, i, e[e.length - 2], !1),
            a = new wr(t);
        a.setDirectedEdges(o, l), this.add(a);
      }
    }, {
      key: "deleteCutEdges",
      value: function deleteCutEdges() {
        this.computeNextCWEdges(), Gr.findLabeledEdgeRings(this._dirEdges);
        var t = new S();

        for (var _e582 = this._dirEdges.iterator(); _e582.hasNext();) {
          var _n431 = _e582.next();

          if (_n431.isMarked()) continue;

          var _s258 = _n431.getSym();

          if (_n431.getLabel() === _s258.getLabel()) {
            _n431.setMarked(!0), _s258.setMarked(!0);

            var _e583 = _n431.getEdge();

            t.add(_e583.getLine());
          }
        }

        return t;
      }
    }, {
      key: "getEdgeRings",
      value: function getEdgeRings() {
        this.computeNextCWEdges(), Gr.label(this._dirEdges, -1);
        var t = Gr.findLabeledEdgeRings(this._dirEdges);
        this.convertMaximalToMinimalEdgeRings(t);
        var e = new S();

        for (var _t732 = this._dirEdges.iterator(); _t732.hasNext();) {
          var _n432 = _t732.next();

          if (_n432.isMarked()) continue;
          if (_n432.isInRing()) continue;

          var _s259 = this.findEdgeRing(_n432);

          e.add(_s259);
        }

        return e;
      }
    }, {
      key: "getNode",
      value: function getNode(t) {
        var e = this.findNode(t);
        return null === e && (e = new Zi(t), this.add(e)), e;
      }
    }, {
      key: "convertMaximalToMinimalEdgeRings",
      value: function convertMaximalToMinimalEdgeRings(t) {
        for (var _e584 = t.iterator(); _e584.hasNext();) {
          var _t733 = _e584.next(),
              _n433 = _t733.getLabel(),
              _s260 = Gr.findIntersectionNodes(_t733, _n433);

          if (null !== _s260) for (var _t734 = _s260.iterator(); _t734.hasNext();) {
            var _e585 = _t734.next();

            Gr.computeNextCCWEdges(_e585, _n433);
          }
        }
      }
    }, {
      key: "deleteDangles",
      value: function deleteDangles() {
        var t = this.findNodesOfDegree(1),
            e = new xt(),
            n = new tn();

        for (var _e586 = t.iterator(); _e586.hasNext();) {
          n.push(_e586.next());
        }

        for (; !n.isEmpty();) {
          var _t735 = n.pop();

          Gr.deleteAllEdges(_t735);

          for (var _s261 = _t735.getOutEdges().getEdges().iterator(); _s261.hasNext();) {
            var _t736 = _s261.next();

            _t736.setMarked(!0);

            var _i141 = _t736.getSym();

            null !== _i141 && _i141.setMarked(!0);

            var _r73 = _t736.getEdge();

            e.add(_r73.getLine());

            var _o42 = _t736.getToNode();

            1 === Gr.getDegreeNonDeleted(_o42) && n.push(_o42);
          }
        }

        return e;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._factory = null;
        var t = arguments[0];
        this._factory = t;
      }
    }, {
      key: "findLabeledEdgeRings",
      value: function findLabeledEdgeRings(t) {
        var e = new S();
        var n = 1;

        for (var _s262 = t.iterator(); _s262.hasNext();) {
          var _t737 = _s262.next();

          if (_t737.isMarked()) continue;
          if (_t737.getLabel() >= 0) continue;
          e.add(_t737);

          var _i142 = Fr.findDirEdgesInRing(_t737);

          Gr.label(_i142, n), n++;
        }

        return e;
      }
    }, {
      key: "getDegreeNonDeleted",
      value: function getDegreeNonDeleted(t) {
        var e = 0;

        for (var _n434 = t.getOutEdges().getEdges().iterator(); _n434.hasNext();) {
          _n434.next().isMarked() || e++;
        }

        return e;
      }
    }, {
      key: "deleteAllEdges",
      value: function deleteAllEdges(t) {
        for (var _e587 = t.getOutEdges().getEdges().iterator(); _e587.hasNext();) {
          var _t738 = _e587.next();

          _t738.setMarked(!0);

          var _n435 = _t738.getSym();

          null !== _n435 && _n435.setMarked(!0);
        }
      }
    }, {
      key: "label",
      value: function label(t, e) {
        for (var _n436 = t.iterator(); _n436.hasNext();) {
          _n436.next().setLabel(e);
        }
      }
    }, {
      key: "computeNextCWEdges",
      value: function computeNextCWEdges(t) {
        var e = null,
            n = null;

        for (var _s263 = t.getOutEdges().getEdges().iterator(); _s263.hasNext();) {
          var _t739 = _s263.next();

          if (!_t739.isMarked()) {
            if (null === e && (e = _t739), null !== n) {
              n.getSym().setNext(_t739);
            }

            n = _t739;
          }
        }

        if (null !== n) {
          n.getSym().setNext(e);
        }
      }
    }, {
      key: "computeNextCCWEdges",
      value: function computeNextCCWEdges(t, e) {
        var n = null,
            s = null;
        var i = t.getOutEdges().getEdges();

        for (var _t740 = i.size() - 1; _t740 >= 0; _t740--) {
          var _r74 = i.get(_t740),
              _o43 = _r74.getSym();

          var _l35 = null;
          _r74.getLabel() === e && (_l35 = _r74);
          var _a19 = null;
          _o43.getLabel() === e && (_a19 = _o43), null === _l35 && null === _a19 || (null !== _a19 && (s = _a19), null !== _l35 && (null !== s && (s.setNext(_l35), s = null), null === n && (n = _l35)));
        }

        null !== s && (g.isTrue(null !== n), s.setNext(n));
      }
    }, {
      key: "getDegree",
      value: function getDegree(t, e) {
        var n = 0;

        for (var _s264 = t.getOutEdges().getEdges().iterator(); _s264.hasNext();) {
          _s264.next().getLabel() === e && n++;
        }

        return n;
      }
    }, {
      key: "findIntersectionNodes",
      value: function findIntersectionNodes(t, e) {
        var n = t,
            s = null;

        do {
          var _i143 = n.getFromNode();

          Gr.getDegree(_i143, e) > 1 && (null === s && (s = new S()), s.add(_i143)), n = n.getNext(), g.isTrue(null !== n, "found null DE in ring"), g.isTrue(n === t || !n.isInRing(), "found DE already in ring");
        } while (n !== t);

        return s;
      }
    }]);

    return Gr;
  }(Qi);

  var qr = /*#__PURE__*/function () {
    function qr() {
      _classCallCheck(this, qr);

      qr.constructor_.apply(this, arguments);
    }

    _createClass(qr, [{
      key: "assignHolesToShells",
      value: function assignHolesToShells(t) {
        for (var _e588 = t.iterator(); _e588.hasNext();) {
          var _t741 = _e588.next();

          this.assignHoleToShell(_t741);
        }
      }
    }, {
      key: "buildIndex",
      value: function buildIndex() {
        this._shellIndex = new Os();

        var _iterator10 = _createForOfIteratorHelper(this._shells),
            _step10;

        try {
          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
            var _t742 = _step10.value;

            this._shellIndex.insert(_t742.getRing().getEnvelopeInternal(), _t742);
          }
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }
      }
    }, {
      key: "queryOverlappingShells",
      value: function queryOverlappingShells(t) {
        return this._shellIndex.query(t);
      }
    }, {
      key: "findShellContaining",
      value: function findShellContaining(t) {
        var e = t.getRing().getEnvelopeInternal(),
            n = this.queryOverlappingShells(e);
        return Fr.findEdgeRingContaining(t, n);
      }
    }, {
      key: "assignHoleToShell",
      value: function assignHoleToShell(t) {
        var e = this.findShellContaining(t);
        null !== e && e.addHole(t);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._shells = null, this._shellIndex = null;
        var t = arguments[0];
        this._shells = t, this.buildIndex();
      }
    }, {
      key: "assignHolesToShells",
      value: function assignHolesToShells(t, e) {
        new qr(e).assignHolesToShells(t);
      }
    }]);

    return qr;
  }();

  var Br = /*#__PURE__*/function () {
    function Br() {
      _classCallCheck(this, Br);

      Br.constructor_.apply(this, arguments);
    }

    _createClass(Br, [{
      key: "getGeometry",
      value: function getGeometry() {
        return null === this._geomFactory && (this._geomFactory = new Ct()), this.polygonize(), this._extractOnlyPolygonal ? this._geomFactory.buildGeometry(this._polyList) : this._geomFactory.createGeometryCollection(Ct.toGeometryArray(this._polyList));
      }
    }, {
      key: "getInvalidRingLines",
      value: function getInvalidRingLines() {
        return this.polygonize(), this._invalidRingLines;
      }
    }, {
      key: "findValidRings",
      value: function findValidRings(t, e, n) {
        for (var _s265 = t.iterator(); _s265.hasNext();) {
          var _t743 = _s265.next();

          _t743.isValid() ? e.add(_t743) : n.add(_t743.getLineString());
        }
      }
    }, {
      key: "polygonize",
      value: function polygonize() {
        if (null !== this._polyList) return null;
        if (this._polyList = new S(), null === this._graph) return null;
        this._dangles = this._graph.deleteDangles(), this._cutEdges = this._graph.deleteCutEdges();

        var t = this._graph.getEdgeRings();

        var e = new S();
        this._invalidRingLines = new S(), this._isCheckingRingsValid ? this.findValidRings(t, e, this._invalidRingLines) : e = t, this.findShellsAndHoles(e), qr.assignHolesToShells(this._holeList, this._shellList), ye.sort(this._shellList, new Fr.EnvelopeComparator());
        var n = !0;
        this._extractOnlyPolygonal && (Br.findDisjointShells(this._shellList), n = !1), this._polyList = Br.extractPolygons(this._shellList, n);
      }
    }, {
      key: "getDangles",
      value: function getDangles() {
        return this.polygonize(), this._dangles;
      }
    }, {
      key: "getCutEdges",
      value: function getCutEdges() {
        return this.polygonize(), this._cutEdges;
      }
    }, {
      key: "getPolygons",
      value: function getPolygons() {
        return this.polygonize(), this._polyList;
      }
    }, {
      key: "add",
      value: function add() {
        if (y(arguments[0], x)) {
          for (var _t744 = arguments[0].iterator(); _t744.hasNext();) {
            var _e589 = _t744.next();

            this.add(_e589);
          }
        } else if (arguments[0] instanceof j) {
          var _t745 = arguments[0];
          this._geomFactory = _t745.getFactory(), null === this._graph && (this._graph = new Gr(this._geomFactory)), this._graph.addEdge(_t745);
        } else if (arguments[0] instanceof V) {
          arguments[0].apply(this._lineStringAdder);
        }
      }
    }, {
      key: "setCheckRingsValid",
      value: function setCheckRingsValid(t) {
        this._isCheckingRingsValid = t;
      }
    }, {
      key: "findShellsAndHoles",
      value: function findShellsAndHoles(t) {
        this._holeList = new S(), this._shellList = new S();

        for (var _e590 = t.iterator(); _e590.hasNext();) {
          var _t746 = _e590.next();

          _t746.computeHole(), _t746.isHole() ? this._holeList.add(_t746) : this._shellList.add(_t746);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._lineStringAdder = new Yr(this), this._graph = null, this._dangles = new S(), this._cutEdges = new S(), this._invalidRingLines = new S(), this._holeList = null, this._shellList = null, this._polyList = null, this._isCheckingRingsValid = !0, this._extractOnlyPolygonal = null, this._geomFactory = null, 0 === arguments.length) Br.constructor_.call(this, !1);else if (1 === arguments.length) {
          var _t747 = arguments[0];
          this._extractOnlyPolygonal = _t747;
        }
      }
    }, {
      key: "extractPolygons",
      value: function extractPolygons(t, e) {
        var n = new S();

        for (var _s266 = t.iterator(); _s266.hasNext();) {
          var _t748 = _s266.next();

          (e || _t748.isIncluded()) && n.add(_t748.getPolygon());
        }

        return n;
      }
    }, {
      key: "findOuterShells",
      value: function findOuterShells(t) {
        for (var _e591 = t.iterator(); _e591.hasNext();) {
          var _t749 = _e591.next(),
              _n437 = _t749.getOuterHole();

          null === _n437 || _n437.isProcessed() || (_t749.setIncluded(!0), _n437.setProcessed(!0));
        }
      }
    }, {
      key: "findDisjointShells",
      value: function findDisjointShells(t) {
        Br.findOuterShells(t);
        var e = null;

        do {
          e = !1;

          for (var _n438 = t.iterator(); _n438.hasNext();) {
            var _t750 = _n438.next();

            _t750.isIncludedSet() || (_t750.updateIncluded(), _t750.isIncludedSet() || (e = !0));
          }
        } while (e);
      }
    }]);

    return Br;
  }();

  var Yr = /*#__PURE__*/function () {
    function Yr() {
      _classCallCheck(this, Yr);

      Yr.constructor_.apply(this, arguments);
    }

    _createClass(Yr, [{
      key: "filter",
      value: function filter(t) {
        t instanceof j && this.p.add(t);
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Y];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this.p = null;
        var t = arguments[0];
        this.p = t;
      }
    }]);

    return Yr;
  }();

  Br.LineStringAdder = Yr;
  var Vr = Object.freeze({
    __proto__: null,
    Polygonizer: Br
  });

  var zr = /*#__PURE__*/function () {
    function zr() {
      _classCallCheck(this, zr);

      zr.constructor_.apply(this, arguments);
    }

    _createClass(zr, [{
      key: "insertEdgeEnds",
      value: function insertEdgeEnds(t) {
        for (var _e592 = t.iterator(); _e592.hasNext();) {
          var _t751 = _e592.next();

          this._nodes.add(_t751);
        }
      }
    }, {
      key: "computeProperIntersectionIM",
      value: function computeProperIntersectionIM(t, e) {
        var n = this._arg[0].getGeometry().getDimension(),
            s = this._arg[1].getGeometry().getDimension(),
            i = t.hasProperIntersection(),
            r = t.hasProperInteriorIntersection();

        2 === n && 2 === s ? i && e.setAtLeast("212101212") : 2 === n && 1 === s ? (i && e.setAtLeast("FFF0FFFF2"), r && e.setAtLeast("1FFFFF1FF")) : 1 === n && 2 === s ? (i && e.setAtLeast("F0FFFFFF2"), r && e.setAtLeast("1F1FFFFFF")) : 1 === n && 1 === s && r && e.setAtLeast("0FFFFFFFF");
      }
    }, {
      key: "labelIsolatedEdges",
      value: function labelIsolatedEdges(t, e) {
        for (var _n439 = this._arg[t].getEdgeIterator(); _n439.hasNext();) {
          var _t752 = _n439.next();

          _t752.isIsolated() && (this.labelIsolatedEdge(_t752, e, this._arg[e].getGeometry()), this._isolatedEdges.add(_t752));
        }
      }
    }, {
      key: "labelIsolatedEdge",
      value: function labelIsolatedEdge(t, e, n) {
        if (n.getDimension() > 0) {
          var _s267 = this._ptLocator.locate(t.getCoordinate(), n);

          t.getLabel().setAllLocations(e, _s267);
        } else t.getLabel().setAllLocations(e, Kt.EXTERIOR);
      }
    }, {
      key: "computeIM",
      value: function computeIM() {
        var t = new Qt();
        if (t.set(Kt.EXTERIOR, Kt.EXTERIOR, 2), !this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal())) return this.computeDisjointIM(t), t;
        this._arg[0].computeSelfNodes(this._li, !1), this._arg[1].computeSelfNodes(this._li, !1);

        var e = this._arg[0].computeEdgeIntersections(this._arg[1], this._li, !1);

        this.computeIntersectionNodes(0), this.computeIntersectionNodes(1), this.copyNodesAndLabels(0), this.copyNodesAndLabels(1), this.labelIsolatedNodes(), this.computeProperIntersectionIM(e, t);
        var n = new Lr(),
            s = n.computeEdgeEnds(this._arg[0].getEdgeIterator());
        this.insertEdgeEnds(s);
        var i = n.computeEdgeEnds(this._arg[1].getEdgeIterator());
        return this.insertEdgeEnds(i), this.labelNodeEdges(), this.labelIsolatedEdges(0, 1), this.labelIsolatedEdges(1, 0), this.updateIM(t), t;
      }
    }, {
      key: "labelNodeEdges",
      value: function labelNodeEdges() {
        for (var _t753 = this._nodes.iterator(); _t753.hasNext();) {
          _t753.next().getEdges().computeLabelling(this._arg);
        }
      }
    }, {
      key: "copyNodesAndLabels",
      value: function copyNodesAndLabels(t) {
        for (var _e593 = this._arg[t].getNodeIterator(); _e593.hasNext();) {
          var _n440 = _e593.next();

          this._nodes.addNode(_n440.getCoordinate()).setLabel(t, _n440.getLabel().getLocation(t));
        }
      }
    }, {
      key: "labelIntersectionNodes",
      value: function labelIntersectionNodes(t) {
        for (var _e594 = this._arg[t].getEdgeIterator(); _e594.hasNext();) {
          var _n441 = _e594.next(),
              _s268 = _n441.getLabel().getLocation(t);

          for (var _e595 = _n441.getEdgeIntersectionList().iterator(); _e595.hasNext();) {
            var _n442 = _e595.next(),
                _i144 = this._nodes.find(_n442.coord);

            _i144.getLabel().isNull(t) && (_s268 === Kt.BOUNDARY ? _i144.setLabelBoundary(t) : _i144.setLabel(t, Kt.INTERIOR));
          }
        }
      }
    }, {
      key: "labelIsolatedNode",
      value: function labelIsolatedNode(t, e) {
        var n = this._ptLocator.locate(t.getCoordinate(), this._arg[e].getGeometry());

        t.getLabel().setAllLocations(e, n);
      }
    }, {
      key: "computeIntersectionNodes",
      value: function computeIntersectionNodes(t) {
        for (var _e596 = this._arg[t].getEdgeIterator(); _e596.hasNext();) {
          var _n443 = _e596.next(),
              _s269 = _n443.getLabel().getLocation(t);

          for (var _e597 = _n443.getEdgeIntersectionList().iterator(); _e597.hasNext();) {
            var _n444 = _e597.next(),
                _i145 = this._nodes.addNode(_n444.coord);

            _s269 === Kt.BOUNDARY ? _i145.setLabelBoundary(t) : _i145.getLabel().isNull(t) && _i145.setLabel(t, Kt.INTERIOR);
          }
        }
      }
    }, {
      key: "labelIsolatedNodes",
      value: function labelIsolatedNodes() {
        for (var _t754 = this._nodes.iterator(); _t754.hasNext();) {
          var _e598 = _t754.next(),
              _n445 = _e598.getLabel();

          g.isTrue(_n445.getGeometryCount() > 0, "node with empty label found"), _e598.isIsolated() && (_n445.isNull(0) ? this.labelIsolatedNode(_e598, 0) : this.labelIsolatedNode(_e598, 1));
        }
      }
    }, {
      key: "updateIM",
      value: function updateIM(t) {
        for (var _e599 = this._isolatedEdges.iterator(); _e599.hasNext();) {
          _e599.next().updateIM(t);
        }

        for (var _e600 = this._nodes.iterator(); _e600.hasNext();) {
          var _n446 = _e600.next();

          _n446.updateIM(t), _n446.updateIMFromEdges(t);
        }
      }
    }, {
      key: "computeDisjointIM",
      value: function computeDisjointIM(t) {
        var e = this._arg[0].getGeometry();

        e.isEmpty() || (t.set(Kt.INTERIOR, Kt.EXTERIOR, e.getDimension()), t.set(Kt.BOUNDARY, Kt.EXTERIOR, e.getBoundaryDimension()));

        var n = this._arg[1].getGeometry();

        n.isEmpty() || (t.set(Kt.EXTERIOR, Kt.INTERIOR, n.getDimension()), t.set(Kt.EXTERIOR, Kt.BOUNDARY, n.getBoundaryDimension()));
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._li = new Zt(), this._ptLocator = new mn(), this._arg = null, this._nodes = new ts(new Or()), this._im = null, this._isolatedEdges = new S(), this._invalidPoint = null;
        var t = arguments[0];
        this._arg = t;
      }
    }]);

    return zr;
  }();

  var Xr = /*#__PURE__*/function () {
    function Xr() {
      _classCallCheck(this, Xr);

      Xr.constructor_.apply(this, arguments);
    }

    _createClass(Xr, [{
      key: "isContainedInBoundary",
      value: function isContainedInBoundary(t) {
        if (t instanceof et) return !1;
        if (t instanceof Q) return this.isPointContainedInBoundary(t);
        if (t instanceof j) return this.isLineStringContainedInBoundary(t);

        for (var _e601 = 0; _e601 < t.getNumGeometries(); _e601++) {
          var _n447 = t.getGeometryN(_e601);

          if (!this.isContainedInBoundary(_n447)) return !1;
        }

        return !0;
      }
    }, {
      key: "isLineSegmentContainedInBoundary",
      value: function isLineSegmentContainedInBoundary(t, e) {
        if (t.equals(e)) return this.isPointContainedInBoundary(t);

        if (t.x === e.x) {
          if (t.x === this._rectEnv.getMinX() || t.x === this._rectEnv.getMaxX()) return !0;
        } else if (t.y === e.y && (t.y === this._rectEnv.getMinY() || t.y === this._rectEnv.getMaxY())) return !0;

        return !1;
      }
    }, {
      key: "isLineStringContainedInBoundary",
      value: function isLineStringContainedInBoundary(t) {
        var e = t.getCoordinateSequence(),
            n = new m(),
            s = new m();

        for (var _t755 = 0; _t755 < e.size() - 1; _t755++) {
          if (e.getCoordinate(_t755, n), e.getCoordinate(_t755 + 1, s), !this.isLineSegmentContainedInBoundary(n, s)) return !1;
        }

        return !0;
      }
    }, {
      key: "isPointContainedInBoundary",
      value: function isPointContainedInBoundary() {
        if (arguments[0] instanceof Q) {
          var _t756 = arguments[0];
          return this.isPointContainedInBoundary(_t756.getCoordinate());
        }

        if (arguments[0] instanceof m) {
          var _t757 = arguments[0];
          return _t757.x === this._rectEnv.getMinX() || _t757.x === this._rectEnv.getMaxX() || _t757.y === this._rectEnv.getMinY() || _t757.y === this._rectEnv.getMaxY();
        }
      }
    }, {
      key: "contains",
      value: function contains(t) {
        return !!this._rectEnv.contains(t.getEnvelopeInternal()) && !this.isContainedInBoundary(t);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._rectEnv = null;
        var t = arguments[0];
        this._rectEnv = t.getEnvelopeInternal();
      }
    }, {
      key: "contains",
      value: function contains(t, e) {
        return new Xr(t).contains(e);
      }
    }]);

    return Xr;
  }();

  var kr = /*#__PURE__*/function () {
    function kr() {
      _classCallCheck(this, kr);

      kr.constructor_.apply(this, arguments);
    }

    _createClass(kr, [{
      key: "intersects",
      value: function intersects(t, e) {
        var n = new T(t, e);
        if (!this._rectEnv.intersects(n)) return !1;
        if (this._rectEnv.intersects(t)) return !0;
        if (this._rectEnv.intersects(e)) return !0;

        if (t.compareTo(e) > 0) {
          var _n448 = t;
          t = e, e = _n448;
        }

        var s = !1;
        return e.y > t.y && (s = !0), s ? this._li.computeIntersection(t, e, this._diagDown0, this._diagDown1) : this._li.computeIntersection(t, e, this._diagUp0, this._diagUp1), !!this._li.hasIntersection();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._li = new Zt(), this._rectEnv = null, this._diagUp0 = null, this._diagUp1 = null, this._diagDown0 = null, this._diagDown1 = null;
        var t = arguments[0];
        this._rectEnv = t, this._diagUp0 = new m(t.getMinX(), t.getMinY()), this._diagUp1 = new m(t.getMaxX(), t.getMaxY()), this._diagDown0 = new m(t.getMinX(), t.getMaxY()), this._diagDown1 = new m(t.getMaxX(), t.getMinY());
      }
    }]);

    return kr;
  }();

  var Ur = /*#__PURE__*/function () {
    function Ur() {
      _classCallCheck(this, Ur);

      Ur.constructor_.apply(this, arguments);
    }

    _createClass(Ur, [{
      key: "intersects",
      value: function intersects(t) {
        if (!this._rectEnv.intersects(t.getEnvelopeInternal())) return !1;
        var e = new Hr(this._rectEnv);
        if (e.applyTo(t), e.intersects()) return !0;
        var n = new Wr(this._rectangle);
        if (n.applyTo(t), n.containsPoint()) return !0;
        var s = new Zr(this._rectangle);
        return s.applyTo(t), !!s.intersects();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._rectangle = null, this._rectEnv = null;
        var t = arguments[0];
        this._rectangle = t, this._rectEnv = t.getEnvelopeInternal();
      }
    }, {
      key: "intersects",
      value: function intersects(t, e) {
        return new Ur(t).intersects(e);
      }
    }]);

    return Ur;
  }();

  var Hr = /*#__PURE__*/function (_Ie) {
    _inherits(Hr, _Ie);

    var _super72 = _createSuper(Hr);

    function Hr() {
      var _this55;

      _classCallCheck(this, Hr);

      _this55 = _super72.call(this), Hr.constructor_.apply(_assertThisInitialized(_this55), arguments);
      return _this55;
    }

    _createClass(Hr, [{
      key: "isDone",
      value: function isDone() {
        return !0 === this._intersects;
      }
    }, {
      key: "visit",
      value: function visit(t) {
        var e = t.getEnvelopeInternal();
        return this._rectEnv.intersects(e) ? this._rectEnv.contains(e) || e.getMinX() >= this._rectEnv.getMinX() && e.getMaxX() <= this._rectEnv.getMaxX() || e.getMinY() >= this._rectEnv.getMinY() && e.getMaxY() <= this._rectEnv.getMaxY() ? (this._intersects = !0, null) : void 0 : null;
      }
    }, {
      key: "intersects",
      value: function intersects() {
        return this._intersects;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._rectEnv = null, this._intersects = !1;
        var t = arguments[0];
        this._rectEnv = t;
      }
    }]);

    return Hr;
  }(Ie);

  var Wr = /*#__PURE__*/function (_Ie2) {
    _inherits(Wr, _Ie2);

    var _super73 = _createSuper(Wr);

    function Wr() {
      var _this56;

      _classCallCheck(this, Wr);

      _this56 = _super73.call(this), Wr.constructor_.apply(_assertThisInitialized(_this56), arguments);
      return _this56;
    }

    _createClass(Wr, [{
      key: "isDone",
      value: function isDone() {
        return !0 === this._containsPoint;
      }
    }, {
      key: "visit",
      value: function visit(t) {
        if (!(t instanceof et)) return null;
        var e = t.getEnvelopeInternal();
        if (!this._rectEnv.intersects(e)) return null;
        var n = new m();

        for (var _s270 = 0; _s270 < 4; _s270++) {
          if (this._rectSeq.getCoordinate(_s270, n), e.contains(n) && We.containsPointInPolygon(n, t)) return this._containsPoint = !0, null;
        }
      }
    }, {
      key: "containsPoint",
      value: function containsPoint() {
        return this._containsPoint;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._rectSeq = null, this._rectEnv = null, this._containsPoint = !1;
        var t = arguments[0];
        this._rectSeq = t.getExteriorRing().getCoordinateSequence(), this._rectEnv = t.getEnvelopeInternal();
      }
    }]);

    return Wr;
  }(Ie);

  var Zr = /*#__PURE__*/function (_Ie3) {
    _inherits(Zr, _Ie3);

    var _super74 = _createSuper(Zr);

    function Zr() {
      var _this57;

      _classCallCheck(this, Zr);

      _this57 = _super74.call(this), Zr.constructor_.apply(_assertThisInitialized(_this57), arguments);
      return _this57;
    }

    _createClass(Zr, [{
      key: "intersects",
      value: function intersects() {
        return this._hasIntersection;
      }
    }, {
      key: "isDone",
      value: function isDone() {
        return !0 === this._hasIntersection;
      }
    }, {
      key: "visit",
      value: function visit(t) {
        var e = t.getEnvelopeInternal();
        if (!this._rectEnv.intersects(e)) return null;
        var n = fe.getLines(t);
        this.checkIntersectionWithLineStrings(n);
      }
    }, {
      key: "checkIntersectionWithLineStrings",
      value: function checkIntersectionWithLineStrings(t) {
        for (var _e602 = t.iterator(); _e602.hasNext();) {
          var _t758 = _e602.next();

          if (this.checkIntersectionWithSegments(_t758), this._hasIntersection) return null;
        }
      }
    }, {
      key: "checkIntersectionWithSegments",
      value: function checkIntersectionWithSegments(t) {
        var e = t.getCoordinateSequence();

        for (var _t759 = 1; _t759 < e.size(); _t759++) {
          if (e.getCoordinate(_t759 - 1, this._p0), e.getCoordinate(_t759, this._p1), this._rectIntersector.intersects(this._p0, this._p1)) return this._hasIntersection = !0, null;
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._rectEnv = null, this._rectIntersector = null, this._hasIntersection = !1, this._p0 = new m(), this._p1 = new m();
        var t = arguments[0];
        this._rectEnv = t.getEnvelopeInternal(), this._rectIntersector = new kr(this._rectEnv);
      }
    }]);

    return Zr;
  }(Ie);

  var jr = /*#__PURE__*/function (_Er2) {
    _inherits(jr, _Er2);

    var _super75 = _createSuper(jr);

    function jr() {
      var _this58;

      _classCallCheck(this, jr);

      _this58 = _super75.call(this), jr.constructor_.apply(_assertThisInitialized(_this58), arguments);
      return _this58;
    }

    _createClass(jr, [{
      key: "getIntersectionMatrix",
      value: function getIntersectionMatrix() {
        return this._relate.computeIM();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._relate = null, 2 === arguments.length) {
          var _t760 = arguments[0],
              _e603 = arguments[1];
          Er.constructor_.call(this, _t760, _e603), this._relate = new zr(this._arg);
        } else if (3 === arguments.length) {
          var _t761 = arguments[0],
              _e604 = arguments[1],
              _n449 = arguments[2];
          Er.constructor_.call(this, _t761, _e604, _n449), this._relate = new zr(this._arg);
        }
      }
    }, {
      key: "covers",
      value: function covers(t, e) {
        return !(2 === e.getDimension() && t.getDimension() < 2) && !(1 === e.getDimension() && t.getDimension() < 1 && e.getLength() > 0) && !!t.getEnvelopeInternal().covers(e.getEnvelopeInternal()) && (!!t.isRectangle() || new jr(t, e).getIntersectionMatrix().isCovers());
      }
    }, {
      key: "intersects",
      value: function intersects(t, e) {
        if (!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())) return !1;
        if (t.isRectangle()) return Ur.intersects(t, e);
        if (e.isRectangle()) return Ur.intersects(e, t);

        if (t.isGeometryCollection() || e.isGeometryCollection()) {
          for (var _n450 = 0; _n450 < t.getNumGeometries(); _n450++) {
            for (var _s271 = 0; _s271 < e.getNumGeometries(); _s271++) {
              if (t.getGeometryN(_n450).intersects(e.getGeometryN(_s271))) return !0;
            }
          }

          return !1;
        }

        return new jr(t, e).getIntersectionMatrix().isIntersects();
      }
    }, {
      key: "touches",
      value: function touches(t, e) {
        return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && new jr(t, e).getIntersectionMatrix().isTouches(t.getDimension(), e.getDimension());
      }
    }, {
      key: "equalsTopo",
      value: function equalsTopo(t, e) {
        return !!t.getEnvelopeInternal().equals(e.getEnvelopeInternal()) && jr.relate(t, e).isEquals(t.getDimension(), e.getDimension());
      }
    }, {
      key: "relate",
      value: function relate() {
        if (2 === arguments.length) {
          return new jr(arguments[0], arguments[1]).getIntersectionMatrix();
        }

        if (3 === arguments.length) {
          return new jr(arguments[0], arguments[1], arguments[2]).getIntersectionMatrix();
        }
      }
    }, {
      key: "overlaps",
      value: function overlaps(t, e) {
        return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && new jr(t, e).getIntersectionMatrix().isOverlaps(t.getDimension(), e.getDimension());
      }
    }, {
      key: "crosses",
      value: function crosses(t, e) {
        return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && new jr(t, e).getIntersectionMatrix().isCrosses(t.getDimension(), e.getDimension());
      }
    }, {
      key: "contains",
      value: function contains(t, e) {
        return !(2 === e.getDimension() && t.getDimension() < 2) && !(1 === e.getDimension() && t.getDimension() < 1 && e.getLength() > 0) && !!t.getEnvelopeInternal().contains(e.getEnvelopeInternal()) && (t.isRectangle() ? Xr.contains(t, e) : new jr(t, e).getIntersectionMatrix().isContains());
      }
    }]);

    return jr;
  }(Er);

  var Kr = Object.freeze({
    __proto__: null,
    RelateOp: jr
  });

  var Qr = /*#__PURE__*/function () {
    function Qr() {
      _classCallCheck(this, Qr);

      Qr.constructor_.apply(this, arguments);
    }

    _createClass(Qr, [{
      key: "union",
      value: function union() {
        var t = new mn(),
            e = new it();

        for (var _n451 = 0; _n451 < this._pointGeom.getNumGeometries(); _n451++) {
          var _s272 = this._pointGeom.getGeometryN(_n451).getCoordinate();

          t.locate(_s272, this._otherGeom) === Kt.EXTERIOR && e.add(_s272);
        }

        if (0 === e.size()) return this._otherGeom;
        var n = null;
        var s = dt.toCoordinateArray(e);
        return n = 1 === s.length ? this._geomFact.createPoint(s[0]) : this._geomFact.createMultiPointFromCoords(s), ce.combine(n, this._otherGeom);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._pointGeom = null, this._otherGeom = null, this._geomFact = null;
        var t = arguments[0],
            e = arguments[1];
        this._pointGeom = t, this._otherGeom = e, this._geomFact = e.getFactory();
      }
    }, {
      key: "union",
      value: function union(t, e) {
        return new Qr(t, e).union();
      }
    }]);

    return Qr;
  }();

  var Jr = /*#__PURE__*/function () {
    function Jr() {
      _classCallCheck(this, Jr);

      Jr.constructor_.apply(this, arguments);
    }

    _createClass(Jr, [{
      key: "getFactory",
      value: function getFactory() {
        return this._geomFactory;
      }
    }, {
      key: "recordDimension",
      value: function recordDimension(t) {
        t > this._dimension && (this._dimension = t);
      }
    }, {
      key: "getDimension",
      value: function getDimension() {
        return this._dimension;
      }
    }, {
      key: "filter",
      value: function filter(t) {
        return this.recordDimension(t.getDimension()), t instanceof ot || t.isEmpty() ? null : t instanceof et ? (this._polygons.add(t), null) : t instanceof j ? (this._lines.add(t), null) : t instanceof Q ? (this._points.add(t), null) : void g.shouldNeverReachHere("Unhandled geometry type: " + t.getGeometryType());
      }
    }, {
      key: "getExtract",
      value: function getExtract(t) {
        switch (t) {
          case 0:
            return this._points;

          case 1:
            return this._lines;

          case 2:
            return this._polygons;
        }

        return g.shouldNeverReachHere("Invalid dimension: " + t), null;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return this._polygons.isEmpty() && this._lines.isEmpty() && this._points.isEmpty();
      }
    }, {
      key: "add",
      value: function add() {
        if (y(arguments[0], x)) {
          var _t762 = arguments[0];

          var _iterator11 = _createForOfIteratorHelper(_t762),
              _step11;

          try {
            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
              var _e605 = _step11.value;
              this.add(_e605);
            }
          } catch (err) {
            _iterator11.e(err);
          } finally {
            _iterator11.f();
          }
        } else if (arguments[0] instanceof V) {
          var _t763 = arguments[0];
          null === this._geomFactory && (this._geomFactory = _t763.getFactory()), _t763.apply(this);
        }
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Z];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._geomFactory = null, this._polygons = new S(), this._lines = new S(), this._points = new S(), this._dimension = W.FALSE;
      }
    }, {
      key: "extract",
      value: function extract() {
        if (y(arguments[0], x)) {
          var _t764 = arguments[0],
              _e606 = new Jr();

          return _e606.add(_t764), _e606;
        }

        if (arguments[0] instanceof V) {
          var _t765 = arguments[0],
              _e607 = new Jr();

          return _e607.add(_t765), _e607;
        }
      }
    }]);

    return Jr;
  }();

  var $r = /*#__PURE__*/function () {
    function $r() {
      _classCallCheck(this, $r);

      $r.constructor_.apply(this, arguments);
    }

    _createClass($r, [{
      key: "isBorderSegmentsSame",
      value: function isBorderSegmentsSame(t, e) {
        var n = this.extractBorderSegments(this._g0, this._g1, e),
            s = new S();
        return $r.extractBorderSegments(t, e, s), this.isEqual(n, s);
      }
    }, {
      key: "extractByEnvelope",
      value: function extractByEnvelope(t, e, n) {
        var s = new S();

        for (var _i146 = 0; _i146 < e.getNumGeometries(); _i146++) {
          var _r75 = e.getGeometryN(_i146);

          if (_r75.getEnvelopeInternal().intersects(t)) s.add(_r75);else {
            var _t766 = _r75.copy();

            n.add(_t766);
          }
        }

        return this._geomFactory.buildGeometry(s);
      }
    }, {
      key: "isEqual",
      value: function isEqual(t, e) {
        if (t.size() !== e.size()) return !1;
        var n = new xt(t);

        var _iterator12 = _createForOfIteratorHelper(e),
            _step12;

        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var _t767 = _step12.value;
            if (!n.contains(_t767)) return !1;
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }

        return !0;
      }
    }, {
      key: "union",
      value: function union() {
        var t = $r.overlapEnvelope(this._g0, this._g1);

        if (t.isNull()) {
          var _t768 = this._g0.copy(),
              _e608 = this._g1.copy();

          return ce.combine(_t768, _e608);
        }

        var e = new S(),
            n = this.extractByEnvelope(t, this._g0, e),
            s = this.extractByEnvelope(t, this._g1, e),
            i = this.unionFull(n, s);
        var r = null;
        return this._isUnionSafe = this.isBorderSegmentsSame(i, t), r = this._isUnionSafe ? this.combine(i, e) : this.unionFull(this._g0, this._g1), r;
      }
    }, {
      key: "combine",
      value: function combine(t, e) {
        if (e.size() <= 0) return t;
        e.add(t);
        return ce.combine(e);
      }
    }, {
      key: "unionFull",
      value: function unionFull(t, e) {
        try {
          return t.union(e);
        } catch (n) {
          if (n instanceof ns) return $r.unionBuffer(t, e);
          throw n;
        }
      }
    }, {
      key: "extractBorderSegments",
      value: function extractBorderSegments(t, e, n) {
        var s = new S();
        return $r.extractBorderSegments(t, n, s), null !== e && $r.extractBorderSegments(e, n, s), s;
      }
    }, {
      key: "isUnionOptimized",
      value: function isUnionOptimized() {
        return this._isUnionSafe;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._geomFactory = null, this._g0 = null, this._g1 = null, this._isUnionSafe = null;
        var t = arguments[0],
            e = arguments[1];
        this._g0 = t, this._g1 = e, this._geomFactory = t.getFactory();
      }
    }, {
      key: "containsProperly",
      value: function containsProperly() {
        if (2 === arguments.length) {
          var _t769 = arguments[0],
              _e609 = arguments[1];
          return !_t769.isNull() && _e609.getX() > _t769.getMinX() && _e609.getX() < _t769.getMaxX() && _e609.getY() > _t769.getMinY() && _e609.getY() < _t769.getMaxY();
        }

        if (3 === arguments.length) {
          var _t770 = arguments[0],
              _e610 = arguments[1],
              _n452 = arguments[2];
          return $r.containsProperly(_t770, _e610) && $r.containsProperly(_t770, _n452);
        }
      }
    }, {
      key: "union",
      value: function union(t, e) {
        return new $r(t, e).union();
      }
    }, {
      key: "intersects",
      value: function intersects(t, e, n) {
        return t.intersects(e) || t.intersects(n);
      }
    }, {
      key: "overlapEnvelope",
      value: function overlapEnvelope(t, e) {
        var n = t.getEnvelopeInternal(),
            s = e.getEnvelopeInternal();
        return n.intersection(s);
      }
    }, {
      key: "extractBorderSegments",
      value: function extractBorderSegments(t, e, n) {
        t.apply(new ( /*#__PURE__*/function () {
          function _class17() {
            _classCallCheck(this, _class17);
          }

          _createClass(_class17, [{
            key: "filter",
            value: function filter(t, s) {
              if (s <= 0) return null;
              var i = t.getCoordinate(s - 1),
                  r = t.getCoordinate(s);

              if ($r.intersects(e, i, r) && !$r.containsProperly(e, i, r)) {
                var _t771 = new jt(i, r);

                n.add(_t771);
              }
            }
          }, {
            key: "isDone",
            value: function isDone() {
              return !1;
            }
          }, {
            key: "isGeometryChanged",
            value: function isGeometryChanged() {
              return !1;
            }
          }, {
            key: "interfaces_",
            get: function get() {
              return [L];
            }
          }]);

          return _class17;
        }())());
      }
    }, {
      key: "unionBuffer",
      value: function unionBuffer(t, e) {
        return t.getFactory().createGeometryCollection([t, e]).buffer(0);
      }
    }]);

    return $r;
  }();

  var to = /*#__PURE__*/function () {
    function to() {
      _classCallCheck(this, to);

      to.constructor_.apply(this, arguments);
    }

    _createClass(to, [{
      key: "reduceToGeometries",
      value: function reduceToGeometries(t) {
        var e = new S();

        for (var _n453 = t.iterator(); _n453.hasNext();) {
          var _t772 = _n453.next();

          var _s273 = null;
          y(_t772, I) ? _s273 = this.unionTree(_t772) : _t772 instanceof V && (_s273 = _t772), e.add(_s273);
        }

        return e;
      }
    }, {
      key: "union",
      value: function union() {
        if (null === this._inputPolys) throw new IllegalStateException("union() method cannot be called twice");
        if (this._inputPolys.isEmpty()) return null;
        this._geomFactory = this._inputPolys.iterator().next().getFactory();
        var t = new Os(to.STRTREE_NODE_CAPACITY);

        for (var _e611 = this._inputPolys.iterator(); _e611.hasNext();) {
          var _n454 = _e611.next();

          t.insert(_n454.getEnvelopeInternal(), _n454);
        }

        this._inputPolys = null;
        var e = t.itemsTree();
        return this.unionTree(e);
      }
    }, {
      key: "binaryUnion",
      value: function binaryUnion() {
        if (1 === arguments.length) {
          var _t773 = arguments[0];
          return this.binaryUnion(_t773, 0, _t773.size());
        }

        if (3 === arguments.length) {
          var _t774 = arguments[0],
              _e612 = arguments[1],
              _n455 = arguments[2];

          if (_n455 - _e612 <= 1) {
            var _n456 = to.getGeometry(_t774, _e612);

            return this.unionSafe(_n456, null);
          }

          if (_n455 - _e612 == 2) return this.unionSafe(to.getGeometry(_t774, _e612), to.getGeometry(_t774, _e612 + 1));
          {
            var _s274 = Math.trunc((_n455 + _e612) / 2),
                _i147 = this.binaryUnion(_t774, _e612, _s274),
                _r76 = this.binaryUnion(_t774, _s274, _n455);

            return this.unionSafe(_i147, _r76);
          }
        }
      }
    }, {
      key: "repeatedUnion",
      value: function repeatedUnion(t) {
        var e = null;

        for (var _n457 = t.iterator(); _n457.hasNext();) {
          var _t775 = _n457.next();

          e = null === e ? _t775.copy() : e.union(_t775);
        }

        return e;
      }
    }, {
      key: "unionSafe",
      value: function unionSafe(t, e) {
        return null === t && null === e ? null : null === t ? e.copy() : null === e ? t.copy() : this.unionActual(t, e);
      }
    }, {
      key: "unionActual",
      value: function unionActual(t, e) {
        var n = $r.union(t, e);
        return to.restrictToPolygons(n);
      }
    }, {
      key: "unionTree",
      value: function unionTree(t) {
        var e = this.reduceToGeometries(t);
        return this.binaryUnion(e);
      }
    }, {
      key: "bufferUnion",
      value: function bufferUnion() {
        if (1 === arguments.length) {
          var _t776 = arguments[0];
          return _t776.get(0).getFactory().buildGeometry(_t776).buffer(0);
        }

        if (2 === arguments.length) {
          var _t777 = arguments[0],
              _e613 = arguments[1];
          return _t777.getFactory().createGeometryCollection([_t777, _e613]).buffer(0);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._inputPolys = null, this._geomFactory = null;
        var t = arguments[0];
        this._inputPolys = t, null === this._inputPolys && (this._inputPolys = new S());
      }
    }, {
      key: "restrictToPolygons",
      value: function restrictToPolygons(t) {
        if (y(t, tt)) return t;
        var e = Ee.getPolygons(t);
        return 1 === e.size() ? e.get(0) : t.getFactory().createMultiPolygon(Ct.toPolygonArray(e));
      }
    }, {
      key: "getGeometry",
      value: function getGeometry(t, e) {
        return e >= t.size() ? null : t.get(e);
      }
    }, {
      key: "union",
      value: function union(t) {
        return new to(t).union();
      }
    }]);

    return to;
  }();

  to.STRTREE_NODE_CAPACITY = 4;

  var eo = /*#__PURE__*/function () {
    function eo() {
      _classCallCheck(this, eo);

      eo.constructor_.apply(this, arguments);
    }

    _createClass(eo, [{
      key: "unionNoOpt",
      value: function unionNoOpt(t) {
        var e = this._geomFact.createPoint();

        return xr.overlayOp(t, e, Ir.UNION);
      }
    }, {
      key: "unionWithNull",
      value: function unionWithNull(t, e) {
        return null === t && null === e ? null : null === e ? t : null === t ? e : t.union(e);
      }
    }, {
      key: "extract",
      value: function extract() {
        if (y(arguments[0], x)) {
          var _t778 = arguments[0];
          this._extracter = Jr.extract(_t778);
        } else if (arguments[0] instanceof V) {
          var _t779 = arguments[0];
          this._extracter = Jr.extract(_t779);
        }
      }
    }, {
      key: "union",
      value: function union() {
        if (null === this._geomFact && (this._geomFact = this._extracter.getFactory()), null === this._geomFact) return null;
        if (this._extracter.isEmpty()) return this._geomFact.createEmpty(this._extracter.getDimension());

        var t = this._extracter.getExtract(0),
            e = this._extracter.getExtract(1),
            n = this._extracter.getExtract(2);

        var s = null;

        if (t.size() > 0) {
          var _e614 = this._geomFact.buildGeometry(t);

          s = this.unionNoOpt(_e614);
        }

        var i = null;

        if (e.size() > 0) {
          var _t780 = this._geomFact.buildGeometry(e);

          i = this.unionNoOpt(_t780);
        }

        var r = null;
        n.size() > 0 && (r = to.union(n));
        var o = this.unionWithNull(i, r);
        var l = null;
        return l = null === s ? o : null === o ? s : Qr.union(s, o), null === l ? this._geomFact.createGeometryCollection() : l;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._geomFact = null, this._extracter = null, 1 === arguments.length) {
          if (y(arguments[0], x)) {
            var _t781 = arguments[0];
            this.extract(_t781);
          } else if (arguments[0] instanceof V) {
            var _t782 = arguments[0];
            this.extract(_t782);
          }
        } else if (2 === arguments.length) {
          var _t783 = arguments[0],
              _e615 = arguments[1];
          this._geomFact = _e615, this.extract(_t783);
        }
      }
    }, {
      key: "union",
      value: function union() {
        if (1 === arguments.length) {
          if (y(arguments[0], x)) {
            return new eo(arguments[0]).union();
          }

          if (arguments[0] instanceof V) {
            return new eo(arguments[0]).union();
          }
        } else if (2 === arguments.length) {
          return new eo(arguments[0], arguments[1]).union();
        }
      }
    }]);

    return eo;
  }();

  var no = Object.freeze({
    __proto__: null,
    UnaryUnionOp: eo
  }),
      so = Object.freeze({
    __proto__: null,
    IsValidOp: Ar,
    ConsistentAreaTester: Mr
  }),
      io = Object.freeze({
    __proto__: null,
    BoundaryOp: ni,
    IsSimpleOp: ii,
    buffer: Gi,
    distance: Vi,
    linemerge: sr,
    overlay: Nr,
    polygonize: Vr,
    relate: Kr,
    union: no,
    valid: so
  });

  var ro = /*#__PURE__*/function (_he$CoordinateOperati) {
    _inherits(ro, _he$CoordinateOperati);

    var _super76 = _createSuper(ro);

    function ro() {
      var _this59;

      _classCallCheck(this, ro);

      _this59 = _super76.call(this), ro.constructor_.apply(_assertThisInitialized(_this59), arguments);
      return _this59;
    }

    _createClass(ro, [{
      key: "edit",
      value: function edit() {
        if (2 === arguments.length && arguments[1] instanceof V && arguments[0] instanceof Array) {
          var _t784 = arguments[0],
              _e616 = arguments[1];
          if (0 === _t784.length) return null;

          var _n458 = new Array(_t784.length).fill(null);

          for (var _e617 = 0; _e617 < _t784.length; _e617++) {
            var _s276 = new m(_t784[_e617]);

            this._targetPM.makePrecise(_s276), _n458[_e617] = _s276;
          }

          var _s275 = new C(_n458, !1).toCoordinateArray();

          var _i148 = 0;
          _e616 instanceof j && (_i148 = 2), _e616 instanceof at && (_i148 = 4);
          var _r77 = _n458;
          return this._removeCollapsed && (_r77 = null), _s275.length < _i148 ? _r77 : _s275;
        }

        return _get(_getPrototypeOf(ro.prototype), "edit", this).apply(this, arguments);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._targetPM = null, this._removeCollapsed = !0;
        var t = arguments[0],
            e = arguments[1];
        this._targetPM = t, this._removeCollapsed = e;
      }
    }]);

    return ro;
  }(he.CoordinateOperation);

  var oo = /*#__PURE__*/function () {
    function oo() {
      _classCallCheck(this, oo);

      oo.constructor_.apply(this, arguments);
    }

    _createClass(oo, [{
      key: "fixPolygonalTopology",
      value: function fixPolygonalTopology(t) {
        var e = t;
        this._changePrecisionModel || (e = this.changePM(t, this._targetPM));
        return Fi.bufferOp(e, 0);
      }
    }, {
      key: "reducePointwise",
      value: function reducePointwise(t) {
        var e = null;

        if (this._changePrecisionModel) {
          var _n459 = this.createFactory(t.getFactory(), this._targetPM);

          e = new he(_n459);
        } else e = new he();

        var n = this._removeCollapsed;
        t.getDimension() >= 2 && (n = !0);
        return e.edit(t, new ro(this._targetPM, n));
      }
    }, {
      key: "changePM",
      value: function changePM(t, e) {
        return this.createEditor(t.getFactory(), e).edit(t, new he.NoOpGeometryOperation());
      }
    }, {
      key: "setRemoveCollapsedComponents",
      value: function setRemoveCollapsedComponents(t) {
        this._removeCollapsed = t;
      }
    }, {
      key: "createFactory",
      value: function createFactory(t, e) {
        return new Ct(e, t.getSRID(), t.getCoordinateSequenceFactory());
      }
    }, {
      key: "setChangePrecisionModel",
      value: function setChangePrecisionModel(t) {
        this._changePrecisionModel = t;
      }
    }, {
      key: "reduce",
      value: function reduce(t) {
        var e = this.reducePointwise(t);
        return this._isPointwise ? e : y(e, tt) ? Ar.isValid(e) ? e : this.fixPolygonalTopology(e) : e;
      }
    }, {
      key: "setPointwise",
      value: function setPointwise(t) {
        this._isPointwise = t;
      }
    }, {
      key: "createEditor",
      value: function createEditor(t, e) {
        if (t.getPrecisionModel() === e) return new he();
        var n = this.createFactory(t, e);
        return new he(n);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._targetPM = null, this._removeCollapsed = !0, this._changePrecisionModel = !1, this._isPointwise = !1;
        var t = arguments[0];
        this._targetPM = t;
      }
    }, {
      key: "reduce",
      value: function reduce(t, e) {
        return new oo(e).reduce(t);
      }
    }, {
      key: "reducePointwise",
      value: function reducePointwise(t, e) {
        var n = new oo(e);
        return n.setPointwise(!0), n.reduce(t);
      }
    }]);

    return oo;
  }();

  var lo = Object.freeze({
    __proto__: null,
    GeometryPrecisionReducer: oo
  });

  var ao = /*#__PURE__*/function () {
    function ao() {
      _classCallCheck(this, ao);

      ao.constructor_.apply(this, arguments);
    }

    _createClass(ao, [{
      key: "simplifySection",
      value: function simplifySection(t, e) {
        if (t + 1 === e) return null;
        this._seg.p0 = this._pts[t], this._seg.p1 = this._pts[e];
        var n = -1,
            s = t;

        for (var _i149 = t + 1; _i149 < e; _i149++) {
          var _t785 = this._seg.distance(this._pts[_i149]);

          _t785 > n && (n = _t785, s = _i149);
        }

        if (n <= this._distanceTolerance) for (var _n460 = t + 1; _n460 < e; _n460++) {
          this._usePt[_n460] = !1;
        } else this.simplifySection(t, s), this.simplifySection(s, e);
      }
    }, {
      key: "setDistanceTolerance",
      value: function setDistanceTolerance(t) {
        this._distanceTolerance = t;
      }
    }, {
      key: "simplify",
      value: function simplify() {
        this._usePt = new Array(this._pts.length).fill(null);

        for (var _t786 = 0; _t786 < this._pts.length; _t786++) {
          this._usePt[_t786] = !0;
        }

        this.simplifySection(0, this._pts.length - 1);
        var t = new C();

        for (var _e618 = 0; _e618 < this._pts.length; _e618++) {
          this._usePt[_e618] && t.add(new m(this._pts[_e618]));
        }

        return t.toCoordinateArray();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._pts = null, this._usePt = null, this._distanceTolerance = null, this._seg = new jt();
        var t = arguments[0];
        this._pts = t;
      }
    }, {
      key: "simplify",
      value: function simplify(t, e) {
        var n = new ao(t);
        return n.setDistanceTolerance(e), n.simplify();
      }
    }]);

    return ao;
  }();

  var co = /*#__PURE__*/function () {
    function co() {
      _classCallCheck(this, co);

      co.constructor_.apply(this, arguments);
    }

    _createClass(co, [{
      key: "setEnsureValid",
      value: function setEnsureValid(t) {
        this._isEnsureValidTopology = t;
      }
    }, {
      key: "getResultGeometry",
      value: function getResultGeometry() {
        return this._inputGeom.isEmpty() ? this._inputGeom.copy() : new ho(this._isEnsureValidTopology, this._distanceTolerance).transform(this._inputGeom);
      }
    }, {
      key: "setDistanceTolerance",
      value: function setDistanceTolerance(t) {
        if (t < 0) throw new s("Tolerance must be non-negative");
        this._distanceTolerance = t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._inputGeom = null, this._distanceTolerance = null, this._isEnsureValidTopology = !0;
        var t = arguments[0];
        this._inputGeom = t;
      }
    }, {
      key: "simplify",
      value: function simplify(t, e) {
        var n = new co(t);
        return n.setDistanceTolerance(e), n.getResultGeometry();
      }
    }]);

    return co;
  }();

  var ho = /*#__PURE__*/function (_pe3) {
    _inherits(ho, _pe3);

    var _super77 = _createSuper(ho);

    function ho() {
      var _this60;

      _classCallCheck(this, ho);

      _this60 = _super77.call(this), ho.constructor_.apply(_assertThisInitialized(_this60), arguments);
      return _this60;
    }

    _createClass(ho, [{
      key: "transformPolygon",
      value: function transformPolygon(t, e) {
        if (t.isEmpty()) return null;

        var n = _get(_getPrototypeOf(ho.prototype), "transformPolygon", this).call(this, t, e);

        return e instanceof ft ? n : this.createValidArea(n);
      }
    }, {
      key: "createValidArea",
      value: function createValidArea(t) {
        return this._isEnsureValidTopology ? t.buffer(0) : t;
      }
    }, {
      key: "transformCoordinates",
      value: function transformCoordinates(t, e) {
        var n = t.toCoordinateArray();
        var s = null;
        return s = 0 === n.length ? new Array(0).fill(null) : ao.simplify(n, this._distanceTolerance), this._factory.getCoordinateSequenceFactory().create(s);
      }
    }, {
      key: "transformMultiPolygon",
      value: function transformMultiPolygon(t, e) {
        var n = _get(_getPrototypeOf(ho.prototype), "transformMultiPolygon", this).call(this, t, e);

        return this.createValidArea(n);
      }
    }, {
      key: "transformLinearRing",
      value: function transformLinearRing(t, e) {
        var n = e instanceof et,
            s = _get(_getPrototypeOf(ho.prototype), "transformLinearRing", this).call(this, t, e);

        return !n || s instanceof at ? s : null;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._isEnsureValidTopology = !0, this._distanceTolerance = null;
        var t = arguments[0],
            e = arguments[1];
        this._isEnsureValidTopology = t, this._distanceTolerance = e;
      }
    }]);

    return ho;
  }(pe);

  co.DPTransformer = ho;

  var uo = /*#__PURE__*/function (_jt) {
    _inherits(uo, _jt);

    var _super78 = _createSuper(uo);

    function uo() {
      var _this61;

      _classCallCheck(this, uo);

      _this61 = _super78.call(this), uo.constructor_.apply(_assertThisInitialized(_this61), arguments);
      return _this61;
    }

    _createClass(uo, [{
      key: "getIndex",
      value: function getIndex() {
        return this._index;
      }
    }, {
      key: "getParent",
      value: function getParent() {
        return this._parent;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._parent = null, this._index = null, 2 === arguments.length) {
          var _t787 = arguments[0],
              _e619 = arguments[1];
          uo.constructor_.call(this, _t787, _e619, null, -1);
        } else if (4 === arguments.length) {
          var _t788 = arguments[0],
              _e620 = arguments[1],
              _n461 = arguments[2],
              _s277 = arguments[3];
          jt.constructor_.call(this, _t788, _e620), this._parent = _n461, this._index = _s277;
        }
      }
    }]);

    return uo;
  }(jt);

  var go = /*#__PURE__*/function () {
    function go() {
      _classCallCheck(this, go);

      go.constructor_.apply(this, arguments);
    }

    _createClass(go, [{
      key: "addToResult",
      value: function addToResult(t) {
        this._resultSegs.add(t);
      }
    }, {
      key: "asLineString",
      value: function asLineString() {
        return this._parentLine.getFactory().createLineString(go.extractCoordinates(this._resultSegs));
      }
    }, {
      key: "getResultSize",
      value: function getResultSize() {
        var t = this._resultSegs.size();

        return 0 === t ? 0 : t + 1;
      }
    }, {
      key: "getParent",
      value: function getParent() {
        return this._parentLine;
      }
    }, {
      key: "getSegment",
      value: function getSegment(t) {
        return this._segs[t];
      }
    }, {
      key: "getParentCoordinates",
      value: function getParentCoordinates() {
        return this._parentLine.getCoordinates();
      }
    }, {
      key: "getMinimumSize",
      value: function getMinimumSize() {
        return this._minimumSize;
      }
    }, {
      key: "asLinearRing",
      value: function asLinearRing() {
        return this._parentLine.getFactory().createLinearRing(go.extractCoordinates(this._resultSegs));
      }
    }, {
      key: "getSegments",
      value: function getSegments() {
        return this._segs;
      }
    }, {
      key: "init",
      value: function init() {
        var t = this._parentLine.getCoordinates();

        this._segs = new Array(t.length - 1).fill(null);

        for (var _e621 = 0; _e621 < t.length - 1; _e621++) {
          var _n462 = new uo(t[_e621], t[_e621 + 1], this._parentLine, _e621);

          this._segs[_e621] = _n462;
        }
      }
    }, {
      key: "getResultCoordinates",
      value: function getResultCoordinates() {
        return go.extractCoordinates(this._resultSegs);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._parentLine = null, this._segs = null, this._resultSegs = new S(), this._minimumSize = null, 1 === arguments.length) {
          var _t789 = arguments[0];
          go.constructor_.call(this, _t789, 2);
        } else if (2 === arguments.length) {
          var _t790 = arguments[0],
              _e622 = arguments[1];
          this._parentLine = _t790, this._minimumSize = _e622, this.init();
        }
      }
    }, {
      key: "extractCoordinates",
      value: function extractCoordinates(t) {
        var e = new Array(t.size() + 1).fill(null);
        var n = null;

        for (var _s278 = 0; _s278 < t.size(); _s278++) {
          n = t.get(_s278), e[_s278] = n.p0;
        }

        return e[e.length - 1] = n.p1, e;
      }
    }]);

    return go;
  }();

  var _o = /*#__PURE__*/function () {
    function _o() {
      _classCallCheck(this, _o);

      _o.constructor_.apply(this, arguments);
    }

    _createClass(_o, [{
      key: "remove",
      value: function remove(t) {
        this._index.remove(new T(t.p0, t.p1), t);
      }
    }, {
      key: "add",
      value: function add() {
        if (arguments[0] instanceof go) {
          var _t791 = arguments[0].getSegments();

          for (var _e623 = 0; _e623 < _t791.length; _e623++) {
            var _n463 = _t791[_e623];
            this.add(_n463);
          }
        } else if (arguments[0] instanceof jt) {
          var _t792 = arguments[0];

          this._index.insert(new T(_t792.p0, _t792.p1), _t792);
        }
      }
    }, {
      key: "query",
      value: function query(t) {
        var e = new T(t.p0, t.p1),
            n = new po(t);

        this._index.query(e, n);

        return n.getItems();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._index = new Es();
      }
    }]);

    return _o;
  }();

  var po = /*#__PURE__*/function () {
    function po() {
      _classCallCheck(this, po);

      po.constructor_.apply(this, arguments);
    }

    _createClass(po, [{
      key: "visitItem",
      value: function visitItem(t) {
        var e = t;
        T.intersects(e.p0, e.p1, this._querySeg.p0, this._querySeg.p1) && this._items.add(t);
      }
    }, {
      key: "getItems",
      value: function getItems() {
        return this._items;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [be];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._querySeg = null, this._items = new S();
        var t = arguments[0];
        this._querySeg = t;
      }
    }]);

    return po;
  }();

  var mo = /*#__PURE__*/function () {
    function mo() {
      _classCallCheck(this, mo);

      mo.constructor_.apply(this, arguments);
    }

    _createClass(mo, [{
      key: "flatten",
      value: function flatten(t, e) {
        var n = this._linePts[t],
            s = this._linePts[e],
            i = new jt(n, s);
        return this.remove(this._line, t, e), this._outputIndex.add(i), i;
      }
    }, {
      key: "hasBadIntersection",
      value: function hasBadIntersection(t, e, n) {
        return !!this.hasBadOutputIntersection(n) || !!this.hasBadInputIntersection(t, e, n);
      }
    }, {
      key: "setDistanceTolerance",
      value: function setDistanceTolerance(t) {
        this._distanceTolerance = t;
      }
    }, {
      key: "simplifySection",
      value: function simplifySection(t, e, n) {
        n += 1;
        var s = new Array(2).fill(null);

        if (t + 1 === e) {
          var _e624 = this._line.getSegment(t);

          return this._line.addToResult(_e624), null;
        }

        var i = !0;

        if (this._line.getResultSize() < this._line.getMinimumSize()) {
          n + 1 < this._line.getMinimumSize() && (i = !1);
        }

        var r = new Array(1).fill(null),
            o = this.findFurthestPoint(this._linePts, t, e, r);
        r[0] > this._distanceTolerance && (i = !1);
        var l = new jt();

        if (l.p0 = this._linePts[t], l.p1 = this._linePts[e], s[0] = t, s[1] = e, this.hasBadIntersection(this._line, s, l) && (i = !1), i) {
          var _n464 = this.flatten(t, e);

          return this._line.addToResult(_n464), null;
        }

        this.simplifySection(t, o, n), this.simplifySection(o, e, n);
      }
    }, {
      key: "hasBadOutputIntersection",
      value: function hasBadOutputIntersection(t) {
        for (var _e625 = this._outputIndex.query(t).iterator(); _e625.hasNext();) {
          var _n465 = _e625.next();

          if (this.hasInteriorIntersection(_n465, t)) return !0;
        }

        return !1;
      }
    }, {
      key: "findFurthestPoint",
      value: function findFurthestPoint(t, e, n, s) {
        var i = new jt();
        i.p0 = t[e], i.p1 = t[n];
        var r = -1,
            o = e;

        for (var _s279 = e + 1; _s279 < n; _s279++) {
          var _e626 = t[_s279],
              _n466 = i.distance(_e626);

          _n466 > r && (r = _n466, o = _s279);
        }

        return s[0] = r, o;
      }
    }, {
      key: "simplify",
      value: function simplify(t) {
        this._line = t, this._linePts = t.getParentCoordinates(), this.simplifySection(0, this._linePts.length - 1, 0);
      }
    }, {
      key: "remove",
      value: function remove(t, e, n) {
        for (var _s280 = e; _s280 < n; _s280++) {
          var _e627 = t.getSegment(_s280);

          this._inputIndex.remove(_e627);
        }
      }
    }, {
      key: "hasInteriorIntersection",
      value: function hasInteriorIntersection(t, e) {
        return this._li.computeIntersection(t.p0, t.p1, e.p0, e.p1), this._li.isInteriorIntersection();
      }
    }, {
      key: "hasBadInputIntersection",
      value: function hasBadInputIntersection(t, e, n) {
        for (var _s281 = this._inputIndex.query(n).iterator(); _s281.hasNext();) {
          var _i150 = _s281.next();

          if (this.hasInteriorIntersection(_i150, n)) {
            if (mo.isInLineSection(t, e, _i150)) continue;
            return !0;
          }
        }

        return !1;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._li = new Zt(), this._inputIndex = new _o(), this._outputIndex = new _o(), this._line = null, this._linePts = null, this._distanceTolerance = 0;
        var t = arguments[0],
            e = arguments[1];
        this._inputIndex = t, this._outputIndex = e;
      }
    }, {
      key: "isInLineSection",
      value: function isInLineSection(t, e, n) {
        if (n.getParent() !== t.getParent()) return !1;
        var s = n.getIndex();
        return s >= e[0] && s < e[1];
      }
    }]);

    return mo;
  }();

  var fo = /*#__PURE__*/function () {
    function fo() {
      _classCallCheck(this, fo);

      fo.constructor_.apply(this, arguments);
    }

    _createClass(fo, [{
      key: "setDistanceTolerance",
      value: function setDistanceTolerance(t) {
        this._distanceTolerance = t;
      }
    }, {
      key: "simplify",
      value: function simplify(t) {
        for (var _e628 = t.iterator(); _e628.hasNext();) {
          this._inputIndex.add(_e628.next());
        }

        for (var _e629 = t.iterator(); _e629.hasNext();) {
          var _t793 = new mo(this._inputIndex, this._outputIndex);

          _t793.setDistanceTolerance(this._distanceTolerance), _t793.simplify(_e629.next());
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._inputIndex = new _o(), this._outputIndex = new _o(), this._distanceTolerance = 0;
      }
    }]);

    return fo;
  }();

  var yo = /*#__PURE__*/function () {
    function yo() {
      _classCallCheck(this, yo);

      yo.constructor_.apply(this, arguments);
    }

    _createClass(yo, [{
      key: "getResultGeometry",
      value: function getResultGeometry() {
        if (this._inputGeom.isEmpty()) return this._inputGeom.copy();
        this._linestringMap = new It(), this._inputGeom.apply(new Eo(this)), this._lineSimplifier.simplify(this._linestringMap.values());
        return new xo(this._linestringMap).transform(this._inputGeom);
      }
    }, {
      key: "setDistanceTolerance",
      value: function setDistanceTolerance(t) {
        if (t < 0) throw new s("Tolerance must be non-negative");

        this._lineSimplifier.setDistanceTolerance(t);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._inputGeom = null, this._lineSimplifier = new fo(), this._linestringMap = null;
        var t = arguments[0];
        this._inputGeom = t;
      }
    }, {
      key: "simplify",
      value: function simplify(t, e) {
        var n = new yo(t);
        return n.setDistanceTolerance(e), n.getResultGeometry();
      }
    }]);

    return yo;
  }();

  var xo = /*#__PURE__*/function (_pe4) {
    _inherits(xo, _pe4);

    var _super79 = _createSuper(xo);

    function xo() {
      var _this62;

      _classCallCheck(this, xo);

      _this62 = _super79.call(this), xo.constructor_.apply(_assertThisInitialized(_this62), arguments);
      return _this62;
    }

    _createClass(xo, [{
      key: "transformCoordinates",
      value: function transformCoordinates(t, e) {
        if (0 === t.size()) return null;

        if (e instanceof j) {
          var _t794 = this._linestringMap.get(e);

          return this.createCoordinateSequence(_t794.getResultCoordinates());
        }

        return _get(_getPrototypeOf(xo.prototype), "transformCoordinates", this).call(this, t, e);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._linestringMap = null;
        var t = arguments[0];
        this._linestringMap = t;
      }
    }]);

    return xo;
  }(pe);

  var Eo = /*#__PURE__*/function () {
    function Eo() {
      _classCallCheck(this, Eo);

      Eo.constructor_.apply(this, arguments);
    }

    _createClass(Eo, [{
      key: "filter",
      value: function filter(t) {
        if (t instanceof j) {
          var _e630 = t;
          if (_e630.isEmpty()) return null;

          var _n467 = _e630.isClosed() ? 4 : 2,
              _s282 = new go(_e630, _n467);

          this.tps._linestringMap.put(_e630, _s282);
        }
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Y];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this.tps = null;
        var t = arguments[0];
        this.tps = t;
      }
    }]);

    return Eo;
  }();

  yo.LineStringTransformer = xo, yo.LineStringMapBuilderFilter = Eo;

  var Io = /*#__PURE__*/function () {
    function Io() {
      _classCallCheck(this, Io);

      Io.constructor_.apply(this, arguments);
    }

    _createClass(Io, [{
      key: "simplifyVertex",
      value: function simplifyVertex(t) {
        var e = t,
            n = e.getArea(),
            s = null;

        for (; null !== e;) {
          var _t795 = e.getArea();

          _t795 < n && (n = _t795, s = e), e = e._next;
        }

        return null !== s && n < this._tolerance && s.remove(), t.isLive() ? n : -1;
      }
    }, {
      key: "simplify",
      value: function simplify() {
        var t = No.buildLine(this._pts);
        var e = this._tolerance;

        do {
          e = this.simplifyVertex(t);
        } while (e < this._tolerance);

        var n = t.getCoordinates();
        return n.length < 2 ? [n[0], new m(n[0])] : n;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._pts = null, this._tolerance = null;
        var t = arguments[0],
            e = arguments[1];
        this._pts = t, this._tolerance = e * e;
      }
    }, {
      key: "simplify",
      value: function simplify(t, e) {
        return new Io(t, e).simplify();
      }
    }]);

    return Io;
  }();

  var No = /*#__PURE__*/function () {
    function No() {
      _classCallCheck(this, No);

      No.constructor_.apply(this, arguments);
    }

    _createClass(No, [{
      key: "getCoordinates",
      value: function getCoordinates() {
        var t = new C();
        var e = this;

        do {
          t.add(e._pt, !1), e = e._next;
        } while (null !== e);

        return t.toCoordinateArray();
      }
    }, {
      key: "getArea",
      value: function getArea() {
        return this._area;
      }
    }, {
      key: "updateArea",
      value: function updateArea() {
        if (null === this._prev || null === this._next) return this._area = No.MAX_AREA, null;
        this._area = Math.abs(ee.area(this._prev._pt, this._pt, this._next._pt));
      }
    }, {
      key: "remove",
      value: function remove() {
        var t = this._prev,
            e = this._next;
        var n = null;
        return null !== this._prev && (this._prev.setNext(e), this._prev.updateArea(), n = this._prev), null !== this._next && (this._next.setPrev(t), this._next.updateArea(), null === n && (n = this._next)), this._isLive = !1, n;
      }
    }, {
      key: "isLive",
      value: function isLive() {
        return this._isLive;
      }
    }, {
      key: "setPrev",
      value: function setPrev(t) {
        this._prev = t;
      }
    }, {
      key: "setNext",
      value: function setNext(t) {
        this._next = t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._pt = null, this._prev = null, this._next = null, this._area = No.MAX_AREA, this._isLive = !0;
        var t = arguments[0];
        this._pt = t;
      }
    }, {
      key: "buildLine",
      value: function buildLine(t) {
        var e = null,
            n = null;

        for (var _s283 = 0; _s283 < t.length; _s283++) {
          var _i151 = new No(t[_s283]);

          null === e && (e = _i151), _i151.setPrev(n), null !== n && (n.setNext(_i151), n.updateArea()), n = _i151;
        }

        return e;
      }
    }]);

    return No;
  }();

  No.MAX_AREA = r.MAX_VALUE, Io.VWVertex = No;

  var So = /*#__PURE__*/function () {
    function So() {
      _classCallCheck(this, So);

      So.constructor_.apply(this, arguments);
    }

    _createClass(So, [{
      key: "setEnsureValid",
      value: function setEnsureValid(t) {
        this._isEnsureValidTopology = t;
      }
    }, {
      key: "getResultGeometry",
      value: function getResultGeometry() {
        return this._inputGeom.isEmpty() ? this._inputGeom.copy() : new wo(this._isEnsureValidTopology, this._distanceTolerance).transform(this._inputGeom);
      }
    }, {
      key: "setDistanceTolerance",
      value: function setDistanceTolerance(t) {
        if (t < 0) throw new s("Tolerance must be non-negative");
        this._distanceTolerance = t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._inputGeom = null, this._distanceTolerance = null, this._isEnsureValidTopology = !0;
        var t = arguments[0];
        this._inputGeom = t;
      }
    }, {
      key: "simplify",
      value: function simplify(t, e) {
        var n = new So(t);
        return n.setDistanceTolerance(e), n.getResultGeometry();
      }
    }]);

    return So;
  }();

  var wo = /*#__PURE__*/function (_pe5) {
    _inherits(wo, _pe5);

    var _super80 = _createSuper(wo);

    function wo() {
      var _this63;

      _classCallCheck(this, wo);

      _this63 = _super80.call(this), wo.constructor_.apply(_assertThisInitialized(_this63), arguments);
      return _this63;
    }

    _createClass(wo, [{
      key: "transformPolygon",
      value: function transformPolygon(t, e) {
        if (t.isEmpty()) return null;

        var n = _get(_getPrototypeOf(wo.prototype), "transformPolygon", this).call(this, t, e);

        return e instanceof ft ? n : this.createValidArea(n);
      }
    }, {
      key: "createValidArea",
      value: function createValidArea(t) {
        return this._isEnsureValidTopology ? t.buffer(0) : t;
      }
    }, {
      key: "transformCoordinates",
      value: function transformCoordinates(t, e) {
        var n = t.toCoordinateArray();
        var s = null;
        return s = 0 === n.length ? new Array(0).fill(null) : Io.simplify(n, this._distanceTolerance), this._factory.getCoordinateSequenceFactory().create(s);
      }
    }, {
      key: "transformMultiPolygon",
      value: function transformMultiPolygon(t, e) {
        var n = _get(_getPrototypeOf(wo.prototype), "transformMultiPolygon", this).call(this, t, e);

        return this.createValidArea(n);
      }
    }, {
      key: "transformLinearRing",
      value: function transformLinearRing(t, e) {
        var n = e instanceof et,
            s = _get(_getPrototypeOf(wo.prototype), "transformLinearRing", this).call(this, t, e);

        return !n || s instanceof at ? s : null;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._isEnsureValidTopology = !0, this._distanceTolerance = null;
        var t = arguments[0],
            e = arguments[1];
        this._isEnsureValidTopology = t, this._distanceTolerance = e;
      }
    }]);

    return wo;
  }(pe);

  So.VWTransformer = wo;
  var Co = Object.freeze({
    __proto__: null,
    DouglasPeuckerSimplifier: co,
    TopologyPreservingSimplifier: yo,
    VWSimplifier: So
  });

  var Lo = /*#__PURE__*/function () {
    function Lo() {
      _classCallCheck(this, Lo);

      Lo.constructor_.apply(this, arguments);
    }

    _createClass(Lo, [{
      key: "splitAt",
      value: function splitAt() {
        if (1 === arguments.length) {
          var _t796 = arguments[0],
              _e631 = this._minimumLen / this._segLen;

          if (_t796.distance(this._seg.p0) < this._minimumLen) return this._splitPt = this._seg.pointAlong(_e631), null;
          if (_t796.distance(this._seg.p1) < this._minimumLen) return this._splitPt = Lo.pointAlongReverse(this._seg, _e631), null;
          this._splitPt = _t796;
        } else if (2 === arguments.length) {
          var _t797 = arguments[0],
              _e632 = arguments[1],
              _n468 = this.getConstrainedLength(_t797) / this._segLen;

          _e632.equals2D(this._seg.p0) ? this._splitPt = this._seg.pointAlong(_n468) : this._splitPt = Lo.pointAlongReverse(this._seg, _n468);
        }
      }
    }, {
      key: "setMinimumLength",
      value: function setMinimumLength(t) {
        this._minimumLen = t;
      }
    }, {
      key: "getConstrainedLength",
      value: function getConstrainedLength(t) {
        return t < this._minimumLen ? this._minimumLen : t;
      }
    }, {
      key: "getSplitPoint",
      value: function getSplitPoint() {
        return this._splitPt;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._seg = null, this._segLen = null, this._splitPt = null, this._minimumLen = 0;
        var t = arguments[0];
        this._seg = t, this._segLen = t.getLength();
      }
    }, {
      key: "pointAlongReverse",
      value: function pointAlongReverse(t, e) {
        var n = new m();
        return n.x = t.p1.x - e * (t.p1.x - t.p0.x), n.y = t.p1.y - e * (t.p1.y - t.p0.y), n;
      }
    }]);

    return Lo;
  }();

  var To = /*#__PURE__*/function () {
    function To() {
      _classCallCheck(this, To);
    }

    _createClass(To, [{
      key: "findSplitPoint",
      value: function findSplitPoint(t, e) {}
    }]);

    return To;
  }();

  var Ro = /*#__PURE__*/function () {
    function Ro() {
      _classCallCheck(this, Ro);
    }

    _createClass(Ro, [{
      key: "findSplitPoint",
      value: function findSplitPoint(t, e) {
        var n = t.getLineSegment(),
            s = n.getLength() / 2,
            i = new Lo(n),
            r = Ro.projectedSplitPoint(t, e);
        var o = 2 * r.distance(e) * .8;
        return o > s && (o = s), i.setMinimumLength(o), i.splitAt(r), i.getSplitPoint();
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [To];
      }
    }], [{
      key: "projectedSplitPoint",
      value: function projectedSplitPoint(t, e) {
        return t.getLineSegment().project(e);
      }
    }]);

    return Ro;
  }();

  var Po = /*#__PURE__*/function () {
    function Po() {
      _classCallCheck(this, Po);
    }

    _createClass(Po, null, [{
      key: "triArea",
      value: function triArea(t, e, n) {
        return (e.x - t.x) * (n.y - t.y) - (e.y - t.y) * (n.x - t.x);
      }
    }, {
      key: "isInCircleDDNormalized",
      value: function isInCircleDDNormalized(t, e, n, s) {
        var i = v.valueOf(t.x).selfSubtract(s.x),
            r = v.valueOf(t.y).selfSubtract(s.y),
            o = v.valueOf(e.x).selfSubtract(s.x),
            l = v.valueOf(e.y).selfSubtract(s.y),
            a = v.valueOf(n.x).selfSubtract(s.x),
            c = v.valueOf(n.y).selfSubtract(s.y),
            h = i.multiply(l).selfSubtract(o.multiply(r)),
            u = o.multiply(c).selfSubtract(a.multiply(l)),
            g = a.multiply(r).selfSubtract(i.multiply(c)),
            d = i.multiply(i).selfAdd(r.multiply(r)),
            _ = o.multiply(o).selfAdd(l.multiply(l)),
            p = a.multiply(a).selfAdd(c.multiply(c));

        return d.selfMultiply(u).selfAdd(_.selfMultiply(g)).selfAdd(p.selfMultiply(h)).doubleValue() > 0;
      }
    }, {
      key: "checkRobustInCircle",
      value: function checkRobustInCircle(t, e, n, s) {
        var i = Po.isInCircleNonRobust(t, e, n, s),
            r = Po.isInCircleDDSlow(t, e, n, s),
            o = Po.isInCircleCC(t, e, n, s),
            l = ee.circumcentre(t, e, n);
        F.out.println("p radius diff a = " + Math.abs(s.distance(l) - t.distance(l)) / t.distance(l)), i === r && i === o || (F.out.println("inCircle robustness failure (double result = " + i + ", DD result = " + r + ", CC result = " + o + ")"), F.out.println(Ht.toLineString(new pt([t, e, n, s]))), F.out.println("Circumcentre = " + Ht.toPoint(l) + " radius = " + t.distance(l)), F.out.println("p radius diff a = " + Math.abs(s.distance(l) / t.distance(l) - 1)), F.out.println("p radius diff b = " + Math.abs(s.distance(l) / e.distance(l) - 1)), F.out.println("p radius diff c = " + Math.abs(s.distance(l) / n.distance(l) - 1)), F.out.println());
      }
    }, {
      key: "isInCircleDDFast",
      value: function isInCircleDDFast(t, e, n, s) {
        var i = v.sqr(t.x).selfAdd(v.sqr(t.y)).selfMultiply(Po.triAreaDDFast(e, n, s)),
            r = v.sqr(e.x).selfAdd(v.sqr(e.y)).selfMultiply(Po.triAreaDDFast(t, n, s)),
            o = v.sqr(n.x).selfAdd(v.sqr(n.y)).selfMultiply(Po.triAreaDDFast(t, e, s)),
            l = v.sqr(s.x).selfAdd(v.sqr(s.y)).selfMultiply(Po.triAreaDDFast(t, e, n));
        return i.selfSubtract(r).selfAdd(o).selfSubtract(l).doubleValue() > 0;
      }
    }, {
      key: "isInCircleCC",
      value: function isInCircleCC(t, e, n, s) {
        var i = ee.circumcentre(t, e, n),
            r = t.distance(i);
        return s.distance(i) - r <= 0;
      }
    }, {
      key: "isInCircleNormalized",
      value: function isInCircleNormalized(t, e, n, s) {
        var i = t.x - s.x,
            r = t.y - s.y,
            o = e.x - s.x,
            l = e.y - s.y,
            a = n.x - s.x,
            c = n.y - s.y;
        return (i * i + r * r) * (o * c - a * l) + (o * o + l * l) * (a * r - i * c) + (a * a + c * c) * (i * l - o * r) > 0;
      }
    }, {
      key: "isInCircleDDSlow",
      value: function isInCircleDDSlow(t, e, n, s) {
        var i = v.valueOf(s.x),
            r = v.valueOf(s.y),
            o = v.valueOf(t.x),
            l = v.valueOf(t.y),
            a = v.valueOf(e.x),
            c = v.valueOf(e.y),
            h = v.valueOf(n.x),
            u = v.valueOf(n.y),
            g = o.multiply(o).add(l.multiply(l)).multiply(Po.triAreaDDSlow(a, c, h, u, i, r)),
            d = a.multiply(a).add(c.multiply(c)).multiply(Po.triAreaDDSlow(o, l, h, u, i, r)),
            _ = h.multiply(h).add(u.multiply(u)).multiply(Po.triAreaDDSlow(o, l, a, c, i, r)),
            p = i.multiply(i).add(r.multiply(r)).multiply(Po.triAreaDDSlow(o, l, a, c, h, u));

        return g.subtract(d).add(_).subtract(p).doubleValue() > 0;
      }
    }, {
      key: "isInCircleNonRobust",
      value: function isInCircleNonRobust(t, e, n, s) {
        return (t.x * t.x + t.y * t.y) * Po.triArea(e, n, s) - (e.x * e.x + e.y * e.y) * Po.triArea(t, n, s) + (n.x * n.x + n.y * n.y) * Po.triArea(t, e, s) - (s.x * s.x + s.y * s.y) * Po.triArea(t, e, n) > 0;
      }
    }, {
      key: "isInCircleRobust",
      value: function isInCircleRobust(t, e, n, s) {
        return Po.isInCircleNormalized(t, e, n, s);
      }
    }, {
      key: "triAreaDDSlow",
      value: function triAreaDDSlow(t, e, n, s, i, r) {
        return n.subtract(t).multiply(r.subtract(e)).subtract(s.subtract(e).multiply(i.subtract(t)));
      }
    }, {
      key: "triAreaDDFast",
      value: function triAreaDDFast(t, e, n) {
        var s = v.valueOf(e.x).selfSubtract(t.x).selfMultiply(v.valueOf(n.y).selfSubtract(t.y)),
            i = v.valueOf(e.y).selfSubtract(t.y).selfMultiply(v.valueOf(n.x).selfSubtract(t.x));
        return s.selfSubtract(i);
      }
    }]);

    return Po;
  }();

  var Oo = /*#__PURE__*/function () {
    function Oo() {
      _classCallCheck(this, Oo);

      Oo.constructor_.apply(this, arguments);
    }

    _createClass(Oo, [{
      key: "circleCenter",
      value: function circleCenter(t, e) {
        var n = new Oo(this.getX(), this.getY()),
            s = this.bisector(n, t),
            i = this.bisector(t, e),
            r = new te(s, i);
        var o = null;

        try {
          o = new Oo(r.getX(), r.getY());
        } catch (s) {
          if (!(s instanceof $t)) throw s;
          F.err.println("a: " + n + "  b: " + t + "  c: " + e), F.err.println(s);
        }

        return o;
      }
    }, {
      key: "dot",
      value: function dot(t) {
        return this._p.x * t.getX() + this._p.y * t.getY();
      }
    }, {
      key: "magn",
      value: function magn() {
        return Math.sqrt(this._p.x * this._p.x + this._p.y * this._p.y);
      }
    }, {
      key: "getZ",
      value: function getZ() {
        return this._p.getZ();
      }
    }, {
      key: "bisector",
      value: function bisector(t, e) {
        var n = e.getX() - t.getX(),
            s = e.getY() - t.getY(),
            i = new te(t.getX() + n / 2, t.getY() + s / 2, 1),
            r = new te(t.getX() - s + n / 2, t.getY() + n + s / 2, 1);
        return new te(i, r);
      }
    }, {
      key: "equals",
      value: function equals() {
        if (1 === arguments.length) {
          var _t798 = arguments[0];
          return this._p.x === _t798.getX() && this._p.y === _t798.getY();
        }

        if (2 === arguments.length) {
          var _t799 = arguments[0],
              _e633 = arguments[1];
          return this._p.distance(_t799.getCoordinate()) < _e633;
        }
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate() {
        return this._p;
      }
    }, {
      key: "isInCircle",
      value: function isInCircle(t, e, n) {
        return Po.isInCircleRobust(t._p, e._p, n._p, this._p);
      }
    }, {
      key: "interpolateZValue",
      value: function interpolateZValue(t, e, n) {
        var s = t.getX(),
            i = t.getY(),
            r = e.getX() - s,
            o = n.getX() - s,
            l = e.getY() - i,
            a = n.getY() - i,
            c = r * a - o * l,
            h = this.getX() - s,
            u = this.getY() - i,
            g = (a * h - o * u) / c,
            d = (-l * h + r * u) / c;
        return t.getZ() + g * (e.getZ() - t.getZ()) + d * (n.getZ() - t.getZ());
      }
    }, {
      key: "midPoint",
      value: function midPoint(t) {
        var e = (this._p.x + t.getX()) / 2,
            n = (this._p.y + t.getY()) / 2,
            s = (this._p.getZ() + t.getZ()) / 2;
        return new Oo(e, n, s);
      }
    }, {
      key: "rightOf",
      value: function rightOf(t) {
        return this.isCCW(t.dest(), t.orig());
      }
    }, {
      key: "isCCW",
      value: function isCCW(t, e) {
        return (t._p.x - this._p.x) * (e._p.y - this._p.y) - (t._p.y - this._p.y) * (e._p.x - this._p.x) > 0;
      }
    }, {
      key: "getX",
      value: function getX() {
        return this._p.x;
      }
    }, {
      key: "crossProduct",
      value: function crossProduct(t) {
        return this._p.x * t.getY() - this._p.y * t.getX();
      }
    }, {
      key: "setZ",
      value: function setZ(t) {
        this._p.setZ(t);
      }
    }, {
      key: "times",
      value: function times(t) {
        return new Oo(t * this._p.x, t * this._p.y);
      }
    }, {
      key: "cross",
      value: function cross() {
        return new Oo(this._p.y, -this._p.x);
      }
    }, {
      key: "leftOf",
      value: function leftOf(t) {
        return this.isCCW(t.orig(), t.dest());
      }
    }, {
      key: "toString",
      value: function toString() {
        return "POINT (" + this._p.x + " " + this._p.y + ")";
      }
    }, {
      key: "sub",
      value: function sub(t) {
        return new Oo(this._p.x - t.getX(), this._p.y - t.getY());
      }
    }, {
      key: "getY",
      value: function getY() {
        return this._p.y;
      }
    }, {
      key: "classify",
      value: function classify(t, e) {
        var n = e.sub(t),
            s = this.sub(t),
            i = n.crossProduct(s);
        return i > 0 ? Oo.LEFT : i < 0 ? Oo.RIGHT : n.getX() * s.getX() < 0 || n.getY() * s.getY() < 0 ? Oo.BEHIND : n.magn() < s.magn() ? Oo.BEYOND : t.equals(this) ? Oo.ORIGIN : e.equals(this) ? Oo.DESTINATION : Oo.BETWEEN;
      }
    }, {
      key: "sum",
      value: function sum(t) {
        return new Oo(this._p.x + t.getX(), this._p.y + t.getY());
      }
    }, {
      key: "distance",
      value: function distance(t, e) {
        return Math.sqrt(Math.pow(e.getX() - t.getX(), 2) + Math.pow(e.getY() - t.getY(), 2));
      }
    }, {
      key: "circumRadiusRatio",
      value: function circumRadiusRatio(t, e) {
        var n = this.circleCenter(t, e),
            s = this.distance(n, t);
        var i = this.distance(this, t),
            r = this.distance(t, e);
        return r < i && (i = r), r = this.distance(e, this), r < i && (i = r), s / i;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._p = null, 1 === arguments.length) {
          var _t800 = arguments[0];
          this._p = new m(_t800);
        } else if (2 === arguments.length) {
          var _t801 = arguments[0],
              _e634 = arguments[1];
          this._p = new m(_t801, _e634);
        } else if (3 === arguments.length) {
          var _t802 = arguments[0],
              _e635 = arguments[1],
              _n469 = arguments[2];
          this._p = new m(_t802, _e635, _n469);
        }
      }
    }, {
      key: "interpolateZ",
      value: function interpolateZ() {
        if (3 === arguments.length) {
          var _t803 = arguments[0],
              _e636 = arguments[1],
              _n470 = arguments[2],
              _s284 = _e636.distance(_n470),
              _i152 = _t803.distance(_e636),
              _r78 = _n470.getZ() - _e636.getZ();

          return _e636.getZ() + _r78 * (_i152 / _s284);
        }

        if (4 === arguments.length) {
          var _t804 = arguments[0],
              _e637 = arguments[1],
              _n471 = arguments[2],
              _s285 = arguments[3],
              _i153 = _e637.x,
              _r79 = _e637.y,
              _o44 = _n471.x - _i153,
              _l36 = _s285.x - _i153,
              _a20 = _n471.y - _r79,
              _c15 = _s285.y - _r79,
              _h11 = _o44 * _c15 - _l36 * _a20,
              _u5 = _t804.x - _i153,
              _g2 = _t804.y - _r79,
              _d2 = (_c15 * _u5 - _l36 * _g2) / _h11,
              _2 = (-_a20 * _u5 + _o44 * _g2) / _h11;

          return _e637.getZ() + _d2 * (_n471.getZ() - _e637.getZ()) + _2 * (_s285.getZ() - _e637.getZ());
        }
      }
    }]);

    return Oo;
  }();

  Oo.LEFT = 0, Oo.RIGHT = 1, Oo.BEYOND = 2, Oo.BEHIND = 3, Oo.BETWEEN = 4, Oo.ORIGIN = 5, Oo.DESTINATION = 6;

  var vo = /*#__PURE__*/function (_Oo) {
    _inherits(vo, _Oo);

    var _super81 = _createSuper(vo);

    function vo() {
      var _this64;

      _classCallCheck(this, vo);

      _this64 = _super81.call(this), vo.constructor_.apply(_assertThisInitialized(_this64), arguments);
      return _this64;
    }

    _createClass(vo, [{
      key: "getConstraint",
      value: function getConstraint() {
        return this._constraint;
      }
    }, {
      key: "setOnConstraint",
      value: function setOnConstraint(t) {
        this._isOnConstraint = t;
      }
    }, {
      key: "merge",
      value: function merge(t) {
        t._isOnConstraint && (this._isOnConstraint = !0, this._constraint = t._constraint);
      }
    }, {
      key: "isOnConstraint",
      value: function isOnConstraint() {
        return this._isOnConstraint;
      }
    }, {
      key: "setConstraint",
      value: function setConstraint(t) {
        this._isOnConstraint = !0, this._constraint = t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._isOnConstraint = null, this._constraint = null;
        var t = arguments[0];
        Oo.constructor_.call(this, t);
      }
    }]);

    return vo;
  }(Oo);

  var Mo = /*#__PURE__*/function () {
    function Mo() {
      _classCallCheck(this, Mo);

      Mo.constructor_.apply(this, arguments);
    }

    _createClass(Mo, [{
      key: "equalsNonOriented",
      value: function equalsNonOriented(t) {
        return !!this.equalsOriented(t) || !!this.equalsOriented(t.sym());
      }
    }, {
      key: "toLineSegment",
      value: function toLineSegment() {
        return new jt(this._vertex.getCoordinate(), this.dest().getCoordinate());
      }
    }, {
      key: "dest",
      value: function dest() {
        return this.sym().orig();
      }
    }, {
      key: "oNext",
      value: function oNext() {
        return this._next;
      }
    }, {
      key: "equalsOriented",
      value: function equalsOriented(t) {
        return !(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate()) || !this.dest().getCoordinate().equals2D(t.dest().getCoordinate()));
      }
    }, {
      key: "dNext",
      value: function dNext() {
        return this.sym().oNext().sym();
      }
    }, {
      key: "lPrev",
      value: function lPrev() {
        return this._next.sym();
      }
    }, {
      key: "rPrev",
      value: function rPrev() {
        return this.sym().oNext();
      }
    }, {
      key: "rot",
      value: function rot() {
        return this._rot;
      }
    }, {
      key: "oPrev",
      value: function oPrev() {
        return this._rot._next._rot;
      }
    }, {
      key: "sym",
      value: function sym() {
        return this._rot._rot;
      }
    }, {
      key: "setOrig",
      value: function setOrig(t) {
        this._vertex = t;
      }
    }, {
      key: "lNext",
      value: function lNext() {
        return this.invRot().oNext().rot();
      }
    }, {
      key: "getLength",
      value: function getLength() {
        return this.orig().getCoordinate().distance(this.dest().getCoordinate());
      }
    }, {
      key: "invRot",
      value: function invRot() {
        return this._rot.sym();
      }
    }, {
      key: "setDest",
      value: function setDest(t) {
        this.sym().setOrig(t);
      }
    }, {
      key: "setData",
      value: function setData(t) {
        this._data = t;
      }
    }, {
      key: "getData",
      value: function getData() {
        return this._data;
      }
    }, {
      key: "delete",
      value: function _delete() {
        this._rot = null;
      }
    }, {
      key: "orig",
      value: function orig() {
        return this._vertex;
      }
    }, {
      key: "rNext",
      value: function rNext() {
        return this._rot._next.invRot();
      }
    }, {
      key: "toString",
      value: function toString() {
        var t = this._vertex.getCoordinate(),
            e = this.dest().getCoordinate();

        return Ht.toLineString(t, e);
      }
    }, {
      key: "isLive",
      value: function isLive() {
        return null !== this._rot;
      }
    }, {
      key: "getPrimary",
      value: function getPrimary() {
        return this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0 ? this : this.sym();
      }
    }, {
      key: "dPrev",
      value: function dPrev() {
        return this.invRot().oNext().invRot();
      }
    }, {
      key: "setNext",
      value: function setNext(t) {
        this._next = t;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._rot = null, this._vertex = null, this._next = null, this._data = null;
      }
    }, {
      key: "makeEdge",
      value: function makeEdge(t, e) {
        var n = new Mo(),
            s = new Mo(),
            i = new Mo(),
            r = new Mo();
        n._rot = s, s._rot = i, i._rot = r, r._rot = n, n.setNext(n), s.setNext(r), i.setNext(i), r.setNext(s);
        var o = n;
        return o.setOrig(t), o.setDest(e), o;
      }
    }, {
      key: "swap",
      value: function swap(t) {
        var e = t.oPrev(),
            n = t.sym().oPrev();
        Mo.splice(t, e), Mo.splice(t.sym(), n), Mo.splice(t, e.lNext()), Mo.splice(t.sym(), n.lNext()), t.setOrig(e.dest()), t.setDest(n.dest());
      }
    }, {
      key: "splice",
      value: function splice(t, e) {
        var n = t.oNext().rot(),
            s = e.oNext().rot(),
            i = e.oNext(),
            r = t.oNext(),
            o = s.oNext(),
            l = n.oNext();
        t.setNext(i), e.setNext(r), n.setNext(o), s.setNext(l);
      }
    }, {
      key: "connect",
      value: function connect(t, e) {
        var n = Mo.makeEdge(t.dest(), e.orig());
        return Mo.splice(n, t.lNext()), Mo.splice(n.sym(), e), n;
      }
    }]);

    return Mo;
  }();

  var bo = /*#__PURE__*/function () {
    function bo() {
      _classCallCheck(this, bo);

      bo.constructor_.apply(this, arguments);
    }

    _createClass(bo, [{
      key: "insertSite",
      value: function insertSite(t) {
        var e = this._subdiv.locate(t);

        if (this._subdiv.isVertexOfEdge(e, t)) return e;
        this._subdiv.isOnEdge(e, t.getCoordinate()) && (e = e.oPrev(), this._subdiv.delete(e.oNext()));

        var n = this._subdiv.makeEdge(e.orig(), t);

        Mo.splice(n, e);
        var s = n;

        do {
          n = this._subdiv.connect(e, n.sym()), e = n.oPrev();
        } while (e.lNext() !== s);

        for (;;) {
          var _i154 = e.oPrev();

          if (_i154.dest().rightOf(e) && t.isInCircle(e.orig(), _i154.dest(), e.dest())) Mo.swap(e), e = e.oPrev();else {
            if (e.oNext() === s) return n;
            e = e.oNext().lPrev();
          }
        }
      }
    }, {
      key: "insertSites",
      value: function insertSites(t) {
        for (var _e638 = t.iterator(); _e638.hasNext();) {
          var _t805 = _e638.next();

          this.insertSite(_t805);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._subdiv = null, this._isUsingTolerance = !1;
        var t = arguments[0];
        this._subdiv = t, this._isUsingTolerance = t.getTolerance() > 0;
      }
    }]);

    return bo;
  }();

  var Do = /*#__PURE__*/function () {
    function Do() {
      _classCallCheck(this, Do);
    }

    _createClass(Do, [{
      key: "locate",
      value: function locate(t) {}
    }]);

    return Do;
  }();

  var Ao = /*#__PURE__*/function () {
    function Ao() {
      _classCallCheck(this, Ao);

      Ao.constructor_.apply(this, arguments);
    }

    _createClass(Ao, [{
      key: "init",
      value: function init() {
        this._lastEdge = this.findEdge();
      }
    }, {
      key: "locate",
      value: function locate(t) {
        this._lastEdge.isLive() || this.init();

        var e = this._subdiv.locateFromEdge(t, this._lastEdge);

        return this._lastEdge = e, e;
      }
    }, {
      key: "findEdge",
      value: function findEdge() {
        return this._subdiv.getEdges().iterator().next();
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Do];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._subdiv = null, this._lastEdge = null;
        var t = arguments[0];
        this._subdiv = t, this.init();
      }
    }]);

    return Ao;
  }();

  var Fo = /*#__PURE__*/function (_h12) {
    _inherits(Fo, _h12);

    var _super82 = _createSuper(Fo);

    function Fo() {
      var _this65;

      _classCallCheck(this, Fo);

      _this65 = _super82.call(this), Fo.constructor_.apply(_assertThisInitialized(_this65), arguments);
      return _this65;
    }

    _createClass(Fo, [{
      key: "getSegment",
      value: function getSegment() {
        return this._seg;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._seg = null, 1 === arguments.length) {
          if ("string" == typeof arguments[0]) {
            var _t806 = arguments[0];
            h.constructor_.call(this, _t806);
          } else if (arguments[0] instanceof jt) {
            var _t807 = arguments[0];
            h.constructor_.call(this, "Locate failed to converge (at edge: " + _t807 + ").  Possible causes include invalid Subdivision topology or very close sites"), this._seg = new jt(_t807);
          }
        } else if (2 === arguments.length) {
          var _t808 = arguments[0],
              _e639 = arguments[1];
          h.constructor_.call(this, Fo.msgWithSpatial(_t808, _e639)), this._seg = new jt(_e639);
        }
      }
    }, {
      key: "msgWithSpatial",
      value: function msgWithSpatial(t, e) {
        return null !== e ? t + " [ " + e + " ]" : t;
      }
    }]);

    return Fo;
  }(h);

  var Go = /*#__PURE__*/function () {
    function Go() {
      _classCallCheck(this, Go);
    }

    _createClass(Go, [{
      key: "visit",
      value: function visit(t) {}
    }]);

    return Go;
  }();

  var qo = /*#__PURE__*/function () {
    function qo() {
      _classCallCheck(this, qo);

      qo.constructor_.apply(this, arguments);
    }

    _createClass(qo, [{
      key: "getTriangleVertices",
      value: function getTriangleVertices(t) {
        var e = new Vo();
        return this.visitTriangles(e, t), e.getTriangleVertices();
      }
    }, {
      key: "isFrameVertex",
      value: function isFrameVertex(t) {
        return !!t.equals(this._frameVertex[0]) || !!t.equals(this._frameVertex[1]) || !!t.equals(this._frameVertex[2]);
      }
    }, {
      key: "isVertexOfEdge",
      value: function isVertexOfEdge(t, e) {
        return !(!e.equals(t.orig(), this._tolerance) && !e.equals(t.dest(), this._tolerance));
      }
    }, {
      key: "connect",
      value: function connect(t, e) {
        var n = Mo.connect(t, e);
        return this._quadEdges.add(n), n;
      }
    }, {
      key: "getVoronoiCellPolygon",
      value: function getVoronoiCellPolygon(t, e) {
        var n = new S(),
            s = t;

        do {
          var _e640 = t.rot().orig().getCoordinate();

          n.add(_e640), t = t.oPrev();
        } while (t !== s);

        var i = new C();
        i.addAll(n, !1), i.closeRing(), i.size() < 4 && (F.out.println(i), i.add(i.get(i.size() - 1), !0));
        var r = i.toCoordinateArray(),
            o = e.createPolygon(e.createLinearRing(r)),
            l = s.orig();
        return o.setUserData(l.getCoordinate()), o;
      }
    }, {
      key: "setLocator",
      value: function setLocator(t) {
        this._locator = t;
      }
    }, {
      key: "initSubdiv",
      value: function initSubdiv() {
        var t = this.makeEdge(this._frameVertex[0], this._frameVertex[1]),
            e = this.makeEdge(this._frameVertex[1], this._frameVertex[2]);
        Mo.splice(t.sym(), e);
        var n = this.makeEdge(this._frameVertex[2], this._frameVertex[0]);
        return Mo.splice(e.sym(), n), Mo.splice(n.sym(), t), t;
      }
    }, {
      key: "isFrameBorderEdge",
      value: function isFrameBorderEdge(t) {
        var e = new Array(3).fill(null);
        qo.getTriangleEdges(t, e);
        var n = new Array(3).fill(null);
        qo.getTriangleEdges(t.sym(), n);
        var s = t.lNext().dest();
        if (this.isFrameVertex(s)) return !0;
        var i = t.sym().lNext().dest();
        return !!this.isFrameVertex(i);
      }
    }, {
      key: "makeEdge",
      value: function makeEdge(t, e) {
        var n = Mo.makeEdge(t, e);
        return this._quadEdges.add(n), n;
      }
    }, {
      key: "visitTriangles",
      value: function visitTriangles(t, e) {
        this._visitedKey++;
        var n = new tn();
        n.push(this._startingEdge);
        var s = new xt();

        for (; !n.empty();) {
          var _i155 = n.pop();

          if (!s.contains(_i155)) {
            var _r80 = this.fetchTriangleToVisit(_i155, n, e, s);

            null !== _r80 && t.visit(_r80);
          }
        }
      }
    }, {
      key: "isFrameEdge",
      value: function isFrameEdge(t) {
        return !(!this.isFrameVertex(t.orig()) && !this.isFrameVertex(t.dest()));
      }
    }, {
      key: "isOnEdge",
      value: function isOnEdge(t, e) {
        this._seg.setCoordinates(t.orig().getCoordinate(), t.dest().getCoordinate());

        return this._seg.distance(e) < this._edgeCoincidenceTolerance;
      }
    }, {
      key: "getEnvelope",
      value: function getEnvelope() {
        return new T(this._frameEnv);
      }
    }, {
      key: "createFrame",
      value: function createFrame(t) {
        var e = t.getWidth(),
            n = t.getHeight();
        var s = 0;
        s = e > n ? 10 * e : 10 * n, this._frameVertex[0] = new Oo((t.getMaxX() + t.getMinX()) / 2, t.getMaxY() + s), this._frameVertex[1] = new Oo(t.getMinX() - s, t.getMinY() - s), this._frameVertex[2] = new Oo(t.getMaxX() + s, t.getMinY() - s), this._frameEnv = new T(this._frameVertex[0].getCoordinate(), this._frameVertex[1].getCoordinate()), this._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate());
      }
    }, {
      key: "getTriangleCoordinates",
      value: function getTriangleCoordinates(t) {
        var e = new zo();
        return this.visitTriangles(e, t), e.getTriangles();
      }
    }, {
      key: "getVertices",
      value: function getVertices(t) {
        var e = new xt();

        for (var _n472 = this._quadEdges.iterator(); _n472.hasNext();) {
          var _s286 = _n472.next(),
              _i156 = _s286.orig();

          !t && this.isFrameVertex(_i156) || e.add(_i156);

          var _r81 = _s286.dest();

          !t && this.isFrameVertex(_r81) || e.add(_r81);
        }

        return e;
      }
    }, {
      key: "fetchTriangleToVisit",
      value: function fetchTriangleToVisit(t, e, n, s) {
        var i = t,
            r = 0,
            o = !1;

        do {
          this._triEdges[r] = i, this.isFrameEdge(i) && (o = !0);

          var _t809 = i.sym();

          s.contains(_t809) || e.push(_t809), s.add(i), r++, i = i.lNext();
        } while (i !== t);

        return o && !n ? null : this._triEdges;
      }
    }, {
      key: "getEdges",
      value: function getEdges() {
        if (0 === arguments.length) return this._quadEdges;

        if (1 === arguments.length) {
          var _t810 = arguments[0],
              _e641 = this.getPrimaryEdges(!1),
              _n473 = new Array(_e641.size()).fill(null);

          var _s287 = 0;

          for (var _i157 = _e641.iterator(); _i157.hasNext();) {
            var _e642 = _i157.next();

            _n473[_s287++] = _t810.createLineString([_e642.orig().getCoordinate(), _e642.dest().getCoordinate()]);
          }

          return _t810.createMultiLineString(_n473);
        }
      }
    }, {
      key: "getVertexUniqueEdges",
      value: function getVertexUniqueEdges(t) {
        var e = new S(),
            n = new xt();

        for (var _s288 = this._quadEdges.iterator(); _s288.hasNext();) {
          var _i158 = _s288.next(),
              _r82 = _i158.orig();

          n.contains(_r82) || (n.add(_r82), !t && this.isFrameVertex(_r82) || e.add(_i158));

          var _o45 = _i158.sym(),
              _l37 = _o45.orig();

          n.contains(_l37) || (n.add(_l37), !t && this.isFrameVertex(_l37) || e.add(_o45));
        }

        return e;
      }
    }, {
      key: "getTriangleEdges",
      value: function getTriangleEdges(t) {
        var e = new Yo();
        return this.visitTriangles(e, t), e.getTriangleEdges();
      }
    }, {
      key: "getPrimaryEdges",
      value: function getPrimaryEdges(t) {
        this._visitedKey++;
        var e = new S(),
            n = new tn();
        n.push(this._startingEdge);
        var s = new xt();

        for (; !n.empty();) {
          var _i159 = n.pop();

          if (!s.contains(_i159)) {
            var _r83 = _i159.getPrimary();

            !t && this.isFrameEdge(_r83) || e.add(_r83), n.push(_i159.oNext()), n.push(_i159.sym().oNext()), s.add(_i159), s.add(_i159.sym());
          }
        }

        return e;
      }
    }, {
      key: "delete",
      value: function _delete(t) {
        Mo.splice(t, t.oPrev()), Mo.splice(t.sym(), t.sym().oPrev());
        var e = t.sym(),
            n = t.rot(),
            s = t.rot().sym();
        this._quadEdges.remove(t), this._quadEdges.remove(e), this._quadEdges.remove(n), this._quadEdges.remove(s), t.delete(), e.delete(), n.delete(), s.delete();
      }
    }, {
      key: "locateFromEdge",
      value: function locateFromEdge(t, e) {
        var n = 0;

        var s = this._quadEdges.size();

        var i = e;

        for (;;) {
          if (n++, n > s) throw new Fo(i.toLineSegment());
          if (t.equals(i.orig()) || t.equals(i.dest())) break;
          if (t.rightOf(i)) i = i.sym();else if (t.rightOf(i.oNext())) {
            if (t.rightOf(i.dPrev())) break;
            i = i.dPrev();
          } else i = i.oNext();
        }

        return i;
      }
    }, {
      key: "getTolerance",
      value: function getTolerance() {
        return this._tolerance;
      }
    }, {
      key: "getVoronoiCellPolygons",
      value: function getVoronoiCellPolygons(t) {
        this.visitTriangles(new Bo(), !0);
        var e = new S();

        for (var _n474 = this.getVertexUniqueEdges(!1).iterator(); _n474.hasNext();) {
          var _s289 = _n474.next();

          e.add(this.getVoronoiCellPolygon(_s289, t));
        }

        return e;
      }
    }, {
      key: "getVoronoiDiagram",
      value: function getVoronoiDiagram(t) {
        var e = this.getVoronoiCellPolygons(t);
        return t.createGeometryCollection(Ct.toGeometryArray(e));
      }
    }, {
      key: "getTriangles",
      value: function getTriangles(t) {
        var e = this.getTriangleCoordinates(!1),
            n = new Array(e.size()).fill(null);
        var s = 0;

        for (var _i160 = e.iterator(); _i160.hasNext();) {
          var _e643 = _i160.next();

          n[s++] = t.createPolygon(t.createLinearRing(_e643));
        }

        return t.createGeometryCollection(n);
      }
    }, {
      key: "insertSite",
      value: function insertSite(t) {
        var e = this.locate(t);
        if (t.equals(e.orig(), this._tolerance) || t.equals(e.dest(), this._tolerance)) return e;
        var n = this.makeEdge(e.orig(), t);
        Mo.splice(n, e);
        var s = n;

        do {
          n = this.connect(e, n.sym()), e = n.oPrev();
        } while (e.lNext() !== s);

        return s;
      }
    }, {
      key: "locate",
      value: function locate() {
        if (1 === arguments.length) {
          if (arguments[0] instanceof Oo) {
            var _t811 = arguments[0];
            return this._locator.locate(_t811);
          }

          if (arguments[0] instanceof m) {
            var _t812 = arguments[0];
            return this._locator.locate(new Oo(_t812));
          }
        } else if (2 === arguments.length) {
          var _t813 = arguments[0],
              _e644 = arguments[1],
              _n475 = this._locator.locate(new Oo(_t813));

          if (null === _n475) return null;
          var _s290 = _n475;
          _n475.dest().getCoordinate().equals2D(_t813) && (_s290 = _n475.sym());
          var _i161 = _s290;

          do {
            if (_i161.dest().getCoordinate().equals2D(_e644)) return _i161;
            _i161 = _i161.oNext();
          } while (_i161 !== _s290);

          return null;
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._visitedKey = 0, this._quadEdges = new S(), this._startingEdge = null, this._tolerance = null, this._edgeCoincidenceTolerance = null, this._frameVertex = new Array(3).fill(null), this._frameEnv = null, this._locator = null, this._seg = new jt(), this._triEdges = new Array(3).fill(null);
        var t = arguments[0],
            e = arguments[1];
        this._tolerance = e, this._edgeCoincidenceTolerance = e / qo.EDGE_COINCIDENCE_TOL_FACTOR, this.createFrame(t), this._startingEdge = this.initSubdiv(), this._locator = new Ao(this);
      }
    }, {
      key: "getTriangleEdges",
      value: function getTriangleEdges(t, e) {
        if (e[0] = t, e[1] = e[0].lNext(), e[2] = e[1].lNext(), e[2].lNext() !== e[0]) throw new s("Edges do not form a triangle");
      }
    }]);

    return qo;
  }();

  var Bo = /*#__PURE__*/function () {
    function Bo() {
      _classCallCheck(this, Bo);
    }

    _createClass(Bo, [{
      key: "visit",
      value: function visit(t) {
        var e = t[0].orig().getCoordinate(),
            n = t[1].orig().getCoordinate(),
            s = t[2].orig().getCoordinate(),
            i = ee.circumcentreDD(e, n, s),
            r = new Oo(i);

        for (var _e645 = 0; _e645 < 3; _e645++) {
          t[_e645].rot().setOrig(r);
        }
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Go];
      }
    }]);

    return Bo;
  }();

  var Yo = /*#__PURE__*/function () {
    function Yo() {
      _classCallCheck(this, Yo);

      Yo.constructor_.apply(this, arguments);
    }

    _createClass(Yo, [{
      key: "getTriangleEdges",
      value: function getTriangleEdges() {
        return this._triList;
      }
    }, {
      key: "visit",
      value: function visit(t) {
        this._triList.add(t);
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Go];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._triList = new S();
      }
    }]);

    return Yo;
  }();

  var Vo = /*#__PURE__*/function () {
    function Vo() {
      _classCallCheck(this, Vo);

      Vo.constructor_.apply(this, arguments);
    }

    _createClass(Vo, [{
      key: "visit",
      value: function visit(t) {
        this._triList.add([t[0].orig(), t[1].orig(), t[2].orig()]);
      }
    }, {
      key: "getTriangleVertices",
      value: function getTriangleVertices() {
        return this._triList;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Go];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._triList = new S();
      }
    }]);

    return Vo;
  }();

  var zo = /*#__PURE__*/function () {
    function zo() {
      _classCallCheck(this, zo);

      zo.constructor_.apply(this, arguments);
    }

    _createClass(zo, [{
      key: "checkTriangleSize",
      value: function checkTriangleSize(t) {
        var e = "";
        t.length >= 2 ? e = Ht.toLineString(t[0], t[1]) : t.length >= 1 && (e = Ht.toPoint(t[0]));
      }
    }, {
      key: "visit",
      value: function visit(t) {
        this._coordList.clear();

        for (var _e646 = 0; _e646 < 3; _e646++) {
          var _n476 = t[_e646].orig();

          this._coordList.add(_n476.getCoordinate());
        }

        if (this._coordList.size() > 0) {
          this._coordList.closeRing();

          var _t814 = this._coordList.toCoordinateArray();

          if (4 !== _t814.length) return null;

          this._triCoords.add(_t814);
        }
      }
    }, {
      key: "getTriangles",
      value: function getTriangles() {
        return this._triCoords;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [Go];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._coordList = new C(), this._triCoords = new S();
      }
    }]);

    return zo;
  }();

  qo.TriangleCircumcentreVisitor = Bo, qo.TriangleEdgesListVisitor = Yo, qo.TriangleVertexListVisitor = Vo, qo.TriangleCoordinatesVisitor = zo, qo.EDGE_COINCIDENCE_TOL_FACTOR = 1e3;

  var Xo = /*#__PURE__*/function () {
    function Xo() {
      _classCallCheck(this, Xo);

      Xo.constructor_.apply(this, arguments);
    }

    _createClass(Xo, [{
      key: "getLineSegment",
      value: function getLineSegment() {
        return this._ls;
      }
    }, {
      key: "getEndZ",
      value: function getEndZ() {
        return this._ls.getCoordinate(1).getZ();
      }
    }, {
      key: "getStartZ",
      value: function getStartZ() {
        return this._ls.getCoordinate(0).getZ();
      }
    }, {
      key: "intersection",
      value: function intersection(t) {
        return this._ls.intersection(t.getLineSegment());
      }
    }, {
      key: "getStart",
      value: function getStart() {
        return this._ls.getCoordinate(0);
      }
    }, {
      key: "getEnd",
      value: function getEnd() {
        return this._ls.getCoordinate(1);
      }
    }, {
      key: "getEndY",
      value: function getEndY() {
        return this._ls.getCoordinate(1).y;
      }
    }, {
      key: "getStartX",
      value: function getStartX() {
        return this._ls.getCoordinate(0).x;
      }
    }, {
      key: "equalsTopo",
      value: function equalsTopo(t) {
        return this._ls.equalsTopo(t.getLineSegment());
      }
    }, {
      key: "getStartY",
      value: function getStartY() {
        return this._ls.getCoordinate(0).y;
      }
    }, {
      key: "setData",
      value: function setData(t) {
        this._data = t;
      }
    }, {
      key: "getData",
      value: function getData() {
        return this._data;
      }
    }, {
      key: "getEndX",
      value: function getEndX() {
        return this._ls.getCoordinate(1).x;
      }
    }, {
      key: "toString",
      value: function toString() {
        return this._ls.toString();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._ls = null, this._data = null, 2 === arguments.length) {
          var _t815 = arguments[0],
              _e647 = arguments[1];
          this._ls = new jt(_t815, _e647);
        } else if (3 === arguments.length) {
          var _t816 = arguments[0],
              _e648 = arguments[1],
              _n477 = arguments[2];
          this._ls = new jt(_t816, _e648), this._data = _n477;
        } else if (6 === arguments.length) {
          var _t817 = arguments[0],
              _e649 = arguments[1],
              _n478 = arguments[2],
              _s291 = arguments[3],
              _i162 = arguments[4],
              _r84 = arguments[5];
          Xo.constructor_.call(this, new m(_t817, _e649, _n478), new m(_s291, _i162, _r84));
        } else if (7 === arguments.length) {
          var _t818 = arguments[0],
              _e650 = arguments[1],
              _n479 = arguments[2],
              _s292 = arguments[3],
              _i163 = arguments[4],
              _r85 = arguments[5],
              _o46 = arguments[6];
          Xo.constructor_.call(this, new m(_t818, _e650, _n479), new m(_s292, _i163, _r85), _o46);
        }
      }
    }]);

    return Xo;
  }();

  var ko = /*#__PURE__*/function (_h13) {
    _inherits(ko, _h13);

    var _super83 = _createSuper(ko);

    function ko() {
      var _this66;

      _classCallCheck(this, ko);

      _this66 = _super83.call(this), ko.constructor_.apply(_assertThisInitialized(_this66), arguments);
      return _this66;
    }

    _createClass(ko, [{
      key: "getCoordinate",
      value: function getCoordinate() {
        return this._pt;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._pt = null, 1 === arguments.length) {
          var _t819 = arguments[0];
          h.constructor_.call(this, _t819);
        } else if (2 === arguments.length) {
          var _t820 = arguments[0],
              _e651 = arguments[1];
          h.constructor_.call(this, ko.msgWithCoord(_t820, _e651)), this._pt = new m(_e651);
        }
      }
    }, {
      key: "msgWithCoord",
      value: function msgWithCoord(t, e) {
        return null !== e ? t + " [ " + Ht.toPoint(e) + " ]" : t;
      }
    }]);

    return ko;
  }(h);

  var Uo = /*#__PURE__*/function () {
    function Uo() {
      _classCallCheck(this, Uo);

      Uo.constructor_.apply(this, arguments);
    }

    _createClass(Uo, [{
      key: "getInitialVertices",
      value: function getInitialVertices() {
        return this._initialVertices;
      }
    }, {
      key: "getKDT",
      value: function getKDT() {
        return this._kdt;
      }
    }, {
      key: "enforceConstraints",
      value: function enforceConstraints() {
        this.addConstraintVertices();
        var t = 0,
            e = 0;

        do {
          e = this.enforceGabriel(this._segments), t++;
        } while (e > 0 && t < Uo.MAX_SPLIT_ITER);

        if (t === Uo.MAX_SPLIT_ITER) throw new ko("Too many splitting iterations while enforcing constraints.  Last split point was at: ", this._splitPt);
      }
    }, {
      key: "insertSites",
      value: function insertSites(t) {
        for (var _e652 = t.iterator(); _e652.hasNext();) {
          var _t821 = _e652.next();

          this.insertSite(_t821);
        }
      }
    }, {
      key: "getVertexFactory",
      value: function getVertexFactory() {
        return this._vertexFactory;
      }
    }, {
      key: "getPointArray",
      value: function getPointArray() {
        var t = new Array(this._initialVertices.size() + this._segVertices.size()).fill(null);
        var e = 0;

        for (var _n480 = this._initialVertices.iterator(); _n480.hasNext();) {
          var _s293 = _n480.next();

          t[e++] = _s293.getCoordinate();
        }

        for (var _n481 = this._segVertices.iterator(); _n481.hasNext();) {
          var _s294 = _n481.next();

          t[e++] = _s294.getCoordinate();
        }

        return t;
      }
    }, {
      key: "setConstraints",
      value: function setConstraints(t, e) {
        this._segments = t, this._segVertices = e;
      }
    }, {
      key: "computeConvexHull",
      value: function computeConvexHull() {
        var t = new Ct(),
            e = this.getPointArray(),
            n = new nn(e, t);
        this._convexHull = n.getConvexHull();
      }
    }, {
      key: "addConstraintVertices",
      value: function addConstraintVertices() {
        this.computeConvexHull(), this.insertSites(this._segVertices);
      }
    }, {
      key: "findNonGabrielPoint",
      value: function findNonGabrielPoint(t) {
        var e = t.getStart(),
            n = t.getEnd(),
            s = new m((e.x + n.x) / 2, (e.y + n.y) / 2),
            i = e.distance(s),
            o = new T(s);
        o.expandBy(i);

        var l = this._kdt.query(o);

        var a = null,
            c = r.MAX_VALUE;

        for (var _t822 = l.iterator(); _t822.hasNext();) {
          var _r86 = _t822.next().getCoordinate();

          if (_r86.equals2D(e) || _r86.equals2D(n)) continue;

          var _o47 = s.distance(_r86);

          if (_o47 < i) {
            var _t823 = _o47;
            (null === a || _t823 < c) && (a = _r86, c = _t823);
          }
        }

        return a;
      }
    }, {
      key: "getConstraintSegments",
      value: function getConstraintSegments() {
        return this._segments;
      }
    }, {
      key: "setSplitPointFinder",
      value: function setSplitPointFinder(t) {
        this._splitFinder = t;
      }
    }, {
      key: "getConvexHull",
      value: function getConvexHull() {
        return this._convexHull;
      }
    }, {
      key: "getTolerance",
      value: function getTolerance() {
        return this._tolerance;
      }
    }, {
      key: "enforceGabriel",
      value: function enforceGabriel(t) {
        var e = new S();
        var n = 0;
        var s = new S();

        for (var _i164 = t.iterator(); _i164.hasNext();) {
          var _t824 = _i164.next(),
              _r87 = this.findNonGabrielPoint(_t824);

          if (null === _r87) continue;
          this._splitPt = this._splitFinder.findSplitPoint(_t824, _r87);

          var _o48 = this.createVertex(this._splitPt, _t824);

          this.insertSite(_o48).getCoordinate().equals2D(this._splitPt);

          var _l38 = new Xo(_t824.getStartX(), _t824.getStartY(), _t824.getStartZ(), _o48.getX(), _o48.getY(), _o48.getZ(), _t824.getData()),
              _a21 = new Xo(_o48.getX(), _o48.getY(), _o48.getZ(), _t824.getEndX(), _t824.getEndY(), _t824.getEndZ(), _t824.getData());

          e.add(_l38), e.add(_a21), s.add(_t824), n += 1;
        }

        return t.removeAll(s), t.addAll(e), n;
      }
    }, {
      key: "createVertex",
      value: function createVertex() {
        if (1 === arguments.length) {
          var _t825 = arguments[0];
          var _e653 = null;
          return _e653 = null !== this._vertexFactory ? this._vertexFactory.createVertex(_t825, null) : new vo(_t825), _e653;
        }

        if (2 === arguments.length) {
          var _t826 = arguments[0],
              _e654 = arguments[1];
          var _n482 = null;
          return _n482 = null !== this._vertexFactory ? this._vertexFactory.createVertex(_t826, _e654) : new vo(_t826), _n482.setOnConstraint(!0), _n482;
        }
      }
    }, {
      key: "getSubdivision",
      value: function getSubdivision() {
        return this._subdiv;
      }
    }, {
      key: "computeBoundingBox",
      value: function computeBoundingBox() {
        var t = Uo.computeVertexEnvelope(this._initialVertices),
            e = Uo.computeVertexEnvelope(this._segVertices),
            n = new T(t);
        n.expandToInclude(e);
        var s = .2 * n.getWidth(),
            i = .2 * n.getHeight(),
            r = Math.max(s, i);
        this._computeAreaEnv = new T(n), this._computeAreaEnv.expandBy(r);
      }
    }, {
      key: "setVertexFactory",
      value: function setVertexFactory(t) {
        this._vertexFactory = t;
      }
    }, {
      key: "formInitialDelaunay",
      value: function formInitialDelaunay() {
        this.computeBoundingBox(), this._subdiv = new qo(this._computeAreaEnv, this._tolerance), this._subdiv.setLocator(new Ao(this._subdiv)), this._incDel = new bo(this._subdiv), this.insertSites(this._initialVertices);
      }
    }, {
      key: "insertSite",
      value: function insertSite() {
        if (arguments[0] instanceof vo) {
          var _t827 = arguments[0],
              _e655 = this._kdt.insert(_t827.getCoordinate(), _t827);

          if (_e655.isRepeated()) {
            var _n483 = _e655.getData();

            return _n483.merge(_t827), _n483;
          }

          return this._incDel.insertSite(_t827), _t827;
        }

        if (arguments[0] instanceof m) {
          var _t828 = arguments[0];
          this.insertSite(this.createVertex(_t828));
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._initialVertices = null, this._segVertices = null, this._segments = new S(), this._subdiv = null, this._incDel = null, this._convexHull = null, this._splitFinder = new Ro(), this._kdt = null, this._vertexFactory = null, this._computeAreaEnv = null, this._splitPt = null, this._tolerance = null;
        var t = arguments[0],
            e = arguments[1];
        this._initialVertices = new S(t), this._tolerance = e, this._kdt = new hs(e);
      }
    }, {
      key: "computeVertexEnvelope",
      value: function computeVertexEnvelope(t) {
        var e = new T();

        for (var _n484 = t.iterator(); _n484.hasNext();) {
          var _t829 = _n484.next();

          e.expandToInclude(_t829.getCoordinate());
        }

        return e;
      }
    }]);

    return Uo;
  }();

  Uo.MAX_SPLIT_ITER = 99;

  var Ho = /*#__PURE__*/function () {
    function Ho() {
      _classCallCheck(this, Ho);

      Ho.constructor_.apply(this, arguments);
    }

    _createClass(Ho, [{
      key: "create",
      value: function create() {
        if (null !== this._subdiv) return null;
        var t = Ho.envelope(this._siteCoords),
            e = Ho.toVertices(this._siteCoords);
        this._subdiv = new qo(t, this._tolerance);
        new bo(this._subdiv).insertSites(e);
      }
    }, {
      key: "setTolerance",
      value: function setTolerance(t) {
        this._tolerance = t;
      }
    }, {
      key: "setSites",
      value: function setSites() {
        if (arguments[0] instanceof V) {
          var _t830 = arguments[0];
          this._siteCoords = Ho.extractUniqueCoordinates(_t830);
        } else if (y(arguments[0], x)) {
          var _t831 = arguments[0];
          this._siteCoords = Ho.unique(dt.toCoordinateArray(_t831));
        }
      }
    }, {
      key: "getEdges",
      value: function getEdges(t) {
        return this.create(), this._subdiv.getEdges(t);
      }
    }, {
      key: "getSubdivision",
      value: function getSubdivision() {
        return this.create(), this._subdiv;
      }
    }, {
      key: "getTriangles",
      value: function getTriangles(t) {
        return this.create(), this._subdiv.getTriangles(t);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._siteCoords = null, this._tolerance = 0, this._subdiv = null;
      }
    }, {
      key: "extractUniqueCoordinates",
      value: function extractUniqueCoordinates(t) {
        if (null === t) return new C();
        var e = t.getCoordinates();
        return Ho.unique(e);
      }
    }, {
      key: "envelope",
      value: function envelope(t) {
        var e = new T();

        for (var _n485 = t.iterator(); _n485.hasNext();) {
          var _t832 = _n485.next();

          e.expandToInclude(_t832);
        }

        return e;
      }
    }, {
      key: "unique",
      value: function unique(t) {
        var e = dt.copyDeep(t);
        $.sort(e);
        return new C(e, !1);
      }
    }, {
      key: "toVertices",
      value: function toVertices(t) {
        var e = new S();

        for (var _n486 = t.iterator(); _n486.hasNext();) {
          var _t833 = _n486.next();

          e.add(new Oo(_t833));
        }

        return e;
      }
    }]);

    return Ho;
  }();

  var Wo = /*#__PURE__*/function () {
    function Wo() {
      _classCallCheck(this, Wo);

      Wo.constructor_.apply(this, arguments);
    }

    _createClass(Wo, [{
      key: "createSiteVertices",
      value: function createSiteVertices(t) {
        var e = new S();

        for (var _n487 = t.iterator(); _n487.hasNext();) {
          var _t834 = _n487.next();

          this._constraintVertexMap.containsKey(_t834) || e.add(new vo(_t834));
        }

        return e;
      }
    }, {
      key: "create",
      value: function create() {
        if (null !== this._subdiv) return null;
        var t = Ho.envelope(this._siteCoords);
        var e = new S();
        null !== this._constraintLines && (t.expandToInclude(this._constraintLines.getEnvelopeInternal()), this.createVertices(this._constraintLines), e = Wo.createConstraintSegments(this._constraintLines));
        var n = this.createSiteVertices(this._siteCoords),
            s = new Uo(n, this._tolerance);
        s.setConstraints(e, new S(this._constraintVertexMap.values())), s.formInitialDelaunay(), s.enforceConstraints(), this._subdiv = s.getSubdivision();
      }
    }, {
      key: "setTolerance",
      value: function setTolerance(t) {
        this._tolerance = t;
      }
    }, {
      key: "setConstraints",
      value: function setConstraints(t) {
        this._constraintLines = t;
      }
    }, {
      key: "setSites",
      value: function setSites(t) {
        this._siteCoords = Ho.extractUniqueCoordinates(t);
      }
    }, {
      key: "getEdges",
      value: function getEdges(t) {
        return this.create(), this._subdiv.getEdges(t);
      }
    }, {
      key: "getSubdivision",
      value: function getSubdivision() {
        return this.create(), this._subdiv;
      }
    }, {
      key: "getTriangles",
      value: function getTriangles(t) {
        return this.create(), this._subdiv.getTriangles(t);
      }
    }, {
      key: "createVertices",
      value: function createVertices(t) {
        var e = t.getCoordinates();

        for (var _t835 = 0; _t835 < e.length; _t835++) {
          var _n488 = new vo(e[_t835]);

          this._constraintVertexMap.put(e[_t835], _n488);
        }
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._siteCoords = null, this._constraintLines = null, this._tolerance = 0, this._subdiv = null, this._constraintVertexMap = new Un();
      }
    }, {
      key: "createConstraintSegments",
      value: function createConstraintSegments() {
        if (1 === arguments.length) {
          var _t836 = arguments[0],
              _e656 = fe.getLines(_t836),
              _n489 = new S();

          for (var _t837 = _e656.iterator(); _t837.hasNext();) {
            var _e657 = _t837.next();

            Wo.createConstraintSegments(_e657, _n489);
          }

          return _n489;
        }

        if (2 === arguments.length) {
          var _t838 = arguments[1],
              _e658 = arguments[0].getCoordinates();

          for (var _n490 = 1; _n490 < _e658.length; _n490++) {
            _t838.add(new Xo(_e658[_n490 - 1], _e658[_n490]));
          }
        }
      }
    }]);

    return Wo;
  }();

  var Zo = /*#__PURE__*/function () {
    function Zo() {
      _classCallCheck(this, Zo);

      Zo.constructor_.apply(this, arguments);
    }

    _createClass(Zo, [{
      key: "create",
      value: function create() {
        if (null !== this._subdiv) return null;
        var t = Ho.envelope(this._siteCoords);

        if (this._diagramEnv = this._clipEnv, null === this._diagramEnv) {
          this._diagramEnv = t;

          var _e659 = this._diagramEnv.getDiameter();

          this._diagramEnv.expandBy(_e659);
        }

        var e = Ho.toVertices(this._siteCoords);
        this._subdiv = new qo(t, this._tolerance);
        new bo(this._subdiv).insertSites(e);
      }
    }, {
      key: "getDiagram",
      value: function getDiagram(t) {
        this.create();

        var e = this._subdiv.getVoronoiDiagram(t);

        return Zo.clipGeometryCollection(e, this._diagramEnv);
      }
    }, {
      key: "setTolerance",
      value: function setTolerance(t) {
        this._tolerance = t;
      }
    }, {
      key: "setSites",
      value: function setSites() {
        if (arguments[0] instanceof V) {
          var _t839 = arguments[0];
          this._siteCoords = Ho.extractUniqueCoordinates(_t839);
        } else if (y(arguments[0], x)) {
          var _t840 = arguments[0];
          this._siteCoords = Ho.unique(dt.toCoordinateArray(_t840));
        }
      }
    }, {
      key: "setClipEnvelope",
      value: function setClipEnvelope(t) {
        this._clipEnv = t;
      }
    }, {
      key: "getSubdivision",
      value: function getSubdivision() {
        return this.create(), this._subdiv;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._siteCoords = null, this._tolerance = 0, this._subdiv = null, this._clipEnv = null, this._diagramEnv = null;
      }
    }, {
      key: "clipGeometryCollection",
      value: function clipGeometryCollection(t, e) {
        var n = t.getFactory().toGeometry(e),
            s = new S();

        for (var _i165 = 0; _i165 < t.getNumGeometries(); _i165++) {
          var _r88 = t.getGeometryN(_i165);

          var _o49 = null;
          e.contains(_r88.getEnvelopeInternal()) ? _o49 = _r88 : e.intersects(_r88.getEnvelopeInternal()) && (_o49 = Ir.intersection(n, _r88), _o49.setUserData(_r88.getUserData())), null === _o49 || _o49.isEmpty() || s.add(_o49);
        }

        return t.getFactory().createGeometryCollection(Ct.toGeometryArray(s));
      }
    }]);

    return Zo;
  }();

  var jo = Object.freeze({
    __proto__: null,
    Vertex: Oo
  }),
      Ko = Object.freeze({
    __proto__: null,
    ConformingDelaunayTriangulationBuilder: Wo,
    DelaunayTriangulationBuilder: Ho,
    VoronoiDiagramBuilder: Zo,
    quadedge: jo
  });

  var Qo = /*#__PURE__*/function () {
    function Qo() {
      _classCallCheck(this, Qo);

      Qo.constructor_.apply(this, arguments);
    }

    _createClass(Qo, [{
      key: "getComponentIndex",
      value: function getComponentIndex() {
        return this._componentIndex;
      }
    }, {
      key: "getLine",
      value: function getLine() {
        return this._currentLine;
      }
    }, {
      key: "getVertexIndex",
      value: function getVertexIndex() {
        return this._vertexIndex;
      }
    }, {
      key: "getSegmentEnd",
      value: function getSegmentEnd() {
        return this._vertexIndex < this.getLine().getNumPoints() - 1 ? this._currentLine.getCoordinateN(this._vertexIndex + 1) : null;
      }
    }, {
      key: "next",
      value: function next() {
        if (!this.hasNext()) return null;
        this._vertexIndex++, this._vertexIndex >= this._currentLine.getNumPoints() && (this._componentIndex++, this.loadCurrentLine(), this._vertexIndex = 0);
      }
    }, {
      key: "loadCurrentLine",
      value: function loadCurrentLine() {
        if (this._componentIndex >= this._numLines) return this._currentLine = null, null;
        this._currentLine = this._linearGeom.getGeometryN(this._componentIndex);
      }
    }, {
      key: "getSegmentStart",
      value: function getSegmentStart() {
        return this._currentLine.getCoordinateN(this._vertexIndex);
      }
    }, {
      key: "isEndOfLine",
      value: function isEndOfLine() {
        return !(this._componentIndex >= this._numLines) && !(this._vertexIndex < this._currentLine.getNumPoints() - 1);
      }
    }, {
      key: "hasNext",
      value: function hasNext() {
        return !(this._componentIndex >= this._numLines) && !(this._componentIndex === this._numLines - 1 && this._vertexIndex >= this._currentLine.getNumPoints());
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._linearGeom = null, this._numLines = null, this._currentLine = null, this._componentIndex = 0, this._vertexIndex = 0, 1 === arguments.length) {
          var _t841 = arguments[0];
          Qo.constructor_.call(this, _t841, 0, 0);
        } else if (2 === arguments.length) {
          var _t842 = arguments[0],
              _e660 = arguments[1];
          Qo.constructor_.call(this, _t842, _e660.getComponentIndex(), Qo.segmentEndVertexIndex(_e660));
        } else if (3 === arguments.length) {
          var _t843 = arguments[0],
              _e661 = arguments[1],
              _n491 = arguments[2];
          if (!y(_t843, k)) throw new s("Lineal geometry is required");
          this._linearGeom = _t843, this._numLines = _t843.getNumGeometries(), this._componentIndex = _e661, this._vertexIndex = _n491, this.loadCurrentLine();
        }
      }
    }, {
      key: "segmentEndVertexIndex",
      value: function segmentEndVertexIndex(t) {
        return t.getSegmentFraction() > 0 ? t.getSegmentIndex() + 1 : t.getSegmentIndex();
      }
    }]);

    return Qo;
  }();

  var Jo = /*#__PURE__*/function () {
    function Jo() {
      _classCallCheck(this, Jo);

      Jo.constructor_.apply(this, arguments);
    }

    _createClass(Jo, [{
      key: "indexOf",
      value: function indexOf(t) {
        return this.indexOfFromStart(t, -1);
      }
    }, {
      key: "indexOfFromStart",
      value: function indexOfFromStart(t, e) {
        var n = r.MAX_VALUE,
            s = e,
            i = 0;
        var o = new jt(),
            l = new Qo(this._linearGeom);

        for (; l.hasNext();) {
          if (!l.isEndOfLine()) {
            o.p0 = l.getSegmentStart(), o.p1 = l.getSegmentEnd();

            var _r89 = o.distance(t),
                _a22 = this.segmentNearestMeasure(o, t, i);

            _r89 < n && _a22 > e && (s = _a22, n = _r89), i += o.getLength();
          }

          l.next();
        }

        return s;
      }
    }, {
      key: "indexOfAfter",
      value: function indexOfAfter(t, e) {
        if (e < 0) return this.indexOf(t);

        var n = this._linearGeom.getLength();

        if (n < e) return n;
        var s = this.indexOfFromStart(t, e);
        return g.isTrue(s >= e, "computed index is before specified minimum index"), s;
      }
    }, {
      key: "segmentNearestMeasure",
      value: function segmentNearestMeasure(t, e, n) {
        var s = t.projectionFactor(e);
        return s <= 0 ? n : s <= 1 ? n + s * t.getLength() : n + t.getLength();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._linearGeom = null;
        var t = arguments[0];
        this._linearGeom = t;
      }
    }, {
      key: "indexOf",
      value: function indexOf(t, e) {
        return new Jo(t).indexOf(e);
      }
    }, {
      key: "indexOfAfter",
      value: function indexOfAfter(t, e, n) {
        return new Jo(t).indexOfAfter(e, n);
      }
    }]);

    return Jo;
  }();

  var $o = /*#__PURE__*/function () {
    function $o() {
      _classCallCheck(this, $o);

      $o.constructor_.apply(this, arguments);
    }

    _createClass($o, [{
      key: "getSegmentIndex",
      value: function getSegmentIndex() {
        return this._segmentIndex;
      }
    }, {
      key: "getComponentIndex",
      value: function getComponentIndex() {
        return this._componentIndex;
      }
    }, {
      key: "isEndpoint",
      value: function isEndpoint(t) {
        var e = t.getGeometryN(this._componentIndex),
            n = $o.numSegments(e);
        return this._segmentIndex >= n || this._segmentIndex === n - 1 && this._segmentFraction >= 1;
      }
    }, {
      key: "isValid",
      value: function isValid(t) {
        if (this._componentIndex < 0 || this._componentIndex >= t.getNumGeometries()) return !1;
        var e = t.getGeometryN(this._componentIndex);
        return !(this._segmentIndex < 0 || this._segmentIndex > e.getNumPoints()) && (this._segmentIndex !== e.getNumPoints() || 0 === this._segmentFraction) && !(this._segmentFraction < 0 || this._segmentFraction > 1);
      }
    }, {
      key: "normalize",
      value: function normalize() {
        this._segmentFraction < 0 && (this._segmentFraction = 0), this._segmentFraction > 1 && (this._segmentFraction = 1), this._componentIndex < 0 && (this._componentIndex = 0, this._segmentIndex = 0, this._segmentFraction = 0), this._segmentIndex < 0 && (this._segmentIndex = 0, this._segmentFraction = 0), 1 === this._segmentFraction && (this._segmentFraction = 0, this._segmentIndex += 1);
      }
    }, {
      key: "toLowest",
      value: function toLowest(t) {
        var e = t.getGeometryN(this._componentIndex),
            n = $o.numSegments(e);
        return this._segmentIndex < n ? this : new $o(this._componentIndex, n - 1, 1, !1);
      }
    }, {
      key: "getCoordinate",
      value: function getCoordinate(t) {
        var e = t.getGeometryN(this._componentIndex),
            n = e.getCoordinateN(this._segmentIndex);
        if (this._segmentIndex >= $o.numSegments(e)) return n;
        var s = e.getCoordinateN(this._segmentIndex + 1);
        return $o.pointAlongSegmentByFraction(n, s, this._segmentFraction);
      }
    }, {
      key: "getSegmentFraction",
      value: function getSegmentFraction() {
        return this._segmentFraction;
      }
    }, {
      key: "getSegment",
      value: function getSegment(t) {
        var e = t.getGeometryN(this._componentIndex),
            n = e.getCoordinateN(this._segmentIndex);

        if (this._segmentIndex >= $o.numSegments(e)) {
          var _t844 = e.getCoordinateN(e.getNumPoints() - 2);

          return new jt(_t844, n);
        }

        var s = e.getCoordinateN(this._segmentIndex + 1);
        return new jt(n, s);
      }
    }, {
      key: "clamp",
      value: function clamp(t) {
        if (this._componentIndex >= t.getNumGeometries()) return this.setToEnd(t), null;

        if (this._segmentIndex >= t.getNumPoints()) {
          var _e662 = t.getGeometryN(this._componentIndex);

          this._segmentIndex = $o.numSegments(_e662), this._segmentFraction = 1;
        }
      }
    }, {
      key: "setToEnd",
      value: function setToEnd(t) {
        this._componentIndex = t.getNumGeometries() - 1;
        var e = t.getGeometryN(this._componentIndex);
        this._segmentIndex = $o.numSegments(e), this._segmentFraction = 0;
      }
    }, {
      key: "compareTo",
      value: function compareTo(t) {
        var e = t;
        return this._componentIndex < e._componentIndex ? -1 : this._componentIndex > e._componentIndex ? 1 : this._segmentIndex < e._segmentIndex ? -1 : this._segmentIndex > e._segmentIndex ? 1 : this._segmentFraction < e._segmentFraction ? -1 : this._segmentFraction > e._segmentFraction ? 1 : 0;
      }
    }, {
      key: "copy",
      value: function copy() {
        return new $o(this._componentIndex, this._segmentIndex, this._segmentFraction);
      }
    }, {
      key: "toString",
      value: function toString() {
        return "LinearLoc[" + this._componentIndex + ", " + this._segmentIndex + ", " + this._segmentFraction + "]";
      }
    }, {
      key: "isOnSameSegment",
      value: function isOnSameSegment(t) {
        return this._componentIndex === t._componentIndex && (this._segmentIndex === t._segmentIndex || t._segmentIndex - this._segmentIndex == 1 && 0 === t._segmentFraction || this._segmentIndex - t._segmentIndex == 1 && 0 === this._segmentFraction);
      }
    }, {
      key: "snapToVertex",
      value: function snapToVertex(t, e) {
        if (this._segmentFraction <= 0 || this._segmentFraction >= 1) return null;
        var n = this.getSegmentLength(t),
            s = this._segmentFraction * n,
            i = n - s;
        s <= i && s < e ? this._segmentFraction = 0 : i <= s && i < e && (this._segmentFraction = 1);
      }
    }, {
      key: "compareLocationValues",
      value: function compareLocationValues(t, e, n) {
        return this._componentIndex < t ? -1 : this._componentIndex > t ? 1 : this._segmentIndex < e ? -1 : this._segmentIndex > e ? 1 : this._segmentFraction < n ? -1 : this._segmentFraction > n ? 1 : 0;
      }
    }, {
      key: "getSegmentLength",
      value: function getSegmentLength(t) {
        var e = t.getGeometryN(this._componentIndex);
        var n = this._segmentIndex;
        this._segmentIndex >= $o.numSegments(e) && (n = e.getNumPoints() - 2);
        var s = e.getCoordinateN(n),
            i = e.getCoordinateN(n + 1);
        return s.distance(i);
      }
    }, {
      key: "isVertex",
      value: function isVertex() {
        return this._segmentFraction <= 0 || this._segmentFraction >= 1;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [o];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this._componentIndex = 0, this._segmentIndex = 0, this._segmentFraction = 0, 0 === arguments.length) ;else if (1 === arguments.length) {
          var _t845 = arguments[0];
          this._componentIndex = _t845._componentIndex, this._segmentIndex = _t845._segmentIndex, this._segmentFraction = _t845._segmentFraction;
        } else if (2 === arguments.length) {
          var _t846 = arguments[0],
              _e663 = arguments[1];
          $o.constructor_.call(this, 0, _t846, _e663);
        } else if (3 === arguments.length) {
          var _t847 = arguments[0],
              _e664 = arguments[1],
              _n492 = arguments[2];
          this._componentIndex = _t847, this._segmentIndex = _e664, this._segmentFraction = _n492, this.normalize();
        } else if (4 === arguments.length) {
          var _t848 = arguments[0],
              _e665 = arguments[1],
              _n493 = arguments[2],
              _s295 = arguments[3];
          this._componentIndex = _t848, this._segmentIndex = _e665, this._segmentFraction = _n493, _s295 && this.normalize();
        }
      }
    }, {
      key: "getEndLocation",
      value: function getEndLocation(t) {
        var e = new $o();
        return e.setToEnd(t), e;
      }
    }, {
      key: "pointAlongSegmentByFraction",
      value: function pointAlongSegmentByFraction(t, e, n) {
        if (n <= 0) return t;
        if (n >= 1) return e;
        var s = (e.x - t.x) * n + t.x,
            i = (e.y - t.y) * n + t.y,
            r = (e.getZ() - t.getZ()) * n + t.getZ();
        return new m(s, i, r);
      }
    }, {
      key: "compareLocationValues",
      value: function compareLocationValues(t, e, n, s, i, r) {
        return t < s ? -1 : t > s ? 1 : e < i ? -1 : e > i ? 1 : n < r ? -1 : n > r ? 1 : 0;
      }
    }, {
      key: "numSegments",
      value: function numSegments(t) {
        var e = t.getNumPoints();
        return e <= 1 ? 0 : e - 1;
      }
    }]);

    return $o;
  }();

  var tl = /*#__PURE__*/function () {
    function tl() {
      _classCallCheck(this, tl);

      tl.constructor_.apply(this, arguments);
    }

    _createClass(tl, [{
      key: "indexOf",
      value: function indexOf(t) {
        return this.indexOfFromStart(t, null);
      }
    }, {
      key: "indexOfFromStart",
      value: function indexOfFromStart(t, e) {
        var n = r.MAX_VALUE,
            s = 0,
            i = 0,
            o = -1;
        var l = new jt();

        for (var _r90 = new Qo(this._linearGeom); _r90.hasNext(); _r90.next()) {
          if (!_r90.isEndOfLine()) {
            l.p0 = _r90.getSegmentStart(), l.p1 = _r90.getSegmentEnd();

            var _a23 = l.distance(t),
                _c16 = l.segmentFraction(t),
                _h14 = _r90.getComponentIndex(),
                _u6 = _r90.getVertexIndex();

            _a23 < n && (null === e || e.compareLocationValues(_h14, _u6, _c16) < 0) && (s = _h14, i = _u6, o = _c16, n = _a23);
          }
        }

        if (n === r.MAX_VALUE) return new $o(e);
        return new $o(s, i, o);
      }
    }, {
      key: "indexOfAfter",
      value: function indexOfAfter(t, e) {
        if (null === e) return this.indexOf(t);
        var n = $o.getEndLocation(this._linearGeom);
        if (n.compareTo(e) <= 0) return n;
        var s = this.indexOfFromStart(t, e);
        return g.isTrue(s.compareTo(e) >= 0, "computed location is before specified minimum location"), s;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._linearGeom = null;
        var t = arguments[0];
        this._linearGeom = t;
      }
    }, {
      key: "indexOf",
      value: function indexOf(t, e) {
        return new tl(t).indexOf(e);
      }
    }, {
      key: "indexOfAfter",
      value: function indexOfAfter(t, e, n) {
        return new tl(t).indexOfAfter(e, n);
      }
    }]);

    return tl;
  }();

  var el = /*#__PURE__*/function () {
    function el() {
      _classCallCheck(this, el);

      el.constructor_.apply(this, arguments);
    }

    _createClass(el, [{
      key: "indicesOf",
      value: function indicesOf(t) {
        var e = t.getGeometryN(0).getCoordinateN(0),
            n = t.getGeometryN(t.getNumGeometries() - 1),
            s = n.getCoordinateN(n.getNumPoints() - 1),
            i = new tl(this._linearGeom),
            r = new Array(2).fill(null);
        return r[0] = i.indexOf(e), 0 === t.getLength() ? r[1] = r[0].copy() : r[1] = i.indexOfAfter(s, r[0]), r;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._linearGeom = null;
        var t = arguments[0];
        this._linearGeom = t;
      }
    }, {
      key: "indicesOf",
      value: function indicesOf(t, e) {
        return new el(t).indicesOf(e);
      }
    }]);

    return el;
  }();

  var nl = /*#__PURE__*/function () {
    function nl() {
      _classCallCheck(this, nl);

      nl.constructor_.apply(this, arguments);
    }

    _createClass(nl, [{
      key: "getLength",
      value: function getLength(t) {
        var e = 0;
        var n = new Qo(this._linearGeom);

        for (; n.hasNext();) {
          if (!n.isEndOfLine()) {
            var _s296 = n.getSegmentStart(),
                _i166 = n.getSegmentEnd().distance(_s296);

            if (t.getComponentIndex() === n.getComponentIndex() && t.getSegmentIndex() === n.getVertexIndex()) return e + _i166 * t.getSegmentFraction();
            e += _i166;
          }

          n.next();
        }

        return e;
      }
    }, {
      key: "resolveHigher",
      value: function resolveHigher(t) {
        if (!t.isEndpoint(this._linearGeom)) return t;
        var e = t.getComponentIndex();
        if (e >= this._linearGeom.getNumGeometries() - 1) return t;

        do {
          e++;
        } while (e < this._linearGeom.getNumGeometries() - 1 && 0 === this._linearGeom.getGeometryN(e).getLength());

        return new $o(e, 0, 0);
      }
    }, {
      key: "getLocation",
      value: function getLocation() {
        if (1 === arguments.length) {
          var _t849 = arguments[0];
          return this.getLocation(_t849, !0);
        }

        if (2 === arguments.length) {
          var _t850 = arguments[0],
              _e666 = arguments[1];
          var _n494 = _t850;

          if (_t850 < 0) {
            _n494 = this._linearGeom.getLength() + _t850;
          }

          var _s297 = this.getLocationForward(_n494);

          return _e666 ? _s297 : this.resolveHigher(_s297);
        }
      }
    }, {
      key: "getLocationForward",
      value: function getLocationForward(t) {
        if (t <= 0) return new $o();
        var e = 0;
        var n = new Qo(this._linearGeom);

        for (; n.hasNext();) {
          if (n.isEndOfLine()) {
            if (e === t) {
              var _t851 = n.getComponentIndex(),
                  _e667 = n.getVertexIndex();

              return new $o(_t851, _e667, 0);
            }
          } else {
            var _s298 = n.getSegmentStart(),
                _i167 = n.getSegmentEnd().distance(_s298);

            if (e + _i167 > t) {
              var _s299 = (t - e) / _i167,
                  _r91 = n.getComponentIndex(),
                  _o50 = n.getVertexIndex();

              return new $o(_r91, _o50, _s299);
            }

            e += _i167;
          }

          n.next();
        }

        return $o.getEndLocation(this._linearGeom);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._linearGeom = null;
        var t = arguments[0];
        this._linearGeom = t;
      }
    }, {
      key: "getLength",
      value: function getLength(t, e) {
        return new nl(t).getLength(e);
      }
    }, {
      key: "getLocation",
      value: function getLocation() {
        if (2 === arguments.length) {
          var _t852 = arguments[1];
          return new nl(arguments[0]).getLocation(_t852);
        }

        if (3 === arguments.length) {
          var _t853 = arguments[1],
              _e668 = arguments[2];
          return new nl(arguments[0]).getLocation(_t853, _e668);
        }
      }
    }]);

    return nl;
  }();

  var sl = /*#__PURE__*/function () {
    function sl() {
      _classCallCheck(this, sl);

      sl.constructor_.apply(this, arguments);
    }

    _createClass(sl, [{
      key: "getGeometry",
      value: function getGeometry() {
        return this.endLine(), this._geomFact.buildGeometry(this._lines);
      }
    }, {
      key: "getLastCoordinate",
      value: function getLastCoordinate() {
        return this._lastPt;
      }
    }, {
      key: "endLine",
      value: function endLine() {
        if (null === this._coordList) return null;
        if (this._ignoreInvalidLines && this._coordList.size() < 2) return this._coordList = null, null;

        var t = this._coordList.toCoordinateArray();

        var e = t;
        this._fixInvalidLines && (e = this.validCoordinateSequence(t)), this._coordList = null;
        var n = null;

        try {
          n = this._geomFact.createLineString(e);
        } catch (t) {
          if (!(t instanceof s)) throw t;
          if (!this._ignoreInvalidLines) throw t;
        }

        null !== n && this._lines.add(n);
      }
    }, {
      key: "setFixInvalidLines",
      value: function setFixInvalidLines(t) {
        this._fixInvalidLines = t;
      }
    }, {
      key: "add",
      value: function add() {
        if (1 === arguments.length) {
          var _t854 = arguments[0];
          this.add(_t854, !0);
        } else if (2 === arguments.length) {
          var _t855 = arguments[0],
              _e669 = arguments[1];
          null === this._coordList && (this._coordList = new C()), this._coordList.add(_t855, _e669), this._lastPt = _t855;
        }
      }
    }, {
      key: "setIgnoreInvalidLines",
      value: function setIgnoreInvalidLines(t) {
        this._ignoreInvalidLines = t;
      }
    }, {
      key: "validCoordinateSequence",
      value: function validCoordinateSequence(t) {
        if (t.length >= 2) return t;
        return [t[0], t[0]];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._geomFact = null, this._lines = new S(), this._coordList = null, this._ignoreInvalidLines = !1, this._fixInvalidLines = !1, this._lastPt = null;
        var t = arguments[0];
        this._geomFact = t;
      }
    }]);

    return sl;
  }();

  var il = /*#__PURE__*/function () {
    function il() {
      _classCallCheck(this, il);

      il.constructor_.apply(this, arguments);
    }

    _createClass(il, [{
      key: "computeLinear",
      value: function computeLinear(t, e) {
        var n = new sl(this._line.getFactory());
        n.setFixInvalidLines(!0), t.isVertex() || n.add(t.getCoordinate(this._line));

        for (var _s300 = new Qo(this._line, t); _s300.hasNext() && !(e.compareLocationValues(_s300.getComponentIndex(), _s300.getVertexIndex(), 0) < 0); _s300.next()) {
          var _t856 = _s300.getSegmentStart();

          n.add(_t856), _s300.isEndOfLine() && n.endLine();
        }

        return e.isVertex() || n.add(e.getCoordinate(this._line)), n.getGeometry();
      }
    }, {
      key: "computeLine",
      value: function computeLine(t, e) {
        var n = this._line.getCoordinates(),
            s = new C();

        var i = t.getSegmentIndex();
        t.getSegmentFraction() > 0 && (i += 1);
        var r = e.getSegmentIndex();
        1 === e.getSegmentFraction() && (r += 1), r >= n.length && (r = n.length - 1), t.isVertex() || s.add(t.getCoordinate(this._line));

        for (var _t857 = i; _t857 <= r; _t857++) {
          s.add(n[_t857]);
        }

        e.isVertex() || s.add(e.getCoordinate(this._line)), s.size() <= 0 && s.add(t.getCoordinate(this._line));
        var o = s.toCoordinateArray();
        return o.length <= 1 && (o = [o[0], o[0]]), this._line.getFactory().createLineString(o);
      }
    }, {
      key: "extract",
      value: function extract(t, e) {
        return e.compareTo(t) < 0 ? this.reverse(this.computeLinear(e, t)) : this.computeLinear(t, e);
      }
    }, {
      key: "reverse",
      value: function reverse(t) {
        return y(t, k) ? t.reverse() : (g.shouldNeverReachHere("non-linear geometry encountered"), null);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._line = null;
        var t = arguments[0];
        this._line = t;
      }
    }, {
      key: "extract",
      value: function extract(t, e, n) {
        return new il(t).extract(e, n);
      }
    }]);

    return il;
  }();

  var rl = /*#__PURE__*/function () {
    function rl() {
      _classCallCheck(this, rl);

      rl.constructor_.apply(this, arguments);
    }

    _createClass(rl, [{
      key: "clampIndex",
      value: function clampIndex(t) {
        var e = this.positiveIndex(t),
            n = this.getStartIndex();
        if (e < n) return n;
        var s = this.getEndIndex();
        return e > s ? s : e;
      }
    }, {
      key: "locationOf",
      value: function locationOf() {
        if (1 === arguments.length) {
          var _t858 = arguments[0];
          return nl.getLocation(this._linearGeom, _t858);
        }

        if (2 === arguments.length) {
          var _t859 = arguments[0],
              _e670 = arguments[1];
          return nl.getLocation(this._linearGeom, _t859, _e670);
        }
      }
    }, {
      key: "project",
      value: function project(t) {
        return Jo.indexOf(this._linearGeom, t);
      }
    }, {
      key: "positiveIndex",
      value: function positiveIndex(t) {
        return t >= 0 ? t : this._linearGeom.getLength() + t;
      }
    }, {
      key: "extractPoint",
      value: function extractPoint() {
        if (1 === arguments.length) {
          var _t860 = arguments[0];
          return nl.getLocation(this._linearGeom, _t860).getCoordinate(this._linearGeom);
        }

        if (2 === arguments.length) {
          var _t861 = arguments[0],
              _e671 = arguments[1],
              _n495 = nl.getLocation(this._linearGeom, _t861).toLowest(this._linearGeom);

          return _n495.getSegment(this._linearGeom).pointAlongOffset(_n495.getSegmentFraction(), _e671);
        }
      }
    }, {
      key: "isValidIndex",
      value: function isValidIndex(t) {
        return t >= this.getStartIndex() && t <= this.getEndIndex();
      }
    }, {
      key: "getEndIndex",
      value: function getEndIndex() {
        return this._linearGeom.getLength();
      }
    }, {
      key: "getStartIndex",
      value: function getStartIndex() {
        return 0;
      }
    }, {
      key: "indexOfAfter",
      value: function indexOfAfter(t, e) {
        return Jo.indexOfAfter(this._linearGeom, t, e);
      }
    }, {
      key: "extractLine",
      value: function extractLine(t, e) {
        var n = this.clampIndex(t),
            s = this.clampIndex(e),
            i = n === s,
            r = this.locationOf(n, i),
            o = this.locationOf(s);
        return il.extract(this._linearGeom, r, o);
      }
    }, {
      key: "indexOf",
      value: function indexOf(t) {
        return Jo.indexOf(this._linearGeom, t);
      }
    }, {
      key: "indicesOf",
      value: function indicesOf(t) {
        var e = el.indicesOf(this._linearGeom, t);
        return [nl.getLength(this._linearGeom, e[0]), nl.getLength(this._linearGeom, e[1])];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._linearGeom = null;
        var t = arguments[0];
        this._linearGeom = t;
      }
    }]);

    return rl;
  }();

  var ll = /*#__PURE__*/function () {
    function ll() {
      _classCallCheck(this, ll);

      ll.constructor_.apply(this, arguments);
    }

    _createClass(ll, [{
      key: "clampIndex",
      value: function clampIndex(t) {
        var e = t.copy();
        return e.clamp(this._linearGeom), e;
      }
    }, {
      key: "project",
      value: function project(t) {
        return tl.indexOf(this._linearGeom, t);
      }
    }, {
      key: "checkGeometryType",
      value: function checkGeometryType() {
        if (!(this._linearGeom instanceof j || this._linearGeom instanceof wt)) throw new s("Input geometry must be linear");
      }
    }, {
      key: "extractPoint",
      value: function extractPoint() {
        if (1 === arguments.length) {
          return arguments[0].getCoordinate(this._linearGeom);
        }

        if (2 === arguments.length) {
          var _t862 = arguments[1],
              _e672 = arguments[0].toLowest(this._linearGeom);

          return _e672.getSegment(this._linearGeom).pointAlongOffset(_e672.getSegmentFraction(), _t862);
        }
      }
    }, {
      key: "isValidIndex",
      value: function isValidIndex(t) {
        return t.isValid(this._linearGeom);
      }
    }, {
      key: "getEndIndex",
      value: function getEndIndex() {
        return $o.getEndLocation(this._linearGeom);
      }
    }, {
      key: "getStartIndex",
      value: function getStartIndex() {
        return new $o();
      }
    }, {
      key: "indexOfAfter",
      value: function indexOfAfter(t, e) {
        return tl.indexOfAfter(this._linearGeom, t, e);
      }
    }, {
      key: "extractLine",
      value: function extractLine(t, e) {
        return il.extract(this._linearGeom, t, e);
      }
    }, {
      key: "indexOf",
      value: function indexOf(t) {
        return tl.indexOf(this._linearGeom, t);
      }
    }, {
      key: "indicesOf",
      value: function indicesOf(t) {
        return el.indicesOf(this._linearGeom, t);
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._linearGeom = null;
        var t = arguments[0];
        this._linearGeom = t, this.checkGeometryType();
      }
    }]);

    return ll;
  }();

  var al = Object.freeze({
    __proto__: null,
    LengthIndexedLine: rl,
    LengthLocationMap: nl,
    LinearGeometryBuilder: sl,
    LinearIterator: Qo,
    LinearLocation: $o,
    LocationIndexedLine: ll
  });

  var cl = /*#__PURE__*/function () {
    function cl() {
      _classCallCheck(this, cl);
    }

    _createClass(cl, null, [{
      key: "transform",
      value: function transform(t, e) {
        var n = new S();

        for (var _s301 = t.iterator(); _s301.hasNext();) {
          n.add(e.execute(_s301.next()));
        }

        return n;
      }
    }, {
      key: "select",
      value: function select(t, e) {
        var n = new S();

        for (var _s302 = t.iterator(); _s302.hasNext();) {
          var _t863 = _s302.next();

          Boolean.TRUE.equals(e.execute(_t863)) && n.add(_t863);
        }

        return n;
      }
    }, {
      key: "apply",
      value: function apply(t, e) {
        for (var _n496 = t.iterator(); _n496.hasNext();) {
          e.execute(_n496.next());
        }
      }
    }]);

    return cl;
  }();

  cl.Function = function () {};

  var hl = /*#__PURE__*/function () {
    function hl() {
      _classCallCheck(this, hl);

      hl.constructor_.apply(this, arguments);
    }

    _createClass(hl, [{
      key: "filter",
      value: function filter(t) {
        this.pts[this.n++] = t;
      }
    }, {
      key: "getCoordinates",
      value: function getCoordinates() {
        return this.pts;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [z];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this.pts = null, this.n = 0;
        var t = arguments[0];
        this.pts = new Array(t).fill(null);
      }
    }]);

    return hl;
  }();

  var ul = /*#__PURE__*/function () {
    function ul() {
      _classCallCheck(this, ul);

      ul.constructor_.apply(this, arguments);
    }

    _createClass(ul, [{
      key: "filter",
      value: function filter(t) {
        this._n++;
      }
    }, {
      key: "getCount",
      value: function getCount() {
        return this._n;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [z];
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._n = 0;
      }
    }]);

    return ul;
  }();

  var gl = /*#__PURE__*/function () {
    function gl() {
      _classCallCheck(this, gl);

      gl.constructor_.apply(this, arguments);
    }

    _createClass(gl, [{
      key: "count",
      value: function count(t) {
        var e = this._counts.get(t);

        return null === e ? 0 : e.count();
      }
    }, {
      key: "add",
      value: function add(t) {
        var e = this._counts.get(t);

        null === e ? this._counts.put(t, new dl(1)) : e.increment();
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        this._counts = new It();
      }
    }]);

    return gl;
  }();

  var dl = /*#__PURE__*/function () {
    function dl() {
      _classCallCheck(this, dl);

      dl.constructor_.apply(this, arguments);
    }

    _createClass(dl, [{
      key: "count",
      value: function count() {
        return this.count;
      }
    }, {
      key: "increment",
      value: function increment() {
        this.count++;
      }
    }], [{
      key: "constructor_",
      value: function constructor_() {
        if (this.count = 0, 0 === arguments.length) ;else if (1 === arguments.length) {
          var _t864 = arguments[0];
          this.count = _t864;
        }
      }
    }]);

    return dl;
  }();

  function _l() {}

  function pl() {}

  function ml() {}

  gl.Counter = dl;

  var fl = /*#__PURE__*/function (_n497) {
    _inherits(fl, _n497);

    var _super84 = _createSuper(fl);

    function fl() {
      _classCallCheck(this, fl);

      return _super84.apply(this, arguments);
    }

    return fl;
  }(n);

  function yl() {}

  var xl = /*#__PURE__*/function () {
    function xl() {
      _classCallCheck(this, xl);
    }

    _createClass(xl, null, [{
      key: "chars",
      value: function chars(t, e) {
        var n = new Array(e).fill(null);

        for (var _s303 = 0; _s303 < e; _s303++) {
          n[_s303] = t;
        }

        return new String(n);
      }
    }, {
      key: "getStackTrace",
      value: function getStackTrace() {
        if (1 === arguments.length) {
          var _t865 = arguments[0],
              _e673 = new ml(),
              _n498 = new _l(_e673);

          return _t865.printStackTrace(_n498), _e673.toString();
        }

        if (2 === arguments.length) {
          var _t866 = arguments[0],
              _e674 = arguments[1];
          var _n499 = "";

          var _s304 = new yl(new pl(xl.getStackTrace(_t866)));

          for (var _t867 = 0; _t867 < _e674; _t867++) {
            try {
              _n499 += _s304.readLine() + xl.NEWLINE;
            } catch (t) {
              if (!(t instanceof fl)) throw t;
              g.shouldNeverReachHere();
            }
          }

          return _n499;
        }
      }
    }, {
      key: "spaces",
      value: function spaces(t) {
        return xl.chars(" ", t);
      }
    }, {
      key: "split",
      value: function split(t, e) {
        var n = e.length,
            s = new S();
        var i = "" + t,
            r = i.indexOf(e);

        for (; r >= 0;) {
          var _t868 = i.substring(0, r);

          s.add(_t868), i = i.substring(r + n), r = i.indexOf(e);
        }

        i.length > 0 && s.add(i);
        var o = new Array(s.size()).fill(null);

        for (var _t869 = 0; _t869 < o.length; _t869++) {
          o[_t869] = s.get(_t869);
        }

        return o;
      }
    }]);

    return xl;
  }();

  xl.NEWLINE = F.getProperty("line.separator");
  var El = Object.freeze({
    __proto__: null,
    CollectionUtil: cl,
    CoordinateArrayFilter: hl,
    CoordinateCountFilter: ul,
    GeometricShapeFactory: Ne,
    NumberUtil: e,
    ObjectCounter: gl,
    PriorityQueue: ws,
    StringUtil: xl,
    UniqueCoordinateArrayFilter: en
  });

  var Il = /*#__PURE__*/function () {
    function Il() {
      _classCallCheck(this, Il);
    }

    _createClass(Il, [{
      key: "getClass",
      value: function getClass() {
        return Il;
      }
    }, {
      key: "interfaces_",
      get: function get() {
        return [];
      }
    }], [{
      key: "union",
      value: function union(t, e) {
        if (t.isEmpty() || e.isEmpty()) {
          if (t.isEmpty() && e.isEmpty()) return Ir.createEmptyResult(Ir.UNION, t, e, t.getFactory());
          if (t.isEmpty()) return e.copy();
          if (e.isEmpty()) return t.copy();
        }

        return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), xr.overlayOp(t, e, Ir.UNION);
      }
    }]);

    return Il;
  }();

  j.prototype.getBoundary = function () {
    return ni.getBoundary(this);
  }, wt.prototype.getBoundary = function () {
    return ni.getBoundary(this);
  }, V.prototype.equalsTopo = function (t) {
    return jr.equalsTopo(this, t);
  }, V.prototype.equals = function (t) {
    return null !== t && jr.equalsTopo(this, t);
  }, V.prototype.union = function () {
    if (0 === arguments.length) return eo.union(this);

    if (1 === arguments.length) {
      var _t870 = arguments[0];
      return Il.union(this, _t870);
    }
  }, V.prototype.isValid = function () {
    return Ar.isValid(this);
  }, V.prototype.intersection = function (t) {
    return Ir.intersection(this, t);
  }, V.prototype.covers = function (t) {
    return jr.covers(this, t);
  }, V.prototype.coveredBy = function (t) {
    return jr.covers(t, this);
  }, V.prototype.touches = function (t) {
    return jr.touches(this, t);
  }, V.prototype.intersects = function (t) {
    return jr.intersects(this, t);
  }, V.prototype.within = function (t) {
    return jr.contains(t, this);
  }, V.prototype.overlaps = function (t) {
    return jr.overlaps(this, t);
  }, V.prototype.disjoint = function (t) {
    return jr.disjoint(this, t);
  }, V.prototype.crosses = function (t) {
    return jr.crosses(this, t);
  }, V.prototype.buffer = function () {
    if (1 === arguments.length) {
      var _t871 = arguments[0];
      return Fi.bufferOp(this, _t871);
    }

    if (2 === arguments.length) {
      var _t872 = arguments[0],
          _e675 = arguments[1];
      return Fi.bufferOp(this, _t872, _e675);
    }

    if (3 === arguments.length) {
      var _t873 = arguments[0],
          _e676 = arguments[1],
          _n500 = arguments[2];
      return Fi.bufferOp(this, _t873, _e676, _n500);
    }
  }, V.prototype.convexHull = function () {
    return new nn(this).getConvexHull();
  }, V.prototype.relate = function () {
    if (1 === arguments.length) {
      var _t874 = arguments[0];
      return jr.relate(this, _t874);
    }

    if (2 === arguments.length) {
      var _t875 = arguments[0],
          _e677 = arguments[1];
      return jr.relate(this, _t875).matches(_e677);
    }
  }, V.prototype.getCentroid = function () {
    if (this.isEmpty()) return this._factory.createPoint();
    var t = Je.getCentroid(this);
    return this.createPointFromInternalCoord(t, this);
  }, V.prototype.getInteriorPoint = function () {
    if (this.isEmpty()) return this._factory.createPoint();
    var t = null;
    var e = this.getDimension();
    t = 0 === e ? new hn(this) : 1 === e ? new cn(this) : new rn(this);
    var n = t.getInteriorPoint();
    return this.createPointFromInternalCoord(n, this);
  }, V.prototype.symDifference = function (t) {
    return Ir.symDifference(this, t);
  }, V.prototype.createPointFromInternalCoord = function (t, e) {
    return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t);
  }, V.prototype.toText = function () {
    return new Ht().write(this);
  }, V.prototype.toString = function () {
    this.toText();
  }, V.prototype.contains = function (t) {
    return jr.contains(this, t);
  }, V.prototype.difference = function (t) {
    return Ir.difference(this, t);
  }, V.prototype.isSimple = function () {
    return new ii(this).isSimple();
  }, V.prototype.isWithinDistance = function (t, e) {
    return !(this.getEnvelopeInternal().distance(t.getEnvelopeInternal()) > e) && Yi.isWithinDistance(this, t, e);
  }, V.prototype.distance = function (t) {
    return Yi.distance(this, t);
  };
  t.algorithm = xn, t.densify = Nn, t.dissolve = On, t.geom = Le, t.geomgraph = ls, t.index = bs, t.io = Bs, t.linearref = al, t.noding = ei, t.operation = io, t.precision = lo, t.simplify = Co, t.triangulate = Ko, t.util = El, t.version = "2.5.0 (ba89299)", Object.defineProperty(t, "__esModule", {
    value: !0
  });
});
},{}],"index.js":[function(require,module,exports) {
"use strict";

require("ol/ol.css");

var _GeoJSON = _interopRequireDefault(require("ol/format/GeoJSON"));

var _LinearRing = _interopRequireDefault(require("ol/geom/LinearRing"));

var _Map = _interopRequireDefault(require("ol/Map"));

var _OSM = _interopRequireDefault(require("ol/source/OSM"));

var _Vector = _interopRequireDefault(require("ol/source/Vector"));

var _View = _interopRequireDefault(require("ol/View"));

var _geom = require("ol/geom");

var _Tile = _interopRequireDefault(require("ol/layer/Tile"));

var _TileWMS = _interopRequireDefault(require("ol/source/TileWMS"));

var _layer = require("ol/layer");

var _proj = require("ol/proj");

var _jsts = _interopRequireDefault(require("jsts"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//#region jsts buffer import 
var source2 = new _Vector.default();
fetch('data/geojson/citizens.geojson').then(function (response) {
  return response.json();
}).then(function (json) {
  var format = new _GeoJSON.default();
  var features = format.readFeatures(json, {
    featureProjection: 'EPSG:4863'
  });
  var parser = new _jsts.default.io.OL3Parser();
  parser.inject(_geom.Point, _geom.LineString, _LinearRing.default, _geom.Polygon, _geom.MultiPoint, _geom.MultiLineString, _geom.MultiPolygon);

  for (var i = 0; i < features.length; i++) {
    var feature = features[i]; // convert the OpenLayers geometry to a JSTS geometry

    var jstsGeom = parser.read(feature.getGeometry()); // create a buffer of 40 meters around each line

    var buffered = jstsGeom.buffer(40); // convert back from JSTS and replace the geometry on the feature

    feature.setGeometry(parser.write(buffered));
  }

  source2.addFeatures(features);
}); //#endregion
//#region  Исполнение в консоли забития в postgis shp

/*const shell = require('node-powershell');
let ps = new shell({
  executionPolicy: 'Bypass',
  noProfile: true
});

ps.addCommand('shp2pgsql -s <SRID> -c -D -I <path to shapefile> <schema>.<table> | \ ');
ps.invoke().then(output => {
  console.log(output);
}).catch(err => {
  console.log(err);
  ps.dispose();
});*/
//#endregion

var layers = [new _Tile.default({
  source: new _OSM.default()
}), new _layer.Vector({
  source: source2
}), new _Tile.default({
  source: new _TileWMS.default({
    url: 'http://localhost:8080/geoserver/moscow/wms',
    params: {
      'LAYERS': 'moscow:border',
      'TILED': true,
      'TRANSPARENT': true
    },
    serverType: 'geoserver',
    // Countries have transparency, so do not fade tiles:
    transition: 0
  })
}), new _Tile.default({
  source: new _TileWMS.default({
    url: 'http://localhost:8080/geoserver/moscow/wms',
    params: {
      'LAYERS': 'moscow:citizens',
      'TILED': true
    },
    serverType: 'geoserver',
    // Countries have transparency, so do not fade tiles:
    transition: 0
  })
}), new _Tile.default({
  source: new _TileWMS.default({
    url: 'http://localhost:8080/geoserver/moscow/wms',
    params: {
      'LAYERS': 'moscow:poi',
      'TILED': true
    },
    serverType: 'geoserver',
    // Countries have transparency, so do not fade tiles:task2_1
    transition: 0
  })
}), new _Tile.default({
  source: new _TileWMS.default({
    url: 'http://localhost:8080/geoserver/moscow/wms',
    params: {
      'LAYERS': 'moscow:task2_1',
      'TILED': true
    },
    serverType: 'geoserver',
    // Countries have transparency, so do not fade tiles:
    transition: 0
  })
})];
var map = new _Map.default({
  layers: layers,
  target: 'map',
  view: new _View.default({
    center: (0, _proj.fromLonLat)([37.520193, 55.613960]),
    zoom: 13
  })
});
},{"ol/ol.css":"node_modules/ol/ol.css","ol/format/GeoJSON":"node_modules/ol/format/GeoJSON.js","ol/geom/LinearRing":"node_modules/ol/geom/LinearRing.js","ol/Map":"node_modules/ol/Map.js","ol/source/OSM":"node_modules/ol/source/OSM.js","ol/source/Vector":"node_modules/ol/source/Vector.js","ol/View":"node_modules/ol/View.js","ol/geom":"node_modules/ol/geom.js","ol/layer/Tile":"node_modules/ol/layer/Tile.js","ol/source/TileWMS":"node_modules/ol/source/TileWMS.js","ol/layer":"node_modules/ol/layer.js","ol/proj":"node_modules/ol/proj.js","jsts":"node_modules/jsts/dist/jsts.min.js"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "57716" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","index.js"], null)
//# sourceMappingURL=/tiled%20wms.e31bb0bc.js.map